[
  {
    "function_name": "logfs_cleanup_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "713-732",
    "snippet": "void logfs_cleanup_gc(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tif (!super->s_free_list.count)\n\t\treturn;\n\n\t/*\n\t * FIXME: The btree may still contain a single empty node.  So we\n\t * call the grim visitor to clean up that mess.  Btree code should\n\t * do it for us, really.\n\t */\n\tbtree_grim_visitor32(&super->s_cand_tree, 0, NULL);\n\tlogfs_cleanup_list(sb, &super->s_free_list);\n\tlogfs_cleanup_list(sb, &super->s_reserve_list);\n\tfor_each_area(i)\n\t\tlogfs_cleanup_list(sb, &super->s_low_list[i]);\n\tlogfs_cleanup_list(sb, &super->s_ec_list);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_cleanup_list",
          "args": [
            "sb",
            "&super->s_ec_list"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_cleanup_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "699-711",
          "snippet": "static void logfs_cleanup_list(struct super_block *sb,\n\t\tstruct candidate_list *list)\n{\n\tstruct gc_candidate *cand;\n\n\twhile (list->count) {\n\t\tcand = rb_entry(list->rb_tree.rb_node, struct gc_candidate,\n\t\t\t\trb_node);\n\t\tremove_from_list(cand);\n\t\tfree_candidate(sb, cand);\n\t}\n\tBUG_ON(list->rb_tree.rb_node);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_cleanup_list(struct super_block *sb,\n\t\tstruct candidate_list *list)\n{\n\tstruct gc_candidate *cand;\n\n\twhile (list->count) {\n\t\tcand = rb_entry(list->rb_tree.rb_node, struct gc_candidate,\n\t\t\t\trb_node);\n\t\tremove_from_list(cand);\n\t\tfree_candidate(sb, cand);\n\t}\n\tBUG_ON(list->rb_tree.rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_grim_visitor32",
          "args": [
            "&super->s_cand_tree",
            "0",
            "NULL"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_cleanup_gc(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tif (!super->s_free_list.count)\n\t\treturn;\n\n\t/*\n\t * FIXME: The btree may still contain a single empty node.  So we\n\t * call the grim visitor to clean up that mess.  Btree code should\n\t * do it for us, really.\n\t */\n\tbtree_grim_visitor32(&super->s_cand_tree, 0, NULL);\n\tlogfs_cleanup_list(sb, &super->s_free_list);\n\tlogfs_cleanup_list(sb, &super->s_reserve_list);\n\tfor_each_area(i)\n\t\tlogfs_cleanup_list(sb, &super->s_low_list[i]);\n\tlogfs_cleanup_list(sb, &super->s_ec_list);\n}"
  },
  {
    "function_name": "logfs_cleanup_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "699-711",
    "snippet": "static void logfs_cleanup_list(struct super_block *sb,\n\t\tstruct candidate_list *list)\n{\n\tstruct gc_candidate *cand;\n\n\twhile (list->count) {\n\t\tcand = rb_entry(list->rb_tree.rb_node, struct gc_candidate,\n\t\t\t\trb_node);\n\t\tremove_from_list(cand);\n\t\tfree_candidate(sb, cand);\n\t}\n\tBUG_ON(list->rb_tree.rb_node);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list->rb_tree.rb_node"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_candidate",
          "args": [
            "sb",
            "cand"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "free_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "226-232",
          "snippet": "static void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_list",
          "args": [
            "cand"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "218-224",
          "snippet": "static void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "list->rb_tree.rb_node",
            "structgc_candidate",
            "rb_node"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_cleanup_list(struct super_block *sb,\n\t\tstruct candidate_list *list)\n{\n\tstruct gc_candidate *cand;\n\n\twhile (list->count) {\n\t\tcand = rb_entry(list->rb_tree.rb_node, struct gc_candidate,\n\t\t\t\trb_node);\n\t\tremove_from_list(cand);\n\t\tfree_candidate(sb, cand);\n\t}\n\tBUG_ON(list->rb_tree.rb_node);\n}"
  },
  {
    "function_name": "logfs_init_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "684-697",
    "snippet": "int logfs_init_gc(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tbtree_init_mempool32(&super->s_cand_tree, super->s_btree_pool);\n\tlogfs_init_candlist(&super->s_free_list, LIST_SIZE + SCAN_RATIO, 1);\n\tlogfs_init_candlist(&super->s_reserve_list,\n\t\t\tsuper->s_bad_seg_reserve, 1);\n\tfor_each_area(i)\n\t\tlogfs_init_candlist(&super->s_low_list[i], LIST_SIZE, 0);\n\tlogfs_init_candlist(&super->s_ec_list, LIST_SIZE, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define LIST_SIZE 64\t/* base size of candidate lists */",
      "#define SCAN_RATIO 512\t/* number of scanned segments per gc'd segment */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_init_candlist",
          "args": [
            "&super->s_ec_list",
            "LIST_SIZE",
            "1"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_candlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "675-682",
          "snippet": "static void logfs_init_candlist(struct candidate_list *list, int maxcount,\n\t\tint sort_by_ec)\n{\n\tlist->count = 0;\n\tlist->maxcount = maxcount;\n\tlist->sort_by_ec = sort_by_ec;\n\tlist->rb_tree = RB_ROOT;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_init_candlist(struct candidate_list *list, int maxcount,\n\t\tint sort_by_ec)\n{\n\tlist->count = 0;\n\tlist->maxcount = maxcount;\n\tlist->sort_by_ec = sort_by_ec;\n\tlist->rb_tree = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_init_mempool32",
          "args": [
            "&super->s_cand_tree",
            "super->s_btree_pool"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LIST_SIZE 64\t/* base size of candidate lists */\n#define SCAN_RATIO 512\t/* number of scanned segments per gc'd segment */\n\nint logfs_init_gc(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tbtree_init_mempool32(&super->s_cand_tree, super->s_btree_pool);\n\tlogfs_init_candlist(&super->s_free_list, LIST_SIZE + SCAN_RATIO, 1);\n\tlogfs_init_candlist(&super->s_reserve_list,\n\t\t\tsuper->s_bad_seg_reserve, 1);\n\tfor_each_area(i)\n\t\tlogfs_init_candlist(&super->s_low_list[i], LIST_SIZE, 0);\n\tlogfs_init_candlist(&super->s_ec_list, LIST_SIZE, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_init_candlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "675-682",
    "snippet": "static void logfs_init_candlist(struct candidate_list *list, int maxcount,\n\t\tint sort_by_ec)\n{\n\tlist->count = 0;\n\tlist->maxcount = maxcount;\n\tlist->sort_by_ec = sort_by_ec;\n\tlist->rb_tree = RB_ROOT;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_init_candlist(struct candidate_list *list, int maxcount,\n\t\tint sort_by_ec)\n{\n\tlist->count = 0;\n\tlist->maxcount = maxcount;\n\tlist->sort_by_ec = sort_by_ec;\n\tlist->rb_tree = RB_ROOT;\n}"
  },
  {
    "function_name": "logfs_check_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "663-673",
    "snippet": "int logfs_check_areas(struct super_block *sb)\n{\n\tint i, err;\n\n\tfor_each_area(i) {\n\t\terr = check_area(sb, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_area",
          "args": [
            "sb",
            "i"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "check_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "631-661",
          "snippet": "static int check_area(struct super_block *sb, int i)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[i];\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, ec;\n\tu32 segno = area->a_segno;\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\n\tif (!area->a_is_open)\n\t\treturn 0;\n\n\tif (super->s_devops->can_write_buf(sb, ofs) == 0)\n\t\treturn 0;\n\n\tprintk(KERN_INFO\"LogFS: Possibly incomplete write at %llx\\n\", ofs);\n\t/*\n\t * The device cannot write back the write buffer.  Most likely the\n\t * wbuf was already written out and the system crashed at some point\n\t * before the journal commit happened.  In that case we wouldn't have\n\t * to do anything.  But if the crash happened before the wbuf was\n\t * written out correctly, we must GC this segment.  So assume the\n\t * worst and always do the GC run.\n\t */\n\tarea->a_is_open = 0;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tif (cleaned != valid)\n\t\treturn -EIO;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int check_area(struct super_block *sb, int i)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[i];\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, ec;\n\tu32 segno = area->a_segno;\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\n\tif (!area->a_is_open)\n\t\treturn 0;\n\n\tif (super->s_devops->can_write_buf(sb, ofs) == 0)\n\t\treturn 0;\n\n\tprintk(KERN_INFO\"LogFS: Possibly incomplete write at %llx\\n\", ofs);\n\t/*\n\t * The device cannot write back the write buffer.  Most likely the\n\t * wbuf was already written out and the system crashed at some point\n\t * before the journal commit happened.  In that case we wouldn't have\n\t * to do anything.  But if the crash happened before the wbuf was\n\t * written out correctly, we must GC this segment.  So assume the\n\t * worst and always do the GC run.\n\t */\n\tarea->a_is_open = 0;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tif (cleaned != valid)\n\t\treturn -EIO;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_check_areas(struct super_block *sb)\n{\n\tint i, err;\n\n\tfor_each_area(i) {\n\t\terr = check_area(sb, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "631-661",
    "snippet": "static int check_area(struct super_block *sb, int i)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[i];\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, ec;\n\tu32 segno = area->a_segno;\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\n\tif (!area->a_is_open)\n\t\treturn 0;\n\n\tif (super->s_devops->can_write_buf(sb, ofs) == 0)\n\t\treturn 0;\n\n\tprintk(KERN_INFO\"LogFS: Possibly incomplete write at %llx\\n\", ofs);\n\t/*\n\t * The device cannot write back the write buffer.  Most likely the\n\t * wbuf was already written out and the system crashed at some point\n\t * before the journal commit happened.  In that case we wouldn't have\n\t * to do anything.  But if the crash happened before the wbuf was\n\t * written out correctly, we must GC this segment.  So assume the\n\t * worst and always do the GC run.\n\t */\n\tarea->a_is_open = 0;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tif (cleaned != valid)\n\t\treturn -EIO;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_gc_segment",
          "args": [
            "sb",
            "segno"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_gc_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "125-180",
          "snippet": "static u32 logfs_gc_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header sh;\n\tstruct logfs_object_header oh;\n\tu64 ofs, ino, bix;\n\tu32 seg_ofs, logical_segno, cleaned = 0;\n\tint err, len, valid;\n\tgc_level_t gc_level;\n\n\tLOGFS_BUG_ON(segment_is_reserved(sb, segno), sb);\n\n\tbtree_insert32(&super->s_reserved_segments, segno, (void *)1, GFP_NOFS);\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tBUG_ON(err);\n\tgc_level = GC_LEVEL(sh.level);\n\tlogical_segno = be32_to_cpu(sh.segno);\n\tif (sh.crc != logfs_crc32(&sh, sizeof(sh), 4)) {\n\t\tlogfs_mark_segment_bad(sb, segno);\n\t\tcleaned = -1;\n\t\tgoto out;\n\t}\n\n\tfor (seg_ofs = LOGFS_SEGMENT_HEADERSIZE;\n\t\t\tseg_ofs + sizeof(oh) < super->s_segsize; ) {\n\t\tofs = dev_ofs(sb, logical_segno, seg_ofs);\n\t\terr = wbuf_read(sb, dev_ofs(sb, segno, seg_ofs), sizeof(oh),\n\t\t\t\t&oh);\n\t\tBUG_ON(err);\n\n\t\tif (!memchr_inv(&oh, 0xff, sizeof(oh)))\n\t\t\tbreak;\n\n\t\tif (oh.crc != logfs_crc32(&oh, sizeof(oh) - 4, 4)) {\n\t\t\tlogfs_mark_segment_bad(sb, segno);\n\t\t\tcleaned = super->s_segsize - 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tino = be64_to_cpu(oh.ino);\n\t\tbix = be64_to_cpu(oh.bix);\n\t\tlen = sizeof(oh) + be16_to_cpu(oh.len);\n\t\tvalid = logfs_is_valid_block(sb, ofs, ino, bix, gc_level);\n\t\tif (valid == 1) {\n\t\t\tlogfs_cleanse_block(sb, ofs, ino, bix, gc_level);\n\t\t\tcleaned += len;\n\t\t} else if (valid == 2) {\n\t\t\t/* Will be invalid upon journal commit */\n\t\t\tcleaned += len;\n\t\t}\n\t\tseg_ofs += len;\n\t}\nout:\n\tbtree_remove32(&super->s_reserved_segments, segno);\n\treturn cleaned;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u32 logfs_gc_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header sh;\n\tstruct logfs_object_header oh;\n\tu64 ofs, ino, bix;\n\tu32 seg_ofs, logical_segno, cleaned = 0;\n\tint err, len, valid;\n\tgc_level_t gc_level;\n\n\tLOGFS_BUG_ON(segment_is_reserved(sb, segno), sb);\n\n\tbtree_insert32(&super->s_reserved_segments, segno, (void *)1, GFP_NOFS);\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tBUG_ON(err);\n\tgc_level = GC_LEVEL(sh.level);\n\tlogical_segno = be32_to_cpu(sh.segno);\n\tif (sh.crc != logfs_crc32(&sh, sizeof(sh), 4)) {\n\t\tlogfs_mark_segment_bad(sb, segno);\n\t\tcleaned = -1;\n\t\tgoto out;\n\t}\n\n\tfor (seg_ofs = LOGFS_SEGMENT_HEADERSIZE;\n\t\t\tseg_ofs + sizeof(oh) < super->s_segsize; ) {\n\t\tofs = dev_ofs(sb, logical_segno, seg_ofs);\n\t\terr = wbuf_read(sb, dev_ofs(sb, segno, seg_ofs), sizeof(oh),\n\t\t\t\t&oh);\n\t\tBUG_ON(err);\n\n\t\tif (!memchr_inv(&oh, 0xff, sizeof(oh)))\n\t\t\tbreak;\n\n\t\tif (oh.crc != logfs_crc32(&oh, sizeof(oh) - 4, 4)) {\n\t\t\tlogfs_mark_segment_bad(sb, segno);\n\t\t\tcleaned = super->s_segsize - 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tino = be64_to_cpu(oh.ino);\n\t\tbix = be64_to_cpu(oh.bix);\n\t\tlen = sizeof(oh) + be16_to_cpu(oh.len);\n\t\tvalid = logfs_is_valid_block(sb, ofs, ino, bix, gc_level);\n\t\tif (valid == 1) {\n\t\t\tlogfs_cleanse_block(sb, ofs, ino, bix, gc_level);\n\t\t\tcleaned += len;\n\t\t} else if (valid == 2) {\n\t\t\t/* Will be invalid upon journal commit */\n\t\t\tcleaned += len;\n\t\t}\n\t\tseg_ofs += len;\n\t}\nout:\n\tbtree_remove32(&super->s_reserved_segments, segno);\n\treturn cleaned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_valid_bytes",
          "args": [
            "sb",
            "segno",
            "&ec",
            "&gc_level"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_valid_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "96-111",
          "snippet": "static u32 logfs_valid_bytes(struct super_block *sb, u32 segno, u32 *ec,\n\t\tgc_level_t *gc_level)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tif (se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED))\n\t\treturn RESERVED;\n\n\tec_level = be32_to_cpu(se.ec_level);\n\t*ec = ec_level >> 4;\n\t*gc_level = GC_LEVEL(ec_level & 0xf);\n\treturn be32_to_cpu(se.valid);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u32 logfs_valid_bytes(struct super_block *sb, u32 segno, u32 *ec,\n\t\tgc_level_t *gc_level)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tif (se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED))\n\t\treturn RESERVED;\n\n\tec_level = be32_to_cpu(se.ec_level);\n\t*ec = ec_level >> 4;\n\t*gc_level = GC_LEVEL(ec_level & 0xf);\n\treturn be32_to_cpu(se.valid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\"LogFS: Possibly incomplete write at %llx\\n\"",
            "ofs"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "super->s_devops->can_write_buf",
          "args": [
            "sb",
            "ofs"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "area->a_written_bytes"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int check_area(struct super_block *sb, int i)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[i];\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, ec;\n\tu32 segno = area->a_segno;\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\n\tif (!area->a_is_open)\n\t\treturn 0;\n\n\tif (super->s_devops->can_write_buf(sb, ofs) == 0)\n\t\treturn 0;\n\n\tprintk(KERN_INFO\"LogFS: Possibly incomplete write at %llx\\n\", ofs);\n\t/*\n\t * The device cannot write back the write buffer.  Most likely the\n\t * wbuf was already written out and the system crashed at some point\n\t * before the journal commit happened.  In that case we wouldn't have\n\t * to do anything.  But if the crash happened before the wbuf was\n\t * written out correctly, we must GC this segment.  So assume the\n\t * worst and always do the GC run.\n\t */\n\tarea->a_is_open = 0;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tif (cleaned != valid)\n\t\treturn -EIO;\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_gc_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "615-629",
    "snippet": "void logfs_gc_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t//BUG_ON(mutex_trylock(&logfs_super(sb)->s_w_mutex));\n\t/* Write journal before free space is getting saturated with dirty\n\t * objects.\n\t */\n\tif (super->s_dirty_used_bytes + super->s_dirty_free_bytes\n\t\t\t+ LOGFS_MAX_OBJECTSIZE >= super->s_free_bytes)\n\t\tlogfs_write_anchor(sb);\n\t__logfs_gc_pass(sb, super->s_total_levels);\n\tlogfs_wl_pass(sb);\n\tlogfs_journal_wl_pass(sb);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_journal_wl_pass",
          "args": [
            "sb"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_journal_wl_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "578-613",
          "snippet": "static void logfs_journal_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\tu32 min_journal_ec = -1, max_reserve_ec = 0;\n\tint i;\n\n\tif (wl_ratelimit(sb, &super->s_wl_gec_journal))\n\t\treturn;\n\n\tif (super->s_reserve_list.count < super->s_no_journal_segs) {\n\t\t/* Reserve is not full enough to move complete journal */\n\t\treturn;\n\t}\n\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i])\n\t\t\tmin_journal_ec = min(min_journal_ec,\n\t\t\t\t\tsuper->s_journal_ec[i]);\n\tcand = rb_entry(rb_first(&super->s_free_list.rb_tree),\n\t\t\tstruct gc_candidate, rb_node);\n\tmax_reserve_ec = cand->erase_count;\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct logfs_segment_entry se;\n\t\tu32 segno = seg_no(sb, super->s_sb_ofs[i]);\n\t\tu32 ec;\n\n\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\tec = be32_to_cpu(se.ec_level) >> 4;\n\t\tmax_reserve_ec = max(max_reserve_ec, ec);\n\t}\n\n\tif (min_journal_ec > max_reserve_ec + 2 * WL_DELTA) {\n\t\tdo_logfs_journal_wl_pass(sb);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define WL_DELTA 397"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define WL_DELTA 397\n\nstatic void logfs_journal_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\tu32 min_journal_ec = -1, max_reserve_ec = 0;\n\tint i;\n\n\tif (wl_ratelimit(sb, &super->s_wl_gec_journal))\n\t\treturn;\n\n\tif (super->s_reserve_list.count < super->s_no_journal_segs) {\n\t\t/* Reserve is not full enough to move complete journal */\n\t\treturn;\n\t}\n\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i])\n\t\t\tmin_journal_ec = min(min_journal_ec,\n\t\t\t\t\tsuper->s_journal_ec[i]);\n\tcand = rb_entry(rb_first(&super->s_free_list.rb_tree),\n\t\t\tstruct gc_candidate, rb_node);\n\tmax_reserve_ec = cand->erase_count;\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct logfs_segment_entry se;\n\t\tu32 segno = seg_no(sb, super->s_sb_ofs[i]);\n\t\tu32 ec;\n\n\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\tec = be32_to_cpu(se.ec_level) >> 4;\n\t\tmax_reserve_ec = max(max_reserve_ec, ec);\n\t}\n\n\tif (min_journal_ec > max_reserve_ec + 2 * WL_DELTA) {\n\t\tdo_logfs_journal_wl_pass(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_wl_pass",
          "args": [
            "sb"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_wl_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "535-554",
          "snippet": "static void logfs_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *wl_cand, *free_cand;\n\n\tif (wl_ratelimit(sb, &super->s_wl_gec_ostore))\n\t\treturn;\n\n\twl_cand = first_in_list(&super->s_ec_list);\n\tif (!wl_cand)\n\t\treturn;\n\tfree_cand = first_in_list(&super->s_free_list);\n\tif (!free_cand)\n\t\treturn;\n\n\tif (wl_cand->erase_count < free_cand->erase_count + WL_DELTA) {\n\t\tremove_from_list(wl_cand);\n\t\t__logfs_gc_once(sb, wl_cand);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define WL_DELTA 397"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define WL_DELTA 397\n\nstatic void logfs_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *wl_cand, *free_cand;\n\n\tif (wl_ratelimit(sb, &super->s_wl_gec_ostore))\n\t\treturn;\n\n\twl_cand = first_in_list(&super->s_ec_list);\n\tif (!wl_cand)\n\t\treturn;\n\tfree_cand = first_in_list(&super->s_free_list);\n\tif (!free_cand)\n\t\treturn;\n\n\tif (wl_cand->erase_count < free_cand->erase_count + WL_DELTA) {\n\t\tremove_from_list(wl_cand);\n\t\t__logfs_gc_once(sb, wl_cand);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_gc_pass",
          "args": [
            "sb",
            "super->s_total_levels"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_gc_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "456-522",
          "snippet": "static void __logfs_gc_pass(struct super_block *sb, int target)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tint round, progress, last_progress = 0;\n\n\t/*\n\t * Doing too many changes to the segfile at once would result\n\t * in a large number of aliases.  Write the journal before\n\t * things get out of hand.\n\t */\n\tif (super->s_shadow_tree.no_shadowed_segments >= MAX_OBJ_ALIASES)\n\t\tlogfs_write_anchor(sb);\n\n\tif (no_free_segments(sb) >= target &&\n\t\t\tsuper->s_no_object_aliases < MAX_OBJ_ALIASES)\n\t\treturn;\n\n\tlog_gc(\"__logfs_gc_pass(%x)\\n\", target);\n\tfor (round = 0; round < SCAN_ROUNDS; ) {\n\t\tif (no_free_segments(sb) >= target)\n\t\t\tgoto write_alias;\n\n\t\t/* Sync in-memory state with on-medium state in case they\n\t\t * diverged */\n\t\tlogfs_write_anchor(sb);\n\t\tround += logfs_scan_some(sb);\n\t\tif (no_free_segments(sb) >= target)\n\t\t\tgoto write_alias;\n\t\tprogress = logfs_gc_once(sb);\n\t\tif (progress)\n\t\t\tlast_progress = round;\n\t\telse if (round - last_progress > 2)\n\t\t\tbreak;\n\t\tcontinue;\n\n\t\t/*\n\t\t * The goto logic is nasty, I just don't know a better way to\n\t\t * code it.  GC is supposed to ensure two things:\n\t\t * 1. Enough free segments are available.\n\t\t * 2. The number of aliases is bounded.\n\t\t * When 1. is achieved, we take a look at 2. and write back\n\t\t * some alias-containing blocks, if necessary.  However, after\n\t\t * each such write we need to go back to 1., as writes can\n\t\t * consume free segments.\n\t\t */\nwrite_alias:\n\t\tif (super->s_no_object_aliases < MAX_OBJ_ALIASES)\n\t\t\treturn;\n\t\tif (list_empty(&super->s_object_alias)) {\n\t\t\t/* All aliases are still in btree */\n\t\t\treturn;\n\t\t}\n\t\tlog_gc(\"Write back one alias\\n\");\n\t\tblock = list_entry(super->s_object_alias.next,\n\t\t\t\tstruct logfs_block, alias_list);\n\t\tblock->ops->write_block(block);\n\t\t/*\n\t\t * To round off the nasty goto logic, we reset round here.  It\n\t\t * is a safety-net for GC not making any progress and limited\n\t\t * to something reasonably small.  If incremented it for every\n\t\t * single alias, the loop could terminate rather quickly.\n\t\t */\n\t\tround = 0;\n\t}\n\tLOGFS_BUG(sb);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define SCAN_ROUNDS 128\t/* maximum number of complete medium scans */",
            "#define MAX_OBJ_ALIASES\t2600"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define SCAN_ROUNDS 128\t/* maximum number of complete medium scans */\n#define MAX_OBJ_ALIASES\t2600\n\nstatic void __logfs_gc_pass(struct super_block *sb, int target)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tint round, progress, last_progress = 0;\n\n\t/*\n\t * Doing too many changes to the segfile at once would result\n\t * in a large number of aliases.  Write the journal before\n\t * things get out of hand.\n\t */\n\tif (super->s_shadow_tree.no_shadowed_segments >= MAX_OBJ_ALIASES)\n\t\tlogfs_write_anchor(sb);\n\n\tif (no_free_segments(sb) >= target &&\n\t\t\tsuper->s_no_object_aliases < MAX_OBJ_ALIASES)\n\t\treturn;\n\n\tlog_gc(\"__logfs_gc_pass(%x)\\n\", target);\n\tfor (round = 0; round < SCAN_ROUNDS; ) {\n\t\tif (no_free_segments(sb) >= target)\n\t\t\tgoto write_alias;\n\n\t\t/* Sync in-memory state with on-medium state in case they\n\t\t * diverged */\n\t\tlogfs_write_anchor(sb);\n\t\tround += logfs_scan_some(sb);\n\t\tif (no_free_segments(sb) >= target)\n\t\t\tgoto write_alias;\n\t\tprogress = logfs_gc_once(sb);\n\t\tif (progress)\n\t\t\tlast_progress = round;\n\t\telse if (round - last_progress > 2)\n\t\t\tbreak;\n\t\tcontinue;\n\n\t\t/*\n\t\t * The goto logic is nasty, I just don't know a better way to\n\t\t * code it.  GC is supposed to ensure two things:\n\t\t * 1. Enough free segments are available.\n\t\t * 2. The number of aliases is bounded.\n\t\t * When 1. is achieved, we take a look at 2. and write back\n\t\t * some alias-containing blocks, if necessary.  However, after\n\t\t * each such write we need to go back to 1., as writes can\n\t\t * consume free segments.\n\t\t */\nwrite_alias:\n\t\tif (super->s_no_object_aliases < MAX_OBJ_ALIASES)\n\t\t\treturn;\n\t\tif (list_empty(&super->s_object_alias)) {\n\t\t\t/* All aliases are still in btree */\n\t\t\treturn;\n\t\t}\n\t\tlog_gc(\"Write back one alias\\n\");\n\t\tblock = list_entry(super->s_object_alias.next,\n\t\t\t\tstruct logfs_block, alias_list);\n\t\tblock->ops->write_block(block);\n\t\t/*\n\t\t * To round off the nasty goto logic, we reset round here.  It\n\t\t * is a safety-net for GC not making any progress and limited\n\t\t * to something reasonably small.  If incremented it for every\n\t\t * single alias, the loop could terminate rather quickly.\n\t\t */\n\t\tround = 0;\n\t}\n\tLOGFS_BUG(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_anchor",
          "args": [
            "sb"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "734-803",
          "snippet": "void logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_gc_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t//BUG_ON(mutex_trylock(&logfs_super(sb)->s_w_mutex));\n\t/* Write journal before free space is getting saturated with dirty\n\t * objects.\n\t */\n\tif (super->s_dirty_used_bytes + super->s_dirty_free_bytes\n\t\t\t+ LOGFS_MAX_OBJECTSIZE >= super->s_free_bytes)\n\t\tlogfs_write_anchor(sb);\n\t__logfs_gc_pass(sb, super->s_total_levels);\n\tlogfs_wl_pass(sb);\n\tlogfs_journal_wl_pass(sb);\n}"
  },
  {
    "function_name": "logfs_journal_wl_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "578-613",
    "snippet": "static void logfs_journal_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\tu32 min_journal_ec = -1, max_reserve_ec = 0;\n\tint i;\n\n\tif (wl_ratelimit(sb, &super->s_wl_gec_journal))\n\t\treturn;\n\n\tif (super->s_reserve_list.count < super->s_no_journal_segs) {\n\t\t/* Reserve is not full enough to move complete journal */\n\t\treturn;\n\t}\n\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i])\n\t\t\tmin_journal_ec = min(min_journal_ec,\n\t\t\t\t\tsuper->s_journal_ec[i]);\n\tcand = rb_entry(rb_first(&super->s_free_list.rb_tree),\n\t\t\tstruct gc_candidate, rb_node);\n\tmax_reserve_ec = cand->erase_count;\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct logfs_segment_entry se;\n\t\tu32 segno = seg_no(sb, super->s_sb_ofs[i]);\n\t\tu32 ec;\n\n\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\tec = be32_to_cpu(se.ec_level) >> 4;\n\t\tmax_reserve_ec = max(max_reserve_ec, ec);\n\t}\n\n\tif (min_journal_ec > max_reserve_ec + 2 * WL_DELTA) {\n\t\tdo_logfs_journal_wl_pass(sb);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define WL_DELTA 397"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_logfs_journal_wl_pass",
          "args": [
            "sb"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "do_logfs_journal_wl_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "805-845",
          "snippet": "void do_logfs_journal_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tu32 segno, ec;\n\tint i, err;\n\n\tlog_journal(\"Journal requires wear-leveling.\\n\");\n\t/* Drop old segments */\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i]) {\n\t\t\tbtree_remove32(head, super->s_journal_seg[i]);\n\t\t\tlogfs_set_segment_unreserved(sb,\n\t\t\t\t\tsuper->s_journal_seg[i],\n\t\t\t\t\tsuper->s_journal_ec[i]);\n\t\t\tsuper->s_journal_seg[i] = 0;\n\t\t\tsuper->s_journal_ec[i] = 0;\n\t\t}\n\t/* Get new segments */\n\tfor (i = 0; i < super->s_no_journal_segs; i++) {\n\t\tsegno = get_best_cand(sb, &super->s_reserve_list, &ec);\n\t\tsuper->s_journal_seg[i] = segno;\n\t\tsuper->s_journal_ec[i] = ec;\n\t\tlogfs_set_segment_reserved(sb, segno);\n\t\terr = btree_insert32(head, segno, (void *)1, GFP_NOFS);\n\t\tBUG_ON(err); /* mempool should prevent this */\n\t\terr = logfs_erase_segment(sb, segno, 1);\n\t\tBUG_ON(err); /* FIXME: remount-ro would be nicer */\n\t}\n\t/* Manually move journal_area */\n\tfreeseg(sb, area->a_segno);\n\tarea->a_segno = super->s_journal_seg[0];\n\tarea->a_is_open = 0;\n\tarea->a_used_bytes = 0;\n\t/* Write journal */\n\tlogfs_write_anchor(sb);\n\t/* Write superblocks */\n\terr = logfs_write_sb(sb);\n\tBUG_ON(err);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid do_logfs_journal_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tu32 segno, ec;\n\tint i, err;\n\n\tlog_journal(\"Journal requires wear-leveling.\\n\");\n\t/* Drop old segments */\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i]) {\n\t\t\tbtree_remove32(head, super->s_journal_seg[i]);\n\t\t\tlogfs_set_segment_unreserved(sb,\n\t\t\t\t\tsuper->s_journal_seg[i],\n\t\t\t\t\tsuper->s_journal_ec[i]);\n\t\t\tsuper->s_journal_seg[i] = 0;\n\t\t\tsuper->s_journal_ec[i] = 0;\n\t\t}\n\t/* Get new segments */\n\tfor (i = 0; i < super->s_no_journal_segs; i++) {\n\t\tsegno = get_best_cand(sb, &super->s_reserve_list, &ec);\n\t\tsuper->s_journal_seg[i] = segno;\n\t\tsuper->s_journal_ec[i] = ec;\n\t\tlogfs_set_segment_reserved(sb, segno);\n\t\terr = btree_insert32(head, segno, (void *)1, GFP_NOFS);\n\t\tBUG_ON(err); /* mempool should prevent this */\n\t\terr = logfs_erase_segment(sb, segno, 1);\n\t\tBUG_ON(err); /* FIXME: remount-ro would be nicer */\n\t}\n\t/* Manually move journal_area */\n\tfreeseg(sb, area->a_segno);\n\tarea->a_segno = super->s_journal_seg[0];\n\tarea->a_is_open = 0;\n\tarea->a_used_bytes = 0;\n\t/* Write journal */\n\tlogfs_write_anchor(sb);\n\t/* Write superblocks */\n\terr = logfs_write_sb(sb);\n\tBUG_ON(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_reserve_ec",
            "ec"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "get_max_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "168-180",
          "snippet": "static unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic unsigned int get_max_cost(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct victim_sel_policy *p)\n{\n\t/* SSR allocates in a segment unit */\n\tif (p->alloc_mode == SSR)\n\t\treturn 1 << sbi->log_blocks_per_seg;\n\tif (p->gc_mode == GC_GREEDY)\n\t\treturn (1 << sbi->log_blocks_per_seg) * p->ofs_unit;\n\telse if (p->gc_mode == GC_CB)\n\t\treturn UINT_MAX;\n\telse /* No other gc_mode */\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.ec_level"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_segment_entry",
          "args": [
            "sb",
            "segno",
            "&se"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2068-2072",
          "snippet": "void logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seg_no",
          "args": [
            "sb",
            "super->s_sb_ofs[i]"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "seg_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "673-676",
          "snippet": "static inline u32 seg_no(struct super_block *sb, u64 ofs)\n{\n\treturn ofs >> logfs_super(sb)->s_segshift;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u32 seg_no(struct super_block *sb, u64 ofs)\n{\n\treturn ofs >> logfs_super(sb)->s_segshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_first(&super->s_free_list.rb_tree)",
            "structgc_candidate",
            "rb_node"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&super->s_free_list.rb_tree"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "min_journal_ec",
            "super->s_journal_ec[i]"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wl_ratelimit",
          "args": [
            "sb",
            "&super->s_wl_gec_journal"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "wl_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "524-533",
          "snippet": "static int wl_ratelimit(struct super_block *sb, u64 *next_event)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (*next_event < super->s_gec) {\n\t\t*next_event = super->s_gec + WL_RATELIMIT;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define WL_RATELIMIT 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define WL_RATELIMIT 100\n\nstatic int wl_ratelimit(struct super_block *sb, u64 *next_event)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (*next_event < super->s_gec) {\n\t\t*next_event = super->s_gec + WL_RATELIMIT;\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define WL_DELTA 397\n\nstatic void logfs_journal_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\tu32 min_journal_ec = -1, max_reserve_ec = 0;\n\tint i;\n\n\tif (wl_ratelimit(sb, &super->s_wl_gec_journal))\n\t\treturn;\n\n\tif (super->s_reserve_list.count < super->s_no_journal_segs) {\n\t\t/* Reserve is not full enough to move complete journal */\n\t\treturn;\n\t}\n\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i])\n\t\t\tmin_journal_ec = min(min_journal_ec,\n\t\t\t\t\tsuper->s_journal_ec[i]);\n\tcand = rb_entry(rb_first(&super->s_free_list.rb_tree),\n\t\t\tstruct gc_candidate, rb_node);\n\tmax_reserve_ec = cand->erase_count;\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct logfs_segment_entry se;\n\t\tu32 segno = seg_no(sb, super->s_sb_ofs[i]);\n\t\tu32 ec;\n\n\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\tec = be32_to_cpu(se.ec_level) >> 4;\n\t\tmax_reserve_ec = max(max_reserve_ec, ec);\n\t}\n\n\tif (min_journal_ec > max_reserve_ec + 2 * WL_DELTA) {\n\t\tdo_logfs_journal_wl_pass(sb);\n\t}\n}"
  },
  {
    "function_name": "logfs_wl_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "535-554",
    "snippet": "static void logfs_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *wl_cand, *free_cand;\n\n\tif (wl_ratelimit(sb, &super->s_wl_gec_ostore))\n\t\treturn;\n\n\twl_cand = first_in_list(&super->s_ec_list);\n\tif (!wl_cand)\n\t\treturn;\n\tfree_cand = first_in_list(&super->s_free_list);\n\tif (!free_cand)\n\t\treturn;\n\n\tif (wl_cand->erase_count < free_cand->erase_count + WL_DELTA) {\n\t\tremove_from_list(wl_cand);\n\t\t__logfs_gc_once(sb, wl_cand);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define WL_DELTA 397"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_gc_once",
          "args": [
            "sb",
            "wl_cand"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_gc_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "384-409",
          "snippet": "static int __logfs_gc_once(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, segno, ec;\n\tu8 dist;\n\n\tif (!cand) {\n\t\tlog_gc(\"GC attempted, but no candidate found\\n\");\n\t\treturn 0;\n\t}\n\n\tsegno = cand->segno;\n\tdist = cand->dist;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tfree_candidate(sb, cand);\n\tlog_gc(\"GC segment #%02x at %llx, %x required, %x free, %x valid, %llx free\\n\",\n\t\t\tsegno, (u64)segno << super->s_segshift,\n\t\t\tdist, no_free_segments(sb), valid,\n\t\t\tsuper->s_free_bytes);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tlog_gc(\"GC segment #%02x complete - now %x valid\\n\", segno,\n\t\t\tvalid - cleaned);\n\tBUG_ON(cleaned != valid);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_gc_once(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, segno, ec;\n\tu8 dist;\n\n\tif (!cand) {\n\t\tlog_gc(\"GC attempted, but no candidate found\\n\");\n\t\treturn 0;\n\t}\n\n\tsegno = cand->segno;\n\tdist = cand->dist;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tfree_candidate(sb, cand);\n\tlog_gc(\"GC segment #%02x at %llx, %x required, %x free, %x valid, %llx free\\n\",\n\t\t\tsegno, (u64)segno << super->s_segshift,\n\t\t\tdist, no_free_segments(sb), valid,\n\t\t\tsuper->s_free_bytes);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tlog_gc(\"GC segment #%02x complete - now %x valid\\n\", segno,\n\t\t\tvalid - cleaned);\n\tBUG_ON(cleaned != valid);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_list",
          "args": [
            "wl_cand"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "218-224",
          "snippet": "static void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_in_list",
          "args": [
            "&super->s_free_list"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "first_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "348-353",
          "snippet": "static struct gc_candidate *first_in_list(struct candidate_list *list)\n{\n\tif (list->count == 0)\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct gc_candidate *first_in_list(struct candidate_list *list)\n{\n\tif (list->count == 0)\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wl_ratelimit",
          "args": [
            "sb",
            "&super->s_wl_gec_ostore"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "wl_ratelimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "524-533",
          "snippet": "static int wl_ratelimit(struct super_block *sb, u64 *next_event)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (*next_event < super->s_gec) {\n\t\t*next_event = super->s_gec + WL_RATELIMIT;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define WL_RATELIMIT 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define WL_RATELIMIT 100\n\nstatic int wl_ratelimit(struct super_block *sb, u64 *next_event)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (*next_event < super->s_gec) {\n\t\t*next_event = super->s_gec + WL_RATELIMIT;\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define WL_DELTA 397\n\nstatic void logfs_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *wl_cand, *free_cand;\n\n\tif (wl_ratelimit(sb, &super->s_wl_gec_ostore))\n\t\treturn;\n\n\twl_cand = first_in_list(&super->s_ec_list);\n\tif (!wl_cand)\n\t\treturn;\n\tfree_cand = first_in_list(&super->s_free_list);\n\tif (!free_cand)\n\t\treturn;\n\n\tif (wl_cand->erase_count < free_cand->erase_count + WL_DELTA) {\n\t\tremove_from_list(wl_cand);\n\t\t__logfs_gc_once(sb, wl_cand);\n\t}\n}"
  },
  {
    "function_name": "wl_ratelimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "524-533",
    "snippet": "static int wl_ratelimit(struct super_block *sb, u64 *next_event)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (*next_event < super->s_gec) {\n\t\t*next_event = super->s_gec + WL_RATELIMIT;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define WL_RATELIMIT 100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define WL_RATELIMIT 100\n\nstatic int wl_ratelimit(struct super_block *sb, u64 *next_event)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (*next_event < super->s_gec) {\n\t\t*next_event = super->s_gec + WL_RATELIMIT;\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__logfs_gc_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "456-522",
    "snippet": "static void __logfs_gc_pass(struct super_block *sb, int target)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tint round, progress, last_progress = 0;\n\n\t/*\n\t * Doing too many changes to the segfile at once would result\n\t * in a large number of aliases.  Write the journal before\n\t * things get out of hand.\n\t */\n\tif (super->s_shadow_tree.no_shadowed_segments >= MAX_OBJ_ALIASES)\n\t\tlogfs_write_anchor(sb);\n\n\tif (no_free_segments(sb) >= target &&\n\t\t\tsuper->s_no_object_aliases < MAX_OBJ_ALIASES)\n\t\treturn;\n\n\tlog_gc(\"__logfs_gc_pass(%x)\\n\", target);\n\tfor (round = 0; round < SCAN_ROUNDS; ) {\n\t\tif (no_free_segments(sb) >= target)\n\t\t\tgoto write_alias;\n\n\t\t/* Sync in-memory state with on-medium state in case they\n\t\t * diverged */\n\t\tlogfs_write_anchor(sb);\n\t\tround += logfs_scan_some(sb);\n\t\tif (no_free_segments(sb) >= target)\n\t\t\tgoto write_alias;\n\t\tprogress = logfs_gc_once(sb);\n\t\tif (progress)\n\t\t\tlast_progress = round;\n\t\telse if (round - last_progress > 2)\n\t\t\tbreak;\n\t\tcontinue;\n\n\t\t/*\n\t\t * The goto logic is nasty, I just don't know a better way to\n\t\t * code it.  GC is supposed to ensure two things:\n\t\t * 1. Enough free segments are available.\n\t\t * 2. The number of aliases is bounded.\n\t\t * When 1. is achieved, we take a look at 2. and write back\n\t\t * some alias-containing blocks, if necessary.  However, after\n\t\t * each such write we need to go back to 1., as writes can\n\t\t * consume free segments.\n\t\t */\nwrite_alias:\n\t\tif (super->s_no_object_aliases < MAX_OBJ_ALIASES)\n\t\t\treturn;\n\t\tif (list_empty(&super->s_object_alias)) {\n\t\t\t/* All aliases are still in btree */\n\t\t\treturn;\n\t\t}\n\t\tlog_gc(\"Write back one alias\\n\");\n\t\tblock = list_entry(super->s_object_alias.next,\n\t\t\t\tstruct logfs_block, alias_list);\n\t\tblock->ops->write_block(block);\n\t\t/*\n\t\t * To round off the nasty goto logic, we reset round here.  It\n\t\t * is a safety-net for GC not making any progress and limited\n\t\t * to something reasonably small.  If incremented it for every\n\t\t * single alias, the loop could terminate rather quickly.\n\t\t */\n\t\tround = 0;\n\t}\n\tLOGFS_BUG(sb);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define SCAN_ROUNDS 128\t/* maximum number of complete medium scans */",
      "#define MAX_OBJ_ALIASES\t2600"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGFS_BUG",
          "args": [
            "sb"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block->ops->write_block",
          "args": [
            "block"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "super->s_object_alias.next",
            "structlogfs_block",
            "alias_list"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_gc",
          "args": [
            "\"Write back one alias\\n\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&super->s_object_alias"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_gc_once",
          "args": [
            "sb"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_gc_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "411-419",
          "snippet": "static int logfs_gc_once(struct super_block *sb)\n{\n\tstruct gc_candidate *cand;\n\n\tcand = get_candidate(sb);\n\tif (cand)\n\t\tremove_from_list(cand);\n\treturn __logfs_gc_once(sb, cand);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_gc_once(struct super_block *sb)\n{\n\tstruct gc_candidate *cand;\n\n\tcand = get_candidate(sb);\n\tif (cand)\n\t\tremove_from_list(cand);\n\treturn __logfs_gc_once(sb, cand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_free_segments",
          "args": [
            "sb"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "no_free_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "31-36",
          "snippet": "static int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_scan_some",
          "args": [
            "sb"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_scan_some",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "422-445",
          "snippet": "static int logfs_scan_some(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 segno;\n\tint i, ret = 0;\n\n\tsegno = super->s_sweeper;\n\tfor (i = SCAN_RATIO; i > 0; i--) {\n\t\tsegno++;\n\t\tif (segno >= super->s_no_segs) {\n\t\t\tsegno = 0;\n\t\t\tret = 1;\n\t\t\t/* Break out of the loop.  We want to read a single\n\t\t\t * block from the segment size on next invocation if\n\t\t\t * SCAN_RATIO is set to match block size\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tscan_segment(sb, segno);\n\t}\n\tsuper->s_sweeper = segno;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define SCAN_RATIO 512\t/* number of scanned segments per gc'd segment */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define SCAN_RATIO 512\t/* number of scanned segments per gc'd segment */\n\nstatic int logfs_scan_some(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 segno;\n\tint i, ret = 0;\n\n\tsegno = super->s_sweeper;\n\tfor (i = SCAN_RATIO; i > 0; i--) {\n\t\tsegno++;\n\t\tif (segno >= super->s_no_segs) {\n\t\t\tsegno = 0;\n\t\t\tret = 1;\n\t\t\t/* Break out of the loop.  We want to read a single\n\t\t\t * block from the segment size on next invocation if\n\t\t\t * SCAN_RATIO is set to match block size\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tscan_segment(sb, segno);\n\t}\n\tsuper->s_sweeper = segno;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_anchor",
          "args": [
            "sb"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "734-803",
          "snippet": "void logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_gc",
          "args": [
            "\"__logfs_gc_pass(%x)\\n\"",
            "target"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define SCAN_ROUNDS 128\t/* maximum number of complete medium scans */\n#define MAX_OBJ_ALIASES\t2600\n\nstatic void __logfs_gc_pass(struct super_block *sb, int target)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tint round, progress, last_progress = 0;\n\n\t/*\n\t * Doing too many changes to the segfile at once would result\n\t * in a large number of aliases.  Write the journal before\n\t * things get out of hand.\n\t */\n\tif (super->s_shadow_tree.no_shadowed_segments >= MAX_OBJ_ALIASES)\n\t\tlogfs_write_anchor(sb);\n\n\tif (no_free_segments(sb) >= target &&\n\t\t\tsuper->s_no_object_aliases < MAX_OBJ_ALIASES)\n\t\treturn;\n\n\tlog_gc(\"__logfs_gc_pass(%x)\\n\", target);\n\tfor (round = 0; round < SCAN_ROUNDS; ) {\n\t\tif (no_free_segments(sb) >= target)\n\t\t\tgoto write_alias;\n\n\t\t/* Sync in-memory state with on-medium state in case they\n\t\t * diverged */\n\t\tlogfs_write_anchor(sb);\n\t\tround += logfs_scan_some(sb);\n\t\tif (no_free_segments(sb) >= target)\n\t\t\tgoto write_alias;\n\t\tprogress = logfs_gc_once(sb);\n\t\tif (progress)\n\t\t\tlast_progress = round;\n\t\telse if (round - last_progress > 2)\n\t\t\tbreak;\n\t\tcontinue;\n\n\t\t/*\n\t\t * The goto logic is nasty, I just don't know a better way to\n\t\t * code it.  GC is supposed to ensure two things:\n\t\t * 1. Enough free segments are available.\n\t\t * 2. The number of aliases is bounded.\n\t\t * When 1. is achieved, we take a look at 2. and write back\n\t\t * some alias-containing blocks, if necessary.  However, after\n\t\t * each such write we need to go back to 1., as writes can\n\t\t * consume free segments.\n\t\t */\nwrite_alias:\n\t\tif (super->s_no_object_aliases < MAX_OBJ_ALIASES)\n\t\t\treturn;\n\t\tif (list_empty(&super->s_object_alias)) {\n\t\t\t/* All aliases are still in btree */\n\t\t\treturn;\n\t\t}\n\t\tlog_gc(\"Write back one alias\\n\");\n\t\tblock = list_entry(super->s_object_alias.next,\n\t\t\t\tstruct logfs_block, alias_list);\n\t\tblock->ops->write_block(block);\n\t\t/*\n\t\t * To round off the nasty goto logic, we reset round here.  It\n\t\t * is a safety-net for GC not making any progress and limited\n\t\t * to something reasonably small.  If incremented it for every\n\t\t * single alias, the loop could terminate rather quickly.\n\t\t */\n\t\tround = 0;\n\t}\n\tLOGFS_BUG(sb);\n}"
  },
  {
    "function_name": "logfs_scan_some",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "422-445",
    "snippet": "static int logfs_scan_some(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 segno;\n\tint i, ret = 0;\n\n\tsegno = super->s_sweeper;\n\tfor (i = SCAN_RATIO; i > 0; i--) {\n\t\tsegno++;\n\t\tif (segno >= super->s_no_segs) {\n\t\t\tsegno = 0;\n\t\t\tret = 1;\n\t\t\t/* Break out of the loop.  We want to read a single\n\t\t\t * block from the segment size on next invocation if\n\t\t\t * SCAN_RATIO is set to match block size\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tscan_segment(sb, segno);\n\t}\n\tsuper->s_sweeper = segno;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define SCAN_RATIO 512\t/* number of scanned segments per gc'd segment */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scan_segment",
          "args": [
            "sb",
            "segno"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "scan_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "330-346",
          "snippet": "static void scan_segment(struct super_block *sb, u32 segno)\n{\n\tu32 valid, ec = 0;\n\tgc_level_t gc_level = 0;\n\tu8 dist;\n\n\tif (segment_is_reserved(sb, segno))\n\t\treturn;\n\n\tremove_segment_from_lists(sb, segno);\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tif (valid == RESERVED)\n\t\treturn;\n\n\tdist = root_distance(sb, gc_level);\n\tadd_candidate(sb, segno, valid, ec, dist);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void scan_segment(struct super_block *sb, u32 segno)\n{\n\tu32 valid, ec = 0;\n\tgc_level_t gc_level = 0;\n\tu8 dist;\n\n\tif (segment_is_reserved(sb, segno))\n\t\treturn;\n\n\tremove_segment_from_lists(sb, segno);\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tif (valid == RESERVED)\n\t\treturn;\n\n\tdist = root_distance(sb, gc_level);\n\tadd_candidate(sb, segno, valid, ec, dist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define SCAN_RATIO 512\t/* number of scanned segments per gc'd segment */\n\nstatic int logfs_scan_some(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 segno;\n\tint i, ret = 0;\n\n\tsegno = super->s_sweeper;\n\tfor (i = SCAN_RATIO; i > 0; i--) {\n\t\tsegno++;\n\t\tif (segno >= super->s_no_segs) {\n\t\t\tsegno = 0;\n\t\t\tret = 1;\n\t\t\t/* Break out of the loop.  We want to read a single\n\t\t\t * block from the segment size on next invocation if\n\t\t\t * SCAN_RATIO is set to match block size\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tscan_segment(sb, segno);\n\t}\n\tsuper->s_sweeper = segno;\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_gc_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "411-419",
    "snippet": "static int logfs_gc_once(struct super_block *sb)\n{\n\tstruct gc_candidate *cand;\n\n\tcand = get_candidate(sb);\n\tif (cand)\n\t\tremove_from_list(cand);\n\treturn __logfs_gc_once(sb, cand);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_gc_once",
          "args": [
            "sb",
            "cand"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_gc_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "384-409",
          "snippet": "static int __logfs_gc_once(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, segno, ec;\n\tu8 dist;\n\n\tif (!cand) {\n\t\tlog_gc(\"GC attempted, but no candidate found\\n\");\n\t\treturn 0;\n\t}\n\n\tsegno = cand->segno;\n\tdist = cand->dist;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tfree_candidate(sb, cand);\n\tlog_gc(\"GC segment #%02x at %llx, %x required, %x free, %x valid, %llx free\\n\",\n\t\t\tsegno, (u64)segno << super->s_segshift,\n\t\t\tdist, no_free_segments(sb), valid,\n\t\t\tsuper->s_free_bytes);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tlog_gc(\"GC segment #%02x complete - now %x valid\\n\", segno,\n\t\t\tvalid - cleaned);\n\tBUG_ON(cleaned != valid);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_gc_once(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, segno, ec;\n\tu8 dist;\n\n\tif (!cand) {\n\t\tlog_gc(\"GC attempted, but no candidate found\\n\");\n\t\treturn 0;\n\t}\n\n\tsegno = cand->segno;\n\tdist = cand->dist;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tfree_candidate(sb, cand);\n\tlog_gc(\"GC segment #%02x at %llx, %x required, %x free, %x valid, %llx free\\n\",\n\t\t\tsegno, (u64)segno << super->s_segshift,\n\t\t\tdist, no_free_segments(sb), valid,\n\t\t\tsuper->s_free_bytes);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tlog_gc(\"GC segment #%02x complete - now %x valid\\n\", segno,\n\t\t\tvalid - cleaned);\n\tBUG_ON(cleaned != valid);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_list",
          "args": [
            "cand"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "218-224",
          "snippet": "static void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_candidate",
          "args": [
            "sb"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "get_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "364-382",
          "snippet": "static struct gc_candidate *get_candidate(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i, max_dist;\n\tstruct gc_candidate *cand = NULL, *this;\n\n\tmax_dist = min(no_free_segments(sb), LOGFS_NO_AREAS - 1);\n\n\tfor (i = max_dist; i >= 0; i--) {\n\t\tthis = first_in_list(&super->s_low_list[i]);\n\t\tif (!this)\n\t\t\tcontinue;\n\t\tif (!cand)\n\t\t\tcand = this;\n\t\tif (this->valid + LOGFS_MAX_OBJECTSIZE <= cand->valid)\n\t\t\tcand = this;\n\t}\n\treturn cand;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct gc_candidate *get_candidate(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i, max_dist;\n\tstruct gc_candidate *cand = NULL, *this;\n\n\tmax_dist = min(no_free_segments(sb), LOGFS_NO_AREAS - 1);\n\n\tfor (i = max_dist; i >= 0; i--) {\n\t\tthis = first_in_list(&super->s_low_list[i]);\n\t\tif (!this)\n\t\t\tcontinue;\n\t\tif (!cand)\n\t\t\tcand = this;\n\t\tif (this->valid + LOGFS_MAX_OBJECTSIZE <= cand->valid)\n\t\t\tcand = this;\n\t}\n\treturn cand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int logfs_gc_once(struct super_block *sb)\n{\n\tstruct gc_candidate *cand;\n\n\tcand = get_candidate(sb);\n\tif (cand)\n\t\tremove_from_list(cand);\n\treturn __logfs_gc_once(sb, cand);\n}"
  },
  {
    "function_name": "__logfs_gc_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "384-409",
    "snippet": "static int __logfs_gc_once(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, segno, ec;\n\tu8 dist;\n\n\tif (!cand) {\n\t\tlog_gc(\"GC attempted, but no candidate found\\n\");\n\t\treturn 0;\n\t}\n\n\tsegno = cand->segno;\n\tdist = cand->dist;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tfree_candidate(sb, cand);\n\tlog_gc(\"GC segment #%02x at %llx, %x required, %x free, %x valid, %llx free\\n\",\n\t\t\tsegno, (u64)segno << super->s_segshift,\n\t\t\tdist, no_free_segments(sb), valid,\n\t\t\tsuper->s_free_bytes);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tlog_gc(\"GC segment #%02x complete - now %x valid\\n\", segno,\n\t\t\tvalid - cleaned);\n\tBUG_ON(cleaned != valid);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cleaned != valid"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_gc",
          "args": [
            "\"GC segment #%02x complete - now %x valid\\n\"",
            "segno",
            "valid - cleaned"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_gc_segment",
          "args": [
            "sb",
            "segno"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_gc_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "125-180",
          "snippet": "static u32 logfs_gc_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header sh;\n\tstruct logfs_object_header oh;\n\tu64 ofs, ino, bix;\n\tu32 seg_ofs, logical_segno, cleaned = 0;\n\tint err, len, valid;\n\tgc_level_t gc_level;\n\n\tLOGFS_BUG_ON(segment_is_reserved(sb, segno), sb);\n\n\tbtree_insert32(&super->s_reserved_segments, segno, (void *)1, GFP_NOFS);\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tBUG_ON(err);\n\tgc_level = GC_LEVEL(sh.level);\n\tlogical_segno = be32_to_cpu(sh.segno);\n\tif (sh.crc != logfs_crc32(&sh, sizeof(sh), 4)) {\n\t\tlogfs_mark_segment_bad(sb, segno);\n\t\tcleaned = -1;\n\t\tgoto out;\n\t}\n\n\tfor (seg_ofs = LOGFS_SEGMENT_HEADERSIZE;\n\t\t\tseg_ofs + sizeof(oh) < super->s_segsize; ) {\n\t\tofs = dev_ofs(sb, logical_segno, seg_ofs);\n\t\terr = wbuf_read(sb, dev_ofs(sb, segno, seg_ofs), sizeof(oh),\n\t\t\t\t&oh);\n\t\tBUG_ON(err);\n\n\t\tif (!memchr_inv(&oh, 0xff, sizeof(oh)))\n\t\t\tbreak;\n\n\t\tif (oh.crc != logfs_crc32(&oh, sizeof(oh) - 4, 4)) {\n\t\t\tlogfs_mark_segment_bad(sb, segno);\n\t\t\tcleaned = super->s_segsize - 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tino = be64_to_cpu(oh.ino);\n\t\tbix = be64_to_cpu(oh.bix);\n\t\tlen = sizeof(oh) + be16_to_cpu(oh.len);\n\t\tvalid = logfs_is_valid_block(sb, ofs, ino, bix, gc_level);\n\t\tif (valid == 1) {\n\t\t\tlogfs_cleanse_block(sb, ofs, ino, bix, gc_level);\n\t\t\tcleaned += len;\n\t\t} else if (valid == 2) {\n\t\t\t/* Will be invalid upon journal commit */\n\t\t\tcleaned += len;\n\t\t}\n\t\tseg_ofs += len;\n\t}\nout:\n\tbtree_remove32(&super->s_reserved_segments, segno);\n\treturn cleaned;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u32 logfs_gc_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header sh;\n\tstruct logfs_object_header oh;\n\tu64 ofs, ino, bix;\n\tu32 seg_ofs, logical_segno, cleaned = 0;\n\tint err, len, valid;\n\tgc_level_t gc_level;\n\n\tLOGFS_BUG_ON(segment_is_reserved(sb, segno), sb);\n\n\tbtree_insert32(&super->s_reserved_segments, segno, (void *)1, GFP_NOFS);\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tBUG_ON(err);\n\tgc_level = GC_LEVEL(sh.level);\n\tlogical_segno = be32_to_cpu(sh.segno);\n\tif (sh.crc != logfs_crc32(&sh, sizeof(sh), 4)) {\n\t\tlogfs_mark_segment_bad(sb, segno);\n\t\tcleaned = -1;\n\t\tgoto out;\n\t}\n\n\tfor (seg_ofs = LOGFS_SEGMENT_HEADERSIZE;\n\t\t\tseg_ofs + sizeof(oh) < super->s_segsize; ) {\n\t\tofs = dev_ofs(sb, logical_segno, seg_ofs);\n\t\terr = wbuf_read(sb, dev_ofs(sb, segno, seg_ofs), sizeof(oh),\n\t\t\t\t&oh);\n\t\tBUG_ON(err);\n\n\t\tif (!memchr_inv(&oh, 0xff, sizeof(oh)))\n\t\t\tbreak;\n\n\t\tif (oh.crc != logfs_crc32(&oh, sizeof(oh) - 4, 4)) {\n\t\t\tlogfs_mark_segment_bad(sb, segno);\n\t\t\tcleaned = super->s_segsize - 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tino = be64_to_cpu(oh.ino);\n\t\tbix = be64_to_cpu(oh.bix);\n\t\tlen = sizeof(oh) + be16_to_cpu(oh.len);\n\t\tvalid = logfs_is_valid_block(sb, ofs, ino, bix, gc_level);\n\t\tif (valid == 1) {\n\t\t\tlogfs_cleanse_block(sb, ofs, ino, bix, gc_level);\n\t\t\tcleaned += len;\n\t\t} else if (valid == 2) {\n\t\t\t/* Will be invalid upon journal commit */\n\t\t\tcleaned += len;\n\t\t}\n\t\tseg_ofs += len;\n\t}\nout:\n\tbtree_remove32(&super->s_reserved_segments, segno);\n\treturn cleaned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_gc",
          "args": [
            "\"GC segment #%02x at %llx, %x required, %x free, %x valid, %llx free\\n\"",
            "segno",
            "(u64)segno << super->s_segshift",
            "dist",
            "no_free_segments(sb)",
            "valid",
            "super->s_free_bytes"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no_free_segments",
          "args": [
            "sb"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "no_free_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "31-36",
          "snippet": "static int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_candidate",
          "args": [
            "sb",
            "cand"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "free_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "226-232",
          "snippet": "static void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_valid_bytes",
          "args": [
            "sb",
            "segno",
            "&ec",
            "&gc_level"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_valid_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "96-111",
          "snippet": "static u32 logfs_valid_bytes(struct super_block *sb, u32 segno, u32 *ec,\n\t\tgc_level_t *gc_level)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tif (se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED))\n\t\treturn RESERVED;\n\n\tec_level = be32_to_cpu(se.ec_level);\n\t*ec = ec_level >> 4;\n\t*gc_level = GC_LEVEL(ec_level & 0xf);\n\treturn be32_to_cpu(se.valid);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u32 logfs_valid_bytes(struct super_block *sb, u32 segno, u32 *ec,\n\t\tgc_level_t *gc_level)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tif (se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED))\n\t\treturn RESERVED;\n\n\tec_level = be32_to_cpu(se.ec_level);\n\t*ec = ec_level >> 4;\n\t*gc_level = GC_LEVEL(ec_level & 0xf);\n\treturn be32_to_cpu(se.valid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_gc",
          "args": [
            "\"GC attempted, but no candidate found\\n\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int __logfs_gc_once(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tgc_level_t gc_level;\n\tu32 cleaned, valid, segno, ec;\n\tu8 dist;\n\n\tif (!cand) {\n\t\tlog_gc(\"GC attempted, but no candidate found\\n\");\n\t\treturn 0;\n\t}\n\n\tsegno = cand->segno;\n\tdist = cand->dist;\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tfree_candidate(sb, cand);\n\tlog_gc(\"GC segment #%02x at %llx, %x required, %x free, %x valid, %llx free\\n\",\n\t\t\tsegno, (u64)segno << super->s_segshift,\n\t\t\tdist, no_free_segments(sb), valid,\n\t\t\tsuper->s_free_bytes);\n\tcleaned = logfs_gc_segment(sb, segno);\n\tlog_gc(\"GC segment #%02x complete - now %x valid\\n\", segno,\n\t\t\tvalid - cleaned);\n\tBUG_ON(cleaned != valid);\n\treturn 1;\n}"
  },
  {
    "function_name": "get_candidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "364-382",
    "snippet": "static struct gc_candidate *get_candidate(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i, max_dist;\n\tstruct gc_candidate *cand = NULL, *this;\n\n\tmax_dist = min(no_free_segments(sb), LOGFS_NO_AREAS - 1);\n\n\tfor (i = max_dist; i >= 0; i--) {\n\t\tthis = first_in_list(&super->s_low_list[i]);\n\t\tif (!this)\n\t\t\tcontinue;\n\t\tif (!cand)\n\t\t\tcand = this;\n\t\tif (this->valid + LOGFS_MAX_OBJECTSIZE <= cand->valid)\n\t\t\tcand = this;\n\t}\n\treturn cand;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "first_in_list",
          "args": [
            "&super->s_low_list[i]"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "first_in_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "348-353",
          "snippet": "static struct gc_candidate *first_in_list(struct candidate_list *list)\n{\n\tif (list->count == 0)\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct gc_candidate *first_in_list(struct candidate_list *list)\n{\n\tif (list->count == 0)\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "no_free_segments(sb)",
            "LOGFS_NO_AREAS - 1"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_free_segments",
          "args": [
            "sb"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "no_free_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "31-36",
          "snippet": "static int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct gc_candidate *get_candidate(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i, max_dist;\n\tstruct gc_candidate *cand = NULL, *this;\n\n\tmax_dist = min(no_free_segments(sb), LOGFS_NO_AREAS - 1);\n\n\tfor (i = max_dist; i >= 0; i--) {\n\t\tthis = first_in_list(&super->s_low_list[i]);\n\t\tif (!this)\n\t\t\tcontinue;\n\t\tif (!cand)\n\t\t\tcand = this;\n\t\tif (this->valid + LOGFS_MAX_OBJECTSIZE <= cand->valid)\n\t\t\tcand = this;\n\t}\n\treturn cand;\n}"
  },
  {
    "function_name": "first_in_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "348-353",
    "snippet": "static struct gc_candidate *first_in_list(struct candidate_list *list)\n{\n\tif (list->count == 0)\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_first(&list->rb_tree)",
            "structgc_candidate",
            "rb_node"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&list->rb_tree"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct gc_candidate *first_in_list(struct candidate_list *list)\n{\n\tif (list->count == 0)\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n}"
  },
  {
    "function_name": "scan_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "330-346",
    "snippet": "static void scan_segment(struct super_block *sb, u32 segno)\n{\n\tu32 valid, ec = 0;\n\tgc_level_t gc_level = 0;\n\tu8 dist;\n\n\tif (segment_is_reserved(sb, segno))\n\t\treturn;\n\n\tremove_segment_from_lists(sb, segno);\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tif (valid == RESERVED)\n\t\treturn;\n\n\tdist = root_distance(sb, gc_level);\n\tadd_candidate(sb, segno, valid, ec, dist);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_candidate",
          "args": [
            "sb",
            "segno",
            "valid",
            "ec",
            "dist"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "add_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "298-316",
          "snippet": "static int add_candidate(struct super_block *sb, u32 segno, u32 valid, u32 ec,\n\t\tu8 dist)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\n\tcand = kmalloc(sizeof(*cand), GFP_NOFS);\n\tif (!cand)\n\t\treturn -ENOMEM;\n\n\tcand->segno = segno;\n\tcand->valid = valid;\n\tcand->erase_count = ec;\n\tcand->dist = dist;\n\n\tbtree_insert32(&super->s_cand_tree, segno, cand, GFP_NOFS);\n\t__add_candidate(sb, cand);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int add_candidate(struct super_block *sb, u32 segno, u32 valid, u32 ec,\n\t\tu8 dist)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\n\tcand = kmalloc(sizeof(*cand), GFP_NOFS);\n\tif (!cand)\n\t\treturn -ENOMEM;\n\n\tcand->segno = segno;\n\tcand->valid = valid;\n\tcand->erase_count = ec;\n\tcand->dist = dist;\n\n\tbtree_insert32(&super->s_cand_tree, segno, cand, GFP_NOFS);\n\t__add_candidate(sb, cand);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "root_distance",
          "args": [
            "sb",
            "gc_level"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "root_distance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "39-63",
          "snippet": "static u8 root_distance(struct super_block *sb, gc_level_t __gc_level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu8 gc_level = (__force u8)__gc_level;\n\n\tswitch (gc_level) {\n\tcase 0: /* fall through */\n\tcase 1: /* fall through */\n\tcase 2: /* fall through */\n\tcase 3:\n\t\t/* file data or indirect blocks */\n\t\treturn super->s_ifile_levels + super->s_iblock_levels - gc_level;\n\tcase 6: /* fall through */\n\tcase 7: /* fall through */\n\tcase 8: /* fall through */\n\tcase 9:\n\t\t/* inode file data or indirect blocks */\n\t\treturn super->s_ifile_levels - (gc_level - 6);\n\tdefault:\n\t\tprintk(KERN_ERR\"LOGFS: segment of unknown level %x found\\n\",\n\t\t\t\tgc_level);\n\t\tWARN_ON(1);\n\t\treturn super->s_ifile_levels + super->s_iblock_levels;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u8 root_distance(struct super_block *sb, gc_level_t __gc_level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu8 gc_level = (__force u8)__gc_level;\n\n\tswitch (gc_level) {\n\tcase 0: /* fall through */\n\tcase 1: /* fall through */\n\tcase 2: /* fall through */\n\tcase 3:\n\t\t/* file data or indirect blocks */\n\t\treturn super->s_ifile_levels + super->s_iblock_levels - gc_level;\n\tcase 6: /* fall through */\n\tcase 7: /* fall through */\n\tcase 8: /* fall through */\n\tcase 9:\n\t\t/* inode file data or indirect blocks */\n\t\treturn super->s_ifile_levels - (gc_level - 6);\n\tdefault:\n\t\tprintk(KERN_ERR\"LOGFS: segment of unknown level %x found\\n\",\n\t\t\t\tgc_level);\n\t\tWARN_ON(1);\n\t\treturn super->s_ifile_levels + super->s_iblock_levels;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_valid_bytes",
          "args": [
            "sb",
            "segno",
            "&ec",
            "&gc_level"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_valid_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "96-111",
          "snippet": "static u32 logfs_valid_bytes(struct super_block *sb, u32 segno, u32 *ec,\n\t\tgc_level_t *gc_level)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tif (se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED))\n\t\treturn RESERVED;\n\n\tec_level = be32_to_cpu(se.ec_level);\n\t*ec = ec_level >> 4;\n\t*gc_level = GC_LEVEL(ec_level & 0xf);\n\treturn be32_to_cpu(se.valid);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u32 logfs_valid_bytes(struct super_block *sb, u32 segno, u32 *ec,\n\t\tgc_level_t *gc_level)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tif (se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED))\n\t\treturn RESERVED;\n\n\tec_level = be32_to_cpu(se.ec_level);\n\t*ec = ec_level >> 4;\n\t*gc_level = GC_LEVEL(ec_level & 0xf);\n\treturn be32_to_cpu(se.valid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_segment_from_lists",
          "args": [
            "sb",
            "segno"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "remove_segment_from_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "318-328",
          "snippet": "static void remove_segment_from_lists(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\n\tcand = btree_lookup32(&super->s_cand_tree, segno);\n\tif (cand) {\n\t\tremove_from_list(cand);\n\t\tfree_candidate(sb, cand);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void remove_segment_from_lists(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\n\tcand = btree_lookup32(&super->s_cand_tree, segno);\n\tif (cand) {\n\t\tremove_from_list(cand);\n\t\tfree_candidate(sb, cand);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment_is_reserved",
          "args": [
            "sb",
            "segno"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "segment_is_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "65-85",
          "snippet": "static int segment_is_reserved(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area;\n\tvoid *reserved;\n\tint i;\n\n\t/* Some segments are reserved.  Just pretend they were all valid */\n\treserved = btree_lookup32(&super->s_reserved_segments, segno);\n\tif (reserved)\n\t\treturn 1;\n\n\t/* Currently open segments */\n\tfor_each_area(i) {\n\t\tarea = super->s_area[i];\n\t\tif (area->a_is_open && area->a_segno == segno)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int segment_is_reserved(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area;\n\tvoid *reserved;\n\tint i;\n\n\t/* Some segments are reserved.  Just pretend they were all valid */\n\treserved = btree_lookup32(&super->s_reserved_segments, segno);\n\tif (reserved)\n\t\treturn 1;\n\n\t/* Currently open segments */\n\tfor_each_area(i) {\n\t\tarea = super->s_area[i];\n\t\tif (area->a_is_open && area->a_segno == segno)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void scan_segment(struct super_block *sb, u32 segno)\n{\n\tu32 valid, ec = 0;\n\tgc_level_t gc_level = 0;\n\tu8 dist;\n\n\tif (segment_is_reserved(sb, segno))\n\t\treturn;\n\n\tremove_segment_from_lists(sb, segno);\n\tvalid = logfs_valid_bytes(sb, segno, &ec, &gc_level);\n\tif (valid == RESERVED)\n\t\treturn;\n\n\tdist = root_distance(sb, gc_level);\n\tadd_candidate(sb, segno, valid, ec, dist);\n}"
  },
  {
    "function_name": "remove_segment_from_lists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "318-328",
    "snippet": "static void remove_segment_from_lists(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\n\tcand = btree_lookup32(&super->s_cand_tree, segno);\n\tif (cand) {\n\t\tremove_from_list(cand);\n\t\tfree_candidate(sb, cand);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_candidate",
          "args": [
            "sb",
            "cand"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "free_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "226-232",
          "snippet": "static void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_list",
          "args": [
            "cand"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "218-224",
          "snippet": "static void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_lookup32",
          "args": [
            "&super->s_cand_tree",
            "segno"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void remove_segment_from_lists(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\n\tcand = btree_lookup32(&super->s_cand_tree, segno);\n\tif (cand) {\n\t\tremove_from_list(cand);\n\t\tfree_candidate(sb, cand);\n\t}\n}"
  },
  {
    "function_name": "add_candidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "298-316",
    "snippet": "static int add_candidate(struct super_block *sb, u32 segno, u32 valid, u32 ec,\n\t\tu8 dist)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\n\tcand = kmalloc(sizeof(*cand), GFP_NOFS);\n\tif (!cand)\n\t\treturn -ENOMEM;\n\n\tcand->segno = segno;\n\tcand->valid = valid;\n\tcand->erase_count = ec;\n\tcand->dist = dist;\n\n\tbtree_insert32(&super->s_cand_tree, segno, cand, GFP_NOFS);\n\t__add_candidate(sb, cand);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_candidate",
          "args": [
            "sb",
            "cand"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "__add_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "268-296",
          "snippet": "static void __add_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 full = super->s_segsize - LOGFS_SEGMENT_RESERVE;\n\n\tif (cand->valid == 0) {\n\t\t/* 100% free segments */\n\t\tlog_gc_noisy(\"add reserve segment %x (ec %x) at %llx\\n\",\n\t\t\t\tcand->segno, cand->erase_count,\n\t\t\t\tdev_ofs(sb, cand->segno, 0));\n\t\tcand = add_list(cand, &super->s_reserve_list);\n\t\tif (cand) {\n\t\t\tlog_gc_noisy(\"add free segment %x (ec %x) at %llx\\n\",\n\t\t\t\t\tcand->segno, cand->erase_count,\n\t\t\t\t\tdev_ofs(sb, cand->segno, 0));\n\t\t\tcand = add_list(cand, &super->s_free_list);\n\t\t}\n\t} else {\n\t\t/* good candidates for Garbage Collection */\n\t\tif (cand->valid < full)\n\t\t\tcand = add_list(cand, &super->s_low_list[cand->dist]);\n\t\t/* good candidates for wear leveling,\n\t\t * segments that were recently written get ignored */\n\t\tif (cand)\n\t\t\tcand = add_list(cand, &super->s_ec_list);\n\t}\n\tif (cand)\n\t\tfree_candidate(sb, cand);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __add_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 full = super->s_segsize - LOGFS_SEGMENT_RESERVE;\n\n\tif (cand->valid == 0) {\n\t\t/* 100% free segments */\n\t\tlog_gc_noisy(\"add reserve segment %x (ec %x) at %llx\\n\",\n\t\t\t\tcand->segno, cand->erase_count,\n\t\t\t\tdev_ofs(sb, cand->segno, 0));\n\t\tcand = add_list(cand, &super->s_reserve_list);\n\t\tif (cand) {\n\t\t\tlog_gc_noisy(\"add free segment %x (ec %x) at %llx\\n\",\n\t\t\t\t\tcand->segno, cand->erase_count,\n\t\t\t\t\tdev_ofs(sb, cand->segno, 0));\n\t\t\tcand = add_list(cand, &super->s_free_list);\n\t\t}\n\t} else {\n\t\t/* good candidates for Garbage Collection */\n\t\tif (cand->valid < full)\n\t\t\tcand = add_list(cand, &super->s_low_list[cand->dist]);\n\t\t/* good candidates for wear leveling,\n\t\t * segments that were recently written get ignored */\n\t\tif (cand)\n\t\t\tcand = add_list(cand, &super->s_ec_list);\n\t}\n\tif (cand)\n\t\tfree_candidate(sb, cand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_insert32",
          "args": [
            "&super->s_cand_tree",
            "segno",
            "cand",
            "GFP_NOFS"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*cand)",
            "GFP_NOFS"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int add_candidate(struct super_block *sb, u32 segno, u32 valid, u32 ec,\n\t\tu8 dist)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct gc_candidate *cand;\n\n\tcand = kmalloc(sizeof(*cand), GFP_NOFS);\n\tif (!cand)\n\t\treturn -ENOMEM;\n\n\tcand->segno = segno;\n\tcand->valid = valid;\n\tcand->erase_count = ec;\n\tcand->dist = dist;\n\n\tbtree_insert32(&super->s_cand_tree, segno, cand, GFP_NOFS);\n\t__add_candidate(sb, cand);\n\treturn 0;\n}"
  },
  {
    "function_name": "__add_candidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "268-296",
    "snippet": "static void __add_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 full = super->s_segsize - LOGFS_SEGMENT_RESERVE;\n\n\tif (cand->valid == 0) {\n\t\t/* 100% free segments */\n\t\tlog_gc_noisy(\"add reserve segment %x (ec %x) at %llx\\n\",\n\t\t\t\tcand->segno, cand->erase_count,\n\t\t\t\tdev_ofs(sb, cand->segno, 0));\n\t\tcand = add_list(cand, &super->s_reserve_list);\n\t\tif (cand) {\n\t\t\tlog_gc_noisy(\"add free segment %x (ec %x) at %llx\\n\",\n\t\t\t\t\tcand->segno, cand->erase_count,\n\t\t\t\t\tdev_ofs(sb, cand->segno, 0));\n\t\t\tcand = add_list(cand, &super->s_free_list);\n\t\t}\n\t} else {\n\t\t/* good candidates for Garbage Collection */\n\t\tif (cand->valid < full)\n\t\t\tcand = add_list(cand, &super->s_low_list[cand->dist]);\n\t\t/* good candidates for wear leveling,\n\t\t * segments that were recently written get ignored */\n\t\tif (cand)\n\t\t\tcand = add_list(cand, &super->s_ec_list);\n\t}\n\tif (cand)\n\t\tfree_candidate(sb, cand);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_candidate",
          "args": [
            "sb",
            "cand"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "free_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "226-232",
          "snippet": "static void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_list",
          "args": [
            "cand",
            "&super->s_ec_list"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "add_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "182-216",
          "snippet": "static struct gc_candidate *add_list(struct gc_candidate *cand,\n\t\tstruct candidate_list *list)\n{\n\tstruct rb_node **p = &list->rb_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct gc_candidate *cur;\n\tint comp;\n\n\tcand->list = list;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct gc_candidate, rb_node);\n\n\t\tif (list->sort_by_ec)\n\t\t\tcomp = cand->erase_count < cur->erase_count;\n\t\telse\n\t\t\tcomp = cand->valid < cur->valid;\n\n\t\tif (comp)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\t}\n\trb_link_node(&cand->rb_node, parent, p);\n\trb_insert_color(&cand->rb_node, &list->rb_tree);\n\n\tif (list->count <= list->maxcount) {\n\t\tlist->count++;\n\t\treturn NULL;\n\t}\n\tcand = rb_entry(rb_last(&list->rb_tree), struct gc_candidate, rb_node);\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tcand->list = NULL;\n\treturn cand;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct gc_candidate *add_list(struct gc_candidate *cand,\n\t\tstruct candidate_list *list)\n{\n\tstruct rb_node **p = &list->rb_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct gc_candidate *cur;\n\tint comp;\n\n\tcand->list = list;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct gc_candidate, rb_node);\n\n\t\tif (list->sort_by_ec)\n\t\t\tcomp = cand->erase_count < cur->erase_count;\n\t\telse\n\t\t\tcomp = cand->valid < cur->valid;\n\n\t\tif (comp)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\t}\n\trb_link_node(&cand->rb_node, parent, p);\n\trb_insert_color(&cand->rb_node, &list->rb_tree);\n\n\tif (list->count <= list->maxcount) {\n\t\tlist->count++;\n\t\treturn NULL;\n\t}\n\tcand = rb_entry(rb_last(&list->rb_tree), struct gc_candidate, rb_node);\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tcand->list = NULL;\n\treturn cand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_gc_noisy",
          "args": [
            "\"add free segment %x (ec %x) at %llx\\n\"",
            "cand->segno",
            "cand->erase_count",
            "dev_ofs(sb, cand->segno, 0)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "cand->segno",
            "0"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_gc_noisy",
          "args": [
            "\"add reserve segment %x (ec %x) at %llx\\n\"",
            "cand->segno",
            "cand->erase_count",
            "dev_ofs(sb, cand->segno, 0)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void __add_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 full = super->s_segsize - LOGFS_SEGMENT_RESERVE;\n\n\tif (cand->valid == 0) {\n\t\t/* 100% free segments */\n\t\tlog_gc_noisy(\"add reserve segment %x (ec %x) at %llx\\n\",\n\t\t\t\tcand->segno, cand->erase_count,\n\t\t\t\tdev_ofs(sb, cand->segno, 0));\n\t\tcand = add_list(cand, &super->s_reserve_list);\n\t\tif (cand) {\n\t\t\tlog_gc_noisy(\"add free segment %x (ec %x) at %llx\\n\",\n\t\t\t\t\tcand->segno, cand->erase_count,\n\t\t\t\t\tdev_ofs(sb, cand->segno, 0));\n\t\t\tcand = add_list(cand, &super->s_free_list);\n\t\t}\n\t} else {\n\t\t/* good candidates for Garbage Collection */\n\t\tif (cand->valid < full)\n\t\t\tcand = add_list(cand, &super->s_low_list[cand->dist]);\n\t\t/* good candidates for wear leveling,\n\t\t * segments that were recently written get ignored */\n\t\tif (cand)\n\t\t\tcand = add_list(cand, &super->s_ec_list);\n\t}\n\tif (cand)\n\t\tfree_candidate(sb, cand);\n}"
  },
  {
    "function_name": "get_best_cand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "234-248",
    "snippet": "u32 get_best_cand(struct super_block *sb, struct candidate_list *list, u32 *ec)\n{\n\tstruct gc_candidate *cand;\n\tu32 segno;\n\n\tBUG_ON(list->count == 0);\n\n\tcand = rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n\tremove_from_list(cand);\n\tsegno = cand->segno;\n\tif (ec)\n\t\t*ec = cand->erase_count;\n\tfree_candidate(sb, cand);\n\treturn segno;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_candidate",
          "args": [
            "sb",
            "cand"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "free_candidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "226-232",
          "snippet": "static void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_list",
          "args": [
            "cand"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "218-224",
          "snippet": "static void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_first(&list->rb_tree)",
            "structgc_candidate",
            "rb_node"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&list->rb_tree"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list->count == 0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nu32 get_best_cand(struct super_block *sb, struct candidate_list *list, u32 *ec)\n{\n\tstruct gc_candidate *cand;\n\tu32 segno;\n\n\tBUG_ON(list->count == 0);\n\n\tcand = rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n\tremove_from_list(cand);\n\tsegno = cand->segno;\n\tif (ec)\n\t\t*ec = cand->erase_count;\n\tfree_candidate(sb, cand);\n\treturn segno;\n}"
  },
  {
    "function_name": "free_candidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "226-232",
    "snippet": "static void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cand"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_remove32",
          "args": [
            "&super->s_cand_tree",
            "cand->segno"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void free_candidate(struct super_block *sb, struct gc_candidate *cand)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_remove32(&super->s_cand_tree, cand->segno);\n\tkfree(cand);\n}"
  },
  {
    "function_name": "remove_from_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "218-224",
    "snippet": "static void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&cand->rb_node",
            "&list->rb_tree"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void remove_from_list(struct gc_candidate *cand)\n{\n\tstruct candidate_list *list = cand->list;\n\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tlist->count--;\n}"
  },
  {
    "function_name": "add_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "182-216",
    "snippet": "static struct gc_candidate *add_list(struct gc_candidate *cand,\n\t\tstruct candidate_list *list)\n{\n\tstruct rb_node **p = &list->rb_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct gc_candidate *cur;\n\tint comp;\n\n\tcand->list = list;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct gc_candidate, rb_node);\n\n\t\tif (list->sort_by_ec)\n\t\t\tcomp = cand->erase_count < cur->erase_count;\n\t\telse\n\t\t\tcomp = cand->valid < cur->valid;\n\n\t\tif (comp)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\t}\n\trb_link_node(&cand->rb_node, parent, p);\n\trb_insert_color(&cand->rb_node, &list->rb_tree);\n\n\tif (list->count <= list->maxcount) {\n\t\tlist->count++;\n\t\treturn NULL;\n\t}\n\tcand = rb_entry(rb_last(&list->rb_tree), struct gc_candidate, rb_node);\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tcand->list = NULL;\n\treturn cand;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&cand->rb_node",
            "&list->rb_tree"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_last(&list->rb_tree)",
            "structgc_candidate",
            "rb_node"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_last",
          "args": [
            "&list->rb_tree"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&cand->rb_node",
            "&list->rb_tree"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&cand->rb_node",
            "parent",
            "p"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structgc_candidate",
            "rb_node"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic struct gc_candidate *add_list(struct gc_candidate *cand,\n\t\tstruct candidate_list *list)\n{\n\tstruct rb_node **p = &list->rb_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct gc_candidate *cur;\n\tint comp;\n\n\tcand->list = list;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct gc_candidate, rb_node);\n\n\t\tif (list->sort_by_ec)\n\t\t\tcomp = cand->erase_count < cur->erase_count;\n\t\telse\n\t\t\tcomp = cand->valid < cur->valid;\n\n\t\tif (comp)\n\t\t\tp = &parent->rb_left;\n\t\telse\n\t\t\tp = &parent->rb_right;\n\t}\n\trb_link_node(&cand->rb_node, parent, p);\n\trb_insert_color(&cand->rb_node, &list->rb_tree);\n\n\tif (list->count <= list->maxcount) {\n\t\tlist->count++;\n\t\treturn NULL;\n\t}\n\tcand = rb_entry(rb_last(&list->rb_tree), struct gc_candidate, rb_node);\n\trb_erase(&cand->rb_node, &list->rb_tree);\n\tcand->list = NULL;\n\treturn cand;\n}"
  },
  {
    "function_name": "logfs_gc_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "125-180",
    "snippet": "static u32 logfs_gc_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header sh;\n\tstruct logfs_object_header oh;\n\tu64 ofs, ino, bix;\n\tu32 seg_ofs, logical_segno, cleaned = 0;\n\tint err, len, valid;\n\tgc_level_t gc_level;\n\n\tLOGFS_BUG_ON(segment_is_reserved(sb, segno), sb);\n\n\tbtree_insert32(&super->s_reserved_segments, segno, (void *)1, GFP_NOFS);\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tBUG_ON(err);\n\tgc_level = GC_LEVEL(sh.level);\n\tlogical_segno = be32_to_cpu(sh.segno);\n\tif (sh.crc != logfs_crc32(&sh, sizeof(sh), 4)) {\n\t\tlogfs_mark_segment_bad(sb, segno);\n\t\tcleaned = -1;\n\t\tgoto out;\n\t}\n\n\tfor (seg_ofs = LOGFS_SEGMENT_HEADERSIZE;\n\t\t\tseg_ofs + sizeof(oh) < super->s_segsize; ) {\n\t\tofs = dev_ofs(sb, logical_segno, seg_ofs);\n\t\terr = wbuf_read(sb, dev_ofs(sb, segno, seg_ofs), sizeof(oh),\n\t\t\t\t&oh);\n\t\tBUG_ON(err);\n\n\t\tif (!memchr_inv(&oh, 0xff, sizeof(oh)))\n\t\t\tbreak;\n\n\t\tif (oh.crc != logfs_crc32(&oh, sizeof(oh) - 4, 4)) {\n\t\t\tlogfs_mark_segment_bad(sb, segno);\n\t\t\tcleaned = super->s_segsize - 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tino = be64_to_cpu(oh.ino);\n\t\tbix = be64_to_cpu(oh.bix);\n\t\tlen = sizeof(oh) + be16_to_cpu(oh.len);\n\t\tvalid = logfs_is_valid_block(sb, ofs, ino, bix, gc_level);\n\t\tif (valid == 1) {\n\t\t\tlogfs_cleanse_block(sb, ofs, ino, bix, gc_level);\n\t\t\tcleaned += len;\n\t\t} else if (valid == 2) {\n\t\t\t/* Will be invalid upon journal commit */\n\t\t\tcleaned += len;\n\t\t}\n\t\tseg_ofs += len;\n\t}\nout:\n\tbtree_remove32(&super->s_reserved_segments, segno);\n\treturn cleaned;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_remove32",
          "args": [
            "&super->s_reserved_segments",
            "segno"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_cleanse_block",
          "args": [
            "sb",
            "ofs",
            "ino",
            "bix",
            "gc_level"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_cleanse_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "113-123",
          "snippet": "static void logfs_cleanse_block(struct super_block *sb, u64 ofs, u64 ino,\n\t\tu64 bix, gc_level_t gc_level)\n{\n\tstruct inode *inode;\n\tint err, cookie;\n\n\tinode = logfs_safe_iget(sb, ino, &cookie);\n\terr = logfs_rewrite_block(inode, bix, ofs, gc_level, 0);\n\tBUG_ON(err);\n\tlogfs_safe_iput(inode, cookie);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_cleanse_block(struct super_block *sb, u64 ofs, u64 ino,\n\t\tu64 bix, gc_level_t gc_level)\n{\n\tstruct inode *inode;\n\tint err, cookie;\n\n\tinode = logfs_safe_iget(sb, ino, &cookie);\n\terr = logfs_rewrite_block(inode, bix, ofs, gc_level, 0);\n\tBUG_ON(err);\n\tlogfs_safe_iput(inode, cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_is_valid_block",
          "args": [
            "sb",
            "ofs",
            "ino",
            "bix",
            "gc_level"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_is_valid_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1031-1061",
          "snippet": "int logfs_is_valid_block(struct super_block *sb, u64 ofs, u64 ino, u64 bix,\n\t\tgc_level_t gc_level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tint ret, cookie;\n\n\t/* Umount closes a segment with free blocks remaining.  Those\n\t * blocks are by definition invalid. */\n\tif (ino == -1)\n\t\treturn 0;\n\n\tLOGFS_BUG_ON((u64)(u_long)ino != ino, sb);\n\n\tinode = logfs_safe_iget(sb, ino, &cookie);\n\tif (IS_ERR(inode))\n\t\tgoto invalid;\n\n\tret = __logfs_is_valid_block(inode, bix, ofs);\n\tlogfs_safe_iput(inode, cookie);\n\tif (ret)\n\t\treturn ret;\n\ninvalid:\n\t/* Block is nominally invalid, but may still sit in the shadow tree,\n\t * waiting for a journal commit.\n\t */\n\tif (btree_lookup64(&super->s_shadow_tree.old, ofs))\n\t\treturn 2;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_is_valid_block(struct super_block *sb, u64 ofs, u64 ino, u64 bix,\n\t\tgc_level_t gc_level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tint ret, cookie;\n\n\t/* Umount closes a segment with free blocks remaining.  Those\n\t * blocks are by definition invalid. */\n\tif (ino == -1)\n\t\treturn 0;\n\n\tLOGFS_BUG_ON((u64)(u_long)ino != ino, sb);\n\n\tinode = logfs_safe_iget(sb, ino, &cookie);\n\tif (IS_ERR(inode))\n\t\tgoto invalid;\n\n\tret = __logfs_is_valid_block(inode, bix, ofs);\n\tlogfs_safe_iput(inode, cookie);\n\tif (ret)\n\t\treturn ret;\n\ninvalid:\n\t/* Block is nominally invalid, but may still sit in the shadow tree,\n\t * waiting for a journal commit.\n\t */\n\tif (btree_lookup64(&super->s_shadow_tree.old, ofs))\n\t\treturn 2;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oh.len"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oh.bix"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oh.ino"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_mark_segment_bad",
          "args": [
            "sb",
            "segno"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mark_segment_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "87-90",
          "snippet": "static void logfs_mark_segment_bad(struct super_block *sb, u32 segno)\n{\n\tBUG();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_mark_segment_bad(struct super_block *sb, u32 segno)\n{\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "&oh",
            "sizeof(oh) - 4",
            "4"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "&oh",
            "0xff",
            "sizeof(oh)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf_read",
          "args": [
            "sb",
            "dev_ofs(sb, segno, seg_ofs)",
            "sizeof(oh)",
            "&oh"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "wbuf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "400-422",
          "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "segno",
            "seg_ofs"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sh.segno"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GC_LEVEL",
          "args": [
            "sh.level"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_insert32",
          "args": [
            "&super->s_reserved_segments",
            "segno",
            "(void *)1",
            "GFP_NOFS"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "segment_is_reserved(sb, segno)",
            "sb"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment_is_reserved",
          "args": [
            "sb",
            "segno"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "segment_is_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "65-85",
          "snippet": "static int segment_is_reserved(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area;\n\tvoid *reserved;\n\tint i;\n\n\t/* Some segments are reserved.  Just pretend they were all valid */\n\treserved = btree_lookup32(&super->s_reserved_segments, segno);\n\tif (reserved)\n\t\treturn 1;\n\n\t/* Currently open segments */\n\tfor_each_area(i) {\n\t\tarea = super->s_area[i];\n\t\tif (area->a_is_open && area->a_segno == segno)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int segment_is_reserved(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area;\n\tvoid *reserved;\n\tint i;\n\n\t/* Some segments are reserved.  Just pretend they were all valid */\n\treserved = btree_lookup32(&super->s_reserved_segments, segno);\n\tif (reserved)\n\t\treturn 1;\n\n\t/* Currently open segments */\n\tfor_each_area(i) {\n\t\tarea = super->s_area[i];\n\t\tif (area->a_is_open && area->a_segno == segno)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u32 logfs_gc_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header sh;\n\tstruct logfs_object_header oh;\n\tu64 ofs, ino, bix;\n\tu32 seg_ofs, logical_segno, cleaned = 0;\n\tint err, len, valid;\n\tgc_level_t gc_level;\n\n\tLOGFS_BUG_ON(segment_is_reserved(sb, segno), sb);\n\n\tbtree_insert32(&super->s_reserved_segments, segno, (void *)1, GFP_NOFS);\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tBUG_ON(err);\n\tgc_level = GC_LEVEL(sh.level);\n\tlogical_segno = be32_to_cpu(sh.segno);\n\tif (sh.crc != logfs_crc32(&sh, sizeof(sh), 4)) {\n\t\tlogfs_mark_segment_bad(sb, segno);\n\t\tcleaned = -1;\n\t\tgoto out;\n\t}\n\n\tfor (seg_ofs = LOGFS_SEGMENT_HEADERSIZE;\n\t\t\tseg_ofs + sizeof(oh) < super->s_segsize; ) {\n\t\tofs = dev_ofs(sb, logical_segno, seg_ofs);\n\t\terr = wbuf_read(sb, dev_ofs(sb, segno, seg_ofs), sizeof(oh),\n\t\t\t\t&oh);\n\t\tBUG_ON(err);\n\n\t\tif (!memchr_inv(&oh, 0xff, sizeof(oh)))\n\t\t\tbreak;\n\n\t\tif (oh.crc != logfs_crc32(&oh, sizeof(oh) - 4, 4)) {\n\t\t\tlogfs_mark_segment_bad(sb, segno);\n\t\t\tcleaned = super->s_segsize - 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tino = be64_to_cpu(oh.ino);\n\t\tbix = be64_to_cpu(oh.bix);\n\t\tlen = sizeof(oh) + be16_to_cpu(oh.len);\n\t\tvalid = logfs_is_valid_block(sb, ofs, ino, bix, gc_level);\n\t\tif (valid == 1) {\n\t\t\tlogfs_cleanse_block(sb, ofs, ino, bix, gc_level);\n\t\t\tcleaned += len;\n\t\t} else if (valid == 2) {\n\t\t\t/* Will be invalid upon journal commit */\n\t\t\tcleaned += len;\n\t\t}\n\t\tseg_ofs += len;\n\t}\nout:\n\tbtree_remove32(&super->s_reserved_segments, segno);\n\treturn cleaned;\n}"
  },
  {
    "function_name": "logfs_cleanse_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "113-123",
    "snippet": "static void logfs_cleanse_block(struct super_block *sb, u64 ofs, u64 ino,\n\t\tu64 bix, gc_level_t gc_level)\n{\n\tstruct inode *inode;\n\tint err, cookie;\n\n\tinode = logfs_safe_iget(sb, ino, &cookie);\n\terr = logfs_rewrite_block(inode, bix, ofs, gc_level, 0);\n\tBUG_ON(err);\n\tlogfs_safe_iput(inode, cookie);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_safe_iput",
          "args": [
            "inode",
            "cookie"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_safe_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "187-200",
          "snippet": "void logfs_safe_iput(struct inode *inode, int is_cached)\n{\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\treturn;\n\tif (inode->i_ino == LOGFS_INO_SEGFILE)\n\t\treturn;\n\n\tif (is_cached) {\n\t\tlogfs_destroy_inode(inode);\n\t\treturn;\n\t}\n\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_safe_iput(struct inode *inode, int is_cached)\n{\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\treturn;\n\tif (inode->i_ino == LOGFS_INO_SEGFILE)\n\t\treturn;\n\n\tif (is_cached) {\n\t\tlogfs_destroy_inode(inode);\n\t\treturn;\n\t}\n\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_rewrite_block",
          "args": [
            "inode",
            "bix",
            "ofs",
            "gc_level",
            "0"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_rewrite_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1611-1642",
          "snippet": "int logfs_rewrite_block(struct inode *inode, u64 bix, u64 ofs,\n\t\tgc_level_t gc_level, long flags)\n{\n\tlevel_t level = shrink_level(gc_level);\n\tstruct page *page;\n\tint err;\n\n\tpage = logfs_get_write_page(inode, bix, level);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = logfs_segment_read(inode, page, ofs, bix, level);\n\tif (!err) {\n\t\tif (level != 0)\n\t\t\talloc_indirect_block(inode, page, 0);\n\t\terr = logfs_write_buf(inode, page, flags);\n\t\tif (!err && shrink_level(gc_level) == 0) {\n\t\t\t/* Rewrite cannot mark the inode dirty but has to\n\t\t\t * write it immediately.\n\t\t\t * Q: Can't we just create an alias for the inode\n\t\t\t * instead?  And if not, why not?\n\t\t\t */\n\t\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\t\tlogfs_write_anchor(inode->i_sb);\n\t\t\telse {\n\t\t\t\terr = __logfs_write_inode(inode, page, flags);\n\t\t\t}\n\t\t}\n\t}\n\tlogfs_put_write_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_rewrite_block(struct inode *inode, u64 bix, u64 ofs,\n\t\tgc_level_t gc_level, long flags)\n{\n\tlevel_t level = shrink_level(gc_level);\n\tstruct page *page;\n\tint err;\n\n\tpage = logfs_get_write_page(inode, bix, level);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = logfs_segment_read(inode, page, ofs, bix, level);\n\tif (!err) {\n\t\tif (level != 0)\n\t\t\talloc_indirect_block(inode, page, 0);\n\t\terr = logfs_write_buf(inode, page, flags);\n\t\tif (!err && shrink_level(gc_level) == 0) {\n\t\t\t/* Rewrite cannot mark the inode dirty but has to\n\t\t\t * write it immediately.\n\t\t\t * Q: Can't we just create an alias for the inode\n\t\t\t * instead?  And if not, why not?\n\t\t\t */\n\t\t\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\t\t\tlogfs_write_anchor(inode->i_sb);\n\t\t\telse {\n\t\t\t\terr = __logfs_write_inode(inode, page, flags);\n\t\t\t}\n\t\t}\n\t}\n\tlogfs_put_write_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_safe_iget",
          "args": [
            "sb",
            "ino",
            "&cookie"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_safe_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "120-142",
          "snippet": "struct inode *logfs_safe_iget(struct super_block *sb, ino_t ino, int *is_cached)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_inode *li;\n\n\tif (ino == LOGFS_INO_MASTER)\n\t\treturn super->s_master_inode;\n\tif (ino == LOGFS_INO_SEGFILE)\n\t\treturn super->s_segfile_inode;\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_for_each_entry(li, &super->s_freeing_list, li_freeing_list)\n\t\tif (li->vfs_inode.i_ino == ino) {\n\t\t\tli->li_refcount++;\n\t\t\tspin_unlock(&logfs_inode_lock);\n\t\t\t*is_cached = 1;\n\t\t\treturn &li->vfs_inode;\n\t\t}\n\tspin_unlock(&logfs_inode_lock);\n\n\t*is_cached = 0;\n\treturn __logfs_iget(sb, ino);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(logfs_inode_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic DEFINE_SPINLOCK(logfs_inode_lock);\n\nstruct inode *logfs_safe_iget(struct super_block *sb, ino_t ino, int *is_cached)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_inode *li;\n\n\tif (ino == LOGFS_INO_MASTER)\n\t\treturn super->s_master_inode;\n\tif (ino == LOGFS_INO_SEGFILE)\n\t\treturn super->s_segfile_inode;\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_for_each_entry(li, &super->s_freeing_list, li_freeing_list)\n\t\tif (li->vfs_inode.i_ino == ino) {\n\t\t\tli->li_refcount++;\n\t\t\tspin_unlock(&logfs_inode_lock);\n\t\t\t*is_cached = 1;\n\t\t\treturn &li->vfs_inode;\n\t\t}\n\tspin_unlock(&logfs_inode_lock);\n\n\t*is_cached = 0;\n\treturn __logfs_iget(sb, ino);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_cleanse_block(struct super_block *sb, u64 ofs, u64 ino,\n\t\tu64 bix, gc_level_t gc_level)\n{\n\tstruct inode *inode;\n\tint err, cookie;\n\n\tinode = logfs_safe_iget(sb, ino, &cookie);\n\terr = logfs_rewrite_block(inode, bix, ofs, gc_level, 0);\n\tBUG_ON(err);\n\tlogfs_safe_iput(inode, cookie);\n}"
  },
  {
    "function_name": "logfs_valid_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "96-111",
    "snippet": "static u32 logfs_valid_bytes(struct super_block *sb, u32 segno, u32 *ec,\n\t\tgc_level_t *gc_level)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tif (se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED))\n\t\treturn RESERVED;\n\n\tec_level = be32_to_cpu(se.ec_level);\n\t*ec = ec_level >> 4;\n\t*gc_level = GC_LEVEL(ec_level & 0xf);\n\treturn be32_to_cpu(se.valid);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.valid"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GC_LEVEL",
          "args": [
            "ec_level & 0xf"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.ec_level"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "RESERVED"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "BADSEG"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_segment_entry",
          "args": [
            "sb",
            "segno",
            "&se"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2068-2072",
          "snippet": "void logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u32 logfs_valid_bytes(struct super_block *sb, u32 segno, u32 *ec,\n\t\tgc_level_t *gc_level)\n{\n\tstruct logfs_segment_entry se;\n\tu32 ec_level;\n\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tif (se.ec_level == cpu_to_be32(BADSEG) ||\n\t\t\tse.valid == cpu_to_be32(RESERVED))\n\t\treturn RESERVED;\n\n\tec_level = be32_to_cpu(se.ec_level);\n\t*ec = ec_level >> 4;\n\t*gc_level = GC_LEVEL(ec_level & 0xf);\n\treturn be32_to_cpu(se.valid);\n}"
  },
  {
    "function_name": "logfs_mark_segment_bad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "87-90",
    "snippet": "static void logfs_mark_segment_bad(struct super_block *sb, u32 segno)\n{\n\tBUG();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic void logfs_mark_segment_bad(struct super_block *sb, u32 segno)\n{\n\tBUG();\n}"
  },
  {
    "function_name": "segment_is_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "65-85",
    "snippet": "static int segment_is_reserved(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area;\n\tvoid *reserved;\n\tint i;\n\n\t/* Some segments are reserved.  Just pretend they were all valid */\n\treserved = btree_lookup32(&super->s_reserved_segments, segno);\n\tif (reserved)\n\t\treturn 1;\n\n\t/* Currently open segments */\n\tfor_each_area(i) {\n\t\tarea = super->s_area[i];\n\t\tif (area->a_is_open && area->a_segno == segno)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btree_lookup32",
          "args": [
            "&super->s_reserved_segments",
            "segno"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int segment_is_reserved(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area;\n\tvoid *reserved;\n\tint i;\n\n\t/* Some segments are reserved.  Just pretend they were all valid */\n\treserved = btree_lookup32(&super->s_reserved_segments, segno);\n\tif (reserved)\n\t\treturn 1;\n\n\t/* Currently open segments */\n\tfor_each_area(i) {\n\t\tarea = super->s_area[i];\n\t\tif (area->a_is_open && area->a_segno == segno)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "root_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "39-63",
    "snippet": "static u8 root_distance(struct super_block *sb, gc_level_t __gc_level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu8 gc_level = (__force u8)__gc_level;\n\n\tswitch (gc_level) {\n\tcase 0: /* fall through */\n\tcase 1: /* fall through */\n\tcase 2: /* fall through */\n\tcase 3:\n\t\t/* file data or indirect blocks */\n\t\treturn super->s_ifile_levels + super->s_iblock_levels - gc_level;\n\tcase 6: /* fall through */\n\tcase 7: /* fall through */\n\tcase 8: /* fall through */\n\tcase 9:\n\t\t/* inode file data or indirect blocks */\n\t\treturn super->s_ifile_levels - (gc_level - 6);\n\tdefault:\n\t\tprintk(KERN_ERR\"LOGFS: segment of unknown level %x found\\n\",\n\t\t\t\tgc_level);\n\t\tWARN_ON(1);\n\t\treturn super->s_ifile_levels + super->s_iblock_levels;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\"LOGFS: segment of unknown level %x found\\n\"",
            "gc_level"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic u8 root_distance(struct super_block *sb, gc_level_t __gc_level)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu8 gc_level = (__force u8)__gc_level;\n\n\tswitch (gc_level) {\n\tcase 0: /* fall through */\n\tcase 1: /* fall through */\n\tcase 2: /* fall through */\n\tcase 3:\n\t\t/* file data or indirect blocks */\n\t\treturn super->s_ifile_levels + super->s_iblock_levels - gc_level;\n\tcase 6: /* fall through */\n\tcase 7: /* fall through */\n\tcase 8: /* fall through */\n\tcase 9:\n\t\t/* inode file data or indirect blocks */\n\t\treturn super->s_ifile_levels - (gc_level - 6);\n\tdefault:\n\t\tprintk(KERN_ERR\"LOGFS: segment of unknown level %x found\\n\",\n\t\t\t\tgc_level);\n\t\tWARN_ON(1);\n\t\treturn super->s_ifile_levels + super->s_iblock_levels;\n\t}\n}"
  },
  {
    "function_name": "no_free_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
    "lines": "31-36",
    "snippet": "static int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nstatic int no_free_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\treturn super->s_free_list.count;\n}"
  }
]