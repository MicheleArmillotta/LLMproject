[
  {
    "function_name": "smb2_dir_needs_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1389-1393",
    "snippet": "static bool\nsmb2_dir_needs_close(struct cifsFileInfo *cfile)\n{\n\treturn !cfile->invalidHandle;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\nsmb2_dir_needs_close(struct cifsFileInfo *cfile)\n{\n\treturn !cfile->invalidHandle;\n}"
  },
  {
    "function_name": "smb2_wp_retry_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1382-1387",
    "snippet": "static unsigned int\nsmb2_wp_retry_size(struct inode *inode)\n{\n\treturn min_t(unsigned int, CIFS_SB(inode->i_sb)->wsize,\n\t\t     SMB2_MAX_BUFFER_SIZE);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "CIFS_SB(inode->i_sb)->wsize",
            "SMB2_MAX_BUFFER_SIZE"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\nsmb2_wp_retry_size(struct inode *inode)\n{\n\treturn min_t(unsigned int, CIFS_SB(inode->i_sb)->wsize,\n\t\t     SMB2_MAX_BUFFER_SIZE);\n}"
  },
  {
    "function_name": "smb3_parse_lease_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1371-1380",
    "snippet": "static __u8\nsmb3_parse_lease_buf(void *buf, unsigned int *epoch)\n{\n\tstruct create_lease_v2 *lc = (struct create_lease_v2 *)buf;\n\n\t*epoch = le16_to_cpu(lc->lcontext.Epoch);\n\tif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS)\n\t\treturn SMB2_OPLOCK_LEVEL_NOCHANGE;\n\treturn le32_to_cpu(lc->lcontext.LeaseState);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lc->lcontext.LeaseState"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "lc->lcontext.Epoch"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u8\nsmb3_parse_lease_buf(void *buf, unsigned int *epoch)\n{\n\tstruct create_lease_v2 *lc = (struct create_lease_v2 *)buf;\n\n\t*epoch = le16_to_cpu(lc->lcontext.Epoch);\n\tif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS)\n\t\treturn SMB2_OPLOCK_LEVEL_NOCHANGE;\n\treturn le32_to_cpu(lc->lcontext.LeaseState);\n}"
  },
  {
    "function_name": "smb2_parse_lease_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1360-1369",
    "snippet": "static __u8\nsmb2_parse_lease_buf(void *buf, unsigned int *epoch)\n{\n\tstruct create_lease *lc = (struct create_lease *)buf;\n\n\t*epoch = 0; /* not used */\n\tif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS)\n\t\treturn SMB2_OPLOCK_LEVEL_NOCHANGE;\n\treturn le32_to_cpu(lc->lcontext.LeaseState);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lc->lcontext.LeaseState"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u8\nsmb2_parse_lease_buf(void *buf, unsigned int *epoch)\n{\n\tstruct create_lease *lc = (struct create_lease *)buf;\n\n\t*epoch = 0; /* not used */\n\tif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS)\n\t\treturn SMB2_OPLOCK_LEVEL_NOCHANGE;\n\treturn le32_to_cpu(lc->lcontext.LeaseState);\n}"
  },
  {
    "function_name": "smb3_create_lease_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1333-1358",
    "snippet": "static char *\nsmb3_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_lease_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->lcontext.LeaseKeyLow = cpu_to_le64(*((u64 *)lease_key));\n\tbuf->lcontext.LeaseKeyHigh = cpu_to_le64(*((u64 *)(lease_key + 8)));\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease_v2, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_REQUEST_LEASE is \"RqLs\" */\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof\n\t\t\t\t(struct create_lease_v2, Name)"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sizeof(struct lease_context_v2)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof\n\t\t\t\t\t(struct create_lease_v2, lcontext)"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_oplock_to_lease",
          "args": [
            "oplock"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "map_oplock_to_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "1293-1304",
          "snippet": "static __le32\nmap_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING | SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING | SMB2_LEASE_READ_CACHING |\n\t\t       SMB2_LEASE_WRITE_CACHING;\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __le32\nmap_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING | SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING | SMB2_LEASE_READ_CACHING |\n\t\t       SMB2_LEASE_WRITE_CACHING;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "*((u64 *)(lease_key + 8))"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "*((u64 *)lease_key)"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct create_lease_v2)",
            "GFP_KERNEL"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic char *\nsmb3_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_lease_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->lcontext.LeaseKeyLow = cpu_to_le64(*((u64 *)lease_key));\n\tbuf->lcontext.LeaseKeyHigh = cpu_to_le64(*((u64 *)(lease_key + 8)));\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease_v2, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_REQUEST_LEASE is \"RqLs\" */\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}"
  },
  {
    "function_name": "smb2_create_lease_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1306-1331",
    "snippet": "static char *\nsmb2_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease *buf;\n\n\tbuf = kzalloc(sizeof(struct create_lease), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->lcontext.LeaseKeyLow = cpu_to_le64(*((u64 *)lease_key));\n\tbuf->lcontext.LeaseKeyHigh = cpu_to_le64(*((u64 *)(lease_key + 8)));\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_REQUEST_LEASE is \"RqLs\" */\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof\n\t\t\t\t(struct create_lease, Name)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sizeof(struct lease_context)"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "offsetof\n\t\t\t\t\t(struct create_lease, lcontext)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_oplock_to_lease",
          "args": [
            "oplock"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "map_oplock_to_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "1293-1304",
          "snippet": "static __le32\nmap_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING | SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING | SMB2_LEASE_READ_CACHING |\n\t\t       SMB2_LEASE_WRITE_CACHING;\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __le32\nmap_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING | SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING | SMB2_LEASE_READ_CACHING |\n\t\t       SMB2_LEASE_WRITE_CACHING;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "*((u64 *)(lease_key + 8))"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "*((u64 *)lease_key)"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct create_lease)",
            "GFP_KERNEL"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic char *\nsmb2_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease *buf;\n\n\tbuf = kzalloc(sizeof(struct create_lease), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->lcontext.LeaseKeyLow = cpu_to_le64(*((u64 *)lease_key));\n\tbuf->lcontext.LeaseKeyHigh = cpu_to_le64(*((u64 *)(lease_key + 8)));\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_REQUEST_LEASE is \"RqLs\" */\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}"
  },
  {
    "function_name": "map_oplock_to_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1293-1304",
    "snippet": "static __le32\nmap_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING | SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING | SMB2_LEASE_READ_CACHING |\n\t\t       SMB2_LEASE_WRITE_CACHING;\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __le32\nmap_oplock_to_lease(u8 oplock)\n{\n\tif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn SMB2_LEASE_WRITE_CACHING | SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_II)\n\t\treturn SMB2_LEASE_READ_CACHING;\n\telse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\n\t\treturn SMB2_LEASE_HANDLE_CACHING | SMB2_LEASE_READ_CACHING |\n\t\t       SMB2_LEASE_WRITE_CACHING;\n\treturn 0;\n}"
  },
  {
    "function_name": "smb21_is_read_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1286-1291",
    "snippet": "static bool\nsmb21_is_read_op(__u32 oplock)\n{\n\treturn (oplock & SMB2_LEASE_READ_CACHING_HE) &&\n\t       !(oplock & SMB2_LEASE_WRITE_CACHING_HE);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\nsmb21_is_read_op(__u32 oplock)\n{\n\treturn (oplock & SMB2_LEASE_READ_CACHING_HE) &&\n\t       !(oplock & SMB2_LEASE_WRITE_CACHING_HE);\n}"
  },
  {
    "function_name": "smb2_is_read_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1280-1284",
    "snippet": "static bool\nsmb2_is_read_op(__u32 oplock)\n{\n\treturn oplock == SMB2_OPLOCK_LEVEL_II;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\nsmb2_is_read_op(__u32 oplock)\n{\n\treturn oplock == SMB2_OPLOCK_LEVEL_II;\n}"
  },
  {
    "function_name": "smb3_set_oplock_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1245-1278",
    "snippet": "static void\nsmb3_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\tunsigned int old_oplock = cinode->oplock;\n\n\tsmb21_set_oplock_level(cinode, oplock, epoch, purge_cache);\n\n\tif (purge_cache) {\n\t\t*purge_cache = false;\n\t\tif (old_oplock == CIFS_CACHE_READ_FLG) {\n\t\t\tif (cinode->oplock == CIFS_CACHE_READ_FLG &&\n\t\t\t    (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RH_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RHW_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == 0 &&\n\t\t\t\t (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t} else if (old_oplock == CIFS_CACHE_RH_FLG) {\n\t\t\tif (cinode->oplock == CIFS_CACHE_RH_FLG &&\n\t\t\t    (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RHW_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t}\n\t\tcinode->epoch = epoch;\n\t}\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb21_set_oplock_level",
          "args": [
            "cinode",
            "oplock",
            "epoch",
            "purge_cache"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "smb21_set_oplock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "1216-1243",
          "snippet": "static void\nsmb21_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t       unsigned int epoch, bool *purge_cache)\n{\n\tchar message[5] = {0};\n\n\toplock &= 0xFF;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\n\tcinode->oplock = 0;\n\tif (oplock & SMB2_LEASE_READ_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_READ_FLG;\n\t\tstrcat(message, \"R\");\n\t}\n\tif (oplock & SMB2_LEASE_HANDLE_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_HANDLE_FLG;\n\t\tstrcat(message, \"H\");\n\t}\n\tif (oplock & SMB2_LEASE_WRITE_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_WRITE_FLG;\n\t\tstrcat(message, \"W\");\n\t}\n\tif (!cinode->oplock)\n\t\tstrcat(message, \"None\");\n\tcifs_dbg(FYI, \"%s Lease granted on inode %p\\n\", message,\n\t\t &cinode->vfs_inode);\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb21_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t       unsigned int epoch, bool *purge_cache)\n{\n\tchar message[5] = {0};\n\n\toplock &= 0xFF;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\n\tcinode->oplock = 0;\n\tif (oplock & SMB2_LEASE_READ_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_READ_FLG;\n\t\tstrcat(message, \"R\");\n\t}\n\tif (oplock & SMB2_LEASE_HANDLE_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_HANDLE_FLG;\n\t\tstrcat(message, \"H\");\n\t}\n\tif (oplock & SMB2_LEASE_WRITE_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_WRITE_FLG;\n\t\tstrcat(message, \"W\");\n\t}\n\tif (!cinode->oplock)\n\t\tstrcat(message, \"None\");\n\tcifs_dbg(FYI, \"%s Lease granted on inode %p\\n\", message,\n\t\t &cinode->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb3_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\tunsigned int old_oplock = cinode->oplock;\n\n\tsmb21_set_oplock_level(cinode, oplock, epoch, purge_cache);\n\n\tif (purge_cache) {\n\t\t*purge_cache = false;\n\t\tif (old_oplock == CIFS_CACHE_READ_FLG) {\n\t\t\tif (cinode->oplock == CIFS_CACHE_READ_FLG &&\n\t\t\t    (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RH_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RHW_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == 0 &&\n\t\t\t\t (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t} else if (old_oplock == CIFS_CACHE_RH_FLG) {\n\t\t\tif (cinode->oplock == CIFS_CACHE_RH_FLG &&\n\t\t\t    (epoch - cinode->epoch > 0))\n\t\t\t\t*purge_cache = true;\n\t\t\telse if (cinode->oplock == CIFS_CACHE_RHW_FLG &&\n\t\t\t\t (epoch - cinode->epoch > 1))\n\t\t\t\t*purge_cache = true;\n\t\t}\n\t\tcinode->epoch = epoch;\n\t}\n}"
  },
  {
    "function_name": "smb21_set_oplock_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1216-1243",
    "snippet": "static void\nsmb21_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t       unsigned int epoch, bool *purge_cache)\n{\n\tchar message[5] = {0};\n\n\toplock &= 0xFF;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\n\tcinode->oplock = 0;\n\tif (oplock & SMB2_LEASE_READ_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_READ_FLG;\n\t\tstrcat(message, \"R\");\n\t}\n\tif (oplock & SMB2_LEASE_HANDLE_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_HANDLE_FLG;\n\t\tstrcat(message, \"H\");\n\t}\n\tif (oplock & SMB2_LEASE_WRITE_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_WRITE_FLG;\n\t\tstrcat(message, \"W\");\n\t}\n\tif (!cinode->oplock)\n\t\tstrcat(message, \"None\");\n\tcifs_dbg(FYI, \"%s Lease granted on inode %p\\n\", message,\n\t\t &cinode->vfs_inode);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s Lease granted on inode %p\\n\"",
            "message",
            "&cinode->vfs_inode"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "message",
            "\"None\""
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "message",
            "\"W\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "message",
            "\"H\""
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "message",
            "\"R\""
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb21_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t       unsigned int epoch, bool *purge_cache)\n{\n\tchar message[5] = {0};\n\n\toplock &= 0xFF;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\n\tcinode->oplock = 0;\n\tif (oplock & SMB2_LEASE_READ_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_READ_FLG;\n\t\tstrcat(message, \"R\");\n\t}\n\tif (oplock & SMB2_LEASE_HANDLE_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_HANDLE_FLG;\n\t\tstrcat(message, \"H\");\n\t}\n\tif (oplock & SMB2_LEASE_WRITE_CACHING_HE) {\n\t\tcinode->oplock |= CIFS_CACHE_WRITE_FLG;\n\t\tstrcat(message, \"W\");\n\t}\n\tif (!cinode->oplock)\n\t\tstrcat(message, \"None\");\n\tcifs_dbg(FYI, \"%s Lease granted on inode %p\\n\", message,\n\t\t &cinode->vfs_inode);\n}"
  },
  {
    "function_name": "smb2_set_oplock_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1193-1214",
    "snippet": "static void\nsmb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\toplock &= 0xFF;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\tif (oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\tcinode->oplock = CIFS_CACHE_RHW_FLG;\n\t\tcifs_dbg(FYI, \"Batch Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_RW_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == SMB2_OPLOCK_LEVEL_II) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Level II Oplock granted on inode %p\\n\"",
            "&cinode->vfs_inode"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Exclusive Oplock granted on inode %p\\n\"",
            "&cinode->vfs_inode"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Batch Oplock granted on inode %p\\n\"",
            "&cinode->vfs_inode"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t      unsigned int epoch, bool *purge_cache)\n{\n\toplock &= 0xFF;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\tif (oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\tcinode->oplock = CIFS_CACHE_RHW_FLG;\n\t\tcifs_dbg(FYI, \"Batch Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_RW_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == SMB2_OPLOCK_LEVEL_II) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}"
  },
  {
    "function_name": "smb2_downgrade_oplock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1182-1191",
    "snippet": "static void\nsmb2_downgrade_oplock(struct TCP_Server_Info *server,\n\t\t\tstruct cifsInodeInfo *cinode, bool set_level2)\n{\n\tif (set_level2)\n\t\tserver->ops->set_oplock_level(cinode, SMB2_OPLOCK_LEVEL_II,\n\t\t\t\t\t\t0, NULL);\n\telse\n\t\tserver->ops->set_oplock_level(cinode, 0, 0, NULL);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "server->ops->set_oplock_level",
          "args": [
            "cinode",
            "0",
            "0",
            "NULL"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->set_oplock_level",
          "args": [
            "cinode",
            "SMB2_OPLOCK_LEVEL_II",
            "0",
            "NULL"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_downgrade_oplock(struct TCP_Server_Info *server,\n\t\t\tstruct cifsInodeInfo *cinode, bool set_level2)\n{\n\tif (set_level2)\n\t\tserver->ops->set_oplock_level(cinode, SMB2_OPLOCK_LEVEL_II,\n\t\t\t\t\t\t0, NULL);\n\telse\n\t\tserver->ops->set_oplock_level(cinode, 0, 0, NULL);\n}"
  },
  {
    "function_name": "smb3_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1164-1180",
    "snippet": "static long smb3_fallocate(struct file *file, struct cifs_tcon *tcon, int mode,\n\t\t\t   loff_t off, loff_t len)\n{\n\t/* KEEP_SIZE already checked for by do_fallocate */\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn smb3_punch_hole(file, tcon, off, len);\n\telse if (mode & FALLOC_FL_ZERO_RANGE) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\t\treturn smb3_zero_range(file, tcon, off, len, true);\n\t\treturn smb3_zero_range(file, tcon, off, len, false);\n\t} else if (mode == FALLOC_FL_KEEP_SIZE)\n\t\treturn smb3_simple_falloc(file, tcon, off, len, true);\n\telse if (mode == 0)\n\t\treturn smb3_simple_falloc(file, tcon, off, len, false);\n\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb3_simple_falloc",
          "args": [
            "file",
            "tcon",
            "off",
            "len",
            "false"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "smb3_simple_falloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "1106-1161",
          "snippet": "static long smb3_simple_falloc(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t off, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tlong rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* if file not oplocked can't be sure whether asking to extend size */\n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false)\n\t\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Files are non-sparse by default so falloc may be a no-op\n\t * Must check if file sparse. If not sparse, and not extending\n\t * then no need to do anything since file already allocated\n\t */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) == 0) {\n\t\tif (keep_size == true)\n\t\t\treturn 0;\n\t\t/* check if extending file */\n\t\telse if (i_size_read(inode) >= off + len)\n\t\t\t/* not extending file and already not sparse */\n\t\t\treturn 0;\n\t\t/* BB: in future add else clause to extend file */\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((keep_size == true) || (i_size_read(inode) >= off + len)) {\n\t\t/*\n\t\t * Check if falloc starts within first few pages of file\n\t\t * and ends within a few pages of the end of file to\n\t\t * ensure that most of file is being forced to be\n\t\t * fallocated now. If so then setting whole file sparse\n\t\t * ie potentially making a few extra pages at the beginning\n\t\t * or end of the file non-sparse via set_sparse is harmless.\n\t\t */\n\t\tif ((off > 8192) || (off + len + 8192 < i_size_read(inode)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\trc = smb2_set_sparse(xid, tcon, cfile, inode, false);\n\t}\n\t/* BB: else ... in future add code to extend file and set sparse */\n\n\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic long smb3_simple_falloc(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t off, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tlong rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* if file not oplocked can't be sure whether asking to extend size */\n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false)\n\t\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Files are non-sparse by default so falloc may be a no-op\n\t * Must check if file sparse. If not sparse, and not extending\n\t * then no need to do anything since file already allocated\n\t */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) == 0) {\n\t\tif (keep_size == true)\n\t\t\treturn 0;\n\t\t/* check if extending file */\n\t\telse if (i_size_read(inode) >= off + len)\n\t\t\t/* not extending file and already not sparse */\n\t\t\treturn 0;\n\t\t/* BB: in future add else clause to extend file */\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((keep_size == true) || (i_size_read(inode) >= off + len)) {\n\t\t/*\n\t\t * Check if falloc starts within first few pages of file\n\t\t * and ends within a few pages of the end of file to\n\t\t * ensure that most of file is being forced to be\n\t\t * fallocated now. If so then setting whole file sparse\n\t\t * ie potentially making a few extra pages at the beginning\n\t\t * or end of the file non-sparse via set_sparse is harmless.\n\t\t */\n\t\tif ((off > 8192) || (off + len + 8192 < i_size_read(inode)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\trc = smb2_set_sparse(xid, tcon, cfile, inode, false);\n\t}\n\t/* BB: else ... in future add code to extend file and set sparse */\n\n\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb3_zero_range",
          "args": [
            "file",
            "tcon",
            "off",
            "len",
            "false"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "smb3_zero_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "1022-1070",
          "snippet": "static long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* if file not oplocked can't be sure whether asking to extend size */\n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false)\n\t\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Must check if file sparse since fallocate -z (zero range) assumes\n\t * non-sparse allocation\n\t */\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * need to make sure we are not asked to extend the file since the SMB3\n\t * fsctl does not change the file size. In the future we could change\n\t * this to zero the first part of the range then set the file size\n\t * which for a non sparse file would zero the newly extended range\n\t */\n\tif (keep_size == false)\n\t\tif (i_size_read(inode) < offset + len)\n\t\t\treturn -EOPNOTSUPP;\n\n\tcifs_dbg(FYI, \"offset %lld len %lld\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\ttrue /* is_fctl */, (char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information), NULL, NULL);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* if file not oplocked can't be sure whether asking to extend size */\n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false)\n\t\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Must check if file sparse since fallocate -z (zero range) assumes\n\t * non-sparse allocation\n\t */\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * need to make sure we are not asked to extend the file since the SMB3\n\t * fsctl does not change the file size. In the future we could change\n\t * this to zero the first part of the range then set the file size\n\t * which for a non sparse file would zero the newly extended range\n\t */\n\tif (keep_size == false)\n\t\tif (i_size_read(inode) < offset + len)\n\t\t\treturn -EOPNOTSUPP;\n\n\tcifs_dbg(FYI, \"offset %lld len %lld\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\ttrue /* is_fctl */, (char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information), NULL, NULL);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb3_punch_hole",
          "args": [
            "file",
            "tcon",
            "off",
            "len"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "smb3_punch_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "1072-1104",
          "snippet": "static long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\t__u8 set_sparse = 1;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* Need to make file sparse, if not already, before freeing range. */\n\t/* Consider adding equivalent for compressed since it could also work */\n\tif (!smb2_set_sparse(xid, tcon, cfile, inode, set_sparse))\n\t\treturn -EOPNOTSUPP;\n\n\tcifs_dbg(FYI, \"offset %lld len %lld\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\ttrue /* is_fctl */, (char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information), NULL, NULL);\n\tfree_xid(xid);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\t__u8 set_sparse = 1;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* Need to make file sparse, if not already, before freeing range. */\n\t/* Consider adding equivalent for compressed since it could also work */\n\tif (!smb2_set_sparse(xid, tcon, cfile, inode, set_sparse))\n\t\treturn -EOPNOTSUPP;\n\n\tcifs_dbg(FYI, \"offset %lld len %lld\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\ttrue /* is_fctl */, (char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information), NULL, NULL);\n\tfree_xid(xid);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic long smb3_fallocate(struct file *file, struct cifs_tcon *tcon, int mode,\n\t\t\t   loff_t off, loff_t len)\n{\n\t/* KEEP_SIZE already checked for by do_fallocate */\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn smb3_punch_hole(file, tcon, off, len);\n\telse if (mode & FALLOC_FL_ZERO_RANGE) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\t\treturn smb3_zero_range(file, tcon, off, len, true);\n\t\treturn smb3_zero_range(file, tcon, off, len, false);\n\t} else if (mode == FALLOC_FL_KEEP_SIZE)\n\t\treturn smb3_simple_falloc(file, tcon, off, len, true);\n\telse if (mode == 0)\n\t\treturn smb3_simple_falloc(file, tcon, off, len, false);\n\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "smb3_simple_falloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1106-1161",
    "snippet": "static long smb3_simple_falloc(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t off, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tlong rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* if file not oplocked can't be sure whether asking to extend size */\n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false)\n\t\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Files are non-sparse by default so falloc may be a no-op\n\t * Must check if file sparse. If not sparse, and not extending\n\t * then no need to do anything since file already allocated\n\t */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) == 0) {\n\t\tif (keep_size == true)\n\t\t\treturn 0;\n\t\t/* check if extending file */\n\t\telse if (i_size_read(inode) >= off + len)\n\t\t\t/* not extending file and already not sparse */\n\t\t\treturn 0;\n\t\t/* BB: in future add else clause to extend file */\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((keep_size == true) || (i_size_read(inode) >= off + len)) {\n\t\t/*\n\t\t * Check if falloc starts within first few pages of file\n\t\t * and ends within a few pages of the end of file to\n\t\t * ensure that most of file is being forced to be\n\t\t * fallocated now. If so then setting whole file sparse\n\t\t * ie potentially making a few extra pages at the beginning\n\t\t * or end of the file non-sparse via set_sparse is harmless.\n\t\t */\n\t\tif ((off > 8192) || (off + len + 8192 < i_size_read(inode)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\trc = smb2_set_sparse(xid, tcon, cfile, inode, false);\n\t}\n\t/* BB: else ... in future add code to extend file and set sparse */\n\n\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_set_sparse",
          "args": [
            "xid",
            "tcon",
            "cfile",
            "inode",
            "false"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_set_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "739-782",
          "snippet": "static bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t/* if file already sparse don't bother setting sparse again */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true; /* already sparse */\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true; /* already not sparse */\n\n\t/*\n\t * Can't check for sparse support on share the usual way via the\n\t * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share\n\t * since Samba server doesn't set the flag on the share, yet\n\t * supports the set sparse FSCTL and returns sparse correctly\n\t * in the file attributes. If we fail setting sparse though we\n\t * mark that server does not support sparse files for this share\n\t * to avoid repeatedly sending the unsupported fsctl to server\n\t * if the file is repeatedly extended.\n\t */\n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\ttrue /* is_fctl */, &setsparse, 1, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t/* if file already sparse don't bother setting sparse again */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true; /* already sparse */\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true; /* already not sparse */\n\n\t/*\n\t * Can't check for sparse support on share the usual way via the\n\t * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share\n\t * since Samba server doesn't set the flag on the share, yet\n\t * supports the set sparse FSCTL and returns sparse correctly\n\t * in the file attributes. If we fail setting sparse though we\n\t * mark that server does not support sparse files for this share\n\t * to avoid repeatedly sending the unsupported fsctl to server\n\t * if the file is repeatedly extended.\n\t */\n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\ttrue /* is_fctl */, &setsparse, 1, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cifsi"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic long smb3_simple_falloc(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t off, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tlong rc = -EOPNOTSUPP;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* if file not oplocked can't be sure whether asking to extend size */\n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false)\n\t\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Files are non-sparse by default so falloc may be a no-op\n\t * Must check if file sparse. If not sparse, and not extending\n\t * then no need to do anything since file already allocated\n\t */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) == 0) {\n\t\tif (keep_size == true)\n\t\t\treturn 0;\n\t\t/* check if extending file */\n\t\telse if (i_size_read(inode) >= off + len)\n\t\t\t/* not extending file and already not sparse */\n\t\t\treturn 0;\n\t\t/* BB: in future add else clause to extend file */\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((keep_size == true) || (i_size_read(inode) >= off + len)) {\n\t\t/*\n\t\t * Check if falloc starts within first few pages of file\n\t\t * and ends within a few pages of the end of file to\n\t\t * ensure that most of file is being forced to be\n\t\t * fallocated now. If so then setting whole file sparse\n\t\t * ie potentially making a few extra pages at the beginning\n\t\t * or end of the file non-sparse via set_sparse is harmless.\n\t\t */\n\t\tif ((off > 8192) || (off + len + 8192 < i_size_read(inode)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\trc = smb2_set_sparse(xid, tcon, cfile, inode, false);\n\t}\n\t/* BB: else ... in future add code to extend file and set sparse */\n\n\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb3_punch_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1072-1104",
    "snippet": "static long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\t__u8 set_sparse = 1;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* Need to make file sparse, if not already, before freeing range. */\n\t/* Consider adding equivalent for compressed since it could also work */\n\tif (!smb2_set_sparse(xid, tcon, cfile, inode, set_sparse))\n\t\treturn -EOPNOTSUPP;\n\n\tcifs_dbg(FYI, \"offset %lld len %lld\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\ttrue /* is_fctl */, (char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information), NULL, NULL);\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_ioctl",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.persistent_fid",
            "cfile->fid.volatile_fid",
            "FSCTL_SET_ZERO_DATA",
            "true/* is_fctl */",
            "(char *)&fsctl_buf",
            "sizeof(struct file_zero_data_information)",
            "NULL",
            "NULL"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1213-1346",
          "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "offset + len"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "offset"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"offset %lld len %lld\"",
            "offset",
            "len"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_set_sparse",
          "args": [
            "xid",
            "tcon",
            "cfile",
            "inode",
            "set_sparse"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_set_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "739-782",
          "snippet": "static bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t/* if file already sparse don't bother setting sparse again */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true; /* already sparse */\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true; /* already not sparse */\n\n\t/*\n\t * Can't check for sparse support on share the usual way via the\n\t * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share\n\t * since Samba server doesn't set the flag on the share, yet\n\t * supports the set sparse FSCTL and returns sparse correctly\n\t * in the file attributes. If we fail setting sparse though we\n\t * mark that server does not support sparse files for this share\n\t * to avoid repeatedly sending the unsupported fsctl to server\n\t * if the file is repeatedly extended.\n\t */\n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\ttrue /* is_fctl */, &setsparse, 1, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t/* if file already sparse don't bother setting sparse again */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true; /* already sparse */\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true; /* already not sparse */\n\n\t/*\n\t * Can't check for sparse support on share the usual way via the\n\t * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share\n\t * since Samba server doesn't set the flag on the share, yet\n\t * supports the set sparse FSCTL and returns sparse correctly\n\t * in the file attributes. If we fail setting sparse though we\n\t * mark that server does not support sparse files for this share\n\t * to avoid repeatedly sending the unsupported fsctl to server\n\t * if the file is repeatedly extended.\n\t */\n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\ttrue /* is_fctl */, &setsparse, 1, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\t__u8 set_sparse = 1;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* Need to make file sparse, if not already, before freeing range. */\n\t/* Consider adding equivalent for compressed since it could also work */\n\tif (!smb2_set_sparse(xid, tcon, cfile, inode, set_sparse))\n\t\treturn -EOPNOTSUPP;\n\n\tcifs_dbg(FYI, \"offset %lld len %lld\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\ttrue /* is_fctl */, (char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information), NULL, NULL);\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb3_zero_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "1022-1070",
    "snippet": "static long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* if file not oplocked can't be sure whether asking to extend size */\n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false)\n\t\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Must check if file sparse since fallocate -z (zero range) assumes\n\t * non-sparse allocation\n\t */\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * need to make sure we are not asked to extend the file since the SMB3\n\t * fsctl does not change the file size. In the future we could change\n\t * this to zero the first part of the range then set the file size\n\t * which for a non sparse file would zero the newly extended range\n\t */\n\tif (keep_size == false)\n\t\tif (i_size_read(inode) < offset + len)\n\t\t\treturn -EOPNOTSUPP;\n\n\tcifs_dbg(FYI, \"offset %lld len %lld\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\ttrue /* is_fctl */, (char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information), NULL, NULL);\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_ioctl",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.persistent_fid",
            "cfile->fid.volatile_fid",
            "FSCTL_SET_ZERO_DATA",
            "true/* is_fctl */",
            "(char *)&fsctl_buf",
            "sizeof(struct file_zero_data_information)",
            "NULL",
            "NULL"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1213-1346",
          "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "offset + len"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "offset"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"offset %lld len %lld\"",
            "offset",
            "len"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cifsi"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,\n\t\t\t    loff_t offset, loff_t len, bool keep_size)\n{\n\tstruct inode *inode;\n\tstruct cifsInodeInfo *cifsi;\n\tstruct cifsFileInfo *cfile = file->private_data;\n\tstruct file_zero_data_information fsctl_buf;\n\tlong rc;\n\tunsigned int xid;\n\n\txid = get_xid();\n\n\tinode = cfile->dentry->d_inode;\n\tcifsi = CIFS_I(inode);\n\n\t/* if file not oplocked can't be sure whether asking to extend size */\n\tif (!CIFS_CACHE_READ(cifsi))\n\t\tif (keep_size == false)\n\t\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Must check if file sparse since fallocate -z (zero range) assumes\n\t * non-sparse allocation\n\t */\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * need to make sure we are not asked to extend the file since the SMB3\n\t * fsctl does not change the file size. In the future we could change\n\t * this to zero the first part of the range then set the file size\n\t * which for a non sparse file would zero the newly extended range\n\t */\n\tif (keep_size == false)\n\t\tif (i_size_read(inode) < offset + len)\n\t\t\treturn -EOPNOTSUPP;\n\n\tcifs_dbg(FYI, \"offset %lld len %lld\", offset, len);\n\n\tfsctl_buf.FileOffset = cpu_to_le64(offset);\n\tfsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,\n\t\t\ttrue /* is_fctl */, (char *)&fsctl_buf,\n\t\t\tsizeof(struct file_zero_data_information), NULL, NULL);\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_query_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "971-1020",
    "snippet": "static int\nsmb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *full_path, char **target_path,\n\t\t   struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\tstruct smb2_err_rsp *err_buf = NULL;\n\tstruct smb2_symlink_err_rsp *symlink;\n\tunsigned int sub_len, sub_offset;\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, full_path);\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, &err_buf);\n\n\tif (!rc || !err_buf) {\n\t\tkfree(utf16_path);\n\t\treturn -ENOENT;\n\t}\n\t/* open must fail on symlink - reset rc */\n\trc = 0;\n\tsymlink = (struct smb2_symlink_err_rsp *)err_buf->ErrorData;\n\tsub_len = le16_to_cpu(symlink->SubstituteNameLength);\n\tsub_offset = le16_to_cpu(symlink->SubstituteNameOffset);\n\t*target_path = cifs_strndup_from_utf16(\n\t\t\t\t(char *)symlink->PathBuffer + sub_offset,\n\t\t\t\tsub_len, true, cifs_sb->local_nls);\n\tif (!(*target_path)) {\n\t\tkfree(utf16_path);\n\t\treturn -ENOMEM;\n\t}\n\tconvert_delimiter(*target_path, '/');\n\tcifs_dbg(FYI, \"%s: target path: %s\\n\", __func__, *target_path);\n\tkfree(utf16_path);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: target path: %s\\n\"",
            "__func__",
            "*target_path"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_delimiter",
          "args": [
            "*target_path",
            "'/'"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "convert_delimiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1185-1198",
          "snippet": "static inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strndup_from_utf16",
          "args": [
            "(char *)symlink->PathBuffer + sub_offset",
            "sub_len",
            "true",
            "cifs_sb->local_nls"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strndup_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "310-335",
          "snippet": "char *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nchar *\ncifs_strndup_from_utf16(const char *src, const int maxlen,\n\t\t\tconst bool is_unicode, const struct nls_table *codepage)\n{\n\tint len;\n\tchar *dst;\n\n\tif (is_unicode) {\n\t\tlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\n\t\tlen += nls_nullsize(codepage);\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tcifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\n\t\t\t       NO_MAP_UNI_RSVD);\n\t} else {\n\t\tlen = strnlen(src, maxlen);\n\t\tlen++;\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn NULL;\n\t\tstrlcpy(dst, src, len);\n\t}\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "symlink->SubstituteNameOffset"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "utf16_path",
            "&oplock",
            "NULL",
            "&err_buf"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_convert_path_to_utf16",
          "args": [
            "full_path",
            "cifs_sb"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_path_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "378-401",
          "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: path: %s\\n\"",
            "__func__",
            "full_path"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *full_path, char **target_path,\n\t\t   struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\tstruct smb2_err_rsp *err_buf = NULL;\n\tstruct smb2_symlink_err_rsp *symlink;\n\tunsigned int sub_len, sub_offset;\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, full_path);\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, &err_buf);\n\n\tif (!rc || !err_buf) {\n\t\tkfree(utf16_path);\n\t\treturn -ENOENT;\n\t}\n\t/* open must fail on symlink - reset rc */\n\trc = 0;\n\tsymlink = (struct smb2_symlink_err_rsp *)err_buf->ErrorData;\n\tsub_len = le16_to_cpu(symlink->SubstituteNameLength);\n\tsub_offset = le16_to_cpu(symlink->SubstituteNameOffset);\n\t*target_path = cifs_strndup_from_utf16(\n\t\t\t\t(char *)symlink->PathBuffer + sub_offset,\n\t\t\t\tsub_len, true, cifs_sb->local_nls);\n\tif (!(*target_path)) {\n\t\tkfree(utf16_path);\n\t\treturn -ENOMEM;\n\t}\n\tconvert_delimiter(*target_path, '/');\n\tcifs_dbg(FYI, \"%s: target path: %s\\n\", __func__, *target_path);\n\tkfree(utf16_path);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_new_lease_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "965-969",
    "snippet": "static void\nsmb2_new_lease_key(struct cifs_fid *fid)\n{\n\tget_random_bytes(fid->lease_key, SMB2_LEASE_KEY_SIZE);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "fid->lease_key",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_new_lease_key(struct cifs_fid *fid)\n{\n\tget_random_bytes(fid->lease_key, SMB2_LEASE_KEY_SIZE);\n}"
  },
  {
    "function_name": "smb2_set_lease_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "959-963",
    "snippet": "static void\nsmb2_set_lease_key(struct inode *inode, struct cifs_fid *fid)\n{\n\tmemcpy(CIFS_I(inode)->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "CIFS_I(inode)->lease_key",
            "fid->lease_key",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_set_lease_key(struct inode *inode, struct cifs_fid *fid)\n{\n\tmemcpy(CIFS_I(inode)->lease_key, fid->lease_key, SMB2_LEASE_KEY_SIZE);\n}"
  },
  {
    "function_name": "smb2_get_lease_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "953-957",
    "snippet": "static void\nsmb2_get_lease_key(struct inode *inode, struct cifs_fid *fid)\n{\n\tmemcpy(fid->lease_key, CIFS_I(inode)->lease_key, SMB2_LEASE_KEY_SIZE);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fid->lease_key",
            "CIFS_I(inode)->lease_key",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_get_lease_key(struct inode *inode, struct cifs_fid *fid)\n{\n\tmemcpy(fid->lease_key, CIFS_I(inode)->lease_key, SMB2_LEASE_KEY_SIZE);\n}"
  },
  {
    "function_name": "smb2_mand_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "942-951",
    "snippet": "static int\nsmb2_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\n\t       __u64 length, __u32 type, int lock, int unlock, bool wait)\n{\n\tif (unlock && !lock)\n\t\ttype = SMB2_LOCKFLAG_UNLOCK;\n\treturn SMB2_lock(xid, tlink_tcon(cfile->tlink),\n\t\t\t cfile->fid.persistent_fid, cfile->fid.volatile_fid,\n\t\t\t current->tgid, length, offset, type, wait);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_lock",
          "args": [
            "xid",
            "tlink_tcon(cfile->tlink)",
            "cfile->fid.persistent_fid",
            "cfile->fid.volatile_fid",
            "current->tgid",
            "length",
            "offset",
            "type",
            "wait"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2612-2627",
          "snippet": "int\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\n\t  const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t  const __u64 length, const __u64 offset, const __u32 lock_flags,\n\t  const bool wait)\n{\n\tstruct smb2_lock_element lock;\n\n\tlock.Offset = cpu_to_le64(offset);\n\tlock.Length = cpu_to_le64(length);\n\tlock.Flags = cpu_to_le32(lock_flags);\n\tif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\n\t\tlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\n\treturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\n\t  const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t  const __u64 length, const __u64 offset, const __u32 lock_flags,\n\t  const bool wait)\n{\n\tstruct smb2_lock_element lock;\n\n\tlock.Offset = cpu_to_le64(offset);\n\tlock.Length = cpu_to_le64(length);\n\tlock.Flags = cpu_to_le32(lock_flags);\n\tif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\n\t\tlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\n\treturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\n\t       __u64 length, __u32 type, int lock, int unlock, bool wait)\n{\n\tif (unlock && !lock)\n\t\ttype = SMB2_LOCKFLAG_UNLOCK;\n\treturn SMB2_lock(xid, tlink_tcon(cfile->tlink),\n\t\t\t cfile->fid.persistent_fid, cfile->fid.volatile_fid,\n\t\t\t current->tgid, length, offset, type, wait);\n}"
  },
  {
    "function_name": "smb2_compare_fids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "935-940",
    "snippet": "static bool\nsmb2_compare_fids(struct cifsFileInfo *ob1, struct cifsFileInfo *ob2)\n{\n\treturn ob1->fid.persistent_fid == ob2->fid.persistent_fid &&\n\t       ob1->fid.volatile_fid == ob2->fid.volatile_fid;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\nsmb2_compare_fids(struct cifsFileInfo *ob1, struct cifsFileInfo *ob2)\n{\n\treturn ob1->fid.persistent_fid == ob2->fid.persistent_fid &&\n\t       ob1->fid.volatile_fid == ob2->fid.volatile_fid;\n}"
  },
  {
    "function_name": "smb2_queryfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "908-933",
    "snippet": "static int\nsmb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct kstatfs *buf)\n{\n\tint rc;\n\t__le16 srch_path = 0; /* Null - open root of share */\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\n\tif (rc)\n\t\treturn rc;\n\tbuf->f_type = SMB2_MAGIC_NUMBER;\n\trc = SMB2_QFS_info(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\t   buf);\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_QFS_info",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid",
            "buf"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_QFS_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2470-2505",
          "snippet": "int\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\n\trc = build_qfs_info_req(&iov, tcon, FS_FULL_SIZE_INFORMATION,\n\t\t\t\tsizeof(struct smb2_fs_full_size_info),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\tinfo = (struct smb2_fs_full_size_info *)(4 /* RFC1001 len */ +\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)&rsp->hdr);\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tcopy_fs_info_to_kstatfs(info, fsdata);\n\nqfsinf_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\n\trc = build_qfs_info_req(&iov, tcon, FS_FULL_SIZE_INFORMATION,\n\t\t\t\tsizeof(struct smb2_fs_full_size_info),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\tinfo = (struct smb2_fs_full_size_info *)(4 /* RFC1001 len */ +\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)&rsp->hdr);\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tcopy_fs_info_to_kstatfs(info, fsdata);\n\nqfsinf_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "&srch_path",
            "&oplock",
            "NULL",
            "NULL"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct kstatfs *buf)\n{\n\tint rc;\n\t__le16 srch_path = 0; /* Null - open root of share */\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\n\tif (rc)\n\t\treturn rc;\n\tbuf->f_type = SMB2_MAGIC_NUMBER;\n\trc = SMB2_QFS_info(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\t   buf);\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_oplock_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "895-906",
    "snippet": "static int\nsmb2_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,\n\t\t     struct cifsInodeInfo *cinode)\n{\n\tif (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)\n\t\treturn SMB2_lease_break(0, tcon, cinode->lease_key,\n\t\t\t\t\tsmb2_get_lease_state(cinode));\n\n\treturn SMB2_oplock_break(0, tcon, fid->persistent_fid,\n\t\t\t\t fid->volatile_fid,\n\t\t\t\t CIFS_CACHE_READ(cinode) ? 1 : 0);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_oplock_break",
          "args": [
            "0",
            "tcon",
            "fid->persistent_fid",
            "fid->volatile_fid",
            "CIFS_CACHE_READ(cinode) ? 1 : 0"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_oplock_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2396-2424",
          "snippet": "int\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const u64 persistent_fid, const u64 volatile_fid,\n\t\t  __u8 oplock_level)\n{\n\tint rc;\n\tstruct smb2_oplock_break *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_oplock_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->VolatileFid = volatile_fid;\n\treq->PersistentFid = persistent_fid;\n\treq->OplockLevel = oplock_level;\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Oplock Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const u64 persistent_fid, const u64 volatile_fid,\n\t\t  __u8 oplock_level)\n{\n\tint rc;\n\tstruct smb2_oplock_break *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_oplock_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->VolatileFid = volatile_fid;\n\treq->PersistentFid = persistent_fid;\n\treq->OplockLevel = oplock_level;\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Oplock Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cinode"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_lease_break",
          "args": [
            "0",
            "tcon",
            "cinode->lease_key",
            "smb2_get_lease_state(cinode)"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_lease_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2629-2658",
          "snippet": "int\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\tinc_rfc1001_len(req, 12);\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\tinc_rfc1001_len(req, 12);\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_get_lease_state",
          "args": [
            "cinode"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_get_lease_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "403-415",
          "snippet": "__le32\nsmb2_get_lease_state(struct cifsInodeInfo *cinode)\n{\n\t__le32 lease = 0;\n\n\tif (CIFS_CACHE_WRITE(cinode))\n\t\tlease |= SMB2_LEASE_WRITE_CACHING;\n\tif (CIFS_CACHE_HANDLE(cinode))\n\t\tlease |= SMB2_LEASE_HANDLE_CACHING;\n\tif (CIFS_CACHE_READ(cinode))\n\t\tlease |= SMB2_LEASE_READ_CACHING;\n\treturn lease;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le32\nsmb2_get_lease_state(struct cifsInodeInfo *cinode)\n{\n\t__le32 lease = 0;\n\n\tif (CIFS_CACHE_WRITE(cinode))\n\t\tlease |= SMB2_LEASE_WRITE_CACHING;\n\tif (CIFS_CACHE_HANDLE(cinode))\n\t\tlease |= SMB2_LEASE_HANDLE_CACHING;\n\tif (CIFS_CACHE_READ(cinode))\n\t\tlease |= SMB2_LEASE_READ_CACHING;\n\treturn lease;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,\n\t\t     struct cifsInodeInfo *cinode)\n{\n\tif (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)\n\t\treturn SMB2_lease_break(0, tcon, cinode->lease_key,\n\t\t\t\t\tsmb2_get_lease_state(cinode));\n\n\treturn SMB2_oplock_break(0, tcon, fid->persistent_fid,\n\t\t\t\t fid->volatile_fid,\n\t\t\t\t CIFS_CACHE_READ(cinode) ? 1 : 0);\n}"
  },
  {
    "function_name": "smb2_is_status_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "877-893",
    "snippet": "static bool\nsmb2_is_status_pending(char *buf, struct TCP_Server_Info *server, int length)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\n\tif (hdr->Status != STATUS_PENDING)\n\t\treturn false;\n\n\tif (!length) {\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += le16_to_cpu(hdr->CreditRequest);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->request_q"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "hdr->CreditRequest"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\nsmb2_is_status_pending(char *buf, struct TCP_Server_Info *server, int length)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\n\tif (hdr->Status != STATUS_PENDING)\n\t\treturn false;\n\n\tif (!length) {\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += le16_to_cpu(hdr->CreditRequest);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "smb2_close_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "866-871",
    "snippet": "static int\nsmb2_close_dir(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct cifs_fid *fid)\n{\n\treturn SMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid->persistent_fid",
            "fid->volatile_fid"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_close_dir(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct cifs_fid *fid)\n{\n\treturn SMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}"
  },
  {
    "function_name": "smb2_query_dir_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "857-864",
    "snippet": "static int\nsmb2_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    struct cifs_fid *fid, __u16 search_flags,\n\t\t    struct cifs_search_info *srch_inf)\n{\n\treturn SMB2_query_directory(xid, tcon, fid->persistent_fid,\n\t\t\t\t    fid->volatile_fid, 0, srch_inf);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_query_directory",
          "args": [
            "xid",
            "tcon",
            "fid->persistent_fid",
            "fid->volatile_fid",
            "0",
            "srch_inf"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_query_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2107-2229",
          "snippet": "int\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint len;\n\tint resp_buftype;\n\tunsigned char *bufptr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\t__le16 asteriks = cpu_to_le16('*');\n\tchar *end_of_smb;\n\tunsigned int output_size = CIFSMaxBufSize;\n\tsize_t info_buf_size;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\trc = -EINVAL;\n\t\tgoto qdir_exit;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\tinc_rfc1001_len(req, len - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_query_directory_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA && rsp->hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t}\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\tgoto qdir_exit;\n\t}\n\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  info_buf_size);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry = 4 /* rfclen */ +\n\t\t(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\n\t/* 4 for rfc1002 length field */\n\tend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\n\tsrch_inf->entries_in_buffer =\n\t\t\tnum_entries(srch_inf->srch_entries_start, end_of_smb,\n\t\t\t\t    &srch_inf->last_entry, info_buf_size);\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_dbg(VFS, \"illegal search buffer type\\n\");\n\n\treturn rc;\n\nqdir_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint len;\n\tint resp_buftype;\n\tunsigned char *bufptr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\t__le16 asteriks = cpu_to_le16('*');\n\tchar *end_of_smb;\n\tunsigned int output_size = CIFSMaxBufSize;\n\tsize_t info_buf_size;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\trc = -EINVAL;\n\t\tgoto qdir_exit;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\tinc_rfc1001_len(req, len - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_query_directory_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA && rsp->hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t}\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\tgoto qdir_exit;\n\t}\n\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  info_buf_size);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry = 4 /* rfclen */ +\n\t\t(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\n\t/* 4 for rfc1002 length field */\n\tend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\n\tsrch_inf->entries_in_buffer =\n\t\t\tnum_entries(srch_inf->srch_entries_start, end_of_smb,\n\t\t\t\t    &srch_inf->last_entry, info_buf_size);\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_dbg(VFS, \"illegal search buffer type\\n\");\n\n\treturn rc;\n\nqdir_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    struct cifs_fid *fid, __u16 search_flags,\n\t\t    struct cifs_search_info *srch_inf)\n{\n\treturn SMB2_query_directory(xid, tcon, fid->persistent_fid,\n\t\t\t\t    fid->volatile_fid, 0, srch_inf);\n}"
  },
  {
    "function_name": "smb2_query_dir_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "816-855",
    "snippet": "static int\nsmb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *path, struct cifs_sb_info *cifs_sb,\n\t\t     struct cifs_fid *fid, __u16 search_flags,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\t__le16 *utf16_path;\n\tint rc;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES | FILE_READ_DATA;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tkfree(utf16_path);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"open dir failed\\n\");\n\t\treturn rc;\n\t}\n\n\tsrch_inf->entries_in_buffer = 0;\n\tsrch_inf->index_of_last_entry = 0;\n\n\trc = SMB2_query_directory(xid, tcon, fid->persistent_fid,\n\t\t\t\t  fid->volatile_fid, 0, srch_inf);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"query directory failed\\n\");\n\t\tSMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid->persistent_fid",
            "fid->volatile_fid"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"query directory failed\\n\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_query_directory",
          "args": [
            "xid",
            "tcon",
            "fid->persistent_fid",
            "fid->volatile_fid",
            "0",
            "srch_inf"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_query_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2107-2229",
          "snippet": "int\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint len;\n\tint resp_buftype;\n\tunsigned char *bufptr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\t__le16 asteriks = cpu_to_le16('*');\n\tchar *end_of_smb;\n\tunsigned int output_size = CIFSMaxBufSize;\n\tsize_t info_buf_size;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\trc = -EINVAL;\n\t\tgoto qdir_exit;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\tinc_rfc1001_len(req, len - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_query_directory_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA && rsp->hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t}\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\tgoto qdir_exit;\n\t}\n\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  info_buf_size);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry = 4 /* rfclen */ +\n\t\t(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\n\t/* 4 for rfc1002 length field */\n\tend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\n\tsrch_inf->entries_in_buffer =\n\t\t\tnum_entries(srch_inf->srch_entries_start, end_of_smb,\n\t\t\t\t    &srch_inf->last_entry, info_buf_size);\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_dbg(VFS, \"illegal search buffer type\\n\");\n\n\treturn rc;\n\nqdir_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint len;\n\tint resp_buftype;\n\tunsigned char *bufptr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\t__le16 asteriks = cpu_to_le16('*');\n\tchar *end_of_smb;\n\tunsigned int output_size = CIFSMaxBufSize;\n\tsize_t info_buf_size;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\trc = -EINVAL;\n\t\tgoto qdir_exit;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\tinc_rfc1001_len(req, len - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_query_directory_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA && rsp->hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t}\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\tgoto qdir_exit;\n\t}\n\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  info_buf_size);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry = 4 /* rfclen */ +\n\t\t(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\n\t/* 4 for rfc1002 length field */\n\tend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\n\tsrch_inf->entries_in_buffer =\n\t\t\tnum_entries(srch_inf->srch_entries_start, end_of_smb,\n\t\t\t\t    &srch_inf->last_entry, info_buf_size);\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_dbg(VFS, \"illegal search buffer type\\n\");\n\n\treturn rc;\n\nqdir_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"open dir failed\\n\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "utf16_path",
            "&oplock",
            "NULL",
            "NULL"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_convert_path_to_utf16",
          "args": [
            "path",
            "cifs_sb"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_path_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "378-401",
          "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *path, struct cifs_sb_info *cifs_sb,\n\t\t     struct cifs_fid *fid, __u16 search_flags,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\t__le16 *utf16_path;\n\tint rc;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES | FILE_READ_DATA;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tkfree(utf16_path);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"open dir failed\\n\");\n\t\treturn rc;\n\t}\n\n\tsrch_inf->entries_in_buffer = 0;\n\tsrch_inf->index_of_last_entry = 0;\n\n\trc = SMB2_query_directory(xid, tcon, fid->persistent_fid,\n\t\t\t\t  fid->volatile_fid, 0, srch_inf);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"query directory failed\\n\");\n\t\tSMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_set_compression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "808-814",
    "snippet": "static int\nsmb2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile)\n{\n\treturn SMB2_set_compression(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t    cfile->fid.volatile_fid);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_set_compression",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.persistent_fid",
            "cfile->fid.volatile_fid"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_set_compression",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1352-1371",
          "snippet": "int\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\tcpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION, true /* is_fsctl */,\n\t\t\t(char *)&fsctl_input /* data input */,\n\t\t\t2 /* in data len */, &ret_data /* out data */, NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\tcpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION, true /* is_fsctl */,\n\t\t\t(char *)&fsctl_input /* data input */,\n\t\t\t2 /* in data len */, &ret_data /* out data */, NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile)\n{\n\treturn SMB2_set_compression(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t    cfile->fid.volatile_fid);\n}"
  },
  {
    "function_name": "smb2_set_file_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "784-806",
    "snippet": "static int\nsmb2_set_file_size(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile, __u64 size, bool set_alloc)\n{\n\t__le64 eof = cpu_to_le64(size);\n\tstruct inode *inode;\n\n\t/*\n\t * If extending file more than one page make sparse. Many Linux fs\n\t * make files sparse by default when extending via ftruncate\n\t */\n\tinode = cfile->dentry->d_inode;\n\n\tif (!set_alloc && (size > inode->i_size + 8192)) {\n\t\t__u8 set_sparse = 1;\n\n\t\t/* whether set sparse succeeds or not, extend the file */\n\t\tsmb2_set_sparse(xid, tcon, cfile, inode, set_sparse);\n\t}\n\n\treturn SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t    cfile->fid.volatile_fid, cfile->pid, &eof, false);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_set_eof",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.persistent_fid",
            "cfile->fid.volatile_fid",
            "cfile->pid",
            "&eof",
            "false"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_set_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2364-2383",
          "snippet": "int\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_set_sparse",
          "args": [
            "xid",
            "tcon",
            "cfile",
            "inode",
            "set_sparse"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_set_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "739-782",
          "snippet": "static bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t/* if file already sparse don't bother setting sparse again */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true; /* already sparse */\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true; /* already not sparse */\n\n\t/*\n\t * Can't check for sparse support on share the usual way via the\n\t * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share\n\t * since Samba server doesn't set the flag on the share, yet\n\t * supports the set sparse FSCTL and returns sparse correctly\n\t * in the file attributes. If we fail setting sparse though we\n\t * mark that server does not support sparse files for this share\n\t * to avoid repeatedly sending the unsupported fsctl to server\n\t * if the file is repeatedly extended.\n\t */\n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\ttrue /* is_fctl */, &setsparse, 1, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t/* if file already sparse don't bother setting sparse again */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true; /* already sparse */\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true; /* already not sparse */\n\n\t/*\n\t * Can't check for sparse support on share the usual way via the\n\t * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share\n\t * since Samba server doesn't set the flag on the share, yet\n\t * supports the set sparse FSCTL and returns sparse correctly\n\t * in the file attributes. If we fail setting sparse though we\n\t * mark that server does not support sparse files for this share\n\t * to avoid repeatedly sending the unsupported fsctl to server\n\t * if the file is repeatedly extended.\n\t */\n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\ttrue /* is_fctl */, &setsparse, 1, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "size"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_set_file_size(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile, __u64 size, bool set_alloc)\n{\n\t__le64 eof = cpu_to_le64(size);\n\tstruct inode *inode;\n\n\t/*\n\t * If extending file more than one page make sparse. Many Linux fs\n\t * make files sparse by default when extending via ftruncate\n\t */\n\tinode = cfile->dentry->d_inode;\n\n\tif (!set_alloc && (size > inode->i_size + 8192)) {\n\t\t__u8 set_sparse = 1;\n\n\t\t/* whether set sparse succeeds or not, extend the file */\n\t\tsmb2_set_sparse(xid, tcon, cfile, inode, set_sparse);\n\t}\n\n\treturn SMB2_set_eof(xid, tcon, cfile->fid.persistent_fid,\n\t\t\t    cfile->fid.volatile_fid, cfile->pid, &eof, false);\n}"
  },
  {
    "function_name": "smb2_set_sparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "739-782",
    "snippet": "static bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t/* if file already sparse don't bother setting sparse again */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true; /* already sparse */\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true; /* already not sparse */\n\n\t/*\n\t * Can't check for sparse support on share the usual way via the\n\t * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share\n\t * since Samba server doesn't set the flag on the share, yet\n\t * supports the set sparse FSCTL and returns sparse correctly\n\t * in the file attributes. If we fail setting sparse though we\n\t * mark that server does not support sparse files for this share\n\t * to avoid repeatedly sending the unsupported fsctl to server\n\t * if the file is repeatedly extended.\n\t */\n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\ttrue /* is_fctl */, &setsparse, 1, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"set sparse rc = %d\\n\"",
            "rc"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_ioctl",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.persistent_fid",
            "cfile->fid.volatile_fid",
            "FSCTL_SET_SPARSE",
            "true/* is_fctl */",
            "&setsparse",
            "1",
            "NULL",
            "NULL"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1213-1346",
          "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool smb2_set_sparse(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifsFileInfo *cfile, struct inode *inode, __u8 setsparse)\n{\n\tstruct cifsInodeInfo *cifsi;\n\tint rc;\n\n\tcifsi = CIFS_I(inode);\n\n\t/* if file already sparse don't bother setting sparse again */\n\tif ((cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && setsparse)\n\t\treturn true; /* already sparse */\n\n\tif (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE) && !setsparse)\n\t\treturn true; /* already not sparse */\n\n\t/*\n\t * Can't check for sparse support on share the usual way via the\n\t * FS attribute info (FILE_SUPPORTS_SPARSE_FILES) on the share\n\t * since Samba server doesn't set the flag on the share, yet\n\t * supports the set sparse FSCTL and returns sparse correctly\n\t * in the file attributes. If we fail setting sparse though we\n\t * mark that server does not support sparse files for this share\n\t * to avoid repeatedly sending the unsupported fsctl to server\n\t * if the file is repeatedly extended.\n\t */\n\tif (tcon->broken_sparse_sup)\n\t\treturn false;\n\n\trc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,\n\t\t\tcfile->fid.volatile_fid, FSCTL_SET_SPARSE,\n\t\t\ttrue /* is_fctl */, &setsparse, 1, NULL, NULL);\n\tif (rc) {\n\t\ttcon->broken_sparse_sup = true;\n\t\tcifs_dbg(FYI, \"set sparse rc = %d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tif (setsparse)\n\t\tcifsi->cifsAttrs |= FILE_ATTRIBUTE_SPARSE_FILE;\n\telse\n\t\tcifsi->cifsAttrs &= (~FILE_ATTRIBUTE_SPARSE_FILE);\n\n\treturn true;\n}"
  },
  {
    "function_name": "smb2_sync_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "727-736",
    "snippet": "static int\nsmb2_sync_write(const unsigned int xid, struct cifs_fid *pfid,\n\t\tstruct cifs_io_parms *parms, unsigned int *written,\n\t\tstruct kvec *iov, unsigned long nr_segs)\n{\n\n\tparms->persistent_fid = pfid->persistent_fid;\n\tparms->volatile_fid = pfid->volatile_fid;\n\treturn SMB2_write(xid, parms, written, iov, nr_segs);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_write",
          "args": [
            "xid",
            "parms",
            "written",
            "iov",
            "nr_segs"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2009-2062",
          "snippet": "int\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* length of entire message including data to be written */\n\tinc_rfc1001_len(req, io_parms->length - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\n\t\t\t  &resp_buftype, 0);\n\trsp = (struct smb2_write_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\treq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* length of entire message including data to be written */\n\tinc_rfc1001_len(req, io_parms->length - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\n\t\t\t  &resp_buftype, 0);\n\trsp = (struct smb2_write_rsp *)iov[0].iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_sync_write(const unsigned int xid, struct cifs_fid *pfid,\n\t\tstruct cifs_io_parms *parms, unsigned int *written,\n\t\tstruct kvec *iov, unsigned long nr_segs)\n{\n\n\tparms->persistent_fid = pfid->persistent_fid;\n\tparms->volatile_fid = pfid->volatile_fid;\n\treturn SMB2_write(xid, parms, written, iov, nr_segs);\n}"
  },
  {
    "function_name": "smb2_sync_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "717-725",
    "snippet": "static int\nsmb2_sync_read(const unsigned int xid, struct cifs_fid *pfid,\n\t       struct cifs_io_parms *parms, unsigned int *bytes_read,\n\t       char **buf, int *buf_type)\n{\n\tparms->persistent_fid = pfid->persistent_fid;\n\tparms->volatile_fid = pfid->volatile_fid;\n\treturn SMB2_read(xid, parms, bytes_read, buf, buf_type);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_read",
          "args": [
            "xid",
            "parms",
            "bytes_read",
            "buf",
            "buf_type"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1819-1868",
          "snippet": "int\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req(iov, io_parms, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, 1,\n\t\t\t  &resp_buftype, CIFS_LOG_ERROR);\n\n\trsp = (struct smb2_read_rsp *)iov[0].iov_base;\n\n\tif (rsp->hdr.Status == STATUS_END_OF_FILE) {\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t\t    (*nbytes > io_parms->length)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t *nbytes, io_parms->length);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp->hdr.ProtocolId + rsp->DataOffset,\n\t\t       *nbytes);\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req(iov, io_parms, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, 1,\n\t\t\t  &resp_buftype, CIFS_LOG_ERROR);\n\n\trsp = (struct smb2_read_rsp *)iov[0].iov_base;\n\n\tif (rsp->hdr.Status == STATUS_END_OF_FILE) {\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t\t    (*nbytes > io_parms->length)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t *nbytes, io_parms->length);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp->hdr.ProtocolId + rsp->DataOffset,\n\t\t       *nbytes);\n\t\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_sync_read(const unsigned int xid, struct cifs_fid *pfid,\n\t       struct cifs_io_parms *parms, unsigned int *bytes_read,\n\t       char **buf, int *buf_type)\n{\n\tparms->persistent_fid = pfid->persistent_fid;\n\tparms->volatile_fid = pfid->volatile_fid;\n\treturn SMB2_read(xid, parms, bytes_read, buf, buf_type);\n}"
  },
  {
    "function_name": "smb2_read_data_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "709-714",
    "snippet": "static unsigned int\nsmb2_read_data_length(char *buf)\n{\n\tstruct smb2_read_rsp *rsp = (struct smb2_read_rsp *)buf;\n\treturn le32_to_cpu(rsp->DataLength);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->DataLength"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\nsmb2_read_data_length(char *buf)\n{\n\tstruct smb2_read_rsp *rsp = (struct smb2_read_rsp *)buf;\n\treturn le32_to_cpu(rsp->DataLength);\n}"
  },
  {
    "function_name": "smb2_read_data_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "702-707",
    "snippet": "static unsigned int\nsmb2_read_data_offset(char *buf)\n{\n\tstruct smb2_read_rsp *rsp = (struct smb2_read_rsp *)buf;\n\treturn rsp->DataOffset;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\nsmb2_read_data_offset(char *buf)\n{\n\tstruct smb2_read_rsp *rsp = (struct smb2_read_rsp *)buf;\n\treturn rsp->DataOffset;\n}"
  },
  {
    "function_name": "smb2_flush_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "695-700",
    "snippet": "static int\nsmb2_flush_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\treturn SMB2_flush(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_flush",
          "args": [
            "xid",
            "tcon",
            "fid->persistent_fid",
            "fid->volatile_fid"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1601-1637",
          "snippet": "int\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb2_flush_req *req;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Flush\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_FLUSH, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\n\tif ((rc != 0) && tcon)\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\n\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb2_flush_req *req;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Flush\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_FLUSH, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\n\tif ((rc != 0) && tcon)\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\n\tfree_rsp_buf(resp_buftype, iov[0].iov_base);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_flush_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\treturn SMB2_flush(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}"
  },
  {
    "function_name": "smb2_clone_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "574-693",
    "snippet": "static int\nsmb2_clone_range(const unsigned int xid,\n\t\t\tstruct cifsFileInfo *srcfile,\n\t\t\tstruct cifsFileInfo *trgtfile, u64 src_off,\n\t\t\tu64 len, u64 dest_off)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct copychunk_ioctl *pcchunk;\n\tstruct copychunk_ioctl_rsp *retbuf = NULL;\n\tstruct cifs_tcon *tcon;\n\tint chunks_copied = 0;\n\tbool chunk_sizes_updated = false;\n\n\tpcchunk = kmalloc(sizeof(struct copychunk_ioctl), GFP_KERNEL);\n\n\tif (pcchunk == NULL)\n\t\treturn -ENOMEM;\n\n\tcifs_dbg(FYI, \"in smb2_clone_range - about to call request res key\\n\");\n\t/* Request a key from the server to identify the source of the copy */\n\trc = SMB2_request_res_key(xid, tlink_tcon(srcfile->tlink),\n\t\t\t\tsrcfile->fid.persistent_fid,\n\t\t\t\tsrcfile->fid.volatile_fid, pcchunk);\n\n\t/* Note: request_res_key sets res_key null only if rc !=0 */\n\tif (rc)\n\t\tgoto cchunk_out;\n\n\t/* For now array only one chunk long, will make more flexible later */\n\tpcchunk->ChunkCount = cpu_to_le32(1);\n\tpcchunk->Reserved = 0;\n\tpcchunk->Reserved2 = 0;\n\n\ttcon = tlink_tcon(trgtfile->tlink);\n\n\twhile (len > 0) {\n\t\tpcchunk->SourceOffset = cpu_to_le64(src_off);\n\t\tpcchunk->TargetOffset = cpu_to_le64(dest_off);\n\t\tpcchunk->Length =\n\t\t\tcpu_to_le32(min_t(u32, len, tcon->max_bytes_chunk));\n\n\t\t/* Request server copy to target from src identified by key */\n\t\trc = SMB2_ioctl(xid, tcon, trgtfile->fid.persistent_fid,\n\t\t\ttrgtfile->fid.volatile_fid, FSCTL_SRV_COPYCHUNK_WRITE,\n\t\t\ttrue /* is_fsctl */, (char *)pcchunk,\n\t\t\tsizeof(struct copychunk_ioctl),\t(char **)&retbuf,\n\t\t\t&ret_data_len);\n\t\tif (rc == 0) {\n\t\t\tif (ret_data_len !=\n\t\t\t\t\tsizeof(struct copychunk_ioctl_rsp)) {\n\t\t\t\tcifs_dbg(VFS, \"invalid cchunk response size\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tif (retbuf->TotalBytesWritten == 0) {\n\t\t\t\tcifs_dbg(FYI, \"no bytes copied\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Check if server claimed to write more than we asked\n\t\t\t */\n\t\t\tif (le32_to_cpu(retbuf->TotalBytesWritten) >\n\t\t\t    le32_to_cpu(pcchunk->Length)) {\n\t\t\t\tcifs_dbg(VFS, \"invalid copy chunk response\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tif (le32_to_cpu(retbuf->ChunksWritten) != 1) {\n\t\t\t\tcifs_dbg(VFS, \"invalid num chunks written\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tchunks_copied++;\n\n\t\t\tsrc_off += le32_to_cpu(retbuf->TotalBytesWritten);\n\t\t\tdest_off += le32_to_cpu(retbuf->TotalBytesWritten);\n\t\t\tlen -= le32_to_cpu(retbuf->TotalBytesWritten);\n\n\t\t\tcifs_dbg(FYI, \"Chunks %d PartialChunk %d Total %d\\n\",\n\t\t\t\tle32_to_cpu(retbuf->ChunksWritten),\n\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten),\n\t\t\t\tle32_to_cpu(retbuf->TotalBytesWritten));\n\t\t} else if (rc == -EINVAL) {\n\t\t\tif (ret_data_len != sizeof(struct copychunk_ioctl_rsp))\n\t\t\t\tgoto cchunk_out;\n\n\t\t\tcifs_dbg(FYI, \"MaxChunks %d BytesChunk %d MaxCopy %d\\n\",\n\t\t\t\tle32_to_cpu(retbuf->ChunksWritten),\n\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten),\n\t\t\t\tle32_to_cpu(retbuf->TotalBytesWritten));\n\n\t\t\t/*\n\t\t\t * Check if this is the first request using these sizes,\n\t\t\t * (ie check if copy succeed once with original sizes\n\t\t\t * and check if the server gave us different sizes after\n\t\t\t * we already updated max sizes on previous request).\n\t\t\t * if not then why is the server returning an error now\n\t\t\t */\n\t\t\tif ((chunks_copied != 0) || chunk_sizes_updated)\n\t\t\t\tgoto cchunk_out;\n\n\t\t\t/* Check that server is not asking us to grow size */\n\t\t\tif (le32_to_cpu(retbuf->ChunkBytesWritten) <\n\t\t\t\t\ttcon->max_bytes_chunk)\n\t\t\t\ttcon->max_bytes_chunk =\n\t\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten);\n\t\t\telse\n\t\t\t\tgoto cchunk_out; /* server gave us bogus size */\n\n\t\t\t/* No need to change MaxChunks since already set to 1 */\n\t\t\tchunk_sizes_updated = true;\n\t\t}\n\t}\n\ncchunk_out:\n\tkfree(pcchunk);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pcchunk"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "retbuf->ChunkBytesWritten"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"MaxChunks %d BytesChunk %d MaxCopy %d\\n\"",
            "le32_to_cpu(retbuf->ChunksWritten)",
            "le32_to_cpu(retbuf->ChunkBytesWritten)",
            "le32_to_cpu(retbuf->TotalBytesWritten)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Chunks %d PartialChunk %d Total %d\\n\"",
            "le32_to_cpu(retbuf->ChunksWritten)",
            "le32_to_cpu(retbuf->ChunkBytesWritten)",
            "le32_to_cpu(retbuf->TotalBytesWritten)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"invalid num chunks written\\n\""
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"invalid copy chunk response\\n\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"no bytes copied\\n\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"invalid cchunk response size\\n\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_ioctl",
          "args": [
            "xid",
            "tcon",
            "trgtfile->fid.persistent_fid",
            "trgtfile->fid.volatile_fid",
            "FSCTL_SRV_COPYCHUNK_WRITE",
            "true/* is_fsctl */",
            "(char *)pcchunk",
            "sizeof(struct copychunk_ioctl)",
            "(char **)&retbuf",
            "&ret_data_len"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1213-1346",
          "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "min_t(u32, len, tcon->max_bytes_chunk)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "len",
            "tcon->max_bytes_chunk"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "dest_off"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "src_off"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "trgtfile->tlink"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_request_res_key",
          "args": [
            "xid",
            "tlink_tcon(srcfile->tlink)",
            "srcfile->fid.persistent_fid",
            "srcfile->fid.volatile_fid",
            "pcchunk"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_request_res_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "544-572",
          "snippet": "static int\nSMB2_request_res_key(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid,\n\t\t     struct copychunk_ioctl *pcchunk)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct resume_key_req *res_key;\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SRV_REQUEST_RESUME_KEY, true /* is_fsctl */,\n\t\t\tNULL, 0 /* no input */,\n\t\t\t(char **)&res_key, &ret_data_len);\n\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"refcpy ioctl error %d getting resume key\\n\", rc);\n\t\tgoto req_res_key_exit;\n\t}\n\tif (ret_data_len < sizeof(struct resume_key_req)) {\n\t\tcifs_dbg(VFS, \"Invalid refcopy resume key length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto req_res_key_exit;\n\t}\n\tmemcpy(pcchunk->SourceKey, res_key->ResumeKey, COPY_CHUNK_RES_KEY_SIZE);\n\nreq_res_key_exit:\n\tkfree(res_key);\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nSMB2_request_res_key(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid,\n\t\t     struct copychunk_ioctl *pcchunk)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct resume_key_req *res_key;\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SRV_REQUEST_RESUME_KEY, true /* is_fsctl */,\n\t\t\tNULL, 0 /* no input */,\n\t\t\t(char **)&res_key, &ret_data_len);\n\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"refcpy ioctl error %d getting resume key\\n\", rc);\n\t\tgoto req_res_key_exit;\n\t}\n\tif (ret_data_len < sizeof(struct resume_key_req)) {\n\t\tcifs_dbg(VFS, \"Invalid refcopy resume key length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto req_res_key_exit;\n\t}\n\tmemcpy(pcchunk->SourceKey, res_key->ResumeKey, COPY_CHUNK_RES_KEY_SIZE);\n\nreq_res_key_exit:\n\tkfree(res_key);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"in smb2_clone_range - about to call request res key\\n\""
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct copychunk_ioctl)",
            "GFP_KERNEL"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_clone_range(const unsigned int xid,\n\t\t\tstruct cifsFileInfo *srcfile,\n\t\t\tstruct cifsFileInfo *trgtfile, u64 src_off,\n\t\t\tu64 len, u64 dest_off)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct copychunk_ioctl *pcchunk;\n\tstruct copychunk_ioctl_rsp *retbuf = NULL;\n\tstruct cifs_tcon *tcon;\n\tint chunks_copied = 0;\n\tbool chunk_sizes_updated = false;\n\n\tpcchunk = kmalloc(sizeof(struct copychunk_ioctl), GFP_KERNEL);\n\n\tif (pcchunk == NULL)\n\t\treturn -ENOMEM;\n\n\tcifs_dbg(FYI, \"in smb2_clone_range - about to call request res key\\n\");\n\t/* Request a key from the server to identify the source of the copy */\n\trc = SMB2_request_res_key(xid, tlink_tcon(srcfile->tlink),\n\t\t\t\tsrcfile->fid.persistent_fid,\n\t\t\t\tsrcfile->fid.volatile_fid, pcchunk);\n\n\t/* Note: request_res_key sets res_key null only if rc !=0 */\n\tif (rc)\n\t\tgoto cchunk_out;\n\n\t/* For now array only one chunk long, will make more flexible later */\n\tpcchunk->ChunkCount = cpu_to_le32(1);\n\tpcchunk->Reserved = 0;\n\tpcchunk->Reserved2 = 0;\n\n\ttcon = tlink_tcon(trgtfile->tlink);\n\n\twhile (len > 0) {\n\t\tpcchunk->SourceOffset = cpu_to_le64(src_off);\n\t\tpcchunk->TargetOffset = cpu_to_le64(dest_off);\n\t\tpcchunk->Length =\n\t\t\tcpu_to_le32(min_t(u32, len, tcon->max_bytes_chunk));\n\n\t\t/* Request server copy to target from src identified by key */\n\t\trc = SMB2_ioctl(xid, tcon, trgtfile->fid.persistent_fid,\n\t\t\ttrgtfile->fid.volatile_fid, FSCTL_SRV_COPYCHUNK_WRITE,\n\t\t\ttrue /* is_fsctl */, (char *)pcchunk,\n\t\t\tsizeof(struct copychunk_ioctl),\t(char **)&retbuf,\n\t\t\t&ret_data_len);\n\t\tif (rc == 0) {\n\t\t\tif (ret_data_len !=\n\t\t\t\t\tsizeof(struct copychunk_ioctl_rsp)) {\n\t\t\t\tcifs_dbg(VFS, \"invalid cchunk response size\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tif (retbuf->TotalBytesWritten == 0) {\n\t\t\t\tcifs_dbg(FYI, \"no bytes copied\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Check if server claimed to write more than we asked\n\t\t\t */\n\t\t\tif (le32_to_cpu(retbuf->TotalBytesWritten) >\n\t\t\t    le32_to_cpu(pcchunk->Length)) {\n\t\t\t\tcifs_dbg(VFS, \"invalid copy chunk response\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tif (le32_to_cpu(retbuf->ChunksWritten) != 1) {\n\t\t\t\tcifs_dbg(VFS, \"invalid num chunks written\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto cchunk_out;\n\t\t\t}\n\t\t\tchunks_copied++;\n\n\t\t\tsrc_off += le32_to_cpu(retbuf->TotalBytesWritten);\n\t\t\tdest_off += le32_to_cpu(retbuf->TotalBytesWritten);\n\t\t\tlen -= le32_to_cpu(retbuf->TotalBytesWritten);\n\n\t\t\tcifs_dbg(FYI, \"Chunks %d PartialChunk %d Total %d\\n\",\n\t\t\t\tle32_to_cpu(retbuf->ChunksWritten),\n\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten),\n\t\t\t\tle32_to_cpu(retbuf->TotalBytesWritten));\n\t\t} else if (rc == -EINVAL) {\n\t\t\tif (ret_data_len != sizeof(struct copychunk_ioctl_rsp))\n\t\t\t\tgoto cchunk_out;\n\n\t\t\tcifs_dbg(FYI, \"MaxChunks %d BytesChunk %d MaxCopy %d\\n\",\n\t\t\t\tle32_to_cpu(retbuf->ChunksWritten),\n\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten),\n\t\t\t\tle32_to_cpu(retbuf->TotalBytesWritten));\n\n\t\t\t/*\n\t\t\t * Check if this is the first request using these sizes,\n\t\t\t * (ie check if copy succeed once with original sizes\n\t\t\t * and check if the server gave us different sizes after\n\t\t\t * we already updated max sizes on previous request).\n\t\t\t * if not then why is the server returning an error now\n\t\t\t */\n\t\t\tif ((chunks_copied != 0) || chunk_sizes_updated)\n\t\t\t\tgoto cchunk_out;\n\n\t\t\t/* Check that server is not asking us to grow size */\n\t\t\tif (le32_to_cpu(retbuf->ChunkBytesWritten) <\n\t\t\t\t\ttcon->max_bytes_chunk)\n\t\t\t\ttcon->max_bytes_chunk =\n\t\t\t\t\tle32_to_cpu(retbuf->ChunkBytesWritten);\n\t\t\telse\n\t\t\t\tgoto cchunk_out; /* server gave us bogus size */\n\n\t\t\t/* No need to change MaxChunks since already set to 1 */\n\t\t\tchunk_sizes_updated = true;\n\t\t}\n\t}\n\ncchunk_out:\n\tkfree(pcchunk);\n\treturn rc;\n}"
  },
  {
    "function_name": "SMB2_request_res_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "544-572",
    "snippet": "static int\nSMB2_request_res_key(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid,\n\t\t     struct copychunk_ioctl *pcchunk)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct resume_key_req *res_key;\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SRV_REQUEST_RESUME_KEY, true /* is_fsctl */,\n\t\t\tNULL, 0 /* no input */,\n\t\t\t(char **)&res_key, &ret_data_len);\n\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"refcpy ioctl error %d getting resume key\\n\", rc);\n\t\tgoto req_res_key_exit;\n\t}\n\tif (ret_data_len < sizeof(struct resume_key_req)) {\n\t\tcifs_dbg(VFS, \"Invalid refcopy resume key length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto req_res_key_exit;\n\t}\n\tmemcpy(pcchunk->SourceKey, res_key->ResumeKey, COPY_CHUNK_RES_KEY_SIZE);\n\nreq_res_key_exit:\n\tkfree(res_key);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res_key"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pcchunk->SourceKey",
            "res_key->ResumeKey",
            "COPY_CHUNK_RES_KEY_SIZE"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Invalid refcopy resume key length\\n\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"refcpy ioctl error %d getting resume key\\n\"",
            "rc"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_ioctl",
          "args": [
            "xid",
            "tcon",
            "persistent_fid",
            "volatile_fid",
            "FSCTL_SRV_REQUEST_RESUME_KEY",
            "true/* is_fsctl */",
            "NULL",
            "0/* no input */",
            "(char **)&res_key",
            "&ret_data_len"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1213-1346",
          "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nSMB2_request_res_key(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid,\n\t\t     struct copychunk_ioctl *pcchunk)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct resume_key_req *res_key;\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SRV_REQUEST_RESUME_KEY, true /* is_fsctl */,\n\t\t\tNULL, 0 /* no input */,\n\t\t\t(char **)&res_key, &ret_data_len);\n\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"refcpy ioctl error %d getting resume key\\n\", rc);\n\t\tgoto req_res_key_exit;\n\t}\n\tif (ret_data_len < sizeof(struct resume_key_req)) {\n\t\tcifs_dbg(VFS, \"Invalid refcopy resume key length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto req_res_key_exit;\n\t}\n\tmemcpy(pcchunk->SourceKey, res_key->ResumeKey, COPY_CHUNK_RES_KEY_SIZE);\n\nreq_res_key_exit:\n\tkfree(res_key);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_close_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "537-542",
    "snippet": "static void\nsmb2_close_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\tSMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid->persistent_fid",
            "fid->volatile_fid"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_close_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\tSMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);\n}"
  },
  {
    "function_name": "smb2_set_fid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "524-535",
    "snippet": "static void\nsmb2_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\n\tcfile->fid.persistent_fid = fid->persistent_fid;\n\tcfile->fid.volatile_fid = fid->volatile_fid;\n\tserver->ops->set_oplock_level(cinode, oplock, fid->epoch,\n\t\t\t\t      &fid->purge_cache);\n\tcinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "cinode"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->set_oplock_level",
          "args": [
            "cinode",
            "oplock",
            "fid->epoch",
            "&fid->purge_cache"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tstruct TCP_Server_Info *server = tlink_tcon(cfile->tlink)->ses->server;\n\n\tcfile->fid.persistent_fid = fid->persistent_fid;\n\tcfile->fid.volatile_fid = fid->volatile_fid;\n\tserver->ops->set_oplock_level(cinode, oplock, fid->epoch,\n\t\t\t\t      &fid->purge_cache);\n\tcinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);\n}"
  },
  {
    "function_name": "smb2_print_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "458-522",
    "snippet": "static void\nsmb2_print_stats(struct seq_file *m, struct cifs_tcon *tcon)\n{\n#ifdef CONFIG_CIFS_STATS\n\tatomic_t *sent = tcon->stats.smb2_stats.smb2_com_sent;\n\tatomic_t *failed = tcon->stats.smb2_stats.smb2_com_failed;\n\tseq_printf(m, \"\\nNegotiates: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_NEGOTIATE_HE]),\n\t\t   atomic_read(&failed[SMB2_NEGOTIATE_HE]));\n\tseq_printf(m, \"\\nSessionSetups: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_SESSION_SETUP_HE]),\n\t\t   atomic_read(&failed[SMB2_SESSION_SETUP_HE]));\n\tseq_printf(m, \"\\nLogoffs: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_LOGOFF_HE]),\n\t\t   atomic_read(&failed[SMB2_LOGOFF_HE]));\n\tseq_printf(m, \"\\nTreeConnects: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_TREE_CONNECT_HE]),\n\t\t   atomic_read(&failed[SMB2_TREE_CONNECT_HE]));\n\tseq_printf(m, \"\\nTreeDisconnects: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_TREE_DISCONNECT_HE]),\n\t\t   atomic_read(&failed[SMB2_TREE_DISCONNECT_HE]));\n\tseq_printf(m, \"\\nCreates: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_CREATE_HE]),\n\t\t   atomic_read(&failed[SMB2_CREATE_HE]));\n\tseq_printf(m, \"\\nCloses: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_CLOSE_HE]),\n\t\t   atomic_read(&failed[SMB2_CLOSE_HE]));\n\tseq_printf(m, \"\\nFlushes: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_FLUSH_HE]),\n\t\t   atomic_read(&failed[SMB2_FLUSH_HE]));\n\tseq_printf(m, \"\\nReads: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_READ_HE]),\n\t\t   atomic_read(&failed[SMB2_READ_HE]));\n\tseq_printf(m, \"\\nWrites: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_WRITE_HE]),\n\t\t   atomic_read(&failed[SMB2_WRITE_HE]));\n\tseq_printf(m, \"\\nLocks: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_LOCK_HE]),\n\t\t   atomic_read(&failed[SMB2_LOCK_HE]));\n\tseq_printf(m, \"\\nIOCTLs: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_IOCTL_HE]),\n\t\t   atomic_read(&failed[SMB2_IOCTL_HE]));\n\tseq_printf(m, \"\\nCancels: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_CANCEL_HE]),\n\t\t   atomic_read(&failed[SMB2_CANCEL_HE]));\n\tseq_printf(m, \"\\nEchos: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_ECHO_HE]),\n\t\t   atomic_read(&failed[SMB2_ECHO_HE]));\n\tseq_printf(m, \"\\nQueryDirectories: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_QUERY_DIRECTORY_HE]),\n\t\t   atomic_read(&failed[SMB2_QUERY_DIRECTORY_HE]));\n\tseq_printf(m, \"\\nChangeNotifies: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_CHANGE_NOTIFY_HE]),\n\t\t   atomic_read(&failed[SMB2_CHANGE_NOTIFY_HE]));\n\tseq_printf(m, \"\\nQueryInfos: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_QUERY_INFO_HE]),\n\t\t   atomic_read(&failed[SMB2_QUERY_INFO_HE]));\n\tseq_printf(m, \"\\nSetInfos: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_SET_INFO_HE]),\n\t\t   atomic_read(&failed[SMB2_SET_INFO_HE]));\n\tseq_printf(m, \"\\nOplockBreaks: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_OPLOCK_BREAK_HE]),\n\t\t   atomic_read(&failed[SMB2_OPLOCK_BREAK_HE]));\n#endif\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\nOplockBreaks: %d sent %d failed\"",
            "atomic_read(&sent[SMB2_OPLOCK_BREAK_HE])",
            "atomic_read(&failed[SMB2_OPLOCK_BREAK_HE])"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_OPLOCK_BREAK_HE]"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_OPLOCK_BREAK_HE]"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_SET_INFO_HE]"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_SET_INFO_HE]"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_QUERY_INFO_HE]"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_QUERY_INFO_HE]"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_CHANGE_NOTIFY_HE]"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_CHANGE_NOTIFY_HE]"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_QUERY_DIRECTORY_HE]"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_QUERY_DIRECTORY_HE]"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_ECHO_HE]"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_ECHO_HE]"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_CANCEL_HE]"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_CANCEL_HE]"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_IOCTL_HE]"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_IOCTL_HE]"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_LOCK_HE]"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_LOCK_HE]"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_WRITE_HE]"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_WRITE_HE]"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_READ_HE]"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_READ_HE]"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_FLUSH_HE]"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_FLUSH_HE]"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_CLOSE_HE]"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_CLOSE_HE]"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_CREATE_HE]"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_CREATE_HE]"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_TREE_DISCONNECT_HE]"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_TREE_DISCONNECT_HE]"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_TREE_CONNECT_HE]"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_TREE_CONNECT_HE]"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_LOGOFF_HE]"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_LOGOFF_HE]"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_SESSION_SETUP_HE]"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_SESSION_SETUP_HE]"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&failed[SMB2_NEGOTIATE_HE]"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sent[SMB2_NEGOTIATE_HE]"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_print_stats(struct seq_file *m, struct cifs_tcon *tcon)\n{\n#ifdef CONFIG_CIFS_STATS\n\tatomic_t *sent = tcon->stats.smb2_stats.smb2_com_sent;\n\tatomic_t *failed = tcon->stats.smb2_stats.smb2_com_failed;\n\tseq_printf(m, \"\\nNegotiates: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_NEGOTIATE_HE]),\n\t\t   atomic_read(&failed[SMB2_NEGOTIATE_HE]));\n\tseq_printf(m, \"\\nSessionSetups: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_SESSION_SETUP_HE]),\n\t\t   atomic_read(&failed[SMB2_SESSION_SETUP_HE]));\n\tseq_printf(m, \"\\nLogoffs: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_LOGOFF_HE]),\n\t\t   atomic_read(&failed[SMB2_LOGOFF_HE]));\n\tseq_printf(m, \"\\nTreeConnects: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_TREE_CONNECT_HE]),\n\t\t   atomic_read(&failed[SMB2_TREE_CONNECT_HE]));\n\tseq_printf(m, \"\\nTreeDisconnects: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_TREE_DISCONNECT_HE]),\n\t\t   atomic_read(&failed[SMB2_TREE_DISCONNECT_HE]));\n\tseq_printf(m, \"\\nCreates: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_CREATE_HE]),\n\t\t   atomic_read(&failed[SMB2_CREATE_HE]));\n\tseq_printf(m, \"\\nCloses: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_CLOSE_HE]),\n\t\t   atomic_read(&failed[SMB2_CLOSE_HE]));\n\tseq_printf(m, \"\\nFlushes: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_FLUSH_HE]),\n\t\t   atomic_read(&failed[SMB2_FLUSH_HE]));\n\tseq_printf(m, \"\\nReads: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_READ_HE]),\n\t\t   atomic_read(&failed[SMB2_READ_HE]));\n\tseq_printf(m, \"\\nWrites: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_WRITE_HE]),\n\t\t   atomic_read(&failed[SMB2_WRITE_HE]));\n\tseq_printf(m, \"\\nLocks: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_LOCK_HE]),\n\t\t   atomic_read(&failed[SMB2_LOCK_HE]));\n\tseq_printf(m, \"\\nIOCTLs: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_IOCTL_HE]),\n\t\t   atomic_read(&failed[SMB2_IOCTL_HE]));\n\tseq_printf(m, \"\\nCancels: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_CANCEL_HE]),\n\t\t   atomic_read(&failed[SMB2_CANCEL_HE]));\n\tseq_printf(m, \"\\nEchos: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_ECHO_HE]),\n\t\t   atomic_read(&failed[SMB2_ECHO_HE]));\n\tseq_printf(m, \"\\nQueryDirectories: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_QUERY_DIRECTORY_HE]),\n\t\t   atomic_read(&failed[SMB2_QUERY_DIRECTORY_HE]));\n\tseq_printf(m, \"\\nChangeNotifies: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_CHANGE_NOTIFY_HE]),\n\t\t   atomic_read(&failed[SMB2_CHANGE_NOTIFY_HE]));\n\tseq_printf(m, \"\\nQueryInfos: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_QUERY_INFO_HE]),\n\t\t   atomic_read(&failed[SMB2_QUERY_INFO_HE]));\n\tseq_printf(m, \"\\nSetInfos: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_SET_INFO_HE]),\n\t\t   atomic_read(&failed[SMB2_SET_INFO_HE]));\n\tseq_printf(m, \"\\nOplockBreaks: %d sent %d failed\",\n\t\t   atomic_read(&sent[SMB2_OPLOCK_BREAK_HE]),\n\t\t   atomic_read(&failed[SMB2_OPLOCK_BREAK_HE]));\n#endif\n}"
  },
  {
    "function_name": "smb2_dump_share_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "427-456",
    "snippet": "static void\nsmb2_dump_share_caps(struct seq_file *m, struct cifs_tcon *tcon)\n{\n\tseq_puts(m, \"\\n\\tShare Capabilities:\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_DFS)\n\t\tseq_puts(m, \" DFS,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\n\t\tseq_puts(m, \" CONTINUOUS AVAILABILITY,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_SCALEOUT)\n\t\tseq_puts(m, \" SCALEOUT,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_CLUSTER)\n\t\tseq_puts(m, \" CLUSTER,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_ASYMMETRIC)\n\t\tseq_puts(m, \" ASYMMETRIC,\");\n\tif (tcon->capabilities == 0)\n\t\tseq_puts(m, \" None\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_ALIGNED_DEVICE)\n\t\tseq_puts(m, \" Aligned,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE)\n\t\tseq_puts(m, \" Partition Aligned,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_NO_SEEK_PENALTY)\n\t\tseq_puts(m, \" SSD,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_TRIM_ENABLED)\n\t\tseq_puts(m, \" TRIM-support,\");\n\n\tseq_printf(m, \"\\tShare Flags: 0x%x\", tcon->share_flags);\n\tif (tcon->perf_sector_size)\n\t\tseq_printf(m, \"\\tOptimal sector size: 0x%x\",\n\t\t\t   tcon->perf_sector_size);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\tOptimal sector size: 0x%x\"",
            "tcon->perf_sector_size"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" TRIM-support,\""
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_dump_share_caps(struct seq_file *m, struct cifs_tcon *tcon)\n{\n\tseq_puts(m, \"\\n\\tShare Capabilities:\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_DFS)\n\t\tseq_puts(m, \" DFS,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\n\t\tseq_puts(m, \" CONTINUOUS AVAILABILITY,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_SCALEOUT)\n\t\tseq_puts(m, \" SCALEOUT,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_CLUSTER)\n\t\tseq_puts(m, \" CLUSTER,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_ASYMMETRIC)\n\t\tseq_puts(m, \" ASYMMETRIC,\");\n\tif (tcon->capabilities == 0)\n\t\tseq_puts(m, \" None\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_ALIGNED_DEVICE)\n\t\tseq_puts(m, \" Aligned,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE)\n\t\tseq_puts(m, \" Partition Aligned,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_NO_SEEK_PENALTY)\n\t\tseq_puts(m, \" SSD,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_TRIM_ENABLED)\n\t\tseq_puts(m, \" TRIM-support,\");\n\n\tseq_printf(m, \"\\tShare Flags: 0x%x\", tcon->share_flags);\n\tif (tcon->perf_sector_size)\n\t\tseq_printf(m, \"\\tOptimal sector size: 0x%x\",\n\t\t\t   tcon->perf_sector_size);\n}"
  },
  {
    "function_name": "smb2_clear_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "415-425",
    "snippet": "static void\nsmb2_clear_stats(struct cifs_tcon *tcon)\n{\n#ifdef CONFIG_CIFS_STATS\n\tint i;\n\tfor (i = 0; i < NUMBER_OF_SMB2_COMMANDS; i++) {\n\t\tatomic_set(&tcon->stats.smb2_stats.smb2_com_sent[i], 0);\n\t\tatomic_set(&tcon->stats.smb2_stats.smb2_com_failed[i], 0);\n\t}\n#endif\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.smb2_stats.smb2_com_failed[i]",
            "0"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.smb2_stats.smb2_com_sent[i]",
            "0"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_clear_stats(struct cifs_tcon *tcon)\n{\n#ifdef CONFIG_CIFS_STATS\n\tint i;\n\tfor (i = 0; i < NUMBER_OF_SMB2_COMMANDS; i++) {\n\t\tatomic_set(&tcon->stats.smb2_stats.smb2_com_sent[i], 0);\n\t\tatomic_set(&tcon->stats.smb2_stats.smb2_com_failed[i], 0);\n\t}\n#endif\n}"
  },
  {
    "function_name": "smb2_can_echo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "409-413",
    "snippet": "static bool\nsmb2_can_echo(struct TCP_Server_Info *server)\n{\n\treturn server->echoes;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\nsmb2_can_echo(struct TCP_Server_Info *server)\n{\n\treturn server->echoes;\n}"
  },
  {
    "function_name": "smb2_query_file_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "389-407",
    "snippet": "static int\nsmb2_query_file_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     struct cifs_fid *fid, FILE_ALL_INFO *data)\n{\n\tint rc;\n\tstruct smb2_file_all_info *smb2_data;\n\n\tsmb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t    GFP_KERNEL);\n\tif (smb2_data == NULL)\n\t\treturn -ENOMEM;\n\n\trc = SMB2_query_info(xid, tcon, fid->persistent_fid, fid->volatile_fid,\n\t\t\t     smb2_data);\n\tif (!rc)\n\t\tmove_smb2_info_to_cifs(data, smb2_data);\n\tkfree(smb2_data);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smb2_data"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_smb2_info_to_cifs",
          "args": [
            "data",
            "smb2_data"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "move_smb2_info_to_cifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2inode.c",
          "lines": "113-121",
          "snippet": "void\nmove_smb2_info_to_cifs(FILE_ALL_INFO *dst, struct smb2_file_all_info *src)\n{\n\tmemcpy(dst, src, (size_t)(&src->CurrentByteOffset) - (size_t)src);\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->IndexNumber1 = 0; /* we don't use it */\n}",
          "includes": [
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"fscache.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"smb2glob.h\"\n#include \"fscache.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nvoid\nmove_smb2_info_to_cifs(FILE_ALL_INFO *dst, struct smb2_file_all_info *src)\n{\n\tmemcpy(dst, src, (size_t)(&src->CurrentByteOffset) - (size_t)src);\n\tdst->CurrentByteOffset = src->CurrentByteOffset;\n\tdst->Mode = src->Mode;\n\tdst->AlignmentRequirement = src->AlignmentRequirement;\n\tdst->IndexNumber1 = 0; /* we don't use it */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_query_info",
          "args": [
            "xid",
            "tcon",
            "fid->persistent_fid",
            "fid->volatile_fid",
            "smb2_data"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_query_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1529-1538",
          "snippet": "int\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), data);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct smb2_file_all_info) + PATH_MAX * 2",
            "GFP_KERNEL"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_query_file_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     struct cifs_fid *fid, FILE_ALL_INFO *data)\n{\n\tint rc;\n\tstruct smb2_file_all_info *smb2_data;\n\n\tsmb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t    GFP_KERNEL);\n\tif (smb2_data == NULL)\n\t\treturn -ENOMEM;\n\n\trc = SMB2_query_info(xid, tcon, fid->persistent_fid, fid->volatile_fid,\n\t\t\t     smb2_data);\n\tif (!rc)\n\t\tmove_smb2_info_to_cifs(data, smb2_data);\n\tkfree(smb2_data);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_get_srv_inum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "380-387",
    "snippet": "static int\nsmb2_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t  u64 *uniqueid, FILE_ALL_INFO *data)\n{\n\t*uniqueid = le64_to_cpu(data->IndexNumber);\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "data->IndexNumber"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t  u64 *uniqueid, FILE_ALL_INFO *data)\n{\n\t*uniqueid = le64_to_cpu(data->IndexNumber);\n\treturn 0;\n}"
  },
  {
    "function_name": "smb2_is_path_accessible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "348-378",
    "snippet": "static int\nsmb2_is_path_accessible(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tkfree(utf16_path);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "utf16_path"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "utf16_path",
            "&oplock",
            "NULL",
            "NULL"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_convert_path_to_utf16",
          "args": [
            "full_path",
            "cifs_sb"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_convert_path_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "378-401",
          "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_is_path_accessible(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\t__le16 *utf16_path;\n\t__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\tutf16_path = cifs_convert_path_to_utf16(full_path, cifs_sb);\n\tif (!utf16_path)\n\t\treturn -ENOMEM;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);\n\tif (rc) {\n\t\tkfree(utf16_path);\n\t\treturn rc;\n\t}\n\n\trc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\tkfree(utf16_path);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_qfs_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "320-346",
    "snippet": "static void\nsmb2_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\t__le16 srch_path = 0; /* Null - open root of share */\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\n\tif (rc)\n\t\treturn;\n\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_ATTRIBUTE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_DEVICE_INFORMATION);\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\treturn;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_QFS_attr",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid",
            "FS_DEVICE_INFORMATION"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_QFS_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2507-2568",
          "snippet": "int\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tunsigned int rsp_len, offset;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, level, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(4 /* RFC1001 len */ + offset + (char *)&rsp->hdr);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tunsigned int rsp_len, offset;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, level, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(4 /* RFC1001 len */ + offset + (char *)&rsp->hdr);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "&srch_path",
            "&oplock",
            "NULL",
            "NULL"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\t__le16 srch_path = 0; /* Null - open root of share */\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\n\tif (rc)\n\t\treturn;\n\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_ATTRIBUTE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_DEVICE_INFORMATION);\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\treturn;\n}"
  },
  {
    "function_name": "smb3_qfs_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "286-318",
    "snippet": "static void\nsmb3_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\t__le16 srch_path = 0; /* Null - open root of share */\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\n\tif (rc)\n\t\treturn;\n\n#ifdef CONFIG_CIFS_STATS2\n\tSMB3_request_interfaces(xid, tcon);\n#endif /* STATS2 */\n\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_ATTRIBUTE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_DEVICE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_SECTOR_SIZE_INFORMATION); /* SMB3 specific */\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\treturn;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_close",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1373-1416",
          "snippet": "int\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tint resp_buftype;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\n\trsp = (struct smb2_close_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_QFS_attr",
          "args": [
            "xid",
            "tcon",
            "fid.persistent_fid",
            "fid.volatile_fid",
            "FS_SECTOR_SIZE_INFORMATION"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_QFS_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2507-2568",
          "snippet": "int\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tunsigned int rsp_len, offset;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, level, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(4 /* RFC1001 len */ + offset + (char *)&rsp->hdr);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tunsigned int rsp_len, offset;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, level, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(4 /* RFC1001 len */ + offset + (char *)&rsp->hdr);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, iov.iov_base);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB3_request_interfaces",
          "args": [
            "xid",
            "tcon"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "SMB3_request_interfaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "258-283",
          "snippet": "static int\nSMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\tunsigned int ret_data_len = 0;\n\tstruct network_interface_info_ioctl_rsp *out_buf;\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\t\tFSCTL_QUERY_NETWORK_INTERFACE_INFO, true /* is_fsctl */,\n\t\t\tNULL /* no data input */, 0 /* no data input */,\n\t\t\t(char **)&out_buf, &ret_data_len);\n\tif (rc != 0)\n\t\tcifs_dbg(VFS, \"error %d on ioctl to get interface list\\n\", rc);\n\telse if (ret_data_len < sizeof(struct network_interface_info_ioctl_rsp)) {\n\t\tcifs_dbg(VFS, \"server returned bad net interface info buf\\n\");\n\t\trc = -EINVAL;\n\t} else {\n\t\t/* Dump info on first interface */\n\t\tcifs_dbg(FYI, \"Adapter Capability 0x%x\\t\",\n\t\t\tle32_to_cpu(out_buf->Capability));\n\t\tcifs_dbg(FYI, \"Link Speed %lld\\n\",\n\t\t\tle64_to_cpu(out_buf->LinkSpeed));\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nSMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\tunsigned int ret_data_len = 0;\n\tstruct network_interface_info_ioctl_rsp *out_buf;\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\t\tFSCTL_QUERY_NETWORK_INTERFACE_INFO, true /* is_fsctl */,\n\t\t\tNULL /* no data input */, 0 /* no data input */,\n\t\t\t(char **)&out_buf, &ret_data_len);\n\tif (rc != 0)\n\t\tcifs_dbg(VFS, \"error %d on ioctl to get interface list\\n\", rc);\n\telse if (ret_data_len < sizeof(struct network_interface_info_ioctl_rsp)) {\n\t\tcifs_dbg(VFS, \"server returned bad net interface info buf\\n\");\n\t\trc = -EINVAL;\n\t} else {\n\t\t/* Dump info on first interface */\n\t\tcifs_dbg(FYI, \"Adapter Capability 0x%x\\t\",\n\t\t\tle32_to_cpu(out_buf->Capability));\n\t\tcifs_dbg(FYI, \"Link Speed %lld\\n\",\n\t\t\tle64_to_cpu(out_buf->LinkSpeed));\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMB2_open",
          "args": [
            "xid",
            "&oparms",
            "&srch_path",
            "&oplock",
            "NULL",
            "NULL"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1067-1208",
          "snippet": "int\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int num_iovecs = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &num_iovecs, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[num_iovecs-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\t\trc = add_durable_context(iov, &num_iovecs, oparms);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[num_iovecs-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_create_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb3_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\t__le16 srch_path = 0; /* Null - open root of share */\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tstruct cifs_open_parms oparms;\n\tstruct cifs_fid fid;\n\n\toparms.tcon = tcon;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = 0;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = SMB2_open(xid, &oparms, &srch_path, &oplock, NULL, NULL);\n\tif (rc)\n\t\treturn;\n\n#ifdef CONFIG_CIFS_STATS2\n\tSMB3_request_interfaces(xid, tcon);\n#endif /* STATS2 */\n\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_ATTRIBUTE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_DEVICE_INFORMATION);\n\tSMB2_QFS_attr(xid, tcon, fid.persistent_fid, fid.volatile_fid,\n\t\t\tFS_SECTOR_SIZE_INFORMATION); /* SMB3 specific */\n\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\treturn;\n}"
  },
  {
    "function_name": "SMB3_request_interfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "258-283",
    "snippet": "static int\nSMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\tunsigned int ret_data_len = 0;\n\tstruct network_interface_info_ioctl_rsp *out_buf;\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\t\tFSCTL_QUERY_NETWORK_INTERFACE_INFO, true /* is_fsctl */,\n\t\t\tNULL /* no data input */, 0 /* no data input */,\n\t\t\t(char **)&out_buf, &ret_data_len);\n\tif (rc != 0)\n\t\tcifs_dbg(VFS, \"error %d on ioctl to get interface list\\n\", rc);\n\telse if (ret_data_len < sizeof(struct network_interface_info_ioctl_rsp)) {\n\t\tcifs_dbg(VFS, \"server returned bad net interface info buf\\n\");\n\t\trc = -EINVAL;\n\t} else {\n\t\t/* Dump info on first interface */\n\t\tcifs_dbg(FYI, \"Adapter Capability 0x%x\\t\",\n\t\t\tle32_to_cpu(out_buf->Capability));\n\t\tcifs_dbg(FYI, \"Link Speed %lld\\n\",\n\t\t\tle64_to_cpu(out_buf->LinkSpeed));\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Link Speed %lld\\n\"",
            "le64_to_cpu(out_buf->LinkSpeed)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "out_buf->LinkSpeed"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Adapter Capability 0x%x\\t\"",
            "le32_to_cpu(out_buf->Capability)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "out_buf->Capability"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"server returned bad net interface info buf\\n\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"error %d on ioctl to get interface list\\n\"",
            "rc"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_ioctl",
          "args": [
            "xid",
            "tcon",
            "NO_FILE_ID",
            "NO_FILE_ID",
            "FSCTL_QUERY_NETWORK_INTERFACE_INFO",
            "true/* is_fsctl */",
            "NULL/* no data input */",
            "0/* no data input */",
            "(char **)&out_buf",
            "&ret_data_len"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "1213-1346",
          "snippet": "int\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[2];\n\tint resp_buftype;\n\tint num_iovecs;\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tnum_iovecs = 2;\n\t} else\n\t\tnum_iovecs = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\n\trsp = (struct smb2_ioctl_rsp *)iov[0].iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tif (tcon)\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tif (tcon)\n\t\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tmemcpy(*out_data, rsp->hdr.ProtocolId + le32_to_cpu(rsp->OutputOffset),\n\t       *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nSMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc;\n\tunsigned int ret_data_len = 0;\n\tstruct network_interface_info_ioctl_rsp *out_buf;\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\t\tFSCTL_QUERY_NETWORK_INTERFACE_INFO, true /* is_fsctl */,\n\t\t\tNULL /* no data input */, 0 /* no data input */,\n\t\t\t(char **)&out_buf, &ret_data_len);\n\tif (rc != 0)\n\t\tcifs_dbg(VFS, \"error %d on ioctl to get interface list\\n\", rc);\n\telse if (ret_data_len < sizeof(struct network_interface_info_ioctl_rsp)) {\n\t\tcifs_dbg(VFS, \"server returned bad net interface info buf\\n\");\n\t\trc = -EINVAL;\n\t} else {\n\t\t/* Dump info on first interface */\n\t\tcifs_dbg(FYI, \"Adapter Capability 0x%x\\t\",\n\t\t\tle32_to_cpu(out_buf->Capability));\n\t\tcifs_dbg(FYI, \"Link Speed %lld\\n\",\n\t\t\tle64_to_cpu(out_buf->LinkSpeed));\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_negotiate_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "241-255",
    "snippet": "static unsigned int\nsmb2_negotiate_rsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int rsize;\n\n\t/* start with specified rsize, or default */\n\trsize = volume_info->rsize ? volume_info->rsize : CIFS_DEFAULT_IOSIZE;\n\trsize = min_t(unsigned int, rsize, server->max_read);\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\trsize = min_t(unsigned int, rsize, SMB2_MAX_BUFFER_SIZE);\n\n\treturn rsize;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "rsize",
            "SMB2_MAX_BUFFER_SIZE"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "rsize",
            "server->max_read"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\nsmb2_negotiate_rsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int rsize;\n\n\t/* start with specified rsize, or default */\n\trsize = volume_info->rsize ? volume_info->rsize : CIFS_DEFAULT_IOSIZE;\n\trsize = min_t(unsigned int, rsize, server->max_read);\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\trsize = min_t(unsigned int, rsize, SMB2_MAX_BUFFER_SIZE);\n\n\treturn rsize;\n}"
  },
  {
    "function_name": "smb2_negotiate_wsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "225-239",
    "snippet": "static unsigned int\nsmb2_negotiate_wsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int wsize;\n\n\t/* start with specified wsize, or default */\n\twsize = volume_info->wsize ? volume_info->wsize : CIFS_DEFAULT_IOSIZE;\n\twsize = min_t(unsigned int, wsize, server->max_write);\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\twsize = min_t(unsigned int, wsize, SMB2_MAX_BUFFER_SIZE);\n\n\treturn wsize;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "wsize",
            "SMB2_MAX_BUFFER_SIZE"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "wsize",
            "server->max_write"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\nsmb2_negotiate_wsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int wsize;\n\n\t/* start with specified wsize, or default */\n\twsize = volume_info->wsize ? volume_info->wsize : CIFS_DEFAULT_IOSIZE;\n\twsize = min_t(unsigned int, wsize, server->max_write);\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\twsize = min_t(unsigned int, wsize, SMB2_MAX_BUFFER_SIZE);\n\n\treturn wsize;\n}"
  },
  {
    "function_name": "smb2_negotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "213-223",
    "snippet": "static int\nsmb2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc;\n\tses->server->CurrentMid = 0;\n\trc = SMB2_negotiate(xid, ses);\n\t/* BB we probably don't need to retry with modern servers */\n\tif (rc == -EAGAIN)\n\t\trc = -EHOSTDOWN;\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMB2_negotiate",
          "args": [
            "xid",
            "ses"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_negotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "322-446",
          "snippet": "int\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = small_smb2_init(SMB2_NEGOTIATE, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.SessionId = 0;\n\n\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\n\treq->DialectCount = cpu_to_le16(1); /* One vers= at a time for now */\n\tinc_rfc1001_len(req, 2);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags);\n\n\trsp = (struct smb2_negotiate_rsp *)iov[0].iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc != 0)\n\t\tgoto neg_exit;\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\t/* BB we may eventually want to match the negotiated vs. requested\n\t   dialect, even though we are only requesting one at a time */\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server %d\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\t/* BB Do we need to validate the SecurityMode? */\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       &rsp->hdr);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0)\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\n\trc = cifs_enable_signing(server, ses->sign);\n#ifdef CONFIG_SMB2_ASN1  /* BB REMOVEME when updated asn1.c ready */\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length)\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\tif (rc == 1)\n\t\trc = 0;\n\telse if (rc == 0) {\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n#endif\n\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = small_smb2_init(SMB2_NEGOTIATE, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.SessionId = 0;\n\n\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\n\treq->DialectCount = cpu_to_le16(1); /* One vers= at a time for now */\n\tinc_rfc1001_len(req, 2);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags);\n\n\trsp = (struct smb2_negotiate_rsp *)iov[0].iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc != 0)\n\t\tgoto neg_exit;\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\t/* BB we may eventually want to match the negotiated vs. requested\n\t   dialect, even though we are only requesting one at a time */\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server %d\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\t/* BB Do we need to validate the SecurityMode? */\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       &rsp->hdr);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0)\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\n\trc = cifs_enable_signing(server, ses->sign);\n#ifdef CONFIG_SMB2_ASN1  /* BB REMOVEME when updated asn1.c ready */\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length)\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\tif (rc == 1)\n\t\trc = 0;\n\telse if (rc == 0) {\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n#endif\n\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc;\n\tses->server->CurrentMid = 0;\n\trc = SMB2_negotiate(xid, ses);\n\t/* BB we probably don't need to retry with modern servers */\n\tif (rc == -EAGAIN)\n\t\trc = -EHOSTDOWN;\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_need_neg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "207-211",
    "snippet": "static bool\nsmb2_need_neg(struct TCP_Server_Info *server)\n{\n\treturn server->max_read == 0;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\nsmb2_need_neg(struct TCP_Server_Info *server)\n{\n\treturn server->max_read == 0;\n}"
  },
  {
    "function_name": "smb2_dump_detail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "194-205",
    "snippet": "static void\nsmb2_dump_detail(void *buf)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *smb = (struct smb2_hdr *)buf;\n\n\tcifs_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t smb->Command, smb->Status, smb->Flags, smb->MessageId,\n\t\t smb->ProcessId);\n\tcifs_dbg(VFS, \"smb buf %p len %u\\n\", smb, smb2_calc_size(smb));\n#endif\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"smb buf %p len %u\\n\"",
            "smb",
            "smb2_calc_size(smb)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_calc_size",
          "args": [
            "smb"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_calc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "334-375",
          "snippet": "unsigned int\nsmb2_calc_size(void *buf)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tint offset; /* the offset from the beginning of SMB to data area */\n\tint data_length; /* the length of the variable length data area */\n\t/* Structure Size has already been checked to make sure it is 64 */\n\tint len = 4 + le16_to_cpu(pdu->hdr.StructureSize);\n\n\t/*\n\t * StructureSize2, ie length of fixed parameter area has already\n\t * been checked to make sure it is the correct length.\n\t */\n\tlen += le16_to_cpu(pdu->StructureSize2);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tsmb2_get_data_area_len(&offset, &data_length, hdr);\n\tcifs_dbg(FYI, \"SMB2 data length %d offset %d\\n\", data_length, offset);\n\n\tif (data_length > 0) {\n\t\t/*\n\t\t * Check to make sure that data area begins after fixed area,\n\t\t * Note that last byte of the fixed area is part of data area\n\t\t * for some commands, typically those with odd StructureSize,\n\t\t * so we must add one to the calculation (and 4 to account for\n\t\t * the size of the RFC1001 hdr.\n\t\t */\n\t\tif (offset + 4 + 1 < len) {\n\t\t\tcifs_dbg(VFS, \"data area offset %d overlaps SMB2 header %d\\n\",\n\t\t\t\t offset + 4 + 1, len);\n\t\t\tdata_length = 0;\n\t\t} else {\n\t\t\tlen = 4 + offset + data_length;\n\t\t}\n\t}\ncalc_size_exit:\n\tcifs_dbg(FYI, \"SMB2 len %d\\n\", len);\n\treturn len;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ true,\n\t/* SMB2_SESSION_SETUP */ true,\n\t/* SMB2_LOGOFF */ false,\n\t/* SMB2_TREE_CONNECT */\tfalse,\n\t/* SMB2_TREE_DISCONNECT */ false,\n\t/* SMB2_CREATE */ true,\n\t/* SMB2_CLOSE */ false,\n\t/* SMB2_FLUSH */ false,\n\t/* SMB2_READ */\ttrue,\n\t/* SMB2_WRITE */ false,\n\t/* SMB2_LOCK */\tfalse,\n\t/* SMB2_IOCTL */ true,\n\t/* SMB2_CANCEL */ false, /* BB CHECK this not listed in documentation */\n\t/* SMB2_ECHO */ false,\n\t/* SMB2_QUERY_DIRECTORY */ true,\n\t/* SMB2_CHANGE_NOTIFY */ true,\n\t/* SMB2_QUERY_INFO */ true,\n\t/* SMB2_SET_INFO */ false,\n\t/* SMB2_OPLOCK_BREAK */ false\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ true,\n\t/* SMB2_SESSION_SETUP */ true,\n\t/* SMB2_LOGOFF */ false,\n\t/* SMB2_TREE_CONNECT */\tfalse,\n\t/* SMB2_TREE_DISCONNECT */ false,\n\t/* SMB2_CREATE */ true,\n\t/* SMB2_CLOSE */ false,\n\t/* SMB2_FLUSH */ false,\n\t/* SMB2_READ */\ttrue,\n\t/* SMB2_WRITE */ false,\n\t/* SMB2_LOCK */\tfalse,\n\t/* SMB2_IOCTL */ true,\n\t/* SMB2_CANCEL */ false, /* BB CHECK this not listed in documentation */\n\t/* SMB2_ECHO */ false,\n\t/* SMB2_QUERY_DIRECTORY */ true,\n\t/* SMB2_CHANGE_NOTIFY */ true,\n\t/* SMB2_QUERY_INFO */ true,\n\t/* SMB2_SET_INFO */ false,\n\t/* SMB2_OPLOCK_BREAK */ false\n};\n\nunsigned int\nsmb2_calc_size(void *buf)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tint offset; /* the offset from the beginning of SMB to data area */\n\tint data_length; /* the length of the variable length data area */\n\t/* Structure Size has already been checked to make sure it is 64 */\n\tint len = 4 + le16_to_cpu(pdu->hdr.StructureSize);\n\n\t/*\n\t * StructureSize2, ie length of fixed parameter area has already\n\t * been checked to make sure it is the correct length.\n\t */\n\tlen += le16_to_cpu(pdu->StructureSize2);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tsmb2_get_data_area_len(&offset, &data_length, hdr);\n\tcifs_dbg(FYI, \"SMB2 data length %d offset %d\\n\", data_length, offset);\n\n\tif (data_length > 0) {\n\t\t/*\n\t\t * Check to make sure that data area begins after fixed area,\n\t\t * Note that last byte of the fixed area is part of data area\n\t\t * for some commands, typically those with odd StructureSize,\n\t\t * so we must add one to the calculation (and 4 to account for\n\t\t * the size of the RFC1001 hdr.\n\t\t */\n\t\tif (offset + 4 + 1 < len) {\n\t\t\tcifs_dbg(VFS, \"data area offset %d overlaps SMB2 header %d\\n\",\n\t\t\t\t offset + 4 + 1, len);\n\t\t\tdata_length = 0;\n\t\t} else {\n\t\t\tlen = 4 + offset + data_length;\n\t\t}\n\t}\ncalc_size_exit:\n\tcifs_dbg(FYI, \"SMB2 len %d\\n\", len);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\"",
            "smb->Command",
            "smb->Status",
            "smb->Flags",
            "smb->MessageId",
            "smb->ProcessId"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_dump_detail(void *buf)\n{\n#ifdef CONFIG_CIFS_DEBUG2\n\tstruct smb2_hdr *smb = (struct smb2_hdr *)buf;\n\n\tcifs_dbg(VFS, \"Cmd: %d Err: 0x%x Flags: 0x%x Mid: %llu Pid: %d\\n\",\n\t\t smb->Command, smb->Status, smb->Flags, smb->MessageId,\n\t\t smb->ProcessId);\n\tcifs_dbg(VFS, \"smb buf %p len %u\\n\", smb, smb2_calc_size(smb));\n#endif\n}"
  },
  {
    "function_name": "smb2_find_mid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "174-192",
    "snippet": "static struct mid_q_entry *\nsmb2_find_mid(struct TCP_Server_Info *server, char *buf)\n{\n\tstruct mid_q_entry *mid;\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\t__u64 wire_mid = le64_to_cpu(hdr->MessageId);\n\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_entry(mid, &server->pending_mid_q, qhead) {\n\t\tif ((mid->mid == wire_mid) &&\n\t\t    (mid->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t    (mid->command == hdr->Command)) {\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\treturn mid;\n\t\t}\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mid",
            "&server->pending_mid_q",
            "qhead"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "hdr->MessageId"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic struct mid_q_entry *\nsmb2_find_mid(struct TCP_Server_Info *server, char *buf)\n{\n\tstruct mid_q_entry *mid;\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\t__u64 wire_mid = le64_to_cpu(hdr->MessageId);\n\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_entry(mid, &server->pending_mid_q, qhead) {\n\t\tif ((mid->mid == wire_mid) &&\n\t\t    (mid->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t    (mid->command == hdr->Command)) {\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\treturn mid;\n\t\t}\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "smb2_get_next_mid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "163-172",
    "snippet": "static __u64\nsmb2_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid;\n\t/* for SMB2 we need the current value */\n\tspin_lock(&GlobalMid_Lock);\n\tmid = server->CurrentMid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\nsmb2_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid;\n\t/* for SMB2 we need the current value */\n\tspin_lock(&GlobalMid_Lock);\n\tmid = server->CurrentMid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
  },
  {
    "function_name": "smb2_wait_mtu_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "116-161",
    "snippet": "static int\nsmb2_wait_mtu_credits(struct TCP_Server_Info *server, unsigned int size,\n\t\t      unsigned int *num, unsigned int *credits)\n{\n\tint rc = 0;\n\tunsigned int scredits;\n\n\tspin_lock(&server->req_lock);\n\twhile (1) {\n\t\tif (server->credits <= 0) {\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tcifs_num_waiters_inc(server);\n\t\t\trc = wait_event_killable(server->request_q,\n\t\t\t\t\thas_credits(server, &server->credits));\n\t\t\tcifs_num_waiters_dec(server);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tspin_lock(&server->req_lock);\n\t\t} else {\n\t\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\t\tspin_unlock(&server->req_lock);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tscredits = server->credits;\n\t\t\t/* can deadlock with reopen */\n\t\t\tif (scredits == 1) {\n\t\t\t\t*num = SMB2_MAX_BUFFER_SIZE;\n\t\t\t\t*credits = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* leave one credit for a possible reopen */\n\t\t\tscredits--;\n\t\t\t*num = min_t(unsigned int, size,\n\t\t\t\t     scredits * SMB2_MAX_BUFFER_SIZE);\n\n\t\t\t*credits = DIV_ROUND_UP(*num, SMB2_MAX_BUFFER_SIZE);\n\t\t\tserver->credits -= *credits;\n\t\t\tserver->in_flight++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&server->req_lock);\n\treturn rc;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "*num",
            "SMB2_MAX_BUFFER_SIZE"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "size",
            "scredits * SMB2_MAX_BUFFER_SIZE"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_num_waiters_dec",
          "args": [
            "server"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_num_waiters_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1317-1319",
          "snippet": "static inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_killable",
          "args": [
            "server->request_q",
            "has_credits(server, &server->credits)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_credits",
          "args": [
            "server",
            "&server->credits"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "has_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "631-639",
          "snippet": "static inline bool\nhas_credits(struct TCP_Server_Info *server, int *credits)\n{\n\tint num;\n\tspin_lock(&server->req_lock);\n\tnum = *credits;\n\tspin_unlock(&server->req_lock);\n\treturn num > 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\nhas_credits(struct TCP_Server_Info *server, int *credits)\n{\n\tint num;\n\tspin_lock(&server->req_lock);\n\tnum = *credits;\n\tspin_unlock(&server->req_lock);\n\treturn num > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_num_waiters_inc",
          "args": [
            "server"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_num_waiters_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1313-1315",
          "snippet": "static inline void cifs_num_waiters_inc(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_num_waiters_inc(struct TCP_Server_Info *server)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb2_wait_mtu_credits(struct TCP_Server_Info *server, unsigned int size,\n\t\t      unsigned int *num, unsigned int *credits)\n{\n\tint rc = 0;\n\tunsigned int scredits;\n\n\tspin_lock(&server->req_lock);\n\twhile (1) {\n\t\tif (server->credits <= 0) {\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tcifs_num_waiters_inc(server);\n\t\t\trc = wait_event_killable(server->request_q,\n\t\t\t\t\thas_credits(server, &server->credits));\n\t\t\tcifs_num_waiters_dec(server);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tspin_lock(&server->req_lock);\n\t\t} else {\n\t\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\t\tspin_unlock(&server->req_lock);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\tscredits = server->credits;\n\t\t\t/* can deadlock with reopen */\n\t\t\tif (scredits == 1) {\n\t\t\t\t*num = SMB2_MAX_BUFFER_SIZE;\n\t\t\t\t*credits = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* leave one credit for a possible reopen */\n\t\t\tscredits--;\n\t\t\t*num = min_t(unsigned int, size,\n\t\t\t\t     scredits * SMB2_MAX_BUFFER_SIZE);\n\n\t\t\t*credits = DIV_ROUND_UP(*num, SMB2_MAX_BUFFER_SIZE);\n\t\t\tserver->credits -= *credits;\n\t\t\tserver->in_flight++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&server->req_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "smb2_get_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "110-114",
    "snippet": "static unsigned int\nsmb2_get_credits(struct mid_q_entry *mid)\n{\n\treturn le16_to_cpu(((struct smb2_hdr *)mid->resp_buf)->CreditRequest);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "((struct smb2_hdr *)mid->resp_buf)->CreditRequest"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\nsmb2_get_credits(struct mid_q_entry *mid)\n{\n\treturn le16_to_cpu(((struct smb2_hdr *)mid->resp_buf)->CreditRequest);\n}"
  },
  {
    "function_name": "smb2_get_credits_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "97-108",
    "snippet": "static int *\nsmb2_get_credits_field(struct TCP_Server_Info *server, const int optype)\n{\n\tswitch (optype) {\n\tcase CIFS_ECHO_OP:\n\t\treturn &server->echo_credits;\n\tcase CIFS_OBREAK_OP:\n\t\treturn &server->oplock_credits;\n\tdefault:\n\t\treturn &server->credits;\n\t}\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int *\nsmb2_get_credits_field(struct TCP_Server_Info *server, const int optype)\n{\n\tswitch (optype) {\n\tcase CIFS_ECHO_OP:\n\t\treturn &server->echo_credits;\n\tcase CIFS_OBREAK_OP:\n\t\treturn &server->oplock_credits;\n\tdefault:\n\t\treturn &server->credits;\n\t}\n}"
  },
  {
    "function_name": "smb2_set_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "89-95",
    "snippet": "static void\nsmb2_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tspin_unlock(&server->req_lock);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tspin_unlock(&server->req_lock);\n}"
  },
  {
    "function_name": "smb2_add_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "61-87",
    "snippet": "static void\nsmb2_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tint *val, rc = 0;\n\tspin_lock(&server->req_lock);\n\tval = server->ops->get_credits_field(server, optype);\n\t*val += add;\n\tserver->in_flight--;\n\tif (server->in_flight == 0 && (optype & CIFS_OP_MASK) != CIFS_NEG_OP)\n\t\trc = change_conf(server);\n\t/*\n\t * Sometimes server returns 0 credits on oplock break ack - we need to\n\t * rebalance credits in this case.\n\t */\n\telse if (server->in_flight > 0 && server->oplock_credits == 0 &&\n\t\t server->oplocks) {\n\t\tif (server->credits > 1) {\n\t\t\tserver->credits--;\n\t\t\tserver->oplock_credits++;\n\t\t}\n\t}\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n\tif (rc)\n\t\tcifs_reconnect(server);\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_reconnect",
          "args": [
            "server"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "300-401",
          "snippet": "int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\tmutex_lock(&server->srv_mutex);\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->request_q"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_conf",
          "args": [
            "server"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "change_conf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
          "lines": "32-59",
          "snippet": "static int\nchange_conf(struct TCP_Server_Info *server)\n{\n\tserver->credits += server->echo_credits + server->oplock_credits;\n\tserver->oplock_credits = server->echo_credits = 0;\n\tswitch (server->credits) {\n\tcase 0:\n\t\treturn -1;\n\tcase 1:\n\t\tserver->echoes = false;\n\t\tserver->oplocks = false;\n\t\tcifs_dbg(VFS, \"disabling echoes and oplocks\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = false;\n\t\tserver->echo_credits = 1;\n\t\tcifs_dbg(FYI, \"disabling oplocks\\n\");\n\t\tbreak;\n\tdefault:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = true;\n\t\tserver->echo_credits = 1;\n\t\tserver->oplock_credits = 1;\n\t}\n\tserver->credits -= server->echo_credits + server->oplock_credits;\n\treturn 0;\n}",
          "includes": [
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"smb2proto.h\"",
            "#include \"smb2pdu.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nchange_conf(struct TCP_Server_Info *server)\n{\n\tserver->credits += server->echo_credits + server->oplock_credits;\n\tserver->oplock_credits = server->echo_credits = 0;\n\tswitch (server->credits) {\n\tcase 0:\n\t\treturn -1;\n\tcase 1:\n\t\tserver->echoes = false;\n\t\tserver->oplocks = false;\n\t\tcifs_dbg(VFS, \"disabling echoes and oplocks\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = false;\n\t\tserver->echo_credits = 1;\n\t\tcifs_dbg(FYI, \"disabling oplocks\\n\");\n\t\tbreak;\n\tdefault:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = true;\n\t\tserver->echo_credits = 1;\n\t\tserver->oplock_credits = 1;\n\t}\n\tserver->credits -= server->echo_credits + server->oplock_credits;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->get_credits_field",
          "args": [
            "server",
            "optype"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\nsmb2_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tint *val, rc = 0;\n\tspin_lock(&server->req_lock);\n\tval = server->ops->get_credits_field(server, optype);\n\t*val += add;\n\tserver->in_flight--;\n\tif (server->in_flight == 0 && (optype & CIFS_OP_MASK) != CIFS_NEG_OP)\n\t\trc = change_conf(server);\n\t/*\n\t * Sometimes server returns 0 credits on oplock break ack - we need to\n\t * rebalance credits in this case.\n\t */\n\telse if (server->in_flight > 0 && server->oplock_credits == 0 &&\n\t\t server->oplocks) {\n\t\tif (server->credits > 1) {\n\t\t\tserver->credits--;\n\t\t\tserver->oplock_credits++;\n\t\t}\n\t}\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n\tif (rc)\n\t\tcifs_reconnect(server);\n}"
  },
  {
    "function_name": "change_conf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2ops.c",
    "lines": "32-59",
    "snippet": "static int\nchange_conf(struct TCP_Server_Info *server)\n{\n\tserver->credits += server->echo_credits + server->oplock_credits;\n\tserver->oplock_credits = server->echo_credits = 0;\n\tswitch (server->credits) {\n\tcase 0:\n\t\treturn -1;\n\tcase 1:\n\t\tserver->echoes = false;\n\t\tserver->oplocks = false;\n\t\tcifs_dbg(VFS, \"disabling echoes and oplocks\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = false;\n\t\tserver->echo_credits = 1;\n\t\tcifs_dbg(FYI, \"disabling oplocks\\n\");\n\t\tbreak;\n\tdefault:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = true;\n\t\tserver->echo_credits = 1;\n\t\tserver->oplock_credits = 1;\n\t}\n\tserver->credits -= server->echo_credits + server->oplock_credits;\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2glob.h\"",
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"smb2proto.h\"",
      "#include \"smb2pdu.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"disabling oplocks\\n\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"disabling echoes and oplocks\\n\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include <linux/falloc.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nchange_conf(struct TCP_Server_Info *server)\n{\n\tserver->credits += server->echo_credits + server->oplock_credits;\n\tserver->oplock_credits = server->echo_credits = 0;\n\tswitch (server->credits) {\n\tcase 0:\n\t\treturn -1;\n\tcase 1:\n\t\tserver->echoes = false;\n\t\tserver->oplocks = false;\n\t\tcifs_dbg(VFS, \"disabling echoes and oplocks\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = false;\n\t\tserver->echo_credits = 1;\n\t\tcifs_dbg(FYI, \"disabling oplocks\\n\");\n\t\tbreak;\n\tdefault:\n\t\tserver->echoes = true;\n\t\tserver->oplocks = true;\n\t\tserver->echo_credits = 1;\n\t\tserver->oplock_credits = 1;\n\t}\n\tserver->credits -= server->echo_credits + server->oplock_credits;\n\treturn 0;\n}"
  }
]