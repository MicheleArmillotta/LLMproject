[
  {
    "function_name": "xfs_attr_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
    "lines": "382-449",
    "snippet": "int\nxfs_attr_inactive(xfs_inode_t *dp)\n{\n\txfs_trans_t *trans;\n\txfs_mount_t *mp;\n\tint error;\n\n\tmp = dp->i_mount;\n\tASSERT(! XFS_NOT_DQATTACHED(mp, dp));\n\n\txfs_ilock(dp, XFS_ILOCK_SHARED);\n\tif (!xfs_inode_hasattr(dp) ||\n\t    dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\txfs_iunlock(dp, XFS_ILOCK_SHARED);\n\t\treturn 0;\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_SHARED);\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\ttrans = xfs_trans_alloc(mp, XFS_TRANS_ATTRINVAL);\n\terror = xfs_trans_reserve(trans, &M_RES(mp)->tr_attrinval, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks, not allocate, in the common case.\n\t */\n\txfs_trans_ijoin(trans, dp, 0);\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tif (!xfs_inode_hasattr(dp) ||\n\t    dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\terror = xfs_attr3_root_inactive(&trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_itruncate_extents(&trans, dp, XFS_ATTR_FORK, 0);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_trans_commit(trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\txfs_trans_cancel(trans, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "trans",
            "XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "trans",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_itruncate_extents",
          "args": [
            "&trans",
            "dp",
            "XFS_ATTR_FORK",
            "0"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_itruncate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1492-1605",
          "snippet": "int\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [
            "#define\tXFS_ITRUNC_MAX_EXTENTS\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\n#define\tXFS_ITRUNC_MAX_EXTENTS\t2\n\nint\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_root_inactive",
          "args": [
            "&trans",
            "dp"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_root_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
          "lines": "324-380",
          "snippet": "int\nxfs_attr3_root_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\tblkno;\n\tint\t\t\terror;\n\n\t/*\n\t * Read block 0 to see what we have to work with.\n\t * We only get here if we have extents, since we remove\n\t * the extents in reverse order the extent containing\n\t * block 0 must still be there.\n\t */\n\terror = xfs_da3_node_read(*trans, dp, 0, -1, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tblkno = bp->b_bn;\n\n\t/*\n\t * Invalidate the tree, even if the \"tree\" is only a single leaf block.\n\t * This is a depth-first traversal!\n\t */\n\tinfo = bp->b_addr;\n\tswitch (info->magic) {\n\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\terror = xfs_attr3_node_inactive(trans, dp, bp, 1);\n\t\tbreak;\n\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\terror = xfs_attr3_leaf_inactive(trans, dp, bp);\n\t\tbreak;\n\tdefault:\n\t\terror = -EIO;\n\t\txfs_trans_brelse(*trans, bp);\n\t\tbreak;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Invalidate the incore copy of the root block.\n\t */\n\terror = xfs_da_get_buf(*trans, dp, 0, blkno, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\txfs_trans_binval(*trans, bp);\t/* remove from cache */\n\t/*\n\t * Commit the invalidate and start the next transaction.\n\t */\n\terror = xfs_trans_roll(trans, dp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_root_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\tblkno;\n\tint\t\t\terror;\n\n\t/*\n\t * Read block 0 to see what we have to work with.\n\t * We only get here if we have extents, since we remove\n\t * the extents in reverse order the extent containing\n\t * block 0 must still be there.\n\t */\n\terror = xfs_da3_node_read(*trans, dp, 0, -1, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tblkno = bp->b_bn;\n\n\t/*\n\t * Invalidate the tree, even if the \"tree\" is only a single leaf block.\n\t * This is a depth-first traversal!\n\t */\n\tinfo = bp->b_addr;\n\tswitch (info->magic) {\n\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\terror = xfs_attr3_node_inactive(trans, dp, bp, 1);\n\t\tbreak;\n\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\terror = xfs_attr3_leaf_inactive(trans, dp, bp);\n\t\tbreak;\n\tdefault:\n\t\terror = -EIO;\n\t\txfs_trans_brelse(*trans, bp);\n\t\tbreak;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Invalidate the incore copy of the root block.\n\t */\n\terror = xfs_da_get_buf(*trans, dp, 0, blkno, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\txfs_trans_binval(*trans, bp);\t/* remove from cache */\n\t/*\n\t * Commit the invalidate and start the next transaction.\n\t */\n\terror = xfs_trans_roll(trans, dp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_hasattr",
          "args": [
            "dp"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_hasattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "101-110",
          "snippet": "int\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_inode_hasattr(\n\tstruct xfs_inode\t*ip)\n{\n\tif (!XFS_IFORK_Q(ip) ||\n\t    (ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     ip->i_d.di_anextents == 0))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "trans",
            "dp",
            "0"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "trans",
            "&M_RES(mp)->tr_attrinval",
            "0",
            "0"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_ATTRINVAL"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "! XFS_NOT_DQATTACHED(mp, dp)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_NOT_DQATTACHED",
          "args": [
            "mp",
            "dp"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_inactive(xfs_inode_t *dp)\n{\n\txfs_trans_t *trans;\n\txfs_mount_t *mp;\n\tint error;\n\n\tmp = dp->i_mount;\n\tASSERT(! XFS_NOT_DQATTACHED(mp, dp));\n\n\txfs_ilock(dp, XFS_ILOCK_SHARED);\n\tif (!xfs_inode_hasattr(dp) ||\n\t    dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\txfs_iunlock(dp, XFS_ILOCK_SHARED);\n\t\treturn 0;\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_SHARED);\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\ttrans = xfs_trans_alloc(mp, XFS_TRANS_ATTRINVAL);\n\terror = xfs_trans_reserve(trans, &M_RES(mp)->tr_attrinval, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks, not allocate, in the common case.\n\t */\n\txfs_trans_ijoin(trans, dp, 0);\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tif (!xfs_inode_hasattr(dp) ||\n\t    dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\terror = xfs_attr3_root_inactive(&trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_itruncate_extents(&trans, dp, XFS_ATTR_FORK, 0);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_trans_commit(trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\txfs_trans_cancel(trans, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr3_root_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
    "lines": "324-380",
    "snippet": "int\nxfs_attr3_root_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\tblkno;\n\tint\t\t\terror;\n\n\t/*\n\t * Read block 0 to see what we have to work with.\n\t * We only get here if we have extents, since we remove\n\t * the extents in reverse order the extent containing\n\t * block 0 must still be there.\n\t */\n\terror = xfs_da3_node_read(*trans, dp, 0, -1, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tblkno = bp->b_bn;\n\n\t/*\n\t * Invalidate the tree, even if the \"tree\" is only a single leaf block.\n\t * This is a depth-first traversal!\n\t */\n\tinfo = bp->b_addr;\n\tswitch (info->magic) {\n\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\terror = xfs_attr3_node_inactive(trans, dp, bp, 1);\n\t\tbreak;\n\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\terror = xfs_attr3_leaf_inactive(trans, dp, bp);\n\t\tbreak;\n\tdefault:\n\t\terror = -EIO;\n\t\txfs_trans_brelse(*trans, bp);\n\t\tbreak;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Invalidate the incore copy of the root block.\n\t */\n\terror = xfs_da_get_buf(*trans, dp, 0, blkno, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\txfs_trans_binval(*trans, bp);\t/* remove from cache */\n\t/*\n\t * Commit the invalidate and start the next transaction.\n\t */\n\terror = xfs_trans_roll(trans, dp);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "trans",
            "dp"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "*trans",
            "bp"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "*trans",
            "dp",
            "0",
            "blkno",
            "&bp",
            "XFS_ATTR_FORK"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "*trans",
            "bp"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_inactive",
          "args": [
            "trans",
            "dp",
            "bp"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
          "lines": "118-200",
          "snippet": "STATIC int\nxfs_attr3_leaf_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_attr_inactive_list *list;\n\tstruct xfs_attr_inactive_list *lp;\n\tint\t\t\terror;\n\tint\t\t\tcount;\n\tint\t\t\tsize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\t/*\n\t * Count the number of \"remote\" value extents.\n\t */\n\tcount = 0;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\t/*\n\t * If there are no \"remote\" values, we're done.\n\t */\n\tif (count == 0) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate storage for a list of all the \"remote\" value extents.\n\t */\n\tsize = count * sizeof(xfs_attr_inactive_list_t);\n\tlist = kmem_alloc(size, KM_SLEEP);\n\n\t/*\n\t * Identify each of the \"remote\" value extents.\n\t */\n\tlp = list;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk) {\n\t\t\t\tlp->valueblk = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\tlp->valuelen = xfs_attr3_rmt_blocks(dp->i_mount,\n\t\t\t\t\t\t    be32_to_cpu(name_rmt->valuelen));\n\t\t\t\tlp++;\n\t\t\t}\n\t\t}\n\t}\n\txfs_trans_brelse(*trans, bp);\t/* unlock for trans. in freextent() */\n\n\t/*\n\t * Invalidate each of the \"remote\" value extents.\n\t */\n\terror = 0;\n\tfor (lp = list, i = 0; i < count; i++, lp++) {\n\t\ttmp = xfs_attr3_leaf_freextent(trans, dp,\n\t\t\t\tlp->valueblk, lp->valuelen);\n\n\t\tif (error == 0)\n\t\t\terror = tmp;\t/* save only the 1st errno */\n\t}\n\n\tkmem_free(list);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_leaf_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_attr_inactive_list *list;\n\tstruct xfs_attr_inactive_list *lp;\n\tint\t\t\terror;\n\tint\t\t\tcount;\n\tint\t\t\tsize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\t/*\n\t * Count the number of \"remote\" value extents.\n\t */\n\tcount = 0;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\t/*\n\t * If there are no \"remote\" values, we're done.\n\t */\n\tif (count == 0) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate storage for a list of all the \"remote\" value extents.\n\t */\n\tsize = count * sizeof(xfs_attr_inactive_list_t);\n\tlist = kmem_alloc(size, KM_SLEEP);\n\n\t/*\n\t * Identify each of the \"remote\" value extents.\n\t */\n\tlp = list;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk) {\n\t\t\t\tlp->valueblk = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\tlp->valuelen = xfs_attr3_rmt_blocks(dp->i_mount,\n\t\t\t\t\t\t    be32_to_cpu(name_rmt->valuelen));\n\t\t\t\tlp++;\n\t\t\t}\n\t\t}\n\t}\n\txfs_trans_brelse(*trans, bp);\t/* unlock for trans. in freextent() */\n\n\t/*\n\t * Invalidate each of the \"remote\" value extents.\n\t */\n\terror = 0;\n\tfor (lp = list, i = 0; i < count; i++, lp++) {\n\t\ttmp = xfs_attr3_leaf_freextent(trans, dp,\n\t\t\t\tlp->valueblk, lp->valuelen);\n\n\t\tif (error == 0)\n\t\t\terror = tmp;\t/* save only the 1st errno */\n\t}\n\n\tkmem_free(list);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR3_LEAF_MAGIC"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_node_inactive",
          "args": [
            "trans",
            "dp",
            "bp",
            "1"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_node_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
          "lines": "206-316",
          "snippet": "STATIC int\nxfs_attr3_node_inactive(\n\tstruct xfs_trans **trans,\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\tint\t\tlevel)\n{\n\txfs_da_blkinfo_t *info;\n\txfs_da_intnode_t *node;\n\txfs_dablk_t child_fsb;\n\txfs_daddr_t parent_blkno, child_blkno;\n\tint error, i;\n\tstruct xfs_buf *child_bp;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\n\t/*\n\t * Since this code is recursive (gasp!) we must protect ourselves.\n\t */\n\tif (level > XFS_DA_NODE_MAXDEPTH) {\n\t\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\t\treturn -EIO;\n\t}\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&ichdr, node);\n\tparent_blkno = bp->b_bn;\n\tif (!ichdr.count) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\tbtree = dp->d_ops->node_tree_p(node);\n\tchild_fsb = be32_to_cpu(btree[0].before);\n\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\n\t/*\n\t * If this is the node level just above the leaves, simply loop\n\t * over the leaves removing all of them.  If this is higher up\n\t * in the tree, recurse downward.\n\t */\n\tfor (i = 0; i < ichdr.count; i++) {\n\t\t/*\n\t\t * Read the subsidiary block to see what we have to work with.\n\t\t * Don't do this in a transaction.  This is a depth-first\n\t\t * traversal of the tree so we may deal with many blocks\n\t\t * before we come back to this one.\n\t\t */\n\t\terror = xfs_da3_node_read(*trans, dp, child_fsb, -2, &child_bp,\n\t\t\t\t\t\tXFS_ATTR_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (child_bp) {\n\t\t\t\t\t\t/* save for re-read later */\n\t\t\tchild_blkno = XFS_BUF_ADDR(child_bp);\n\n\t\t\t/*\n\t\t\t * Invalidate the subtree, however we have to.\n\t\t\t */\n\t\t\tinfo = child_bp->b_addr;\n\t\t\tswitch (info->magic) {\n\t\t\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\t\t\terror = xfs_attr3_node_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp, level + 1);\n\t\t\t\tbreak;\n\t\t\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\t\t\terror = xfs_attr3_leaf_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = -EIO;\n\t\t\t\txfs_trans_brelse(*trans, child_bp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * Remove the subsidiary block from the cache\n\t\t\t * and from the log.\n\t\t\t */\n\t\t\terror = xfs_da_get_buf(*trans, dp, 0, child_blkno,\n\t\t\t\t&child_bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\txfs_trans_binval(*trans, child_bp);\n\t\t}\n\n\t\t/*\n\t\t * If we're not done, re-read the parent to get the next\n\t\t * child block number.\n\t\t */\n\t\tif (i + 1 < ichdr.count) {\n\t\t\terror = xfs_da3_node_read(*trans, dp, 0, parent_blkno,\n\t\t\t\t\t\t &bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tchild_fsb = be32_to_cpu(btree[i + 1].before);\n\t\t\txfs_trans_brelse(*trans, bp);\n\t\t}\n\t\t/*\n\t\t * Atomically commit the whole invalidate stuff.\n\t\t */\n\t\terror = xfs_trans_roll(trans, dp);\n\t\tif (error)\n\t\t\treturn  error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_node_inactive(\n\tstruct xfs_trans **trans,\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\tint\t\tlevel)\n{\n\txfs_da_blkinfo_t *info;\n\txfs_da_intnode_t *node;\n\txfs_dablk_t child_fsb;\n\txfs_daddr_t parent_blkno, child_blkno;\n\tint error, i;\n\tstruct xfs_buf *child_bp;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\n\t/*\n\t * Since this code is recursive (gasp!) we must protect ourselves.\n\t */\n\tif (level > XFS_DA_NODE_MAXDEPTH) {\n\t\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\t\treturn -EIO;\n\t}\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&ichdr, node);\n\tparent_blkno = bp->b_bn;\n\tif (!ichdr.count) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\tbtree = dp->d_ops->node_tree_p(node);\n\tchild_fsb = be32_to_cpu(btree[0].before);\n\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\n\t/*\n\t * If this is the node level just above the leaves, simply loop\n\t * over the leaves removing all of them.  If this is higher up\n\t * in the tree, recurse downward.\n\t */\n\tfor (i = 0; i < ichdr.count; i++) {\n\t\t/*\n\t\t * Read the subsidiary block to see what we have to work with.\n\t\t * Don't do this in a transaction.  This is a depth-first\n\t\t * traversal of the tree so we may deal with many blocks\n\t\t * before we come back to this one.\n\t\t */\n\t\terror = xfs_da3_node_read(*trans, dp, child_fsb, -2, &child_bp,\n\t\t\t\t\t\tXFS_ATTR_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (child_bp) {\n\t\t\t\t\t\t/* save for re-read later */\n\t\t\tchild_blkno = XFS_BUF_ADDR(child_bp);\n\n\t\t\t/*\n\t\t\t * Invalidate the subtree, however we have to.\n\t\t\t */\n\t\t\tinfo = child_bp->b_addr;\n\t\t\tswitch (info->magic) {\n\t\t\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\t\t\terror = xfs_attr3_node_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp, level + 1);\n\t\t\t\tbreak;\n\t\t\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\t\t\terror = xfs_attr3_leaf_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = -EIO;\n\t\t\t\txfs_trans_brelse(*trans, child_bp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * Remove the subsidiary block from the cache\n\t\t\t * and from the log.\n\t\t\t */\n\t\t\terror = xfs_da_get_buf(*trans, dp, 0, child_blkno,\n\t\t\t\t&child_bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\txfs_trans_binval(*trans, child_bp);\n\t\t}\n\n\t\t/*\n\t\t * If we're not done, re-read the parent to get the next\n\t\t * child block number.\n\t\t */\n\t\tif (i + 1 < ichdr.count) {\n\t\t\terror = xfs_da3_node_read(*trans, dp, 0, parent_blkno,\n\t\t\t\t\t\t &bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tchild_fsb = be32_to_cpu(btree[i + 1].before);\n\t\t\txfs_trans_brelse(*trans, bp);\n\t\t}\n\t\t/*\n\t\t * Atomically commit the whole invalidate stuff.\n\t\t */\n\t\terror = xfs_trans_roll(trans, dp);\n\t\tif (error)\n\t\t\treturn  error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA3_NODE_MAGIC"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA_NODE_MAGIC"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "*trans",
            "dp",
            "0",
            "-1",
            "&bp",
            "XFS_ATTR_FORK"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_root_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\tblkno;\n\tint\t\t\terror;\n\n\t/*\n\t * Read block 0 to see what we have to work with.\n\t * We only get here if we have extents, since we remove\n\t * the extents in reverse order the extent containing\n\t * block 0 must still be there.\n\t */\n\terror = xfs_da3_node_read(*trans, dp, 0, -1, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tblkno = bp->b_bn;\n\n\t/*\n\t * Invalidate the tree, even if the \"tree\" is only a single leaf block.\n\t * This is a depth-first traversal!\n\t */\n\tinfo = bp->b_addr;\n\tswitch (info->magic) {\n\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\terror = xfs_attr3_node_inactive(trans, dp, bp, 1);\n\t\tbreak;\n\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\terror = xfs_attr3_leaf_inactive(trans, dp, bp);\n\t\tbreak;\n\tdefault:\n\t\terror = -EIO;\n\t\txfs_trans_brelse(*trans, bp);\n\t\tbreak;\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Invalidate the incore copy of the root block.\n\t */\n\terror = xfs_da_get_buf(*trans, dp, 0, blkno, &bp, XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\txfs_trans_binval(*trans, bp);\t/* remove from cache */\n\t/*\n\t * Commit the invalidate and start the next transaction.\n\t */\n\terror = xfs_trans_roll(trans, dp);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr3_node_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
    "lines": "206-316",
    "snippet": "STATIC int\nxfs_attr3_node_inactive(\n\tstruct xfs_trans **trans,\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\tint\t\tlevel)\n{\n\txfs_da_blkinfo_t *info;\n\txfs_da_intnode_t *node;\n\txfs_dablk_t child_fsb;\n\txfs_daddr_t parent_blkno, child_blkno;\n\tint error, i;\n\tstruct xfs_buf *child_bp;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\n\t/*\n\t * Since this code is recursive (gasp!) we must protect ourselves.\n\t */\n\tif (level > XFS_DA_NODE_MAXDEPTH) {\n\t\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\t\treturn -EIO;\n\t}\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&ichdr, node);\n\tparent_blkno = bp->b_bn;\n\tif (!ichdr.count) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\tbtree = dp->d_ops->node_tree_p(node);\n\tchild_fsb = be32_to_cpu(btree[0].before);\n\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\n\t/*\n\t * If this is the node level just above the leaves, simply loop\n\t * over the leaves removing all of them.  If this is higher up\n\t * in the tree, recurse downward.\n\t */\n\tfor (i = 0; i < ichdr.count; i++) {\n\t\t/*\n\t\t * Read the subsidiary block to see what we have to work with.\n\t\t * Don't do this in a transaction.  This is a depth-first\n\t\t * traversal of the tree so we may deal with many blocks\n\t\t * before we come back to this one.\n\t\t */\n\t\terror = xfs_da3_node_read(*trans, dp, child_fsb, -2, &child_bp,\n\t\t\t\t\t\tXFS_ATTR_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (child_bp) {\n\t\t\t\t\t\t/* save for re-read later */\n\t\t\tchild_blkno = XFS_BUF_ADDR(child_bp);\n\n\t\t\t/*\n\t\t\t * Invalidate the subtree, however we have to.\n\t\t\t */\n\t\t\tinfo = child_bp->b_addr;\n\t\t\tswitch (info->magic) {\n\t\t\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\t\t\terror = xfs_attr3_node_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp, level + 1);\n\t\t\t\tbreak;\n\t\t\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\t\t\terror = xfs_attr3_leaf_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = -EIO;\n\t\t\t\txfs_trans_brelse(*trans, child_bp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * Remove the subsidiary block from the cache\n\t\t\t * and from the log.\n\t\t\t */\n\t\t\terror = xfs_da_get_buf(*trans, dp, 0, child_blkno,\n\t\t\t\t&child_bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\txfs_trans_binval(*trans, child_bp);\n\t\t}\n\n\t\t/*\n\t\t * If we're not done, re-read the parent to get the next\n\t\t * child block number.\n\t\t */\n\t\tif (i + 1 < ichdr.count) {\n\t\t\terror = xfs_da3_node_read(*trans, dp, 0, parent_blkno,\n\t\t\t\t\t\t &bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tchild_fsb = be32_to_cpu(btree[i + 1].before);\n\t\t\txfs_trans_brelse(*trans, bp);\n\t\t}\n\t\t/*\n\t\t * Atomically commit the whole invalidate stuff.\n\t\t */\n\t\terror = xfs_trans_roll(trans, dp);\n\t\tif (error)\n\t\t\treturn  error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "trans",
            "dp"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "*trans",
            "bp"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[i + 1].before"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_read",
          "args": [
            "*trans",
            "dp",
            "0",
            "parent_blkno",
            "&bp",
            "XFS_ATTR_FORK"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "248-286",
          "snippet": "int\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_da3_node_buf_ops = {\n\t.verify_read = xfs_da3_node_read_verify,\n\t.verify_write = xfs_da3_node_write_verify,\n};\n\nint\nxfs_da3_node_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhich_fork)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\t\twhich_fork, &xfs_da3_node_buf_ops);\n\tif (!err && tp) {\n\t\tstruct xfs_da_blkinfo\t*info = (*bpp)->b_addr;\n\t\tint\t\t\ttype;\n\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\ttype = XFS_BLFT_DA_NODE_BUF;\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\ttype = XFS_BLFT_ATTR_LEAF_BUF;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\ttype = XFS_BLFT_DIR_LEAFN_BUF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = 0;\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_trans_buf_set_type(tp, *bpp, type);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "*trans",
            "child_bp"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "*trans",
            "dp",
            "0",
            "child_blkno",
            "&child_bp",
            "XFS_ATTR_FORK"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_inactive",
          "args": [
            "trans",
            "dp",
            "child_bp"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
          "lines": "118-200",
          "snippet": "STATIC int\nxfs_attr3_leaf_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_attr_inactive_list *list;\n\tstruct xfs_attr_inactive_list *lp;\n\tint\t\t\terror;\n\tint\t\t\tcount;\n\tint\t\t\tsize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\t/*\n\t * Count the number of \"remote\" value extents.\n\t */\n\tcount = 0;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\t/*\n\t * If there are no \"remote\" values, we're done.\n\t */\n\tif (count == 0) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate storage for a list of all the \"remote\" value extents.\n\t */\n\tsize = count * sizeof(xfs_attr_inactive_list_t);\n\tlist = kmem_alloc(size, KM_SLEEP);\n\n\t/*\n\t * Identify each of the \"remote\" value extents.\n\t */\n\tlp = list;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk) {\n\t\t\t\tlp->valueblk = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\tlp->valuelen = xfs_attr3_rmt_blocks(dp->i_mount,\n\t\t\t\t\t\t    be32_to_cpu(name_rmt->valuelen));\n\t\t\t\tlp++;\n\t\t\t}\n\t\t}\n\t}\n\txfs_trans_brelse(*trans, bp);\t/* unlock for trans. in freextent() */\n\n\t/*\n\t * Invalidate each of the \"remote\" value extents.\n\t */\n\terror = 0;\n\tfor (lp = list, i = 0; i < count; i++, lp++) {\n\t\ttmp = xfs_attr3_leaf_freextent(trans, dp,\n\t\t\t\tlp->valueblk, lp->valuelen);\n\n\t\tif (error == 0)\n\t\t\terror = tmp;\t/* save only the 1st errno */\n\t}\n\n\tkmem_free(list);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_leaf_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_attr_inactive_list *list;\n\tstruct xfs_attr_inactive_list *lp;\n\tint\t\t\terror;\n\tint\t\t\tcount;\n\tint\t\t\tsize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\t/*\n\t * Count the number of \"remote\" value extents.\n\t */\n\tcount = 0;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\t/*\n\t * If there are no \"remote\" values, we're done.\n\t */\n\tif (count == 0) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate storage for a list of all the \"remote\" value extents.\n\t */\n\tsize = count * sizeof(xfs_attr_inactive_list_t);\n\tlist = kmem_alloc(size, KM_SLEEP);\n\n\t/*\n\t * Identify each of the \"remote\" value extents.\n\t */\n\tlp = list;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk) {\n\t\t\t\tlp->valueblk = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\tlp->valuelen = xfs_attr3_rmt_blocks(dp->i_mount,\n\t\t\t\t\t\t    be32_to_cpu(name_rmt->valuelen));\n\t\t\t\tlp++;\n\t\t\t}\n\t\t}\n\t}\n\txfs_trans_brelse(*trans, bp);\t/* unlock for trans. in freextent() */\n\n\t/*\n\t * Invalidate each of the \"remote\" value extents.\n\t */\n\terror = 0;\n\tfor (lp = list, i = 0; i < count; i++, lp++) {\n\t\ttmp = xfs_attr3_leaf_freextent(trans, dp,\n\t\t\t\tlp->valueblk, lp->valuelen);\n\n\t\tif (error == 0)\n\t\t\terror = tmp;\t/* save only the 1st errno */\n\t}\n\n\tkmem_free(list);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR3_LEAF_MAGIC"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_ATTR_LEAF_MAGIC"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_node_inactive",
          "args": [
            "trans",
            "dp",
            "child_bp",
            "level + 1"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_node_inactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
          "lines": "206-316",
          "snippet": "STATIC int\nxfs_attr3_node_inactive(\n\tstruct xfs_trans **trans,\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\tint\t\tlevel)\n{\n\txfs_da_blkinfo_t *info;\n\txfs_da_intnode_t *node;\n\txfs_dablk_t child_fsb;\n\txfs_daddr_t parent_blkno, child_blkno;\n\tint error, i;\n\tstruct xfs_buf *child_bp;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\n\t/*\n\t * Since this code is recursive (gasp!) we must protect ourselves.\n\t */\n\tif (level > XFS_DA_NODE_MAXDEPTH) {\n\t\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\t\treturn -EIO;\n\t}\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&ichdr, node);\n\tparent_blkno = bp->b_bn;\n\tif (!ichdr.count) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\tbtree = dp->d_ops->node_tree_p(node);\n\tchild_fsb = be32_to_cpu(btree[0].before);\n\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\n\t/*\n\t * If this is the node level just above the leaves, simply loop\n\t * over the leaves removing all of them.  If this is higher up\n\t * in the tree, recurse downward.\n\t */\n\tfor (i = 0; i < ichdr.count; i++) {\n\t\t/*\n\t\t * Read the subsidiary block to see what we have to work with.\n\t\t * Don't do this in a transaction.  This is a depth-first\n\t\t * traversal of the tree so we may deal with many blocks\n\t\t * before we come back to this one.\n\t\t */\n\t\terror = xfs_da3_node_read(*trans, dp, child_fsb, -2, &child_bp,\n\t\t\t\t\t\tXFS_ATTR_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (child_bp) {\n\t\t\t\t\t\t/* save for re-read later */\n\t\t\tchild_blkno = XFS_BUF_ADDR(child_bp);\n\n\t\t\t/*\n\t\t\t * Invalidate the subtree, however we have to.\n\t\t\t */\n\t\t\tinfo = child_bp->b_addr;\n\t\t\tswitch (info->magic) {\n\t\t\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\t\t\terror = xfs_attr3_node_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp, level + 1);\n\t\t\t\tbreak;\n\t\t\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\t\t\terror = xfs_attr3_leaf_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = -EIO;\n\t\t\t\txfs_trans_brelse(*trans, child_bp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * Remove the subsidiary block from the cache\n\t\t\t * and from the log.\n\t\t\t */\n\t\t\terror = xfs_da_get_buf(*trans, dp, 0, child_blkno,\n\t\t\t\t&child_bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\txfs_trans_binval(*trans, child_bp);\n\t\t}\n\n\t\t/*\n\t\t * If we're not done, re-read the parent to get the next\n\t\t * child block number.\n\t\t */\n\t\tif (i + 1 < ichdr.count) {\n\t\t\terror = xfs_da3_node_read(*trans, dp, 0, parent_blkno,\n\t\t\t\t\t\t &bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tchild_fsb = be32_to_cpu(btree[i + 1].before);\n\t\t\txfs_trans_brelse(*trans, bp);\n\t\t}\n\t\t/*\n\t\t * Atomically commit the whole invalidate stuff.\n\t\t */\n\t\terror = xfs_trans_roll(trans, dp);\n\t\tif (error)\n\t\t\treturn  error;\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA3_NODE_MAGIC"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DA_NODE_MAGIC"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "child_bp"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btree[0].before"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_tree_p",
          "args": [
            "node"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->node_hdr_from_disk",
          "args": [
            "&ichdr",
            "node"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_node_inactive(\n\tstruct xfs_trans **trans,\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\tint\t\tlevel)\n{\n\txfs_da_blkinfo_t *info;\n\txfs_da_intnode_t *node;\n\txfs_dablk_t child_fsb;\n\txfs_daddr_t parent_blkno, child_blkno;\n\tint error, i;\n\tstruct xfs_buf *child_bp;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr ichdr;\n\n\t/*\n\t * Since this code is recursive (gasp!) we must protect ourselves.\n\t */\n\tif (level > XFS_DA_NODE_MAXDEPTH) {\n\t\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\t\treturn -EIO;\n\t}\n\n\tnode = bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&ichdr, node);\n\tparent_blkno = bp->b_bn;\n\tif (!ichdr.count) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\tbtree = dp->d_ops->node_tree_p(node);\n\tchild_fsb = be32_to_cpu(btree[0].before);\n\txfs_trans_brelse(*trans, bp);\t/* no locks for later trans */\n\n\t/*\n\t * If this is the node level just above the leaves, simply loop\n\t * over the leaves removing all of them.  If this is higher up\n\t * in the tree, recurse downward.\n\t */\n\tfor (i = 0; i < ichdr.count; i++) {\n\t\t/*\n\t\t * Read the subsidiary block to see what we have to work with.\n\t\t * Don't do this in a transaction.  This is a depth-first\n\t\t * traversal of the tree so we may deal with many blocks\n\t\t * before we come back to this one.\n\t\t */\n\t\terror = xfs_da3_node_read(*trans, dp, child_fsb, -2, &child_bp,\n\t\t\t\t\t\tXFS_ATTR_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (child_bp) {\n\t\t\t\t\t\t/* save for re-read later */\n\t\t\tchild_blkno = XFS_BUF_ADDR(child_bp);\n\n\t\t\t/*\n\t\t\t * Invalidate the subtree, however we have to.\n\t\t\t */\n\t\t\tinfo = child_bp->b_addr;\n\t\t\tswitch (info->magic) {\n\t\t\tcase cpu_to_be16(XFS_DA_NODE_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_DA3_NODE_MAGIC):\n\t\t\t\terror = xfs_attr3_node_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp, level + 1);\n\t\t\t\tbreak;\n\t\t\tcase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\n\t\t\tcase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\n\t\t\t\terror = xfs_attr3_leaf_inactive(trans, dp,\n\t\t\t\t\t\t\tchild_bp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = -EIO;\n\t\t\t\txfs_trans_brelse(*trans, child_bp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * Remove the subsidiary block from the cache\n\t\t\t * and from the log.\n\t\t\t */\n\t\t\terror = xfs_da_get_buf(*trans, dp, 0, child_blkno,\n\t\t\t\t&child_bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\txfs_trans_binval(*trans, child_bp);\n\t\t}\n\n\t\t/*\n\t\t * If we're not done, re-read the parent to get the next\n\t\t * child block number.\n\t\t */\n\t\tif (i + 1 < ichdr.count) {\n\t\t\terror = xfs_da3_node_read(*trans, dp, 0, parent_blkno,\n\t\t\t\t\t\t &bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tchild_fsb = be32_to_cpu(btree[i + 1].before);\n\t\t\txfs_trans_brelse(*trans, bp);\n\t\t}\n\t\t/*\n\t\t * Atomically commit the whole invalidate stuff.\n\t\t */\n\t\terror = xfs_trans_roll(trans, dp);\n\t\tif (error)\n\t\t\treturn  error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_inactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
    "lines": "118-200",
    "snippet": "STATIC int\nxfs_attr3_leaf_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_attr_inactive_list *list;\n\tstruct xfs_attr_inactive_list *lp;\n\tint\t\t\terror;\n\tint\t\t\tcount;\n\tint\t\t\tsize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\t/*\n\t * Count the number of \"remote\" value extents.\n\t */\n\tcount = 0;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\t/*\n\t * If there are no \"remote\" values, we're done.\n\t */\n\tif (count == 0) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate storage for a list of all the \"remote\" value extents.\n\t */\n\tsize = count * sizeof(xfs_attr_inactive_list_t);\n\tlist = kmem_alloc(size, KM_SLEEP);\n\n\t/*\n\t * Identify each of the \"remote\" value extents.\n\t */\n\tlp = list;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk) {\n\t\t\t\tlp->valueblk = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\tlp->valuelen = xfs_attr3_rmt_blocks(dp->i_mount,\n\t\t\t\t\t\t    be32_to_cpu(name_rmt->valuelen));\n\t\t\t\tlp++;\n\t\t\t}\n\t\t}\n\t}\n\txfs_trans_brelse(*trans, bp);\t/* unlock for trans. in freextent() */\n\n\t/*\n\t * Invalidate each of the \"remote\" value extents.\n\t */\n\terror = 0;\n\tfor (lp = list, i = 0; i < count; i++, lp++) {\n\t\ttmp = xfs_attr3_leaf_freextent(trans, dp,\n\t\t\t\tlp->valueblk, lp->valuelen);\n\n\t\tif (error == 0)\n\t\t\terror = tmp;\t/* save only the 1st errno */\n\t}\n\n\tkmem_free(list);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "list"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_freextent",
          "args": [
            "trans",
            "dp",
            "lp->valueblk",
            "lp->valuelen"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_freextent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
          "lines": "46-110",
          "snippet": "STATIC int\nxfs_attr3_leaf_freextent(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tblkcnt)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\ttblkno;\n\txfs_daddr_t\t\tdblkno;\n\tint\t\t\ttblkcnt;\n\tint\t\t\tdblkcnt;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's\n\t * blocks.\n\t */\n\ttblkno = blkno;\n\ttblkcnt = blkcnt;\n\twhile (tblkcnt > 0) {\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)tblkno, tblkcnt,\n\t\t\t\t       &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(nmap == 1);\n\t\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\n\t\t/*\n\t\t * If it's a hole, these are already unmapped\n\t\t * so there's nothing to invalidate.\n\t\t */\n\t\tif (map.br_startblock != HOLESTARTBLOCK) {\n\n\t\t\tdblkno = XFS_FSB_TO_DADDR(dp->i_mount,\n\t\t\t\t\t\t  map.br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(dp->i_mount,\n\t\t\t\t\t\tmap.br_blockcount);\n\t\t\tbp = xfs_trans_get_buf(*trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tdblkno, dblkcnt, 0);\n\t\t\tif (!bp)\n\t\t\t\treturn -ENOMEM;\n\t\t\txfs_trans_binval(*trans, bp);\n\t\t\t/*\n\t\t\t * Roll to next transaction.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(trans, dp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\ttblkno += map.br_blockcount;\n\t\ttblkcnt -= map.br_blockcount;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_leaf_freextent(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tblkcnt)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\ttblkno;\n\txfs_daddr_t\t\tdblkno;\n\tint\t\t\ttblkcnt;\n\tint\t\t\tdblkcnt;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's\n\t * blocks.\n\t */\n\ttblkno = blkno;\n\ttblkcnt = blkcnt;\n\twhile (tblkcnt > 0) {\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)tblkno, tblkcnt,\n\t\t\t\t       &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(nmap == 1);\n\t\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\n\t\t/*\n\t\t * If it's a hole, these are already unmapped\n\t\t * so there's nothing to invalidate.\n\t\t */\n\t\tif (map.br_startblock != HOLESTARTBLOCK) {\n\n\t\t\tdblkno = XFS_FSB_TO_DADDR(dp->i_mount,\n\t\t\t\t\t\t  map.br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(dp->i_mount,\n\t\t\t\t\t\tmap.br_blockcount);\n\t\t\tbp = xfs_trans_get_buf(*trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tdblkno, dblkcnt, 0);\n\t\t\tif (!bp)\n\t\t\t\treturn -ENOMEM;\n\t\t\txfs_trans_binval(*trans, bp);\n\t\t\t/*\n\t\t\t * Roll to next transaction.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(trans, dp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\ttblkno += map.br_blockcount;\n\t\ttblkcnt -= map.br_blockcount;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "*trans",
            "bp"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_blocks",
          "args": [
            "dp->i_mount",
            "be32_to_cpu(name_rmt->valuelen)"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "50-60",
          "snippet": "int\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "name_rmt->valuelen"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "name_rmt->valueblk"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_name_remote",
          "args": [
            "leaf",
            "i"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_name_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "796-800",
          "snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_attr_leaf_name_remote_t *\nxfs_attr3_leaf_name_remote(xfs_attr_leafblock_t *leafp, int idx)\n{\n\treturn (xfs_attr_leaf_name_remote_t *)xfs_attr3_leaf_name(leafp, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_entryp",
          "args": [
            "leaf"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_entryp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "777-783",
          "snippet": "static inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_ATTR3_LEAF_MAGIC\t0x3bee\t/* magic number: attribute leaf blks */\n\nstatic inline struct xfs_attr_leaf_entry *\nxfs_attr3_leaf_entryp(xfs_attr_leafblock_t *leafp)\n{\n\tif (leafp->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC))\n\t\treturn &((struct xfs_attr3_leafblock *)leafp)->entries[0];\n\treturn &leafp->entries[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "size",
            "KM_SLEEP"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->nameidx"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_leaf_hdr_from_disk",
          "args": [
            "&ichdr",
            "leaf"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_leaf_hdr_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "89-128",
          "snippet": "void\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_leaf_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_attr_inactive_list *list;\n\tstruct xfs_attr_inactive_list *lp;\n\tint\t\t\terror;\n\tint\t\t\tcount;\n\tint\t\t\tsize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\t/*\n\t * Count the number of \"remote\" value extents.\n\t */\n\tcount = 0;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\t/*\n\t * If there are no \"remote\" values, we're done.\n\t */\n\tif (count == 0) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate storage for a list of all the \"remote\" value extents.\n\t */\n\tsize = count * sizeof(xfs_attr_inactive_list_t);\n\tlist = kmem_alloc(size, KM_SLEEP);\n\n\t/*\n\t * Identify each of the \"remote\" value extents.\n\t */\n\tlp = list;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk) {\n\t\t\t\tlp->valueblk = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\tlp->valuelen = xfs_attr3_rmt_blocks(dp->i_mount,\n\t\t\t\t\t\t    be32_to_cpu(name_rmt->valuelen));\n\t\t\t\tlp++;\n\t\t\t}\n\t\t}\n\t}\n\txfs_trans_brelse(*trans, bp);\t/* unlock for trans. in freextent() */\n\n\t/*\n\t * Invalidate each of the \"remote\" value extents.\n\t */\n\terror = 0;\n\tfor (lp = list, i = 0; i < count; i++, lp++) {\n\t\ttmp = xfs_attr3_leaf_freextent(trans, dp,\n\t\t\t\tlp->valueblk, lp->valuelen);\n\n\t\tif (error == 0)\n\t\t\terror = tmp;\t/* save only the 1st errno */\n\t}\n\n\tkmem_free(list);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_attr3_leaf_freextent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_inactive.c",
    "lines": "46-110",
    "snippet": "STATIC int\nxfs_attr3_leaf_freextent(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tblkcnt)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\ttblkno;\n\txfs_daddr_t\t\tdblkno;\n\tint\t\t\ttblkcnt;\n\tint\t\t\tdblkcnt;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's\n\t * blocks.\n\t */\n\ttblkno = blkno;\n\ttblkcnt = blkcnt;\n\twhile (tblkcnt > 0) {\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)tblkno, tblkcnt,\n\t\t\t\t       &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(nmap == 1);\n\t\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\n\t\t/*\n\t\t * If it's a hole, these are already unmapped\n\t\t * so there's nothing to invalidate.\n\t\t */\n\t\tif (map.br_startblock != HOLESTARTBLOCK) {\n\n\t\t\tdblkno = XFS_FSB_TO_DADDR(dp->i_mount,\n\t\t\t\t\t\t  map.br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(dp->i_mount,\n\t\t\t\t\t\tmap.br_blockcount);\n\t\t\tbp = xfs_trans_get_buf(*trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tdblkno, dblkcnt, 0);\n\t\t\tif (!bp)\n\t\t\t\treturn -ENOMEM;\n\t\t\txfs_trans_binval(*trans, bp);\n\t\t\t/*\n\t\t\t * Roll to next transaction.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(trans, dp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\ttblkno += map.br_blockcount;\n\t\ttblkcnt -= map.br_blockcount;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "trans",
            "dp"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "*trans",
            "bp"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "*trans",
            "dp->i_mount->m_ddev_targp",
            "dblkno",
            "dblkcnt",
            "0"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "dp->i_mount",
            "map.br_blockcount"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "dp->i_mount",
            "map.br_startblock"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "map.br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmap == 1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "dp",
            "(xfs_fileoff_t)tblkno",
            "tblkcnt",
            "&map",
            "&nmap",
            "XFS_BMAPI_ATTRFORK"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_leaf_freextent(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tblkno,\n\tint\t\t\tblkcnt)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\ttblkno;\n\txfs_daddr_t\t\tdblkno;\n\tint\t\t\ttblkcnt;\n\tint\t\t\tdblkcnt;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's\n\t * blocks.\n\t */\n\ttblkno = blkno;\n\ttblkcnt = blkcnt;\n\twhile (tblkcnt > 0) {\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)tblkno, tblkcnt,\n\t\t\t\t       &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tASSERT(nmap == 1);\n\t\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\n\t\t/*\n\t\t * If it's a hole, these are already unmapped\n\t\t * so there's nothing to invalidate.\n\t\t */\n\t\tif (map.br_startblock != HOLESTARTBLOCK) {\n\n\t\t\tdblkno = XFS_FSB_TO_DADDR(dp->i_mount,\n\t\t\t\t\t\t  map.br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(dp->i_mount,\n\t\t\t\t\t\tmap.br_blockcount);\n\t\t\tbp = xfs_trans_get_buf(*trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tdblkno, dblkcnt, 0);\n\t\t\tif (!bp)\n\t\t\t\treturn -ENOMEM;\n\t\t\txfs_trans_binval(*trans, bp);\n\t\t\t/*\n\t\t\t * Roll to next transaction.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(trans, dp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\t\ttblkno += map.br_blockcount;\n\t\ttblkcnt -= map.br_blockcount;\n\t}\n\n\treturn 0;\n}"
  }
]