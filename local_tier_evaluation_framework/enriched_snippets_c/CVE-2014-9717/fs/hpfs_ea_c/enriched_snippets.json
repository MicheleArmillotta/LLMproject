[
  {
    "function_name": "hpfs_set_ea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
    "lines": "189-366",
    "snippet": "void hpfs_set_ea(struct inode *inode, struct fnode *fnode, const char *key,\n\t\t const char *data, int size)\n{\n\tfnode_secno fno = inode->i_ino;\n\tstruct super_block *s = inode->i_sb;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tunsigned char h[4];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t} else if (ea_valuelen(ea) == size) {\n\t\t\t\tmemcpy(ea_data(ea), data, size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ea_valuelen(ea) == size)\n\t\t\t\t\thpfs_ea_write(s, a, ano, pos + 4 + ea->namelen + 1, size, data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!le16_to_cpu(fnode->ea_offs)) {\n\t\t/*if (le16_to_cpu(fnode->ea_size_s)) {\n\t\t\thpfs_error(s, \"fnode %08x: ea_size_s == %03x, ea_offs == 0\",\n\t\t\t\tinode->i_ino, le16_to_cpu(fnode->ea_size_s));\n\t\t\treturn;\n\t\t}*/\n\t\tfnode->ea_offs = cpu_to_le16(0xc4);\n\t}\n\tif (le16_to_cpu(fnode->ea_offs) < 0xc4 || le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200) {\n\t\thpfs_error(s, \"fnode %08lx: ea_offs == %03x, ea_size_s == %03x\",\n\t\t\t(unsigned long)inode->i_ino,\n\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\treturn;\n\t}\n\tif ((le16_to_cpu(fnode->ea_size_s) || !le32_to_cpu(fnode->ea_size_l)) &&\n\t     le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5 <= 0x200) {\n\t\tea = fnode_end_ea(fnode);\n\t\t*(char *)ea = 0;\n\t\tea->namelen = strlen(key);\n\t\tea->valuelen_lo = size;\n\t\tea->valuelen_hi = size >> 8;\n\t\tstrcpy(ea->name, key);\n\t\tmemcpy(ea_data(ea), data, size);\n\t\tfnode->ea_size_s = cpu_to_le16(le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5);\n\t\tgoto ret;\n\t}\n\t/* Most the code here is 99.9993422% unused. I hope there are no bugs.\n\t   But what .. HPFS.IFS has also bugs in ea management. */\n\tif (le16_to_cpu(fnode->ea_size_s) && !le32_to_cpu(fnode->ea_size_l)) {\n\t\tsecno n;\n\t\tstruct buffer_head *bh;\n\t\tchar *data;\n\t\tif (!(n = hpfs_alloc_sector(s, fno, 1, 0))) return;\n\t\tif (!(data = hpfs_get_sector(s, n, &bh))) {\n\t\t\thpfs_free_sectors(s, n, 1);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data, fnode_ea(fnode), le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_l = cpu_to_le32(le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_s = cpu_to_le16(0);\n\t\tfnode->ea_secno = cpu_to_le32(n);\n\t\tfnode->flags &= ~FNODE_anode;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tpos = le32_to_cpu(fnode->ea_size_l) + 5 + strlen(key) + size;\n\tlen = (le32_to_cpu(fnode->ea_size_l) + 511) >> 9;\n\tif (pos >= 30000) goto bail;\n\twhile (((pos + 511) >> 9) > len) {\n\t\tif (!len) {\n\t\t\tsecno q = hpfs_alloc_sector(s, fno, 1, 0);\n\t\t\tif (!q) goto bail;\n\t\t\tfnode->ea_secno = cpu_to_le32(q);\n\t\t\tfnode->flags &= ~FNODE_anode;\n\t\t\tlen++;\n\t\t} else if (!fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_alloc_if_possible(s, le32_to_cpu(fnode->ea_secno) + len)) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\t/* Aargh... don't know how to create ea anodes :-( */\n\t\t\t\t/*struct buffer_head *bh;\n\t\t\t\tstruct anode *anode;\n\t\t\t\tanode_secno a_s;\n\t\t\t\tif (!(anode = hpfs_alloc_anode(s, fno, &a_s, &bh)))\n\t\t\t\t\tgoto bail;\n\t\t\t\tanode->up = cpu_to_le32(fno);\n\t\t\t\tanode->btree.fnode_parent = 1;\n\t\t\t\tanode->btree.n_free_nodes--;\n\t\t\t\tanode->btree.n_used_nodes++;\n\t\t\t\tanode->btree.first_free = cpu_to_le16(le16_to_cpu(anode->btree.first_free) + 12);\n\t\t\t\tanode->u.external[0].disk_secno = cpu_to_le32(le32_to_cpu(fnode->ea_secno));\n\t\t\t\tanode->u.external[0].file_secno = cpu_to_le32(0);\n\t\t\t\tanode->u.external[0].length = cpu_to_le32(len);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tfnode->flags |= FNODE_anode;\n\t\t\t\tfnode->ea_secno = cpu_to_le32(a_s);*/\n\t\t\t\tsecno new_sec;\n\t\t\t\tint i;\n\t\t\t\tif (!(new_sec = hpfs_alloc_sector(s, fno, 1, 1 - ((pos + 511) >> 9))))\n\t\t\t\t\tgoto bail;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstruct buffer_head *bh1, *bh2;\n\t\t\t\t\tvoid *b1, *b2;\n\t\t\t\t\tif (!(b1 = hpfs_map_sector(s, le32_to_cpu(fnode->ea_secno) + i, &bh1, len - i - 1))) {\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(b2 = hpfs_get_sector(s, new_sec + i, &bh2))) {\n\t\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(b2, b1, 512);\n\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\tmark_buffer_dirty(bh2);\n\t\t\t\t\tbrelse(bh2);\n\t\t\t\t}\n\t\t\t\thpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno), len);\n\t\t\t\tfnode->ea_secno = cpu_to_le32(new_sec);\n\t\t\t\tlen = (pos + 511) >> 9;\n\t\t\t}\n\t\t}\n\t\tif (fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_add_sector_to_btree(s, le32_to_cpu(fnode->ea_secno),\n\t\t\t\t\t\t     0, len) != -1) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\th[0] = 0;\n\th[1] = strlen(key);\n\th[2] = size & 0xff;\n\th[3] = size >> 8;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l), 4, h)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 4, h[1] + 1, key)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 5 + h[1], size, data)) goto bail;\n\tfnode->ea_size_l = cpu_to_le32(pos);\n\tret:\n\thpfs_i(inode)->i_ea_size += 5 + strlen(key) + size;\n\treturn;\n\tbail:\n\tif (le32_to_cpu(fnode->ea_secno))\n\t\tif (fnode_in_anode(fnode)) hpfs_truncate_btree(s, le32_to_cpu(fnode->ea_secno), 1, (le32_to_cpu(fnode->ea_size_l) + 511) >> 9);\n\t\telse hpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9), len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9));\n\telse fnode->ea_secno = fnode->ea_size_l = cpu_to_le32(0);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9)",
            "len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fnode->ea_size_l"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_truncate_btree",
          "args": [
            "s",
            "le32_to_cpu(fnode->ea_secno)",
            "1",
            "(le32_to_cpu(fnode->ea_size_l) + 511) >> 9"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_truncate_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "398-475",
          "snippet": "void hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno)); /* I hope gcc optimizes this :-) */\n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno)); /* I hope gcc optimizes this :-) */\n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_in_anode",
          "args": [
            "fnode"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "475-478",
          "snippet": "static inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "pos"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_ea_write",
          "args": [
            "s",
            "le32_to_cpu(fnode->ea_secno)",
            "fnode_in_anode(fnode)",
            "le32_to_cpu(fnode->ea_size_l) + 5 + h[1]",
            "size",
            "data"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "360-382",
          "snippet": "int hpfs_ea_write(struct super_block *s, secno a, int ano, unsigned pos,\n\t     unsigned len, const char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #2\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(data + (pos & 0x1ff), buf, l);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_write(struct super_block *s, secno a, int ano, unsigned pos,\n\t     unsigned len, const char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #2\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(data + (pos & 0x1ff), buf, l);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_add_sector_to_btree",
          "args": [
            "s",
            "le32_to_cpu(fnode->ea_secno)",
            "0",
            "len"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_sector_to_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "60-266",
          "snippet": "secno hpfs_add_sector_to_btree(struct super_block *s, secno node, int fnod, unsigned fsecno)\n{\n\tstruct bplus_header *btree;\n\tstruct anode *anode = NULL, *ranode = NULL;\n\tstruct fnode *fnode;\n\tanode_secno a, na = -1, ra, up = -1;\n\tsecno se;\n\tstruct buffer_head *bh, *bh1, *bh2;\n\tint n;\n\tunsigned fs;\n\tint c1, c2 = 0;\n\tif (fnod) {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) return -1;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t}\n\ta = node;\n\tgo_down:\n\tif ((n = btree->n_used_nodes - 1) < -!!fnod) {\n\t\thpfs_error(s, \"anode %08x has no entries\", a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tif (bp_internal(btree)) {\n\t\ta = le32_to_cpu(btree->u.internal[n].down);\n\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_add_sector_to_btree #1\")) return -1;\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t\tgoto go_down;\n\t}\n\tif (n >= 0) {\n\t\tif (le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length) != fsecno) {\n\t\t\thpfs_error(s, \"allocated size %08x, trying to add sector %08x, %cnode %08x\",\n\t\t\t\tle32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length), fsecno,\n\t\t\t\tfnod?'f':'a', node);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tif (hpfs_alloc_if_possible(s, se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length))) {\n\t\t\tle32_add_cpu(&btree->u.external[n].length, 1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\treturn se;\n\t\t}\n\t} else {\n\t\tif (fsecno) {\n\t\t\thpfs_error(s, \"empty file %08x, trying to add sector %08x\", node, fsecno);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tse = !fnod ? node : (node + 16384) & ~16383;\n\t}\t\n\tif (!(se = hpfs_alloc_sector(s, se, 1, fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M))) {\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfs = n < 0 ? 0 : le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length);\n\tif (!btree->n_free_nodes) {\n\t\tup = a != node ? le32_to_cpu(anode->up) : -1;\n\t\tif (!(anode = hpfs_alloc_anode(s, a, &na, &bh1))) {\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (a == node && fnod) {\n\t\t\tanode->up = cpu_to_le32(node);\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\tanode->btree.n_used_nodes = btree->n_used_nodes;\n\t\t\tanode->btree.first_free = btree->first_free;\n\t\t\tanode->btree.n_free_nodes = 40 - anode->btree.n_used_nodes;\n\t\t\tmemcpy(&anode->u, &btree->u, btree->n_used_nodes * 12);\n\t\t\tbtree->flags |= BP_internal;\n\t\t\tbtree->n_free_nodes = 11;\n\t\t\tbtree->n_used_nodes = 1;\n\t\t\tbtree->first_free = cpu_to_le16((char *)&(btree->u.internal[1]) - (char *)btree);\n\t\t\tbtree->u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[0].down = cpu_to_le32(na);\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else if (!(ranode = hpfs_alloc_anode(s, /*a*/0, &ra, &bh2))) {\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh1);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\thpfs_free_sectors(s, na, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(bh);\n\t\tbh = bh1;\n\t\tbtree = &anode->btree;\n\t}\n\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\tle16_add_cpu(&btree->first_free, 12);\n\tbtree->u.external[n].disk_secno = cpu_to_le32(se);\n\tbtree->u.external[n].file_secno = cpu_to_le32(fs);\n\tbtree->u.external[n].length = cpu_to_le32(1);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tif ((a == node && fnod) || na == -1) return se;\n\tc2 = 0;\n\twhile (up != (anode_secno)-1) {\n\t\tstruct anode *new_anode;\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, up, &c1, &c2, \"hpfs_add_sector_to_btree #2\")) return -1;\n\t\tif (up != node || !fnod) {\n\t\t\tif (!(anode = hpfs_map_anode(s, up, &bh))) return -1;\n\t\t\tbtree = &anode->btree;\n\t\t} else {\n\t\t\tif (!(fnode = hpfs_map_fnode(s, up, &bh))) return -1;\n\t\t\tbtree = &fnode->btree;\n\t\t}\n\t\tif (btree->n_free_nodes) {\n\t\t\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\t\t\tle16_add_cpu(&btree->first_free, 8);\n\t\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[n].down = cpu_to_le32(na);\n\t\t\tbtree->u.internal[n-1].file_secno = cpu_to_le32(fs);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh2);\n\t\t\thpfs_free_sectors(s, ra, 1);\n\t\t\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(up);\n\t\t\t\tif (up == node && fnod)\n\t\t\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\t\telse\n\t\t\t\t\tanode->btree.flags &= ~BP_fnode_parent;\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\treturn se;\n\t\t}\n\t\tup = up != node ? le32_to_cpu(anode->up) : -1;\n\t\tbtree->u.internal[btree->n_used_nodes - 1].file_secno = cpu_to_le32(/*fs*/-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\ta = na;\n\t\tif ((new_anode = hpfs_alloc_anode(s, a, &na, &bh))) {\n\t\t\tanode = new_anode;\n\t\t\t/*anode->up = cpu_to_le32(up != -1 ? up : ra);*/\n\t\t\tanode->btree.flags |= BP_internal;\n\t\t\tanode->btree.n_used_nodes = 1;\n\t\t\tanode->btree.n_free_nodes = 59;\n\t\t\tanode->btree.first_free = cpu_to_le16(16);\n\t\t\tanode->btree.u.internal[0].down = cpu_to_le32(a);\n\t\t\tanode->btree.u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(na);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t} else na = a;\n\t}\n\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\tanode->up = cpu_to_le32(node);\n\t\tif (fnod)\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tif (!fnod) {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &anode->btree;\n\t} else {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &fnode->btree;\n\t}\n\tranode->up = cpu_to_le32(node);\n\tmemcpy(&ranode->btree, btree, le16_to_cpu(btree->first_free));\n\tif (fnod)\n\t\tranode->btree.flags |= BP_fnode_parent;\n\tranode->btree.n_free_nodes = (bp_internal(&ranode->btree) ? 60 : 40) - ranode->btree.n_used_nodes;\n\tif (bp_internal(&ranode->btree)) for (n = 0; n < ranode->btree.n_used_nodes; n++) {\n\t\tstruct anode *unode;\n\t\tif ((unode = hpfs_map_anode(s, le32_to_cpu(ranode->u.internal[n].down), &bh1))) {\n\t\t\tunode->up = cpu_to_le32(ra);\n\t\t\tunode->btree.flags &= ~BP_fnode_parent;\n\t\t\tmark_buffer_dirty(bh1);\n\t\t\tbrelse(bh1);\n\t\t}\n\t}\n\tbtree->flags |= BP_internal;\n\tbtree->n_free_nodes = fnod ? 10 : 58;\n\tbtree->n_used_nodes = 2;\n\tbtree->first_free = cpu_to_le16((char *)&btree->u.internal[2] - (char *)btree);\n\tbtree->u.internal[0].file_secno = cpu_to_le32(fs);\n\tbtree->u.internal[0].down = cpu_to_le32(ra);\n\tbtree->u.internal[1].file_secno = cpu_to_le32(-1);\n\tbtree->u.internal[1].down = cpu_to_le32(na);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tmark_buffer_dirty(bh2);\n\tbrelse(bh2);\n\treturn se;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_add_sector_to_btree(struct super_block *s, secno node, int fnod, unsigned fsecno)\n{\n\tstruct bplus_header *btree;\n\tstruct anode *anode = NULL, *ranode = NULL;\n\tstruct fnode *fnode;\n\tanode_secno a, na = -1, ra, up = -1;\n\tsecno se;\n\tstruct buffer_head *bh, *bh1, *bh2;\n\tint n;\n\tunsigned fs;\n\tint c1, c2 = 0;\n\tif (fnod) {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) return -1;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t}\n\ta = node;\n\tgo_down:\n\tif ((n = btree->n_used_nodes - 1) < -!!fnod) {\n\t\thpfs_error(s, \"anode %08x has no entries\", a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tif (bp_internal(btree)) {\n\t\ta = le32_to_cpu(btree->u.internal[n].down);\n\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_add_sector_to_btree #1\")) return -1;\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t\tgoto go_down;\n\t}\n\tif (n >= 0) {\n\t\tif (le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length) != fsecno) {\n\t\t\thpfs_error(s, \"allocated size %08x, trying to add sector %08x, %cnode %08x\",\n\t\t\t\tle32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length), fsecno,\n\t\t\t\tfnod?'f':'a', node);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tif (hpfs_alloc_if_possible(s, se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length))) {\n\t\t\tle32_add_cpu(&btree->u.external[n].length, 1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\treturn se;\n\t\t}\n\t} else {\n\t\tif (fsecno) {\n\t\t\thpfs_error(s, \"empty file %08x, trying to add sector %08x\", node, fsecno);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tse = !fnod ? node : (node + 16384) & ~16383;\n\t}\t\n\tif (!(se = hpfs_alloc_sector(s, se, 1, fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M))) {\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfs = n < 0 ? 0 : le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length);\n\tif (!btree->n_free_nodes) {\n\t\tup = a != node ? le32_to_cpu(anode->up) : -1;\n\t\tif (!(anode = hpfs_alloc_anode(s, a, &na, &bh1))) {\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (a == node && fnod) {\n\t\t\tanode->up = cpu_to_le32(node);\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\tanode->btree.n_used_nodes = btree->n_used_nodes;\n\t\t\tanode->btree.first_free = btree->first_free;\n\t\t\tanode->btree.n_free_nodes = 40 - anode->btree.n_used_nodes;\n\t\t\tmemcpy(&anode->u, &btree->u, btree->n_used_nodes * 12);\n\t\t\tbtree->flags |= BP_internal;\n\t\t\tbtree->n_free_nodes = 11;\n\t\t\tbtree->n_used_nodes = 1;\n\t\t\tbtree->first_free = cpu_to_le16((char *)&(btree->u.internal[1]) - (char *)btree);\n\t\t\tbtree->u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[0].down = cpu_to_le32(na);\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else if (!(ranode = hpfs_alloc_anode(s, /*a*/0, &ra, &bh2))) {\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh1);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\thpfs_free_sectors(s, na, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(bh);\n\t\tbh = bh1;\n\t\tbtree = &anode->btree;\n\t}\n\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\tle16_add_cpu(&btree->first_free, 12);\n\tbtree->u.external[n].disk_secno = cpu_to_le32(se);\n\tbtree->u.external[n].file_secno = cpu_to_le32(fs);\n\tbtree->u.external[n].length = cpu_to_le32(1);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tif ((a == node && fnod) || na == -1) return se;\n\tc2 = 0;\n\twhile (up != (anode_secno)-1) {\n\t\tstruct anode *new_anode;\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, up, &c1, &c2, \"hpfs_add_sector_to_btree #2\")) return -1;\n\t\tif (up != node || !fnod) {\n\t\t\tif (!(anode = hpfs_map_anode(s, up, &bh))) return -1;\n\t\t\tbtree = &anode->btree;\n\t\t} else {\n\t\t\tif (!(fnode = hpfs_map_fnode(s, up, &bh))) return -1;\n\t\t\tbtree = &fnode->btree;\n\t\t}\n\t\tif (btree->n_free_nodes) {\n\t\t\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\t\t\tle16_add_cpu(&btree->first_free, 8);\n\t\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[n].down = cpu_to_le32(na);\n\t\t\tbtree->u.internal[n-1].file_secno = cpu_to_le32(fs);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh2);\n\t\t\thpfs_free_sectors(s, ra, 1);\n\t\t\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(up);\n\t\t\t\tif (up == node && fnod)\n\t\t\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\t\telse\n\t\t\t\t\tanode->btree.flags &= ~BP_fnode_parent;\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\treturn se;\n\t\t}\n\t\tup = up != node ? le32_to_cpu(anode->up) : -1;\n\t\tbtree->u.internal[btree->n_used_nodes - 1].file_secno = cpu_to_le32(/*fs*/-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\ta = na;\n\t\tif ((new_anode = hpfs_alloc_anode(s, a, &na, &bh))) {\n\t\t\tanode = new_anode;\n\t\t\t/*anode->up = cpu_to_le32(up != -1 ? up : ra);*/\n\t\t\tanode->btree.flags |= BP_internal;\n\t\t\tanode->btree.n_used_nodes = 1;\n\t\t\tanode->btree.n_free_nodes = 59;\n\t\t\tanode->btree.first_free = cpu_to_le16(16);\n\t\t\tanode->btree.u.internal[0].down = cpu_to_le32(a);\n\t\t\tanode->btree.u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(na);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t} else na = a;\n\t}\n\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\tanode->up = cpu_to_le32(node);\n\t\tif (fnod)\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tif (!fnod) {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &anode->btree;\n\t} else {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &fnode->btree;\n\t}\n\tranode->up = cpu_to_le32(node);\n\tmemcpy(&ranode->btree, btree, le16_to_cpu(btree->first_free));\n\tif (fnod)\n\t\tranode->btree.flags |= BP_fnode_parent;\n\tranode->btree.n_free_nodes = (bp_internal(&ranode->btree) ? 60 : 40) - ranode->btree.n_used_nodes;\n\tif (bp_internal(&ranode->btree)) for (n = 0; n < ranode->btree.n_used_nodes; n++) {\n\t\tstruct anode *unode;\n\t\tif ((unode = hpfs_map_anode(s, le32_to_cpu(ranode->u.internal[n].down), &bh1))) {\n\t\t\tunode->up = cpu_to_le32(ra);\n\t\t\tunode->btree.flags &= ~BP_fnode_parent;\n\t\t\tmark_buffer_dirty(bh1);\n\t\t\tbrelse(bh1);\n\t\t}\n\t}\n\tbtree->flags |= BP_internal;\n\tbtree->n_free_nodes = fnod ? 10 : 58;\n\tbtree->n_used_nodes = 2;\n\tbtree->first_free = cpu_to_le16((char *)&btree->u.internal[2] - (char *)btree);\n\tbtree->u.internal[0].file_secno = cpu_to_le32(fs);\n\tbtree->u.internal[0].down = cpu_to_le32(ra);\n\tbtree->u.internal[1].file_secno = cpu_to_le32(-1);\n\tbtree->u.internal[1].down = cpu_to_le32(na);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tmark_buffer_dirty(bh2);\n\tbrelse(bh2);\n\treturn se;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_sec"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh2"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh2"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "b2",
            "b1",
            "512"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_get_sector",
          "args": [
            "s",
            "new_sec + i",
            "&bh2"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_get_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "65-82",
          "snippet": "void *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "le32_to_cpu(fnode->ea_secno) + i",
            "&bh1",
            "len - i - 1"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_sector",
          "args": [
            "s",
            "fno",
            "1",
            "1 - ((pos + 511) >> 9)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "202-274",
          "snippet": "secno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_if_possible",
          "args": [
            "s",
            "le32_to_cpu(fnode->ea_secno) + len"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_if_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "295-310",
          "snippet": "int hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "q"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "n"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "le16_to_cpu(fnode->ea_size_s)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fnode->ea_size_s"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "fnode_ea(fnode)",
            "le16_to_cpu(fnode->ea_size_s)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnode_ea",
          "args": [
            "fnode"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "129-132",
          "snippet": "static inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ea_data(ea)",
            "data",
            "size"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_data",
          "args": [
            "ea"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ea_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "159-162",
          "snippet": "static inline char *ea_data(struct extended_attribute *ea)\n{\n\treturn (char *)((char *)ea + 5 + ea->namelen);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic inline char *ea_data(struct extended_attribute *ea)\n{\n\treturn (char *)((char *)ea + 5 + ea->namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ea->name",
            "key"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnode_end_ea",
          "args": [
            "fnode"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_end_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "134-137",
          "snippet": "static inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"fnode %08lx: ea_offs == %03x, ea_size_s == %03x\"",
            "(unsigned long)inode->i_ino",
            "le16_to_cpu(fnode->ea_offs)",
            "le16_to_cpu(fnode->ea_size_s)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0xc4"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_valuelen",
          "args": [
            "ea"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ea_valuelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "139-142",
          "snippet": "static unsigned ea_valuelen(struct extended_attribute *ea)\n{\n\treturn ea->valuelen_lo + 256 * ea->valuelen_hi;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic unsigned ea_valuelen(struct extended_attribute *ea)\n{\n\treturn ea->valuelen_lo + 256 * ea->valuelen_hi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_indirect_ea",
          "args": [
            "s",
            "ea_in_anode(ea)",
            "ea_sec(ea)",
            "data",
            "size"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "set_indirect_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
          "lines": "65-69",
          "snippet": "static void set_indirect_ea(struct super_block *s, int ano, secno a,\n\t\t\t    const char *data, int size)\n{\n\thpfs_ea_write(s, a, ano, 0, size, data);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void set_indirect_ea(struct super_block *s, int ano, secno a,\n\t\t\t    const char *data, int size)\n{\n\thpfs_ea_write(s, a, ano, 0, size, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_sec",
          "args": [
            "ea"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ea_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "149-152",
          "snippet": "static inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_in_anode",
          "args": [
            "ea"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ea_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "550-553",
          "snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_len",
          "args": [
            "ea"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ea_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "154-157",
          "snippet": "static inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_indirect",
          "args": [
            "ea"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ea_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "545-548",
          "snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->name",
            "key"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_ea_read",
          "args": [
            "s",
            "a",
            "ano",
            "pos + 4",
            "ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0)",
            "ex + 4"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "337-358",
          "snippet": "int hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ea_data(ea)",
            "data",
            "size"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_ea",
          "args": [
            "ea"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "next_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "144-147",
          "snippet": "static inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_set_ea(struct inode *inode, struct fnode *fnode, const char *key,\n\t\t const char *data, int size)\n{\n\tfnode_secno fno = inode->i_ino;\n\tstruct super_block *s = inode->i_sb;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tunsigned char h[4];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t} else if (ea_valuelen(ea) == size) {\n\t\t\t\tmemcpy(ea_data(ea), data, size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ea_valuelen(ea) == size)\n\t\t\t\t\thpfs_ea_write(s, a, ano, pos + 4 + ea->namelen + 1, size, data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!le16_to_cpu(fnode->ea_offs)) {\n\t\t/*if (le16_to_cpu(fnode->ea_size_s)) {\n\t\t\thpfs_error(s, \"fnode %08x: ea_size_s == %03x, ea_offs == 0\",\n\t\t\t\tinode->i_ino, le16_to_cpu(fnode->ea_size_s));\n\t\t\treturn;\n\t\t}*/\n\t\tfnode->ea_offs = cpu_to_le16(0xc4);\n\t}\n\tif (le16_to_cpu(fnode->ea_offs) < 0xc4 || le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200) {\n\t\thpfs_error(s, \"fnode %08lx: ea_offs == %03x, ea_size_s == %03x\",\n\t\t\t(unsigned long)inode->i_ino,\n\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\treturn;\n\t}\n\tif ((le16_to_cpu(fnode->ea_size_s) || !le32_to_cpu(fnode->ea_size_l)) &&\n\t     le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5 <= 0x200) {\n\t\tea = fnode_end_ea(fnode);\n\t\t*(char *)ea = 0;\n\t\tea->namelen = strlen(key);\n\t\tea->valuelen_lo = size;\n\t\tea->valuelen_hi = size >> 8;\n\t\tstrcpy(ea->name, key);\n\t\tmemcpy(ea_data(ea), data, size);\n\t\tfnode->ea_size_s = cpu_to_le16(le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5);\n\t\tgoto ret;\n\t}\n\t/* Most the code here is 99.9993422% unused. I hope there are no bugs.\n\t   But what .. HPFS.IFS has also bugs in ea management. */\n\tif (le16_to_cpu(fnode->ea_size_s) && !le32_to_cpu(fnode->ea_size_l)) {\n\t\tsecno n;\n\t\tstruct buffer_head *bh;\n\t\tchar *data;\n\t\tif (!(n = hpfs_alloc_sector(s, fno, 1, 0))) return;\n\t\tif (!(data = hpfs_get_sector(s, n, &bh))) {\n\t\t\thpfs_free_sectors(s, n, 1);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data, fnode_ea(fnode), le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_l = cpu_to_le32(le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_s = cpu_to_le16(0);\n\t\tfnode->ea_secno = cpu_to_le32(n);\n\t\tfnode->flags &= ~FNODE_anode;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tpos = le32_to_cpu(fnode->ea_size_l) + 5 + strlen(key) + size;\n\tlen = (le32_to_cpu(fnode->ea_size_l) + 511) >> 9;\n\tif (pos >= 30000) goto bail;\n\twhile (((pos + 511) >> 9) > len) {\n\t\tif (!len) {\n\t\t\tsecno q = hpfs_alloc_sector(s, fno, 1, 0);\n\t\t\tif (!q) goto bail;\n\t\t\tfnode->ea_secno = cpu_to_le32(q);\n\t\t\tfnode->flags &= ~FNODE_anode;\n\t\t\tlen++;\n\t\t} else if (!fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_alloc_if_possible(s, le32_to_cpu(fnode->ea_secno) + len)) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\t/* Aargh... don't know how to create ea anodes :-( */\n\t\t\t\t/*struct buffer_head *bh;\n\t\t\t\tstruct anode *anode;\n\t\t\t\tanode_secno a_s;\n\t\t\t\tif (!(anode = hpfs_alloc_anode(s, fno, &a_s, &bh)))\n\t\t\t\t\tgoto bail;\n\t\t\t\tanode->up = cpu_to_le32(fno);\n\t\t\t\tanode->btree.fnode_parent = 1;\n\t\t\t\tanode->btree.n_free_nodes--;\n\t\t\t\tanode->btree.n_used_nodes++;\n\t\t\t\tanode->btree.first_free = cpu_to_le16(le16_to_cpu(anode->btree.first_free) + 12);\n\t\t\t\tanode->u.external[0].disk_secno = cpu_to_le32(le32_to_cpu(fnode->ea_secno));\n\t\t\t\tanode->u.external[0].file_secno = cpu_to_le32(0);\n\t\t\t\tanode->u.external[0].length = cpu_to_le32(len);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tfnode->flags |= FNODE_anode;\n\t\t\t\tfnode->ea_secno = cpu_to_le32(a_s);*/\n\t\t\t\tsecno new_sec;\n\t\t\t\tint i;\n\t\t\t\tif (!(new_sec = hpfs_alloc_sector(s, fno, 1, 1 - ((pos + 511) >> 9))))\n\t\t\t\t\tgoto bail;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstruct buffer_head *bh1, *bh2;\n\t\t\t\t\tvoid *b1, *b2;\n\t\t\t\t\tif (!(b1 = hpfs_map_sector(s, le32_to_cpu(fnode->ea_secno) + i, &bh1, len - i - 1))) {\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(b2 = hpfs_get_sector(s, new_sec + i, &bh2))) {\n\t\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(b2, b1, 512);\n\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\tmark_buffer_dirty(bh2);\n\t\t\t\t\tbrelse(bh2);\n\t\t\t\t}\n\t\t\t\thpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno), len);\n\t\t\t\tfnode->ea_secno = cpu_to_le32(new_sec);\n\t\t\t\tlen = (pos + 511) >> 9;\n\t\t\t}\n\t\t}\n\t\tif (fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_add_sector_to_btree(s, le32_to_cpu(fnode->ea_secno),\n\t\t\t\t\t\t     0, len) != -1) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\th[0] = 0;\n\th[1] = strlen(key);\n\th[2] = size & 0xff;\n\th[3] = size >> 8;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l), 4, h)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 4, h[1] + 1, key)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 5 + h[1], size, data)) goto bail;\n\tfnode->ea_size_l = cpu_to_le32(pos);\n\tret:\n\thpfs_i(inode)->i_ea_size += 5 + strlen(key) + size;\n\treturn;\n\tbail:\n\tif (le32_to_cpu(fnode->ea_secno))\n\t\tif (fnode_in_anode(fnode)) hpfs_truncate_btree(s, le32_to_cpu(fnode->ea_secno), 1, (le32_to_cpu(fnode->ea_size_l) + 511) >> 9);\n\t\telse hpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9), len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9));\n\telse fnode->ea_secno = fnode->ea_size_l = cpu_to_le32(0);\n}"
  },
  {
    "function_name": "hpfs_get_ea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
    "lines": "129-181",
    "snippet": "char *hpfs_get_ea(struct super_block *s, struct fnode *fnode, char *key, int *size)\n{\n\tchar *ret;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(ret, ea_data(ea), ea_valuelen(ea));\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return NULL;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn NULL;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), ret)) {\n\t\t\t\tkfree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_valuelen",
          "args": [
            "ea"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ea_valuelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "139-142",
          "snippet": "static unsigned ea_valuelen(struct extended_attribute *ea)\n{\n\treturn ea->valuelen_lo + 256 * ea->valuelen_hi;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic unsigned ea_valuelen(struct extended_attribute *ea)\n{\n\treturn ea->valuelen_lo + 256 * ea->valuelen_hi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ret"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_ea_read",
          "args": [
            "s",
            "a",
            "ano",
            "pos + 4 + ea->namelen + 1",
            "ea_valuelen(ea)",
            "ret"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "337-358",
          "snippet": "int hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory for EA\\n\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(*size = ea_valuelen(ea)) + 1",
            "GFP_NOFS"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_indirect_ea",
          "args": [
            "s",
            "ea_in_anode(ea)",
            "ea_sec(ea)",
            "*size = ea_len(ea)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "get_indirect_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
          "lines": "50-63",
          "snippet": "static char *get_indirect_ea(struct super_block *s, int ano, secno a, int size)\n{\n\tchar *ret;\n\tif (!(ret = kmalloc(size + 1, GFP_NOFS))) {\n\t\tpr_err(\"out of memory for EA\\n\");\n\t\treturn NULL;\n\t}\n\tif (hpfs_ea_read(s, a, ano, 0, size, ret)) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\tret[size] = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic char *get_indirect_ea(struct super_block *s, int ano, secno a, int size)\n{\n\tchar *ret;\n\tif (!(ret = kmalloc(size + 1, GFP_NOFS))) {\n\t\tpr_err(\"out of memory for EA\\n\");\n\t\treturn NULL;\n\t}\n\tif (hpfs_ea_read(s, a, ano, 0, size, ret)) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\tret[size] = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_len",
          "args": [
            "ea"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ea_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "154-157",
          "snippet": "static inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_sec",
          "args": [
            "ea"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ea_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "149-152",
          "snippet": "static inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_in_anode",
          "args": [
            "ea"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ea_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "550-553",
          "snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_indirect",
          "args": [
            "ea"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ea_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "545-548",
          "snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->name",
            "key"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"EAs don't end correctly, %s %08x, len %08x\"",
            "ano ? \"anode\" : \"sectors\"",
            "a",
            "len"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_in_anode",
          "args": [
            "fnode"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "475-478",
          "snippet": "static inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fnode->ea_size_l"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret",
            "ea_data(ea)",
            "ea_valuelen(ea)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_data",
          "args": [
            "ea"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ea_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "159-162",
          "snippet": "static inline char *ea_data(struct extended_attribute *ea)\n{\n\treturn (char *)((char *)ea + 5 + ea->namelen);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic inline char *ea_data(struct extended_attribute *ea)\n{\n\treturn (char *)((char *)ea + 5 + ea->namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory for EA\\n\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_ea",
          "args": [
            "ea"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "next_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "144-147",
          "snippet": "static inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_ea",
          "args": [
            "fnode"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "129-132",
          "snippet": "static inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_end_ea",
          "args": [
            "fnode"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_end_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "134-137",
          "snippet": "static inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nchar *hpfs_get_ea(struct super_block *s, struct fnode *fnode, char *key, int *size)\n{\n\tchar *ret;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(ret, ea_data(ea), ea_valuelen(ea));\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return NULL;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn NULL;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), ret)) {\n\t\t\t\tkfree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "hpfs_read_ea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
    "lines": "73-126",
    "snippet": "int hpfs_read_ea(struct super_block *s, struct fnode *fnode, char *key,\n\t\tchar *buf, int size)\n{\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tchar ex[4 + 255 + 1 + 8];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(buf, ea_data(ea), ea_valuelen(ea));\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return -EIO;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn -EIO;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), buf))\n\t\t\t\treturn -EIO;\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn -ENOENT;\nindirect:\n\tif (ea_len(ea) >= size)\n\t\treturn -EINVAL;\n\tif (hpfs_ea_read(s, ea_sec(ea), ea_in_anode(ea), 0, ea_len(ea), buf))\n\t\treturn -EIO;\n\tbuf[ea_len(ea)] = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_len",
          "args": [
            "ea"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "ea_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "154-157",
          "snippet": "static inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_ea_read",
          "args": [
            "s",
            "ea_sec(ea)",
            "ea_in_anode(ea)",
            "0",
            "ea_len(ea)",
            "buf"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "337-358",
          "snippet": "int hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_in_anode",
          "args": [
            "ea"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ea_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "550-553",
          "snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_sec",
          "args": [
            "ea"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "ea_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "149-152",
          "snippet": "static inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_valuelen",
          "args": [
            "ea"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ea_valuelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "139-142",
          "snippet": "static unsigned ea_valuelen(struct extended_attribute *ea)\n{\n\treturn ea->valuelen_lo + 256 * ea->valuelen_hi;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic unsigned ea_valuelen(struct extended_attribute *ea)\n{\n\treturn ea->valuelen_lo + 256 * ea->valuelen_hi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_indirect",
          "args": [
            "ea"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ea_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "545-548",
          "snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->name",
            "key"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"EAs don't end correctly, %s %08x, len %08x\"",
            "ano ? \"anode\" : \"sectors\"",
            "a",
            "len"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_in_anode",
          "args": [
            "fnode"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "475-478",
          "snippet": "static inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fnode->ea_size_l"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "ea_data(ea)",
            "ea_valuelen(ea)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_data",
          "args": [
            "ea"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ea_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "159-162",
          "snippet": "static inline char *ea_data(struct extended_attribute *ea)\n{\n\treturn (char *)((char *)ea + 5 + ea->namelen);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic inline char *ea_data(struct extended_attribute *ea)\n{\n\treturn (char *)((char *)ea + 5 + ea->namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_ea",
          "args": [
            "ea"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "next_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "144-147",
          "snippet": "static inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_ea",
          "args": [
            "fnode"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "129-132",
          "snippet": "static inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_end_ea",
          "args": [
            "fnode"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_end_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "134-137",
          "snippet": "static inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_read_ea(struct super_block *s, struct fnode *fnode, char *key,\n\t\tchar *buf, int size)\n{\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tchar ex[4 + 255 + 1 + 8];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(buf, ea_data(ea), ea_valuelen(ea));\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return -EIO;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn -EIO;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), buf))\n\t\t\t\treturn -EIO;\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn -ENOENT;\nindirect:\n\tif (ea_len(ea) >= size)\n\t\treturn -EINVAL;\n\tif (hpfs_ea_read(s, ea_sec(ea), ea_in_anode(ea), 0, ea_len(ea), buf))\n\t\treturn -EIO;\n\tbuf[ea_len(ea)] = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "set_indirect_ea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
    "lines": "65-69",
    "snippet": "static void set_indirect_ea(struct super_block *s, int ano, secno a,\n\t\t\t    const char *data, int size)\n{\n\thpfs_ea_write(s, a, ano, 0, size, data);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_ea_write",
          "args": [
            "s",
            "a",
            "ano",
            "0",
            "size",
            "data"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "360-382",
          "snippet": "int hpfs_ea_write(struct super_block *s, secno a, int ano, unsigned pos,\n\t     unsigned len, const char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #2\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(data + (pos & 0x1ff), buf, l);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_write(struct super_block *s, secno a, int ano, unsigned pos,\n\t     unsigned len, const char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #2\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(data + (pos & 0x1ff), buf, l);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void set_indirect_ea(struct super_block *s, int ano, secno a,\n\t\t\t    const char *data, int size)\n{\n\thpfs_ea_write(s, a, ano, 0, size, data);\n}"
  },
  {
    "function_name": "get_indirect_ea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
    "lines": "50-63",
    "snippet": "static char *get_indirect_ea(struct super_block *s, int ano, secno a, int size)\n{\n\tchar *ret;\n\tif (!(ret = kmalloc(size + 1, GFP_NOFS))) {\n\t\tpr_err(\"out of memory for EA\\n\");\n\t\treturn NULL;\n\t}\n\tif (hpfs_ea_read(s, a, ano, 0, size, ret)) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\tret[size] = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ret"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_ea_read",
          "args": [
            "s",
            "a",
            "ano",
            "0",
            "size",
            "ret"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "337-358",
          "snippet": "int hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory for EA\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size + 1",
            "GFP_NOFS"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic char *get_indirect_ea(struct super_block *s, int ano, secno a, int size)\n{\n\tchar *ret;\n\tif (!(ret = kmalloc(size + 1, GFP_NOFS))) {\n\t\tpr_err(\"out of memory for EA\\n\");\n\t\treturn NULL;\n\t}\n\tif (hpfs_ea_read(s, a, ano, 0, size, ret)) {\n\t\tkfree(ret);\n\t\treturn NULL;\n\t}\n\tret[size] = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "hpfs_ea_ext_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
    "lines": "14-48",
    "snippet": "void hpfs_ea_ext_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tunsigned pos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tstruct extended_attribute *ea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (ea_indirect(ea)) {\n\t\t\tif (ea_valuelen(ea) != 8) {\n\t\t\t\thpfs_error(s, \"ea_indirect(ea) set while ea->valuelen!=8, %s %08x, pos %08x\",\n\t\t\t\t\tano ? \"anode\" : \"sectors\", a, pos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 9, ex+4))\n\t\t\t\treturn;\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!ano) hpfs_free_sectors(s, a, (len+511) >> 9);\n\telse {\n\t\tstruct buffer_head *bh;\n\t\tstruct anode *anode;\n\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\thpfs_remove_btree(s, &anode->btree);\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, a, 1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "a",
            "1"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_remove_btree",
          "args": [
            "s",
            "&anode->btree"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "273-325",
          "snippet": "void hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_anode",
          "args": [
            "s",
            "a",
            "&bh"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "194-223",
          "snippet": "struct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_valuelen",
          "args": [
            "ea"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "ea_valuelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "139-142",
          "snippet": "static unsigned ea_valuelen(struct extended_attribute *ea)\n{\n\treturn ea->valuelen_lo + 256 * ea->valuelen_hi;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic unsigned ea_valuelen(struct extended_attribute *ea)\n{\n\treturn ea->valuelen_lo + 256 * ea->valuelen_hi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_ea_remove",
          "args": [
            "s",
            "ea_sec(ea)",
            "ea_in_anode(ea)",
            "ea_len(ea)"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "384-394",
          "snippet": "void hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_len",
          "args": [
            "ea"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "ea_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "154-157",
          "snippet": "static inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_in_anode",
          "args": [
            "ea"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "ea_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "550-553",
          "snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_sec",
          "args": [
            "ea"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "ea_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "149-152",
          "snippet": "static inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_ea_read",
          "args": [
            "s",
            "a",
            "ano",
            "pos + 4",
            "ea->namelen + 9",
            "ex+4"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "337-358",
          "snippet": "int hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"ea_indirect(ea) set while ea->valuelen!=8, %s %08x, pos %08x\"",
            "ano ? \"anode\" : \"sectors\"",
            "a",
            "pos"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_indirect",
          "args": [
            "ea"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "ea_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "545-548",
          "snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_ea_ext_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tunsigned pos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tstruct extended_attribute *ea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (ea_indirect(ea)) {\n\t\t\tif (ea_valuelen(ea) != 8) {\n\t\t\t\thpfs_error(s, \"ea_indirect(ea) set while ea->valuelen!=8, %s %08x, pos %08x\",\n\t\t\t\t\tano ? \"anode\" : \"sectors\", a, pos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 9, ex+4))\n\t\t\t\treturn;\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!ano) hpfs_free_sectors(s, a, (len+511) >> 9);\n\telse {\n\t\tstruct buffer_head *bh;\n\t\tstruct anode *anode;\n\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\thpfs_remove_btree(s, &anode->btree);\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, a, 1);\n\t\t}\n\t}\n}"
  }
]