[
  {
    "function_name": "gfs2_set_aops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "1218-1230",
    "snippet": "void gfs2_set_aops(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (gfs2_is_writeback(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_writeback_aops;\n\telse if (gfs2_is_ordered(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_ordered_aops;\n\telse if (gfs2_is_jdata(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_jdata_aops;\n\telse\n\t\tBUG();\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations gfs2_writeback_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};",
      "static const struct address_space_operations gfs2_ordered_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};",
      "static const struct address_space_operations gfs2_jdata_aops = {\n\t.writepage = gfs2_jdata_writepage,\n\t.writepages = gfs2_jdata_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_ordered",
          "args": [
            "ip"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "39-43",
          "snippet": "static inline int gfs2_is_ordered(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_ORDERED) && !gfs2_is_jdata(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_ordered(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_ORDERED) && !gfs2_is_jdata(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_writeback",
          "args": [
            "ip"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "33-37",
          "snippet": "static inline int gfs2_is_writeback(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_WRITEBACK) && !gfs2_is_jdata(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_writeback(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_WRITEBACK) && !gfs2_is_jdata(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct address_space_operations gfs2_writeback_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\nstatic const struct address_space_operations gfs2_ordered_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\nstatic const struct address_space_operations gfs2_jdata_aops = {\n\t.writepage = gfs2_jdata_writepage,\n\t.writepages = gfs2_jdata_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\n\nvoid gfs2_set_aops(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (gfs2_is_writeback(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_writeback_aops;\n\telse if (gfs2_is_ordered(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_ordered_aops;\n\telse if (gfs2_is_jdata(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_jdata_aops;\n\telse\n\t\tBUG();\n}"
  },
  {
    "function_name": "gfs2_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "1118-1168",
    "snippet": "int gfs2_releasepage(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct gfs2_sbd *sdp = gfs2_mapping2sbd(mapping);\n\tstruct buffer_head *bh, *head;\n\tstruct gfs2_bufdata *bd;\n\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tif (atomic_read(&bh->b_count))\n\t\t\tgoto cannot_release;\n\t\tbd = bh->b_private;\n\t\tif (bd && bd->bd_tr)\n\t\t\tgoto cannot_release;\n\t\tif (buffer_pinned(bh) || buffer_dirty(bh))\n\t\t\tgoto not_possible;\n\t\tbh = bh->b_this_page;\n\t} while(bh != head);\n\tspin_unlock(&sdp->sd_ail_lock);\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tbd = bh->b_private;\n\t\tif (bd) {\n\t\t\tgfs2_assert_warn(sdp, bd->bd_bh == bh);\n\t\t\tif (!list_empty(&bd->bd_list))\n\t\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tbd->bd_bh = NULL;\n\t\t\tbh->b_private = NULL;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t}\n\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tgfs2_log_unlock(sdp);\n\n\treturn try_to_free_buffers(page);\n\nnot_possible: /* Should never happen */\n\tWARN_ON(buffer_dirty(bh));\n\tWARN_ON(buffer_pinned(bh));\ncannot_release:\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_unlock",
          "args": [
            "sdp"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "36-40",
          "snippet": "static inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_ail_lock"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "buffer_pinned(bh)"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_pinned",
          "args": [
            "bh"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "buffer_dirty(bh)"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "gfs2_bufdata_cachep",
            "bd"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bd->bd_list"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bd->bd_list"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "bd->bd_bh == bh"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_pinned",
          "args": [
            "bh"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_ail_lock"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_log_lock",
          "args": [
            "sdp"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "24-28",
          "snippet": "static inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_mapping2sbd",
          "args": [
            "mapping"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_mapping2sbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "43-52",
          "snippet": "static inline struct gfs2_sbd *gfs2_mapping2sbd(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tif (mapping->a_ops == &gfs2_meta_aops)\n\t\treturn (((struct gfs2_glock *)mapping) - 1)->gl_sbd;\n\telse if (mapping->a_ops == &gfs2_rgrp_aops)\n\t\treturn container_of(mapping, struct gfs2_sbd, sd_aspace);\n\telse\n\t\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct gfs2_sbd *gfs2_mapping2sbd(struct address_space *mapping)\n{\n\tstruct inode *inode = mapping->host;\n\tif (mapping->a_ops == &gfs2_meta_aops)\n\t\treturn (((struct gfs2_glock *)mapping) - 1)->gl_sbd;\n\telse if (mapping->a_ops == &gfs2_rgrp_aops)\n\t\treturn container_of(mapping, struct gfs2_sbd, sd_aspace);\n\telse\n\t\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_releasepage(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct gfs2_sbd *sdp = gfs2_mapping2sbd(mapping);\n\tstruct buffer_head *bh, *head;\n\tstruct gfs2_bufdata *bd;\n\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tif (atomic_read(&bh->b_count))\n\t\t\tgoto cannot_release;\n\t\tbd = bh->b_private;\n\t\tif (bd && bd->bd_tr)\n\t\t\tgoto cannot_release;\n\t\tif (buffer_pinned(bh) || buffer_dirty(bh))\n\t\t\tgoto not_possible;\n\t\tbh = bh->b_this_page;\n\t} while(bh != head);\n\tspin_unlock(&sdp->sd_ail_lock);\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tbd = bh->b_private;\n\t\tif (bd) {\n\t\t\tgfs2_assert_warn(sdp, bd->bd_bh == bh);\n\t\t\tif (!list_empty(&bd->bd_list))\n\t\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tbd->bd_bh = NULL;\n\t\t\tbh->b_private = NULL;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t}\n\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\tgfs2_log_unlock(sdp);\n\n\treturn try_to_free_buffers(page);\n\nnot_possible: /* Should never happen */\n\tWARN_ON(buffer_dirty(bh));\n\tWARN_ON(buffer_pinned(bh));\ncannot_release:\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "1042-1105",
    "snippet": "static ssize_t gfs2_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint rv;\n\n\t/*\n\t * Deferred lock, even if its a write, since we do no allocation\n\t * on this path. All we need change is atime, and this lock mode\n\t * ensures that other nodes have flushed their buffered read caches\n\t * (i.e. their page cache entries for this inode). We do not,\n\t * unfortunately have the option of only flushing a range like\n\t * the VFS does.\n\t */\n\tgfs2_holder_init(ip->i_gl, LM_ST_DEFERRED, 0, &gh);\n\trv = gfs2_glock_nq(&gh);\n\tif (rv)\n\t\treturn rv;\n\trv = gfs2_ok_for_dio(ip, rw, offset);\n\tif (rv != 1)\n\t\tgoto out; /* dio not valid, fall back to buffered i/o */\n\n\t/*\n\t * Now since we are holding a deferred (CW) lock at this point, you\n\t * might be wondering why this is ever needed. There is a case however\n\t * where we've granted a deferred local lock against a cached exclusive\n\t * glock. That is ok provided all granted local locks are deferred, but\n\t * it also means that it is possible to encounter pages which are\n\t * cached and possibly also mapped. So here we check for that and sort\n\t * them out ahead of the dio. The glock state machine will take care of\n\t * everything else.\n\t *\n\t * If in fact the cached glock state (gl->gl_state) is deferred (CW) in\n\t * the first place, mapping->nr_pages will always be zero.\n\t */\n\tif (mapping->nrpages) {\n\t\tloff_t lstart = offset & (PAGE_CACHE_SIZE - 1);\n\t\tloff_t len = iov_iter_count(iter);\n\t\tloff_t end = PAGE_ALIGN(offset + len) - 1;\n\n\t\trv = 0;\n\t\tif (len == 0)\n\t\t\tgoto out;\n\t\tif (test_and_clear_bit(GIF_SW_PAGED, &ip->i_flags))\n\t\t\tunmap_shared_mapping_range(ip->i_inode.i_mapping, offset, len);\n\t\trv = filemap_write_and_wait_range(mapping, lstart, end);\n\t\tif (rv)\n\t\t\tgoto out;\n\t\tif (rw == WRITE)\n\t\t\ttruncate_inode_pages_range(mapping, lstart, end);\n\t}\n\n\trv = __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t  iter, offset,\n\t\t\t\t  gfs2_get_block_direct, NULL, NULL, 0);\nout:\n\tgfs2_glock_dq(&gh);\n\tgfs2_holder_uninit(&gh);\n\treturn rv;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "inode->i_sb->s_bdev",
            "iter",
            "offset",
            "gfs2_get_block_direct",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "__blockdev_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "1304-1324",
          "snippet": "ssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "mapping",
            "lstart",
            "end"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "lstart",
            "end"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_shared_mapping_range",
          "args": [
            "ip->i_inode.i_mapping",
            "offset",
            "len"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "GIF_SW_PAGED",
            "&ip->i_flags"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "offset + len"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ok_for_dio",
          "args": [
            "ip",
            "rw",
            "offset"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ok_for_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "1025-1038",
          "snippet": "static int gfs2_ok_for_dio(struct gfs2_inode *ip, int rw, loff_t offset)\n{\n\t/*\n\t * Should we return an error here? I can't see that O_DIRECT for\n\t * a stuffed file makes any sense. For now we'll silently fall\n\t * back to buffered I/O\n\t */\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\tif (offset >= i_size_read(&ip->i_inode))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_ok_for_dio(struct gfs2_inode *ip, int rw, loff_t offset)\n{\n\t/*\n\t * Should we return an error here? I can't see that O_DIRECT for\n\t * a stuffed file makes any sense. For now we'll silently fall\n\t * back to buffered I/O\n\t */\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\tif (offset >= i_size_read(&ip->i_inode))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_DEFERRED",
            "0",
            "&gh"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic ssize_t gfs2_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint rv;\n\n\t/*\n\t * Deferred lock, even if its a write, since we do no allocation\n\t * on this path. All we need change is atime, and this lock mode\n\t * ensures that other nodes have flushed their buffered read caches\n\t * (i.e. their page cache entries for this inode). We do not,\n\t * unfortunately have the option of only flushing a range like\n\t * the VFS does.\n\t */\n\tgfs2_holder_init(ip->i_gl, LM_ST_DEFERRED, 0, &gh);\n\trv = gfs2_glock_nq(&gh);\n\tif (rv)\n\t\treturn rv;\n\trv = gfs2_ok_for_dio(ip, rw, offset);\n\tif (rv != 1)\n\t\tgoto out; /* dio not valid, fall back to buffered i/o */\n\n\t/*\n\t * Now since we are holding a deferred (CW) lock at this point, you\n\t * might be wondering why this is ever needed. There is a case however\n\t * where we've granted a deferred local lock against a cached exclusive\n\t * glock. That is ok provided all granted local locks are deferred, but\n\t * it also means that it is possible to encounter pages which are\n\t * cached and possibly also mapped. So here we check for that and sort\n\t * them out ahead of the dio. The glock state machine will take care of\n\t * everything else.\n\t *\n\t * If in fact the cached glock state (gl->gl_state) is deferred (CW) in\n\t * the first place, mapping->nr_pages will always be zero.\n\t */\n\tif (mapping->nrpages) {\n\t\tloff_t lstart = offset & (PAGE_CACHE_SIZE - 1);\n\t\tloff_t len = iov_iter_count(iter);\n\t\tloff_t end = PAGE_ALIGN(offset + len) - 1;\n\n\t\trv = 0;\n\t\tif (len == 0)\n\t\t\tgoto out;\n\t\tif (test_and_clear_bit(GIF_SW_PAGED, &ip->i_flags))\n\t\t\tunmap_shared_mapping_range(ip->i_inode.i_mapping, offset, len);\n\t\trv = filemap_write_and_wait_range(mapping, lstart, end);\n\t\tif (rv)\n\t\t\tgoto out;\n\t\tif (rw == WRITE)\n\t\t\ttruncate_inode_pages_range(mapping, lstart, end);\n\t}\n\n\trv = __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t  iter, offset,\n\t\t\t\t  gfs2_get_block_direct, NULL, NULL, 0);\nout:\n\tgfs2_glock_dq(&gh);\n\tgfs2_holder_uninit(&gh);\n\treturn rv;\n}"
  },
  {
    "function_name": "gfs2_ok_for_dio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "1025-1038",
    "snippet": "static int gfs2_ok_for_dio(struct gfs2_inode *ip, int rw, loff_t offset)\n{\n\t/*\n\t * Should we return an error here? I can't see that O_DIRECT for\n\t * a stuffed file makes any sense. For now we'll silently fall\n\t * back to buffered I/O\n\t */\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\tif (offset >= i_size_read(&ip->i_inode))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_ok_for_dio(struct gfs2_inode *ip, int rw, loff_t offset)\n{\n\t/*\n\t * Should we return an error here? I can't see that O_DIRECT for\n\t * a stuffed file makes any sense. For now we'll silently fall\n\t * back to buffered I/O\n\t */\n\tif (gfs2_is_stuffed(ip))\n\t\treturn 0;\n\n\tif (offset >= i_size_read(&ip->i_inode))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "gfs2_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "986-1014",
    "snippet": "static void gfs2_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(page->mapping->host);\n\tunsigned int stop = offset + length;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tstruct buffer_head *bh, *head;\n\tunsigned long pos = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!partial_page)\n\t\tClearPageChecked(page);\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (pos + bh->b_size > stop)\n\t\t\treturn;\n\n\t\tif (offset <= pos)\n\t\t\tgfs2_discard(sdp, bh);\n\t\tpos += bh->b_size;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\nout:\n\tif (!partial_page)\n\t\ttry_to_release_page(page, 0);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "0"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_discard",
          "args": [
            "sdp",
            "bh"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "964-984",
          "snippet": "static void gfs2_discard(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tclear_buffer_dirty(bh);\n\tbd = bh->b_private;\n\tif (bd) {\n\t\tif (!list_empty(&bd->bd_list) && !buffer_pinned(bh))\n\t\t\tlist_del_init(&bd->bd_list);\n\t\telse\n\t\t\tgfs2_remove_from_journal(bh, current->journal_info, 0);\n\t}\n\tbh->b_bdev = NULL;\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_discard(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tclear_buffer_dirty(bh);\n\tbd = bh->b_private;\n\tif (bd) {\n\t\tif (!list_empty(&bd->bd_list) && !buffer_pinned(bh))\n\t\t\tlist_del_init(&bd->bd_list);\n\t\telse\n\t\t\tgfs2_remove_from_journal(bh, current->journal_info, 0);\n\t}\n\tbh->b_bdev = NULL;\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "page->mapping->host"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(page->mapping->host);\n\tunsigned int stop = offset + length;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tstruct buffer_head *bh, *head;\n\tunsigned long pos = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!partial_page)\n\t\tClearPageChecked(page);\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (pos + bh->b_size > stop)\n\t\t\treturn;\n\n\t\tif (offset <= pos)\n\t\t\tgfs2_discard(sdp, bh);\n\t\tpos += bh->b_size;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\nout:\n\tif (!partial_page)\n\t\ttry_to_release_page(page, 0);\n}"
  },
  {
    "function_name": "gfs2_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "964-984",
    "snippet": "static void gfs2_discard(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tclear_buffer_dirty(bh);\n\tbd = bh->b_private;\n\tif (bd) {\n\t\tif (!list_empty(&bd->bd_list) && !buffer_pinned(bh))\n\t\t\tlist_del_init(&bd->bd_list);\n\t\telse\n\t\t\tgfs2_remove_from_journal(bh, current->journal_info, 0);\n\t}\n\tbh->b_bdev = NULL;\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_log_unlock",
          "args": [
            "sdp"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "36-40",
          "snippet": "static inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_req",
          "args": [
            "bh"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_remove_from_journal",
          "args": [
            "bh",
            "current->journal_info",
            "0"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_remove_from_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "264-295",
          "snippet": "void gfs2_remove_from_journal(struct buffer_head *bh, struct gfs2_trans *tr, int meta)\n{\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_sbd *sdp = gfs2_mapping2sbd(mapping);\n\tstruct gfs2_bufdata *bd = bh->b_private;\n\tint was_pinned = 0;\n\n\tif (test_clear_buffer_pinned(bh)) {\n\t\ttrace_gfs2_pin(bd, 0);\n\t\tatomic_dec(&sdp->sd_log_pinned);\n\t\tlist_del_init(&bd->bd_list);\n\t\tif (meta)\n\t\t\ttr->tr_num_buf_rm++;\n\t\telse\n\t\t\ttr->tr_num_databuf_rm++;\n\t\ttr->tr_touched = 1;\n\t\twas_pinned = 1;\n\t\tbrelse(bh);\n\t}\n\tif (bd) {\n\t\tspin_lock(&sdp->sd_ail_lock);\n\t\tif (bd->bd_tr) {\n\t\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\t} else if (was_pinned) {\n\t\t\tbh->b_private = NULL;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t}\n\t\tspin_unlock(&sdp->sd_ail_lock);\n\t}\n\tclear_buffer_dirty(bh);\n\tclear_buffer_uptodate(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_remove_from_journal(struct buffer_head *bh, struct gfs2_trans *tr, int meta)\n{\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_sbd *sdp = gfs2_mapping2sbd(mapping);\n\tstruct gfs2_bufdata *bd = bh->b_private;\n\tint was_pinned = 0;\n\n\tif (test_clear_buffer_pinned(bh)) {\n\t\ttrace_gfs2_pin(bd, 0);\n\t\tatomic_dec(&sdp->sd_log_pinned);\n\t\tlist_del_init(&bd->bd_list);\n\t\tif (meta)\n\t\t\ttr->tr_num_buf_rm++;\n\t\telse\n\t\t\ttr->tr_num_databuf_rm++;\n\t\ttr->tr_touched = 1;\n\t\twas_pinned = 1;\n\t\tbrelse(bh);\n\t}\n\tif (bd) {\n\t\tspin_lock(&sdp->sd_ail_lock);\n\t\tif (bd->bd_tr) {\n\t\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\t} else if (was_pinned) {\n\t\t\tbh->b_private = NULL;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t}\n\t\tspin_unlock(&sdp->sd_ail_lock);\n\t}\n\tclear_buffer_dirty(bh);\n\tclear_buffer_uptodate(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bd->bd_list"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_pinned",
          "args": [
            "bh"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bd->bd_list"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_lock",
          "args": [
            "sdp"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "24-28",
          "snippet": "static inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_discard(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tclear_buffer_dirty(bh);\n\tbd = bh->b_private;\n\tif (bd) {\n\t\tif (!list_empty(&bd->bd_list) && !buffer_pinned(bh))\n\t\t\tlist_del_init(&bd->bd_list);\n\t\telse\n\t\t\tgfs2_remove_from_journal(bh, current->journal_info, 0);\n\t}\n\tbh->b_bdev = NULL;\n\tclear_buffer_mapped(bh);\n\tclear_buffer_req(bh);\n\tclear_buffer_new(bh);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
  },
  {
    "function_name": "gfs2_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "945-962",
    "snippet": "static sector_t gfs2_bmap(struct address_space *mapping, sector_t lblock)\n{\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_holder i_gh;\n\tsector_t dblock = 0;\n\tint error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\tif (error)\n\t\treturn 0;\n\n\tif (!gfs2_is_stuffed(ip))\n\t\tdblock = generic_block_bmap(mapping, lblock, gfs2_block_map);\n\n\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn dblock;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "lblock",
            "gfs2_block_map"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&i_gh"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "mapping->host"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic sector_t gfs2_bmap(struct address_space *mapping, sector_t lblock)\n{\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_holder i_gh;\n\tsector_t dblock = 0;\n\tint error;\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\tif (error)\n\t\treturn 0;\n\n\tif (!gfs2_is_stuffed(ip))\n\t\tdblock = generic_block_bmap(mapping, lblock, gfs2_block_map);\n\n\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn dblock;\n}"
  },
  {
    "function_name": "gfs2_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "931-935",
    "snippet": "static int gfs2_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_buffers(page);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty_buffers",
          "args": [
            "page"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "668-692",
          "snippet": "int __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_buffers(struct page *page)\n{\n\tint newly_dirty;\n\tstruct address_space *mapping = page_mapping(page);\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tspin_lock(&mapping->private_lock);\n\tif (page_has_buffers(page)) {\n\t\tstruct buffer_head *head = page_buffers(page);\n\t\tstruct buffer_head *bh = head;\n\n\t\tdo {\n\t\t\tset_buffer_dirty(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tnewly_dirty = !TestSetPageDirty(page);\n\tspin_unlock(&mapping->private_lock);\n\n\tif (newly_dirty)\n\t\t__set_page_dirty(page, mapping, 1);\n\treturn newly_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_buffers(page);\n}"
  },
  {
    "function_name": "gfs2_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "867-922",
    "snippet": "static int gfs2_write_end(struct file *file, struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct buffer_head *dibh;\n\tunsigned int from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned int to = from + len;\n\tint ret;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tBUG_ON(!tr);\n\n\tBUG_ON(gfs2_glock_is_locked_by_me(ip->i_gl) == NULL);\n\n\tret = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(ret)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tgoto failed;\n\t}\n\n\tif (gfs2_is_stuffed(ip))\n\t\treturn gfs2_stuffed_write_end(inode, dibh, pos, len, copied, page);\n\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_page_add_databufs(ip, page, from, to);\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tif (tr->tr_num_buf_new)\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\telse\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\n\tif (inode == sdp->sd_rindex) {\n\t\tadjust_fs_space(inode);\n\t\tsdp->sd_rindex_uptodate = 0;\n\t}\n\n\tbrelse(dibh);\nfailed:\n\tgfs2_trans_end(sdp);\n\tgfs2_inplace_release(ip);\n\tif (ip->i_res->rs_qa_qd_num)\n\t\tgfs2_quota_unlock(ip);\n\tif (inode == sdp->sd_rindex) {\n\t\tgfs2_glock_dq(&m_ip->i_gh);\n\t\tgfs2_holder_uninit(&m_ip->i_gh);\n\t}\n\tgfs2_glock_dq(&ip->i_gh);\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&ip->i_gh"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&ip->i_gh"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_fs_space",
          "args": [
            "inode"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_fs_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "756-789",
          "snippet": "static void adjust_fs_space(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = inode->i_sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct buffer_head *m_bh, *l_bh;\n\tu64 fs_total, new_free;\n\n\t/* Total up the file system space, according to the latest rindex. */\n\tfs_total = gfs2_ri_total(sdp);\n\tif (gfs2_meta_inode_buffer(m_ip, &m_bh) != 0)\n\t\treturn;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode));\n\tif (fs_total > (m_sc->sc_total + l_sc->sc_total))\n\t\tnew_free = fs_total - (m_sc->sc_total + l_sc->sc_total);\n\telse\n\t\tnew_free = 0;\n\tspin_unlock(&sdp->sd_statfs_spin);\n\tfs_warn(sdp, \"File system extended by %llu blocks.\\n\",\n\t\t(unsigned long long)new_free);\n\tgfs2_statfs_change(sdp, new_free, new_free, 0);\n\n\tif (gfs2_meta_inode_buffer(l_ip, &l_bh) != 0)\n\t\tgoto out;\n\tupdate_statfs(sdp, m_bh, l_bh);\n\tbrelse(l_bh);\nout:\n\tbrelse(m_bh);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void adjust_fs_space(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = inode->i_sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct buffer_head *m_bh, *l_bh;\n\tu64 fs_total, new_free;\n\n\t/* Total up the file system space, according to the latest rindex. */\n\tfs_total = gfs2_ri_total(sdp);\n\tif (gfs2_meta_inode_buffer(m_ip, &m_bh) != 0)\n\t\treturn;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode));\n\tif (fs_total > (m_sc->sc_total + l_sc->sc_total))\n\t\tnew_free = fs_total - (m_sc->sc_total + l_sc->sc_total);\n\telse\n\t\tnew_free = 0;\n\tspin_unlock(&sdp->sd_statfs_spin);\n\tfs_warn(sdp, \"File system extended by %llu blocks.\\n\",\n\t\t(unsigned long long)new_free);\n\tgfs2_statfs_change(sdp, new_free, new_free, 0);\n\n\tif (gfs2_meta_inode_buffer(l_ip, &l_bh) != 0)\n\t\tgoto out;\n\tupdate_statfs(sdp, m_bh, l_bh);\n\tbrelse(l_bh);\nout:\n\tbrelse(m_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "I_DIRTY_DATASYNC"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2067-2104",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_page_add_databufs",
          "args": [
            "ip",
            "page",
            "from",
            "to"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_page_add_databufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "41-58",
          "snippet": "static void gfs2_page_add_databufs(struct gfs2_inode *ip, struct page *page,\n\t\t\t\t   unsigned int from, unsigned int to)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tunsigned int bsize = head->b_size;\n\tstruct buffer_head *bh;\n\tunsigned int start, end;\n\n\tfor (bh = head, start = 0; bh != head || !start;\n\t     bh = bh->b_this_page, start = end) {\n\t\tend = start + bsize;\n\t\tif (end <= from || start >= to)\n\t\t\tcontinue;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tset_buffer_uptodate(bh);\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\t}\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_page_add_databufs(struct gfs2_inode *ip, struct page *page,\n\t\t\t\t   unsigned int from, unsigned int to)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tunsigned int bsize = head->b_size;\n\tstruct buffer_head *bh;\n\tunsigned int start, end;\n\n\tfor (bh = head, start = 0; bh != head || !start;\n\t     bh = bh->b_this_page, start = end) {\n\t\tend = start + bsize;\n\t\tif (end <= from || start >= to)\n\t\t\tcontinue;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tset_buffer_uptodate(bh);\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_writeback",
          "args": [
            "ip"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "33-37",
          "snippet": "static inline int gfs2_is_writeback(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_WRITEBACK) && !gfs2_is_jdata(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_writeback(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\treturn (sdp->sd_args.ar_data == GFS2_DATA_WRITEBACK) && !gfs2_is_jdata(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_stuffed_write_end",
          "args": [
            "inode",
            "dibh",
            "pos",
            "len",
            "copied",
            "page"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_stuffed_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "805-848",
          "snippet": "static int gfs2_stuffed_write_end(struct inode *inode, struct buffer_head *dibh,\n\t\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t\t  struct page *page)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tu64 to = pos + copied;\n\tvoid *kaddr;\n\tunsigned char *buf = dibh->b_data + sizeof(struct gfs2_dinode);\n\n\tBUG_ON((pos + len) > (dibh->b_size - sizeof(struct gfs2_dinode)));\n\tkaddr = kmap_atomic(page);\n\tmemcpy(buf + pos, kaddr + pos, copied);\n\tmemset(kaddr + pos + copied, 0, len - copied);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (copied) {\n\t\tif (inode->i_size < to)\n\t\t\ti_size_write(inode, to);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inode == sdp->sd_rindex) {\n\t\tadjust_fs_space(inode);\n\t\tsdp->sd_rindex_uptodate = 0;\n\t}\n\n\tbrelse(dibh);\n\tgfs2_trans_end(sdp);\n\tif (inode == sdp->sd_rindex) {\n\t\tgfs2_glock_dq(&m_ip->i_gh);\n\t\tgfs2_holder_uninit(&m_ip->i_gh);\n\t}\n\tgfs2_glock_dq(&ip->i_gh);\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn copied;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_stuffed_write_end(struct inode *inode, struct buffer_head *dibh,\n\t\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t\t  struct page *page)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tu64 to = pos + copied;\n\tvoid *kaddr;\n\tunsigned char *buf = dibh->b_data + sizeof(struct gfs2_dinode);\n\n\tBUG_ON((pos + len) > (dibh->b_size - sizeof(struct gfs2_dinode)));\n\tkaddr = kmap_atomic(page);\n\tmemcpy(buf + pos, kaddr + pos, copied);\n\tmemset(kaddr + pos + copied, 0, len - copied);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (copied) {\n\t\tif (inode->i_size < to)\n\t\t\ti_size_write(inode, to);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inode == sdp->sd_rindex) {\n\t\tadjust_fs_space(inode);\n\t\tsdp->sd_rindex_uptodate = 0;\n\t}\n\n\tbrelse(dibh);\n\tgfs2_trans_end(sdp);\n\tif (inode == sdp->sd_rindex) {\n\t\tgfs2_glock_dq(&m_ip->i_gh);\n\t\tgfs2_holder_uninit(&m_ip->i_gh);\n\t}\n\tgfs2_glock_dq(&ip->i_gh);\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "gfs2_glock_is_locked_by_me(ip->i_gl) == NULL"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_is_locked_by_me",
          "args": [
            "ip->i_gl"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_is_locked_by_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "138-157",
          "snippet": "static inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tr"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_statfs_inode"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_write_end(struct file *file, struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct buffer_head *dibh;\n\tunsigned int from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned int to = from + len;\n\tint ret;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tBUG_ON(!tr);\n\n\tBUG_ON(gfs2_glock_is_locked_by_me(ip->i_gl) == NULL);\n\n\tret = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(ret)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tgoto failed;\n\t}\n\n\tif (gfs2_is_stuffed(ip))\n\t\treturn gfs2_stuffed_write_end(inode, dibh, pos, len, copied, page);\n\n\tif (!gfs2_is_writeback(ip))\n\t\tgfs2_page_add_databufs(ip, page, from, to);\n\n\tret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);\n\tif (tr->tr_num_buf_new)\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\telse\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\n\n\tif (inode == sdp->sd_rindex) {\n\t\tadjust_fs_space(inode);\n\t\tsdp->sd_rindex_uptodate = 0;\n\t}\n\n\tbrelse(dibh);\nfailed:\n\tgfs2_trans_end(sdp);\n\tgfs2_inplace_release(ip);\n\tif (ip->i_res->rs_qa_qd_num)\n\t\tgfs2_quota_unlock(ip);\n\tif (inode == sdp->sd_rindex) {\n\t\tgfs2_glock_dq(&m_ip->i_gh);\n\t\tgfs2_holder_uninit(&m_ip->i_gh);\n\t}\n\tgfs2_glock_dq(&ip->i_gh);\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_stuffed_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "805-848",
    "snippet": "static int gfs2_stuffed_write_end(struct inode *inode, struct buffer_head *dibh,\n\t\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t\t  struct page *page)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tu64 to = pos + copied;\n\tvoid *kaddr;\n\tunsigned char *buf = dibh->b_data + sizeof(struct gfs2_dinode);\n\n\tBUG_ON((pos + len) > (dibh->b_size - sizeof(struct gfs2_dinode)));\n\tkaddr = kmap_atomic(page);\n\tmemcpy(buf + pos, kaddr + pos, copied);\n\tmemset(kaddr + pos + copied, 0, len - copied);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (copied) {\n\t\tif (inode->i_size < to)\n\t\t\ti_size_write(inode, to);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inode == sdp->sd_rindex) {\n\t\tadjust_fs_space(inode);\n\t\tsdp->sd_rindex_uptodate = 0;\n\t}\n\n\tbrelse(dibh);\n\tgfs2_trans_end(sdp);\n\tif (inode == sdp->sd_rindex) {\n\t\tgfs2_glock_dq(&m_ip->i_gh);\n\t\tgfs2_holder_uninit(&m_ip->i_gh);\n\t}\n\tgfs2_glock_dq(&ip->i_gh);\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn copied;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&ip->i_gh"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&ip->i_gh"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_fs_space",
          "args": [
            "inode"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_fs_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "756-789",
          "snippet": "static void adjust_fs_space(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = inode->i_sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct buffer_head *m_bh, *l_bh;\n\tu64 fs_total, new_free;\n\n\t/* Total up the file system space, according to the latest rindex. */\n\tfs_total = gfs2_ri_total(sdp);\n\tif (gfs2_meta_inode_buffer(m_ip, &m_bh) != 0)\n\t\treturn;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode));\n\tif (fs_total > (m_sc->sc_total + l_sc->sc_total))\n\t\tnew_free = fs_total - (m_sc->sc_total + l_sc->sc_total);\n\telse\n\t\tnew_free = 0;\n\tspin_unlock(&sdp->sd_statfs_spin);\n\tfs_warn(sdp, \"File system extended by %llu blocks.\\n\",\n\t\t(unsigned long long)new_free);\n\tgfs2_statfs_change(sdp, new_free, new_free, 0);\n\n\tif (gfs2_meta_inode_buffer(l_ip, &l_bh) != 0)\n\t\tgoto out;\n\tupdate_statfs(sdp, m_bh, l_bh);\n\tbrelse(l_bh);\nout:\n\tbrelse(m_bh);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void adjust_fs_space(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = inode->i_sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct buffer_head *m_bh, *l_bh;\n\tu64 fs_total, new_free;\n\n\t/* Total up the file system space, according to the latest rindex. */\n\tfs_total = gfs2_ri_total(sdp);\n\tif (gfs2_meta_inode_buffer(m_ip, &m_bh) != 0)\n\t\treturn;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode));\n\tif (fs_total > (m_sc->sc_total + l_sc->sc_total))\n\t\tnew_free = fs_total - (m_sc->sc_total + l_sc->sc_total);\n\telse\n\t\tnew_free = 0;\n\tspin_unlock(&sdp->sd_statfs_spin);\n\tfs_warn(sdp, \"File system extended by %llu blocks.\\n\",\n\t\t(unsigned long long)new_free);\n\tgfs2_statfs_change(sdp, new_free, new_free, 0);\n\n\tif (gfs2_meta_inode_buffer(l_ip, &l_bh) != 0)\n\t\tgoto out;\n\tupdate_statfs(sdp, m_bh, l_bh);\n\tbrelse(l_bh);\nout:\n\tbrelse(m_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "to"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + pos + copied",
            "0",
            "len - copied"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + pos",
            "kaddr + pos",
            "copied"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(pos + len) > (dibh->b_size - sizeof(struct gfs2_dinode))"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_statfs_inode"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_stuffed_write_end(struct inode *inode, struct buffer_head *dibh,\n\t\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t\t  struct page *page)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tu64 to = pos + copied;\n\tvoid *kaddr;\n\tunsigned char *buf = dibh->b_data + sizeof(struct gfs2_dinode);\n\n\tBUG_ON((pos + len) > (dibh->b_size - sizeof(struct gfs2_dinode)));\n\tkaddr = kmap_atomic(page);\n\tmemcpy(buf + pos, kaddr + pos, copied);\n\tmemset(kaddr + pos + copied, 0, len - copied);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (copied) {\n\t\tif (inode->i_size < to)\n\t\t\ti_size_write(inode, to);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inode == sdp->sd_rindex) {\n\t\tadjust_fs_space(inode);\n\t\tsdp->sd_rindex_uptodate = 0;\n\t}\n\n\tbrelse(dibh);\n\tgfs2_trans_end(sdp);\n\tif (inode == sdp->sd_rindex) {\n\t\tgfs2_glock_dq(&m_ip->i_gh);\n\t\tgfs2_holder_uninit(&m_ip->i_gh);\n\t}\n\tgfs2_glock_dq(&ip->i_gh);\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn copied;\n}"
  },
  {
    "function_name": "adjust_fs_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "756-789",
    "snippet": "static void adjust_fs_space(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = inode->i_sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct buffer_head *m_bh, *l_bh;\n\tu64 fs_total, new_free;\n\n\t/* Total up the file system space, according to the latest rindex. */\n\tfs_total = gfs2_ri_total(sdp);\n\tif (gfs2_meta_inode_buffer(m_ip, &m_bh) != 0)\n\t\treturn;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode));\n\tif (fs_total > (m_sc->sc_total + l_sc->sc_total))\n\t\tnew_free = fs_total - (m_sc->sc_total + l_sc->sc_total);\n\telse\n\t\tnew_free = 0;\n\tspin_unlock(&sdp->sd_statfs_spin);\n\tfs_warn(sdp, \"File system extended by %llu blocks.\\n\",\n\t\t(unsigned long long)new_free);\n\tgfs2_statfs_change(sdp, new_free, new_free, 0);\n\n\tif (gfs2_meta_inode_buffer(l_ip, &l_bh) != 0)\n\t\tgoto out;\n\tupdate_statfs(sdp, m_bh, l_bh);\n\tbrelse(l_bh);\nout:\n\tbrelse(m_bh);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "m_bh"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_statfs",
          "args": [
            "sdp",
            "m_bh",
            "l_bh"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "update_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "550-571",
          "snippet": "void update_statfs(struct gfs2_sbd *sdp, struct buffer_head *m_bh,\n\t\t   struct buffer_head *l_bh)\n{\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tm_sc->sc_total += l_sc->sc_total;\n\tm_sc->sc_free += l_sc->sc_free;\n\tm_sc->sc_dinodes += l_sc->sc_dinodes;\n\tmemset(l_sc, 0, sizeof(struct gfs2_statfs_change));\n\tmemset(l_bh->b_data + sizeof(struct gfs2_dinode),\n\t       0, sizeof(struct gfs2_statfs_change));\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tgfs2_trans_add_meta(m_ip->i_gl, m_bh);\n\tgfs2_statfs_change_out(m_sc, m_bh->b_data + sizeof(struct gfs2_dinode));\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid update_statfs(struct gfs2_sbd *sdp, struct buffer_head *m_bh,\n\t\t   struct buffer_head *l_bh)\n{\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tm_sc->sc_total += l_sc->sc_total;\n\tm_sc->sc_free += l_sc->sc_free;\n\tm_sc->sc_dinodes += l_sc->sc_dinodes;\n\tmemset(l_sc, 0, sizeof(struct gfs2_statfs_change));\n\tmemset(l_bh->b_data + sizeof(struct gfs2_dinode),\n\t       0, sizeof(struct gfs2_statfs_change));\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tgfs2_trans_add_meta(m_ip->i_gl, m_bh);\n\tgfs2_statfs_change_out(m_sc, m_bh->b_data + sizeof(struct gfs2_dinode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "l_ip",
            "&l_bh"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_statfs_change",
          "args": [
            "sdp",
            "new_free",
            "new_free",
            "0"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_statfs_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "515-548",
          "snippet": "void gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"File system extended by %llu blocks.\\n\"",
            "(unsigned long long)new_free"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_statfs_spin"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_statfs_change_in",
          "args": [
            "m_sc",
            "m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode)"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_statfs_change_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "451-458",
          "snippet": "void gfs2_statfs_change_in(struct gfs2_statfs_change_host *sc, const void *buf)\n{\n\tconst struct gfs2_statfs_change *str = buf;\n\n\tsc->sc_total = be64_to_cpu(str->sc_total);\n\tsc->sc_free = be64_to_cpu(str->sc_free);\n\tsc->sc_dinodes = be64_to_cpu(str->sc_dinodes);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_statfs_change_in(struct gfs2_statfs_change_host *sc, const void *buf)\n{\n\tconst struct gfs2_statfs_change *str = buf;\n\n\tsc->sc_total = be64_to_cpu(str->sc_total);\n\tsc->sc_free = be64_to_cpu(str->sc_free);\n\tsc->sc_dinodes = be64_to_cpu(str->sc_dinodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_statfs_spin"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ri_total",
          "args": [
            "sdp"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ri_total",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "841-861",
          "snippet": "u64 gfs2_ri_total(struct gfs2_sbd *sdp)\n{\n\tu64 total_data = 0;\t\n\tstruct inode *inode = sdp->sd_rindex;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tchar buf[sizeof(struct gfs2_rindex)];\n\tint error, rgrps;\n\n\tfor (rgrps = 0;; rgrps++) {\n\t\tloff_t pos = rgrps * sizeof(struct gfs2_rindex);\n\n\t\tif (pos + sizeof(struct gfs2_rindex) > i_size_read(inode))\n\t\t\tbreak;\n\t\terror = gfs2_internal_read(ip, buf, &pos,\n\t\t\t\t\t   sizeof(struct gfs2_rindex));\n\t\tif (error != sizeof(struct gfs2_rindex))\n\t\t\tbreak;\n\t\ttotal_data += be32_to_cpu(((struct gfs2_rindex *)buf)->ri_data);\n\t}\n\treturn total_data;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nu64 gfs2_ri_total(struct gfs2_sbd *sdp)\n{\n\tu64 total_data = 0;\t\n\tstruct inode *inode = sdp->sd_rindex;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tchar buf[sizeof(struct gfs2_rindex)];\n\tint error, rgrps;\n\n\tfor (rgrps = 0;; rgrps++) {\n\t\tloff_t pos = rgrps * sizeof(struct gfs2_rindex);\n\n\t\tif (pos + sizeof(struct gfs2_rindex) > i_size_read(inode))\n\t\t\tbreak;\n\t\terror = gfs2_internal_read(ip, buf, &pos,\n\t\t\t\t\t   sizeof(struct gfs2_rindex));\n\t\tif (error != sizeof(struct gfs2_rindex))\n\t\t\tbreak;\n\t\ttotal_data += be32_to_cpu(((struct gfs2_rindex *)buf)->ri_data);\n\t}\n\treturn total_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_sc_inode"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void adjust_fs_space(struct inode *inode)\n{\n\tstruct gfs2_sbd *sdp = inode->i_sb->s_fs_info;\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct buffer_head *m_bh, *l_bh;\n\tu64 fs_total, new_free;\n\n\t/* Total up the file system space, according to the latest rindex. */\n\tfs_total = gfs2_ri_total(sdp);\n\tif (gfs2_meta_inode_buffer(m_ip, &m_bh) != 0)\n\t\treturn;\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tgfs2_statfs_change_in(m_sc, m_bh->b_data +\n\t\t\t      sizeof(struct gfs2_dinode));\n\tif (fs_total > (m_sc->sc_total + l_sc->sc_total))\n\t\tnew_free = fs_total - (m_sc->sc_total + l_sc->sc_total);\n\telse\n\t\tnew_free = 0;\n\tspin_unlock(&sdp->sd_statfs_spin);\n\tfs_warn(sdp, \"File system extended by %llu blocks.\\n\",\n\t\t(unsigned long long)new_free);\n\tgfs2_statfs_change(sdp, new_free, new_free, 0);\n\n\tif (gfs2_meta_inode_buffer(l_ip, &l_bh) != 0)\n\t\tgoto out;\n\tupdate_statfs(sdp, m_bh, l_bh);\n\tbrelse(l_bh);\nout:\n\tbrelse(m_bh);\n}"
  },
  {
    "function_name": "gfs2_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "639-750",
    "snippet": "static int gfs2_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(mapping->host);\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tunsigned requested = 0;\n\tint alloc_required;\n\tint error = 0;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);\n\terror = gfs2_glock_nq(&ip->i_gh);\n\tif (unlikely(error))\n\t\tgoto out_uninit;\n\tif (&ip->i_inode == sdp->sd_rindex) {\n\t\terror = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &m_ip->i_gh);\n\t\tif (unlikely(error)) {\n\t\t\tgfs2_glock_dq(&ip->i_gh);\n\t\t\tgoto out_uninit;\n\t\t}\n\t}\n\n\talloc_required = gfs2_write_alloc_required(ip, pos, len);\n\n\tif (alloc_required || gfs2_is_jdata(ip))\n\t\tgfs2_write_calc_reserv(ip, len, &data_blocks, &ind_blocks);\n\n\tif (alloc_required) {\n\t\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\trequested = data_blocks + ind_blocks;\n\t\tap.target = requested;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto out_qunlock;\n\t}\n\n\trblocks = RES_DINODE + ind_blocks;\n\tif (gfs2_is_jdata(ip))\n\t\trblocks += data_blocks ? data_blocks : 1;\n\tif (ind_blocks || data_blocks)\n\t\trblocks += RES_STATFS + RES_QUOTA;\n\tif (&ip->i_inode == sdp->sd_rindex)\n\t\trblocks += 2 * RES_STATFS;\n\tif (alloc_required)\n\t\trblocks += gfs2_rg_blocks(ip, requested);\n\n\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\tif (error)\n\t\tgoto out_trans_fail;\n\n\terror = -ENOMEM;\n\tflags |= AOP_FLAG_NOFS;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\t*pagep = page;\n\tif (unlikely(!page))\n\t\tgoto out_endtrans;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = 0;\n\t\tif (pos + len > sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode)) {\n\t\t\terror = gfs2_unstuff_dinode(ip, page);\n\t\t\tif (error == 0)\n\t\t\t\tgoto prepare_write;\n\t\t} else if (!PageUptodate(page)) {\n\t\t\terror = stuffed_readpage(ip, page);\n\t\t}\n\t\tgoto out;\n\t}\n\nprepare_write:\n\terror = __block_write_begin(page, from, len, gfs2_block_map);\nout:\n\tif (error == 0)\n\t\treturn 0;\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tgfs2_trans_end(sdp);\n\tif (pos + len > ip->i_inode.i_size)\n\t\tgfs2_trim_blocks(&ip->i_inode);\n\tgoto out_trans_fail;\n\nout_endtrans:\n\tgfs2_trans_end(sdp);\nout_trans_fail:\n\tif (alloc_required) {\n\t\tgfs2_inplace_release(ip);\nout_qunlock:\n\t\tgfs2_quota_unlock(ip);\n\t}\nout_unlock:\n\tif (&ip->i_inode == sdp->sd_rindex) {\n\t\tgfs2_glock_dq(&m_ip->i_gh);\n\t\tgfs2_holder_uninit(&m_ip->i_gh);\n\t}\n\tgfs2_glock_dq(&ip->i_gh);\nout_uninit:\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&ip->i_gh"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&ip->i_gh"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trim_blocks",
          "args": [
            "&ip->i_inode"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trim_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1187-1194",
          "snippet": "void gfs2_trim_blocks(struct inode *inode)\n{\n\tu64 size = inode->i_size;\n\tint ret;\n\n\tret = do_shrink(inode, size, size);\n\tWARN_ON(ret != 0);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nvoid gfs2_trim_blocks(struct inode *inode)\n{\n\tu64 size = inode->i_size;\n\tint ret;\n\n\tret = do_shrink(inode, size, size);\n\tWARN_ON(ret != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "from",
            "len",
            "gfs2_block_map"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stuffed_readpage",
          "args": [
            "ip",
            "page"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "stuffed_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "448-481",
          "snippet": "static int stuffed_readpage(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *dibh;\n\tu64 dsize = i_size_read(&ip->i_inode);\n\tvoid *kaddr;\n\tint error;\n\n\t/*\n\t * Due to the order of unstuffing files and ->fault(), we can be\n\t * asked for a zero page in the case of a stuffed file being extended,\n\t * so we need to supply one here. It doesn't happen often.\n\t */\n\tif (unlikely(page->index)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tkaddr = kmap_atomic(page);\n\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\tdsize = (dibh->b_size - sizeof(struct gfs2_dinode));\n\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\tkunmap_atomic(kaddr);\n\tflush_dcache_page(page);\n\tbrelse(dibh);\n\tSetPageUptodate(page);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int stuffed_readpage(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *dibh;\n\tu64 dsize = i_size_read(&ip->i_inode);\n\tvoid *kaddr;\n\tint error;\n\n\t/*\n\t * Due to the order of unstuffing files and ->fault(), we can be\n\t * asked for a zero page in the case of a stuffed file being extended,\n\t * so we need to supply one here. It doesn't happen often.\n\t */\n\tif (unlikely(page->index)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tkaddr = kmap_atomic(page);\n\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\tdsize = (dibh->b_size - sizeof(struct gfs2_dinode));\n\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\tkunmap_atomic(kaddr);\n\tflush_dcache_page(page);\n\tbrelse(dibh);\n\tSetPageUptodate(page);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_unstuff_dinode",
          "args": [
            "ip",
            "page"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unstuff_dinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "118-175",
          "snippet": "int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *bh, *dibh;\n\tstruct gfs2_dinode *di;\n\tu64 block = 0;\n\tint isdir = gfs2_is_dir(ip);\n\tint error;\n\n\tdown_write(&ip->i_rw_mutex);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t/* Get a free block, fill it with the stuffed data,\n\t\t   and write it out to disk */\n\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\tif (error)\n\t\t\tgoto out_brelse;\n\t\tif (isdir) {\n\t\t\tgfs2_trans_add_unrevoke(GFS2_SB(&ip->i_inode), block, 1);\n\t\t\terror = gfs2_dir_get_new_buffer(ip, block, &bh);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t\tgfs2_buffer_copy_tail(bh, sizeof(struct gfs2_meta_header),\n\t\t\t\t\t      dibh, sizeof(struct gfs2_dinode));\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\terror = gfs2_unstuffer_page(ip, dibh, block, page);\n\t\t\tif (error)\n\t\t\t\tgoto out_brelse;\n\t\t}\n\t}\n\n\t/*  Set up the pointer to the new block  */\n\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tdi = (struct gfs2_dinode *)dibh->b_data;\n\tgfs2_buffer_clear_tail(dibh, sizeof(struct gfs2_dinode));\n\n\tif (i_size_read(&ip->i_inode)) {\n\t\t*(__be64 *)(di + 1) = cpu_to_be64(block);\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\t\tdi->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\t}\n\n\tip->i_height = 1;\n\tdi->di_height = cpu_to_be16(1);\n\nout_brelse:\n\tbrelse(dibh);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "rblocks",
            "PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rg_blocks",
          "args": [
            "ip",
            "requested"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rg_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.h",
          "lines": "31-36",
          "snippet": "static inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}",
          "includes": [
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n\nstatic inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ip",
            "&ap"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "ip"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_calc_reserv",
          "args": [
            "ip",
            "len",
            "&data_blocks",
            "&ind_blocks"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_calc_reserv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.h",
          "lines": "29-45",
          "snippet": "static inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}",
          "includes": [
            "#include \"inode.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n\nstatic inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,\n\t\t\t\t\t  unsigned int len,\n\t\t\t\t\t  unsigned int *data_blocks,\n\t\t\t\t\t  unsigned int *ind_blocks)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int tmp;\n\n\tBUG_ON(gfs2_is_dir(ip));\n\t*data_blocks = (len >> sdp->sd_sb.sb_bsize_shift) + 3;\n\t*ind_blocks = 3 * (sdp->sd_max_height - 1);\n\n\tfor (tmp = *data_blocks; tmp > sdp->sd_diptrs;) {\n\t\ttmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);\n\t\t*ind_blocks += tmp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_alloc_required",
          "args": [
            "ip",
            "pos",
            "len"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_alloc_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "1455-1494",
          "snippet": "int gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_write_alloc_required(struct gfs2_inode *ip, u64 offset,\n\t\t\t      unsigned int len)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head bh;\n\tunsigned int shift;\n\tu64 lblock, lblock_stop, size;\n\tu64 end_of_file;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\tif (offset + len >\n\t\t    sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tshift = sdp->sd_sb.sb_bsize_shift;\n\tBUG_ON(gfs2_is_dir(ip));\n\tend_of_file = (i_size_read(&ip->i_inode) + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tlblock = offset >> shift;\n\tlblock_stop = (offset + len + sdp->sd_sb.sb_bsize - 1) >> shift;\n\tif (lblock_stop > end_of_file)\n\t\treturn 1;\n\n\tsize = (lblock_stop - lblock) << shift;\n\tdo {\n\t\tbh.b_state = 0;\n\t\tbh.b_size = size;\n\t\tgfs2_block_map(&ip->i_inode, lblock, &bh, 0);\n\t\tif (!buffer_mapped(&bh))\n\t\t\treturn 1;\n\t\tsize -= bh.b_size;\n\t\tlblock += (bh.b_size >> ip->i_inode.i_blkbits);\n\t} while(size > 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "m_ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "GL_NOCACHE",
            "&m_ip->i_gh"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&ip->i_gh"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&ip->i_gh"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_statfs_inode"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "mapping->host"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(mapping->host);\n\tstruct gfs2_inode *m_ip = GFS2_I(sdp->sd_statfs_inode);\n\tunsigned int data_blocks = 0, ind_blocks = 0, rblocks;\n\tunsigned requested = 0;\n\tint alloc_required;\n\tint error = 0;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tstruct page *page;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);\n\terror = gfs2_glock_nq(&ip->i_gh);\n\tif (unlikely(error))\n\t\tgoto out_uninit;\n\tif (&ip->i_inode == sdp->sd_rindex) {\n\t\terror = gfs2_glock_nq_init(m_ip->i_gl, LM_ST_EXCLUSIVE,\n\t\t\t\t\t   GL_NOCACHE, &m_ip->i_gh);\n\t\tif (unlikely(error)) {\n\t\t\tgfs2_glock_dq(&ip->i_gh);\n\t\t\tgoto out_uninit;\n\t\t}\n\t}\n\n\talloc_required = gfs2_write_alloc_required(ip, pos, len);\n\n\tif (alloc_required || gfs2_is_jdata(ip))\n\t\tgfs2_write_calc_reserv(ip, len, &data_blocks, &ind_blocks);\n\n\tif (alloc_required) {\n\t\tstruct gfs2_alloc_parms ap = { .aflags = 0, };\n\t\terror = gfs2_quota_lock_check(ip);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\trequested = data_blocks + ind_blocks;\n\t\tap.target = requested;\n\t\terror = gfs2_inplace_reserve(ip, &ap);\n\t\tif (error)\n\t\t\tgoto out_qunlock;\n\t}\n\n\trblocks = RES_DINODE + ind_blocks;\n\tif (gfs2_is_jdata(ip))\n\t\trblocks += data_blocks ? data_blocks : 1;\n\tif (ind_blocks || data_blocks)\n\t\trblocks += RES_STATFS + RES_QUOTA;\n\tif (&ip->i_inode == sdp->sd_rindex)\n\t\trblocks += 2 * RES_STATFS;\n\tif (alloc_required)\n\t\trblocks += gfs2_rg_blocks(ip, requested);\n\n\terror = gfs2_trans_begin(sdp, rblocks,\n\t\t\t\t PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);\n\tif (error)\n\t\tgoto out_trans_fail;\n\n\terror = -ENOMEM;\n\tflags |= AOP_FLAG_NOFS;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\t*pagep = page;\n\tif (unlikely(!page))\n\t\tgoto out_endtrans;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = 0;\n\t\tif (pos + len > sdp->sd_sb.sb_bsize - sizeof(struct gfs2_dinode)) {\n\t\t\terror = gfs2_unstuff_dinode(ip, page);\n\t\t\tif (error == 0)\n\t\t\t\tgoto prepare_write;\n\t\t} else if (!PageUptodate(page)) {\n\t\t\terror = stuffed_readpage(ip, page);\n\t\t}\n\t\tgoto out;\n\t}\n\nprepare_write:\n\terror = __block_write_begin(page, from, len, gfs2_block_map);\nout:\n\tif (error == 0)\n\t\treturn 0;\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tgfs2_trans_end(sdp);\n\tif (pos + len > ip->i_inode.i_size)\n\t\tgfs2_trim_blocks(&ip->i_inode);\n\tgoto out_trans_fail;\n\nout_endtrans:\n\tgfs2_trans_end(sdp);\nout_trans_fail:\n\tif (alloc_required) {\n\t\tgfs2_inplace_release(ip);\nout_qunlock:\n\t\tgfs2_quota_unlock(ip);\n\t}\nout_unlock:\n\tif (&ip->i_inode == sdp->sd_rindex) {\n\t\tgfs2_glock_dq(&m_ip->i_gh);\n\t\tgfs2_holder_uninit(&m_ip->i_gh);\n\t}\n\tgfs2_glock_dq(&ip->i_gh);\nout_uninit:\n\tgfs2_holder_uninit(&ip->i_gh);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "603-624",
    "snippet": "static int gfs2_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (unlikely(ret))\n\t\tgoto out_uninit;\n\tif (!gfs2_is_stuffed(ip))\n\t\tret = mpage_readpages(mapping, pages, nr_pages, gfs2_block_map);\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\tret = -EIO;\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(SDF_SHUTDOWN, &sdp->sd_flags)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_SHUTDOWN",
            "&sdp->sd_flags"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "gfs2_block_map"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&gh"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\tret = gfs2_glock_nq(&gh);\n\tif (unlikely(ret))\n\t\tgoto out_uninit;\n\tif (!gfs2_is_stuffed(ip))\n\t\tret = mpage_readpages(mapping, pages, nr_pages, gfs2_block_map);\n\tgfs2_glock_dq(&gh);\nout_uninit:\n\tgfs2_holder_uninit(&gh);\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\tret = -EIO;\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_internal_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "559-587",
    "snippet": "int gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "p"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + copied",
            "p + offset",
            "amt"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "mapping",
            "index",
            "__gfs2_readpage",
            "NULL"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}"
  },
  {
    "function_name": "gfs2_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "524-548",
    "snippet": "static int gfs2_readpage(struct file *file, struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_holder gh;\n\tint error;\n\n\tunlock_page(page);\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terror = gfs2_glock_nq(&gh);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = AOP_TRUNCATED_PAGE;\n\tlock_page(page);\n\tif (page->mapping == mapping && !PageUptodate(page))\n\t\terror = __gfs2_readpage(file, page);\n\telse\n\t\tunlock_page(page);\n\tgfs2_glock_dq(&gh);\nout:\n\tgfs2_holder_uninit(&gh);\n\tif (error && error != AOP_TRUNCATED_PAGE)\n\t\tlock_page(page);\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&gh"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq",
          "args": [
            "&gh"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfs2_readpage",
          "args": [
            "file",
            "page"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "495-512",
          "snippet": "static int __gfs2_readpage(void *file, struct page *page)\n{\n\tstruct gfs2_inode *ip = GFS2_I(page->mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(page->mapping->host);\n\tint error;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = stuffed_readpage(ip, page);\n\t\tunlock_page(page);\n\t} else {\n\t\terror = mpage_readpage(page, gfs2_block_map);\n\t}\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int __gfs2_readpage(void *file, struct page *page)\n{\n\tstruct gfs2_inode *ip = GFS2_I(page->mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(page->mapping->host);\n\tint error;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = stuffed_readpage(ip, page);\n\t\tunlock_page(page);\n\t} else {\n\t\terror = mpage_readpage(page, gfs2_block_map);\n\t}\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq",
          "args": [
            "&gh"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1006-1034",
          "snippet": "int gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nint gfs2_glock_nq(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tint error = 0;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\tif (test_bit(GLF_LRU, &gl->gl_flags))\n\t\tgfs2_glock_remove_from_lru(gl);\n\n\tspin_lock(&gl->gl_spin);\n\tadd_to_queue(gh);\n\tif (unlikely((LM_FLAG_NOEXP & gh->gh_flags) &&\n\t\t     test_and_clear_bit(GLF_FROZEN, &gl->gl_flags))) {\n\t\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n\trun_queue(gl, 1);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (!(gh->gh_flags & GL_ASYNC))\n\t\terror = gfs2_glock_wait(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "0",
            "&gh"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "mapping->host"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_readpage(struct file *file, struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_holder gh;\n\tint error;\n\n\tunlock_page(page);\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terror = gfs2_glock_nq(&gh);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = AOP_TRUNCATED_PAGE;\n\tlock_page(page);\n\tif (page->mapping == mapping && !PageUptodate(page))\n\t\terror = __gfs2_readpage(file, page);\n\telse\n\t\tunlock_page(page);\n\tgfs2_glock_dq(&gh);\nout:\n\tgfs2_holder_uninit(&gh);\n\tif (error && error != AOP_TRUNCATED_PAGE)\n\t\tlock_page(page);\n\treturn error;\n}"
  },
  {
    "function_name": "__gfs2_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "495-512",
    "snippet": "static int __gfs2_readpage(void *file, struct page *page)\n{\n\tstruct gfs2_inode *ip = GFS2_I(page->mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(page->mapping->host);\n\tint error;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = stuffed_readpage(ip, page);\n\t\tunlock_page(page);\n\t} else {\n\t\terror = mpage_readpage(page, gfs2_block_map);\n\t}\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\treturn error;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(SDF_SHUTDOWN, &sdp->sd_flags)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_SHUTDOWN",
            "&sdp->sd_flags"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "gfs2_block_map"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stuffed_readpage",
          "args": [
            "ip",
            "page"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "stuffed_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "448-481",
          "snippet": "static int stuffed_readpage(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *dibh;\n\tu64 dsize = i_size_read(&ip->i_inode);\n\tvoid *kaddr;\n\tint error;\n\n\t/*\n\t * Due to the order of unstuffing files and ->fault(), we can be\n\t * asked for a zero page in the case of a stuffed file being extended,\n\t * so we need to supply one here. It doesn't happen often.\n\t */\n\tif (unlikely(page->index)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tkaddr = kmap_atomic(page);\n\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\tdsize = (dibh->b_size - sizeof(struct gfs2_dinode));\n\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\tkunmap_atomic(kaddr);\n\tflush_dcache_page(page);\n\tbrelse(dibh);\n\tSetPageUptodate(page);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int stuffed_readpage(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *dibh;\n\tu64 dsize = i_size_read(&ip->i_inode);\n\tvoid *kaddr;\n\tint error;\n\n\t/*\n\t * Due to the order of unstuffing files and ->fault(), we can be\n\t * asked for a zero page in the case of a stuffed file being extended,\n\t * so we need to supply one here. It doesn't happen often.\n\t */\n\tif (unlikely(page->index)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tkaddr = kmap_atomic(page);\n\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\tdsize = (dibh->b_size - sizeof(struct gfs2_dinode));\n\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\tkunmap_atomic(kaddr);\n\tflush_dcache_page(page);\n\tbrelse(dibh);\n\tSetPageUptodate(page);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_stuffed",
          "args": [
            "ip"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "23-26",
          "snippet": "static inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_stuffed(const struct gfs2_inode *ip)\n{\n\treturn !ip->i_height;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "page->mapping->host"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int __gfs2_readpage(void *file, struct page *page)\n{\n\tstruct gfs2_inode *ip = GFS2_I(page->mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(page->mapping->host);\n\tint error;\n\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = stuffed_readpage(ip, page);\n\t\tunlock_page(page);\n\t} else {\n\t\terror = mpage_readpage(page, gfs2_block_map);\n\t}\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\treturn error;\n}"
  },
  {
    "function_name": "stuffed_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "448-481",
    "snippet": "static int stuffed_readpage(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *dibh;\n\tu64 dsize = i_size_read(&ip->i_inode);\n\tvoid *kaddr;\n\tint error;\n\n\t/*\n\t * Due to the order of unstuffing files and ->fault(), we can be\n\t * asked for a zero page in the case of a stuffed file being extended,\n\t * so we need to supply one here. It doesn't happen often.\n\t */\n\tif (unlikely(page->index)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tkaddr = kmap_atomic(page);\n\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\tdsize = (dibh->b_size - sizeof(struct gfs2_dinode));\n\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\tkunmap_atomic(kaddr);\n\tflush_dcache_page(page);\n\tbrelse(dibh);\n\tSetPageUptodate(page);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + dsize",
            "0",
            "PAGE_CACHE_SIZE - dsize"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "dibh->b_data + sizeof(struct gfs2_dinode)",
            "dsize"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->index"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int stuffed_readpage(struct gfs2_inode *ip, struct page *page)\n{\n\tstruct buffer_head *dibh;\n\tu64 dsize = i_size_read(&ip->i_inode);\n\tvoid *kaddr;\n\tint error;\n\n\t/*\n\t * Due to the order of unstuffing files and ->fault(), we can be\n\t * asked for a zero page in the case of a stuffed file being extended,\n\t * so we need to supply one here. It doesn't happen often.\n\t */\n\tif (unlikely(page->index)) {\n\t\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\tkaddr = kmap_atomic(page);\n\tif (dsize > (dibh->b_size - sizeof(struct gfs2_dinode)))\n\t\tdsize = (dibh->b_size - sizeof(struct gfs2_dinode));\n\tmemcpy(kaddr, dibh->b_data + sizeof(struct gfs2_dinode), dsize);\n\tmemset(kaddr + dsize, 0, PAGE_CACHE_SIZE - dsize);\n\tkunmap_atomic(kaddr);\n\tflush_dcache_page(page);\n\tbrelse(dibh);\n\tSetPageUptodate(page);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_jdata_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "425-438",
    "snippet": "static int gfs2_jdata_writepages(struct address_space *mapping,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(mapping->host);\n\tint ret;\n\n\tret = gfs2_write_cache_jdata(mapping, wbc);\n\tif (ret == 0 && wbc->sync_mode == WB_SYNC_ALL) {\n\t\tgfs2_log_flush(sdp, ip->i_gl, NORMAL_FLUSH);\n\t\tret = gfs2_write_cache_jdata(mapping, wbc);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_write_cache_jdata",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_cache_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "344-415",
          "snippet": "static int gfs2_write_cache_jdata(struct address_space *mapping,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tint done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t uninitialized_var(writeback_index);\n\tpgoff_t index;\n\tpgoff_t end;\n\tpgoff_t done_index;\n\tint cycled;\n\tint range_whole = 0;\n\tint tag;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index; /* prev offset */\n\t\tindex = writeback_index;\n\t\tif (index == 0)\n\t\t\tcycled = 1;\n\t\telse\n\t\t\tcycled = 0;\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t\tcycled = 1; /* ignore range_cyclic tests */\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tret = gfs2_write_jdata_pagevec(mapping, wbc, &pvec, nr_pages, end, &done_index);\n\t\tif (ret)\n\t\t\tdone = 1;\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (!cycled && !done) {\n\t\t/*\n\t\t * range_cyclic:\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tcycled = 1;\n\t\tindex = 0;\n\t\tend = writeback_index - 1;\n\t\tgoto retry;\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_write_cache_jdata(struct address_space *mapping,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tint done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t uninitialized_var(writeback_index);\n\tpgoff_t index;\n\tpgoff_t end;\n\tpgoff_t done_index;\n\tint cycled;\n\tint range_whole = 0;\n\tint tag;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index; /* prev offset */\n\t\tindex = writeback_index;\n\t\tif (index == 0)\n\t\t\tcycled = 1;\n\t\telse\n\t\t\tcycled = 0;\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t\tcycled = 1; /* ignore range_cyclic tests */\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tret = gfs2_write_jdata_pagevec(mapping, wbc, &pvec, nr_pages, end, &done_index);\n\t\tif (ret)\n\t\t\tdone = 1;\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (!cycled && !done) {\n\t\t/*\n\t\t * range_cyclic:\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tcycled = 1;\n\t\tindex = 0;\n\t\tend = writeback_index - 1;\n\t\tgoto retry;\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "ip->i_gl",
            "NORMAL_FLUSH"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "mapping->host"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "mapping->host"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_jdata_writepages(struct address_space *mapping,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_sbd *sdp = GFS2_SB(mapping->host);\n\tint ret;\n\n\tret = gfs2_write_cache_jdata(mapping, wbc);\n\tif (ret == 0 && wbc->sync_mode == WB_SYNC_ALL) {\n\t\tgfs2_log_flush(sdp, ip->i_gl, NORMAL_FLUSH);\n\t\tret = gfs2_write_cache_jdata(mapping, wbc);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_write_cache_jdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "344-415",
    "snippet": "static int gfs2_write_cache_jdata(struct address_space *mapping,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tint done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t uninitialized_var(writeback_index);\n\tpgoff_t index;\n\tpgoff_t end;\n\tpgoff_t done_index;\n\tint cycled;\n\tint range_whole = 0;\n\tint tag;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index; /* prev offset */\n\t\tindex = writeback_index;\n\t\tif (index == 0)\n\t\t\tcycled = 1;\n\t\telse\n\t\t\tcycled = 0;\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t\tcycled = 1; /* ignore range_cyclic tests */\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tret = gfs2_write_jdata_pagevec(mapping, wbc, &pvec, nr_pages, end, &done_index);\n\t\tif (ret)\n\t\t\tdone = 1;\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (!cycled && !done) {\n\t\t/*\n\t\t * range_cyclic:\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tcycled = 1;\n\t\tindex = 0;\n\t\tend = writeback_index - 1;\n\t\tgoto retry;\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_write_jdata_pagevec",
          "args": [
            "mapping",
            "wbc",
            "&pvec",
            "nr_pages",
            "end",
            "&done_index"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_write_jdata_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "231-330",
          "snippet": "static int gfs2_write_jdata_pagevec(struct address_space *mapping,\n\t\t\t\t    struct writeback_control *wbc,\n\t\t\t\t    struct pagevec *pvec,\n\t\t\t\t    int nr_pages, pgoff_t end,\n\t\t\t\t    pgoff_t *done_index)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned nrblocks = nr_pages * (PAGE_CACHE_SIZE/inode->i_sb->s_blocksize);\n\tint i;\n\tint ret;\n\n\tret = gfs2_trans_begin(sdp, nrblocks, nrblocks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor(i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\t/*\n\t\t * At this point, the page may be truncated or\n\t\t * invalidated (changing page->mapping to NULL), or\n\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t * mapping. However, page->index will not change\n\t\t * because we have a reference on the page.\n\t\t */\n\t\tif (page->index > end) {\n\t\t\t/*\n\t\t\t * can't be range_cyclic (1st pass) because\n\t\t\t * end == -1 in that case.\n\t\t\t */\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t*done_index = page->index;\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!PageDirty(page)) {\n\t\t\t/* someone wrote it for us */\n\t\t\tgoto continue_unlock;\n\t\t}\n\n\t\tif (PageWriteback(page)) {\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\twait_on_page_writeback(page);\n\t\t\telse\n\t\t\t\tgoto continue_unlock;\n\t\t}\n\n\t\tBUG_ON(PageWriteback(page));\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto continue_unlock;\n\n\t\ttrace_wbc_writepage(wbc, inode_to_bdi(inode));\n\n\t\tret = __gfs2_jdata_writepage(page, wbc);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\n\t\t\t\t/*\n\t\t\t\t * done_index is set past this page,\n\t\t\t\t * so media errors will not choke\n\t\t\t\t * background writeout for the entire\n\t\t\t\t * file. This has consequences for\n\t\t\t\t * range_cyclic semantics (ie. it may\n\t\t\t\t * not be suitable for data integrity\n\t\t\t\t * writeout).\n\t\t\t\t */\n\t\t\t\t*done_index = page->index + 1;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We stop writing back only if we are not doing\n\t\t * integrity sync. In case of integrity sync we have to\n\t\t * keep going until we have written all the pages\n\t\t * we tagged for writeback prior to entering this loop.\n\t\t */\n\t\tif (--wbc->nr_to_write <= 0 && wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tgfs2_trans_end(sdp);\n\treturn ret;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_write_jdata_pagevec(struct address_space *mapping,\n\t\t\t\t    struct writeback_control *wbc,\n\t\t\t\t    struct pagevec *pvec,\n\t\t\t\t    int nr_pages, pgoff_t end,\n\t\t\t\t    pgoff_t *done_index)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned nrblocks = nr_pages * (PAGE_CACHE_SIZE/inode->i_sb->s_blocksize);\n\tint i;\n\tint ret;\n\n\tret = gfs2_trans_begin(sdp, nrblocks, nrblocks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor(i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\t/*\n\t\t * At this point, the page may be truncated or\n\t\t * invalidated (changing page->mapping to NULL), or\n\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t * mapping. However, page->index will not change\n\t\t * because we have a reference on the page.\n\t\t */\n\t\tif (page->index > end) {\n\t\t\t/*\n\t\t\t * can't be range_cyclic (1st pass) because\n\t\t\t * end == -1 in that case.\n\t\t\t */\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t*done_index = page->index;\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!PageDirty(page)) {\n\t\t\t/* someone wrote it for us */\n\t\t\tgoto continue_unlock;\n\t\t}\n\n\t\tif (PageWriteback(page)) {\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\twait_on_page_writeback(page);\n\t\t\telse\n\t\t\t\tgoto continue_unlock;\n\t\t}\n\n\t\tBUG_ON(PageWriteback(page));\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto continue_unlock;\n\n\t\ttrace_wbc_writepage(wbc, inode_to_bdi(inode));\n\n\t\tret = __gfs2_jdata_writepage(page, wbc);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\n\t\t\t\t/*\n\t\t\t\t * done_index is set past this page,\n\t\t\t\t * so media errors will not choke\n\t\t\t\t * background writeout for the entire\n\t\t\t\t * file. This has consequences for\n\t\t\t\t * range_cyclic semantics (ie. it may\n\t\t\t\t * not be suitable for data integrity\n\t\t\t\t * writeout).\n\t\t\t\t */\n\t\t\t\t*done_index = page->index + 1;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We stop writing back only if we are not doing\n\t\t * integrity sync. In case of integrity sync we have to\n\t\t * keep going until we have written all the pages\n\t\t * we tagged for writeback prior to entering this loop.\n\t\t */\n\t\tif (--wbc->nr_to_write <= 0 && wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tgfs2_trans_end(sdp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "tag",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE-1"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag_pages_for_writeback",
          "args": [
            "mapping",
            "index",
            "end"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_write_cache_jdata(struct address_space *mapping,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tint done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t uninitialized_var(writeback_index);\n\tpgoff_t index;\n\tpgoff_t end;\n\tpgoff_t done_index;\n\tint cycled;\n\tint range_whole = 0;\n\tint tag;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index; /* prev offset */\n\t\tindex = writeback_index;\n\t\tif (index == 0)\n\t\t\tcycled = 1;\n\t\telse\n\t\t\tcycled = 0;\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t\tcycled = 1; /* ignore range_cyclic tests */\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\tdone_index = index;\n\twhile (!done && (index <= end)) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tret = gfs2_write_jdata_pagevec(mapping, wbc, &pvec, nr_pages, end, &done_index);\n\t\tif (ret)\n\t\t\tdone = 1;\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (!cycled && !done) {\n\t\t/*\n\t\t * range_cyclic:\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tcycled = 1;\n\t\tindex = 0;\n\t\tend = writeback_index - 1;\n\t\tgoto retry;\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_write_jdata_pagevec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "231-330",
    "snippet": "static int gfs2_write_jdata_pagevec(struct address_space *mapping,\n\t\t\t\t    struct writeback_control *wbc,\n\t\t\t\t    struct pagevec *pvec,\n\t\t\t\t    int nr_pages, pgoff_t end,\n\t\t\t\t    pgoff_t *done_index)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned nrblocks = nr_pages * (PAGE_CACHE_SIZE/inode->i_sb->s_blocksize);\n\tint i;\n\tint ret;\n\n\tret = gfs2_trans_begin(sdp, nrblocks, nrblocks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor(i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\t/*\n\t\t * At this point, the page may be truncated or\n\t\t * invalidated (changing page->mapping to NULL), or\n\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t * mapping. However, page->index will not change\n\t\t * because we have a reference on the page.\n\t\t */\n\t\tif (page->index > end) {\n\t\t\t/*\n\t\t\t * can't be range_cyclic (1st pass) because\n\t\t\t * end == -1 in that case.\n\t\t\t */\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t*done_index = page->index;\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!PageDirty(page)) {\n\t\t\t/* someone wrote it for us */\n\t\t\tgoto continue_unlock;\n\t\t}\n\n\t\tif (PageWriteback(page)) {\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\twait_on_page_writeback(page);\n\t\t\telse\n\t\t\t\tgoto continue_unlock;\n\t\t}\n\n\t\tBUG_ON(PageWriteback(page));\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto continue_unlock;\n\n\t\ttrace_wbc_writepage(wbc, inode_to_bdi(inode));\n\n\t\tret = __gfs2_jdata_writepage(page, wbc);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\n\t\t\t\t/*\n\t\t\t\t * done_index is set past this page,\n\t\t\t\t * so media errors will not choke\n\t\t\t\t * background writeout for the entire\n\t\t\t\t * file. This has consequences for\n\t\t\t\t * range_cyclic semantics (ie. it may\n\t\t\t\t * not be suitable for data integrity\n\t\t\t\t * writeout).\n\t\t\t\t */\n\t\t\t\t*done_index = page->index + 1;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We stop writing back only if we are not doing\n\t\t * integrity sync. In case of integrity sync we have to\n\t\t * keep going until we have written all the pages\n\t\t * we tagged for writeback prior to entering this loop.\n\t\t */\n\t\tif (--wbc->nr_to_write <= 0 && wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tgfs2_trans_end(sdp);\n\treturn ret;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfs2_jdata_writepage",
          "args": [
            "page",
            "wbc"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_jdata_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "154-169",
          "snippet": "static int __gfs2_jdata_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, inode->i_sb->s_blocksize,\n\t\t\t\t\t     (1 << BH_Dirty)|(1 << BH_Uptodate));\n\t\t}\n\t\tgfs2_page_add_databufs(ip, page, 0, sdp->sd_vfs->s_blocksize-1);\n\t}\n\treturn block_write_full_page(page, gfs2_get_block_noalloc, wbc);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int __gfs2_jdata_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, inode->i_sb->s_blocksize,\n\t\t\t\t\t     (1 << BH_Dirty)|(1 << BH_Uptodate));\n\t\t}\n\t\tgfs2_page_add_databufs(ip, page, 0, sdp->sd_vfs->s_blocksize-1);\n\t}\n\treturn block_write_full_page(page, gfs2_get_block_noalloc, wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_wbc_writepage",
          "args": [
            "wbc",
            "inode_to_bdi(inode)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "nrblocks",
            "nrblocks"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_write_jdata_pagevec(struct address_space *mapping,\n\t\t\t\t    struct writeback_control *wbc,\n\t\t\t\t    struct pagevec *pvec,\n\t\t\t\t    int nr_pages, pgoff_t end,\n\t\t\t\t    pgoff_t *done_index)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned nrblocks = nr_pages * (PAGE_CACHE_SIZE/inode->i_sb->s_blocksize);\n\tint i;\n\tint ret;\n\n\tret = gfs2_trans_begin(sdp, nrblocks, nrblocks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor(i = 0; i < nr_pages; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\t/*\n\t\t * At this point, the page may be truncated or\n\t\t * invalidated (changing page->mapping to NULL), or\n\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t * mapping. However, page->index will not change\n\t\t * because we have a reference on the page.\n\t\t */\n\t\tif (page->index > end) {\n\t\t\t/*\n\t\t\t * can't be range_cyclic (1st pass) because\n\t\t\t * end == -1 in that case.\n\t\t\t */\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t*done_index = page->index;\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!PageDirty(page)) {\n\t\t\t/* someone wrote it for us */\n\t\t\tgoto continue_unlock;\n\t\t}\n\n\t\tif (PageWriteback(page)) {\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\t\twait_on_page_writeback(page);\n\t\t\telse\n\t\t\t\tgoto continue_unlock;\n\t\t}\n\n\t\tBUG_ON(PageWriteback(page));\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto continue_unlock;\n\n\t\ttrace_wbc_writepage(wbc, inode_to_bdi(inode));\n\n\t\tret = __gfs2_jdata_writepage(page, wbc);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == AOP_WRITEPAGE_ACTIVATE) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\n\t\t\t\t/*\n\t\t\t\t * done_index is set past this page,\n\t\t\t\t * so media errors will not choke\n\t\t\t\t * background writeout for the entire\n\t\t\t\t * file. This has consequences for\n\t\t\t\t * range_cyclic semantics (ie. it may\n\t\t\t\t * not be suitable for data integrity\n\t\t\t\t * writeout).\n\t\t\t\t */\n\t\t\t\t*done_index = page->index + 1;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We stop writing back only if we are not doing\n\t\t * integrity sync. In case of integrity sync we have to\n\t\t * keep going until we have written all the pages\n\t\t * we tagged for writeback prior to entering this loop.\n\t\t */\n\t\tif (--wbc->nr_to_write <= 0 && wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tgfs2_trans_end(sdp);\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "214-218",
    "snippet": "static int gfs2_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, gfs2_get_block_noalloc);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "gfs2_get_block_noalloc"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, gfs2_get_block_noalloc);\n}"
  },
  {
    "function_name": "gfs2_jdata_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "179-205",
    "snippet": "static int gfs2_jdata_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tint ret;\n\tint done_trans = 0;\n\n\tif (PageChecked(page)) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out_ignore;\n\t\tret = gfs2_trans_begin(sdp, RES_DINODE + 1, 0);\n\t\tif (ret)\n\t\t\tgoto out_ignore;\n\t\tdone_trans = 1;\n\t}\n\tret = gfs2_writepage_common(page, wbc);\n\tif (ret > 0)\n\t\tret = __gfs2_jdata_writepage(page, wbc);\n\tif (done_trans)\n\t\tgfs2_trans_end(sdp);\n\treturn ret;\n\nout_ignore:\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfs2_jdata_writepage",
          "args": [
            "page",
            "wbc"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_jdata_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "154-169",
          "snippet": "static int __gfs2_jdata_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, inode->i_sb->s_blocksize,\n\t\t\t\t\t     (1 << BH_Dirty)|(1 << BH_Uptodate));\n\t\t}\n\t\tgfs2_page_add_databufs(ip, page, 0, sdp->sd_vfs->s_blocksize-1);\n\t}\n\treturn block_write_full_page(page, gfs2_get_block_noalloc, wbc);\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int __gfs2_jdata_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, inode->i_sb->s_blocksize,\n\t\t\t\t\t     (1 << BH_Dirty)|(1 << BH_Uptodate));\n\t\t}\n\t\tgfs2_page_add_databufs(ip, page, 0, sdp->sd_vfs->s_blocksize-1);\n\t}\n\treturn block_write_full_page(page, gfs2_get_block_noalloc, wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_writepage_common",
          "args": [
            "page",
            "wbc"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_writepage_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "97-123",
          "snippet": "static int gfs2_writepage_common(struct page *page,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\tif (gfs2_assert_withdraw(sdp, gfs2_glock_is_held_excl(ip->i_gl)))\n\t\tgoto out;\n\tif (current->journal_info)\n\t\tgoto redirty;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index > end_index || (page->index == end_index && !offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\treturn 1;\nredirty:\n\tredirty_page_for_writepage(wbc, page);\nout:\n\tunlock_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_writepage_common(struct page *page,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\tif (gfs2_assert_withdraw(sdp, gfs2_glock_is_held_excl(ip->i_gl)))\n\t\tgoto out;\n\tif (current->journal_info)\n\t\tgoto redirty;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index > end_index || (page->index == end_index && !offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\treturn 1;\nredirty:\n\tredirty_page_for_writepage(wbc, page);\nout:\n\tunlock_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_DINODE + 1",
            "0"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_jdata_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tint ret;\n\tint done_trans = 0;\n\n\tif (PageChecked(page)) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out_ignore;\n\t\tret = gfs2_trans_begin(sdp, RES_DINODE + 1, 0);\n\t\tif (ret)\n\t\t\tgoto out_ignore;\n\t\tdone_trans = 1;\n\t}\n\tret = gfs2_writepage_common(page, wbc);\n\tif (ret > 0)\n\t\tret = __gfs2_jdata_writepage(page, wbc);\n\tif (done_trans)\n\t\tgfs2_trans_end(sdp);\n\treturn ret;\n\nout_ignore:\n\tredirty_page_for_writepage(wbc, page);\n\tunlock_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "__gfs2_jdata_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "154-169",
    "snippet": "static int __gfs2_jdata_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, inode->i_sb->s_blocksize,\n\t\t\t\t\t     (1 << BH_Dirty)|(1 << BH_Uptodate));\n\t\t}\n\t\tgfs2_page_add_databufs(ip, page, 0, sdp->sd_vfs->s_blocksize-1);\n\t}\n\treturn block_write_full_page(page, gfs2_get_block_noalloc, wbc);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "gfs2_get_block_noalloc",
            "wbc"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_page_add_databufs",
          "args": [
            "ip",
            "page",
            "0",
            "sdp->sd_vfs->s_blocksize-1"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_page_add_databufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "41-58",
          "snippet": "static void gfs2_page_add_databufs(struct gfs2_inode *ip, struct page *page,\n\t\t\t\t   unsigned int from, unsigned int to)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tunsigned int bsize = head->b_size;\n\tstruct buffer_head *bh;\n\tunsigned int start, end;\n\n\tfor (bh = head, start = 0; bh != head || !start;\n\t     bh = bh->b_this_page, start = end) {\n\t\tend = start + bsize;\n\t\tif (end <= from || start >= to)\n\t\t\tcontinue;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tset_buffer_uptodate(bh);\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\t}\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_page_add_databufs(struct gfs2_inode *ip, struct page *page,\n\t\t\t\t   unsigned int from, unsigned int to)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tunsigned int bsize = head->b_size;\n\tstruct buffer_head *bh;\n\tunsigned int start, end;\n\n\tfor (bh = head, start = 0; bh != head || !start;\n\t     bh = bh->b_this_page, start = end) {\n\t\tend = start + bsize;\n\t\tif (end <= from || start >= to)\n\t\t\tcontinue;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tset_buffer_uptodate(bh);\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "inode->i_sb->s_blocksize",
            "(1 << BH_Dirty)|(1 << BH_Uptodate)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int __gfs2_jdata_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, inode->i_sb->s_blocksize,\n\t\t\t\t\t     (1 << BH_Dirty)|(1 << BH_Uptodate));\n\t\t}\n\t\tgfs2_page_add_databufs(ip, page, 0, sdp->sd_vfs->s_blocksize-1);\n\t}\n\treturn block_write_full_page(page, gfs2_get_block_noalloc, wbc);\n}"
  },
  {
    "function_name": "gfs2_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "132-141",
    "snippet": "static int gfs2_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tret = gfs2_writepage_common(page, wbc);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\treturn nobh_writepage(page, gfs2_get_block_noalloc, wbc);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nobh_writepage",
          "args": [
            "page",
            "gfs2_get_block_noalloc",
            "wbc"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "nobh_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2681-2725",
          "snippet": "int nobh_writepage(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\tint ret;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\tgoto out;\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n#if 0\n\t\t/* Not really sure about this  - do we need this ? */\n\t\tif (page->mapping->a_ops->invalidatepage)\n\t\t\tpage->mapping->a_ops->invalidatepage(page, offset);\n#endif\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\nout:\n\tret = mpage_writepage(page, get_block, wbc);\n\tif (ret == -EAGAIN)\n\t\tret = __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t      end_buffer_async_write);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint nobh_writepage(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\tint ret;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\tgoto out;\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n#if 0\n\t\t/* Not really sure about this  - do we need this ? */\n\t\tif (page->mapping->a_ops->invalidatepage)\n\t\t\tpage->mapping->a_ops->invalidatepage(page, offset);\n#endif\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\nout:\n\tret = mpage_writepage(page, get_block, wbc);\n\tif (ret == -EAGAIN)\n\t\tret = __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t      end_buffer_async_write);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_writepage_common",
          "args": [
            "page",
            "wbc"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_writepage_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "97-123",
          "snippet": "static int gfs2_writepage_common(struct page *page,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\tif (gfs2_assert_withdraw(sdp, gfs2_glock_is_held_excl(ip->i_gl)))\n\t\tgoto out;\n\tif (current->journal_info)\n\t\tgoto redirty;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index > end_index || (page->index == end_index && !offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\treturn 1;\nredirty:\n\tredirty_page_for_writepage(wbc, page);\nout:\n\tunlock_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_writepage_common(struct page *page,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\tif (gfs2_assert_withdraw(sdp, gfs2_glock_is_held_excl(ip->i_gl)))\n\t\tgoto out;\n\tif (current->journal_info)\n\t\tgoto redirty;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index > end_index || (page->index == end_index && !offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\treturn 1;\nredirty:\n\tredirty_page_for_writepage(wbc, page);\nout:\n\tunlock_page(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tret = gfs2_writepage_common(page, wbc);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\treturn nobh_writepage(page, gfs2_get_block_noalloc, wbc);\n}"
  },
  {
    "function_name": "gfs2_writepage_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "97-123",
    "snippet": "static int gfs2_writepage_common(struct page *page,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\tif (gfs2_assert_withdraw(sdp, gfs2_glock_is_held_excl(ip->i_gl)))\n\t\tgoto out;\n\tif (current->journal_info)\n\t\tgoto redirty;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index > end_index || (page->index == end_index && !offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\treturn 1;\nredirty:\n\tredirty_page_for_writepage(wbc, page);\nout:\n\tunlock_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page->mapping->a_ops->invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "gfs2_glock_is_held_excl(ip->i_gl)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_is_held_excl",
          "args": [
            "ip->i_gl"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_is_held_excl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "159-162",
          "snippet": "static inline int gfs2_glock_is_held_excl(struct gfs2_glock *gl)\n{\n\treturn gl->gl_state == LM_ST_EXCLUSIVE;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define LM_ST_EXCLUSIVE\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\n#define LM_ST_EXCLUSIVE\t\t1\n\nstatic inline int gfs2_glock_is_held_excl(struct gfs2_glock *gl)\n{\n\treturn gl->gl_state == LM_ST_EXCLUSIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_writepage_common(struct page *page,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\tif (gfs2_assert_withdraw(sdp, gfs2_glock_is_held_excl(ip->i_gl)))\n\t\tgoto out;\n\tif (current->journal_info)\n\t\tgoto redirty;\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index > end_index || (page->index == end_index && !offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\treturn 1;\nredirty:\n\tredirty_page_for_writepage(wbc, page);\nout:\n\tunlock_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_get_block_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "83-87",
    "snippet": "static int gfs2_get_block_direct(struct inode *inode, sector_t lblock,\n\t\t\t\t struct buffer_head *bh_result, int create)\n{\n\treturn gfs2_block_map(inode, lblock, bh_result, 0);\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "inode",
            "lblock",
            "bh_result",
            "0"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_get_block_direct(struct inode *inode, sector_t lblock,\n\t\t\t\t struct buffer_head *bh_result, int create)\n{\n\treturn gfs2_block_map(inode, lblock, bh_result, 0);\n}"
  },
  {
    "function_name": "gfs2_get_block_noalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "70-81",
    "snippet": "static int gfs2_get_block_noalloc(struct inode *inode, sector_t lblock,\n\t\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tint error;\n\n\terror = gfs2_block_map(inode, lblock, bh_result, 0);\n\tif (error)\n\t\treturn error;\n\tif (!buffer_mapped(bh_result))\n\t\treturn -EIO;\n\treturn 0;\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh_result"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "inode",
            "lblock",
            "bh_result",
            "0"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int gfs2_get_block_noalloc(struct inode *inode, sector_t lblock,\n\t\t\t\t  struct buffer_head *bh_result, int create)\n{\n\tint error;\n\n\terror = gfs2_block_map(inode, lblock, bh_result, 0);\n\tif (error)\n\t\treturn error;\n\tif (!buffer_mapped(bh_result))\n\t\treturn -EIO;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_page_add_databufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
    "lines": "41-58",
    "snippet": "static void gfs2_page_add_databufs(struct gfs2_inode *ip, struct page *page,\n\t\t\t\t   unsigned int from, unsigned int to)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tunsigned int bsize = head->b_size;\n\tstruct buffer_head *bh;\n\tunsigned int start, end;\n\n\tfor (bh = head, start = 0; bh != head || !start;\n\t     bh = bh->b_this_page, start = end) {\n\t\tend = start + bsize;\n\t\tif (end <= from || start >= to)\n\t\t\tcontinue;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tset_buffer_uptodate(bh);\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\t}\n}",
    "includes": [
      "#include \"glops.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"trans.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/aio.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/fs.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_add_data",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "158-193",
          "snippet": "void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_page_add_databufs(struct gfs2_inode *ip, struct page *page,\n\t\t\t\t   unsigned int from, unsigned int to)\n{\n\tstruct buffer_head *head = page_buffers(page);\n\tunsigned int bsize = head->b_size;\n\tstruct buffer_head *bh;\n\tunsigned int start, end;\n\n\tfor (bh = head, start = 0; bh != head || !start;\n\t     bh = bh->b_this_page, start = end) {\n\t\tend = start + bsize;\n\t\tif (end <= from || start >= to)\n\t\t\tcontinue;\n\t\tif (gfs2_is_jdata(ip))\n\t\t\tset_buffer_uptodate(bh);\n\t\tgfs2_trans_add_data(ip->i_gl, bh);\n\t}\n}"
  }
]