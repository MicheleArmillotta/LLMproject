[
  {
    "function_name": "ecryptfs_read_lower_page_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
    "lines": "256-273",
    "snippet": "int ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);\n\tvirt = kmap(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_ecryptfs);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page_for_ecryptfs"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page_for_ecryptfs"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_lower",
          "args": [
            "virt",
            "offset",
            "size",
            "ecryptfs_inode"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "231-239",
          "snippet": "int ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page_for_ecryptfs"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower_page_segment(struct page *page_for_ecryptfs,\n\t\t\t\t     pgoff_t page_index,\n\t\t\t\t     size_t offset_in_page, size_t size,\n\t\t\t\t     struct inode *ecryptfs_inode)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_index) << PAGE_CACHE_SHIFT) + offset_in_page);\n\tvirt = kmap(page_for_ecryptfs);\n\trc = ecryptfs_read_lower(virt, offset, size, ecryptfs_inode);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_ecryptfs);\n\tflush_dcache_page(page_for_ecryptfs);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_read_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
    "lines": "231-239",
    "snippet": "int ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "lower_file",
            "offset",
            "data",
            "size"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "569-583",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}"
  },
  {
    "function_name": "ecryptfs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
    "lines": "105-216",
    "snippet": "int ecryptfs_write(struct inode *ecryptfs_inode, char *data, loff_t offset,\n\t\t   size_t size)\n{\n\tstruct page *ecryptfs_page;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *ecryptfs_page_virt;\n\tloff_t ecryptfs_file_size = i_size_read(ecryptfs_inode);\n\tloff_t data_offset = 0;\n\tloff_t pos;\n\tint rc = 0;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\t/*\n\t * if we are writing beyond current size, then start pos\n\t * at the current size - we'll fill in zeros from there.\n\t */\n\tif (offset > ecryptfs_file_size)\n\t\tpos = ecryptfs_file_size;\n\telse\n\t\tpos = offset;\n\twhile (pos < (offset + size)) {\n\t\tpgoff_t ecryptfs_page_idx = (pos >> PAGE_CACHE_SHIFT);\n\t\tsize_t start_offset_in_page = (pos & ~PAGE_CACHE_MASK);\n\t\tsize_t num_bytes = (PAGE_CACHE_SIZE - start_offset_in_page);\n\t\tloff_t total_remaining_bytes = ((offset + size) - pos);\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (num_bytes > total_remaining_bytes)\n\t\t\tnum_bytes = total_remaining_bytes;\n\t\tif (pos < offset) {\n\t\t\t/* remaining zeros to write, up to destination offset */\n\t\t\tloff_t total_remaining_zeros = (offset - pos);\n\n\t\t\tif (num_bytes > total_remaining_zeros)\n\t\t\t\tnum_bytes = total_remaining_zeros;\n\t\t}\n\t\tecryptfs_page = ecryptfs_get_locked_page(ecryptfs_inode,\n\t\t\t\t\t\t\t ecryptfs_page_idx);\n\t\tif (IS_ERR(ecryptfs_page)) {\n\t\t\trc = PTR_ERR(ecryptfs_page);\n\t\t\tprintk(KERN_ERR \"%s: Error getting page at \"\n\t\t\t       \"index [%ld] from eCryptfs inode \"\n\t\t\t       \"mapping; rc = [%d]\\n\", __func__,\n\t\t\t       ecryptfs_page_idx, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_page_virt = kmap_atomic(ecryptfs_page);\n\n\t\t/*\n\t\t * pos: where we're now writing, offset: where the request was\n\t\t * If current pos is before request, we are filling zeros\n\t\t * If we are at or beyond request, we are writing the *data*\n\t\t * If we're in a fresh page beyond eof, zero it in either case\n\t\t */\n\t\tif (pos < offset || !start_offset_in_page) {\n\t\t\t/* We are extending past the previous end of the file.\n\t\t\t * Fill in zero values to the end of the page */\n\t\t\tmemset(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page), 0,\n\t\t\t\tPAGE_CACHE_SIZE - start_offset_in_page);\n\t\t}\n\n\t\t/* pos >= offset, we are now writing the data request */\n\t\tif (pos >= offset) {\n\t\t\tmemcpy(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page),\n\t\t\t       (data + data_offset), num_bytes);\n\t\t\tdata_offset += num_bytes;\n\t\t}\n\t\tkunmap_atomic(ecryptfs_page_virt);\n\t\tflush_dcache_page(ecryptfs_page);\n\t\tSetPageUptodate(ecryptfs_page);\n\t\tunlock_page(ecryptfs_page);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED)\n\t\t\trc = ecryptfs_encrypt_page(ecryptfs_page);\n\t\telse\n\t\t\trc = ecryptfs_write_lower_page_segment(ecryptfs_inode,\n\t\t\t\t\t\tecryptfs_page,\n\t\t\t\t\t\tstart_offset_in_page,\n\t\t\t\t\t\tdata_offset);\n\t\tpage_cache_release(ecryptfs_page);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting \"\n\t\t\t       \"page; rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tpos += num_bytes;\n\t}\n\tif (pos > ecryptfs_file_size) {\n\t\ti_size_write(ecryptfs_inode, pos);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED) {\n\t\t\tint rc2;\n\n\t\t\trc2 = ecryptfs_write_inode_size_to_metadata(\n\t\t\t\t\t\t\t\tecryptfs_inode);\n\t\t\tif (rc2) {\n\t\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t\t       \"rc = [%d]\\n\", rc2);\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = rc2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\t\"Problem with \"\n\t\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t\t       \"rc = [%d]\\n\"",
            "rc2"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_inode_size_to_metadata",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_inode_size_to_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "456-466",
          "snippet": "int ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint ecryptfs_write_inode_size_to_metadata(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn ecryptfs_write_inode_size_to_xattr(ecryptfs_inode);\n\telse\n\t\treturn ecryptfs_write_inode_size_to_header(ecryptfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "ecryptfs_inode",
            "pos"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "ecryptfs_page"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_lower_page_segment",
          "args": [
            "ecryptfs_inode",
            "ecryptfs_page",
            "start_offset_in_page",
            "data_offset"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "69-85",
          "snippet": "int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_encrypt_page",
          "args": [
            "ecryptfs_page"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_encrypt_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "486-537",
          "snippet": "int ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_CACHE_SIZE);\n\tkunmap(enc_extent_page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ENCRYPT\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nint ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_CACHE_SIZE);\n\tkunmap(enc_extent_page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "ecryptfs_page"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "ecryptfs_page"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "ecryptfs_page"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "ecryptfs_page_virt"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page)",
            "(data + data_offset)",
            "num_bytes"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page)",
            "0",
            "PAGE_CACHE_SIZE - start_offset_in_page"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "ecryptfs_page"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ecryptfs_page"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ecryptfs_page"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_locked_page",
          "args": [
            "ecryptfs_inode",
            "ecryptfs_page_idx"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_locked_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/mmap.c",
          "lines": "47-53",
          "snippet": "struct page *ecryptfs_get_locked_page(struct inode *inode, loff_t index)\n{\n\tstruct page *page = read_mapping_page(inode->i_mapping, index, NULL);\n\tif (!IS_ERR(page))\n\t\tlock_page(page);\n\treturn page;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/page-flags.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nstruct page *ecryptfs_get_locked_page(struct inode *inode, loff_t index)\n{\n\tstruct page *page = read_mapping_page(inode->i_mapping, index, NULL);\n\tif (!IS_ERR(page))\n\t\tlock_page(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write(struct inode *ecryptfs_inode, char *data, loff_t offset,\n\t\t   size_t size)\n{\n\tstruct page *ecryptfs_page;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *ecryptfs_page_virt;\n\tloff_t ecryptfs_file_size = i_size_read(ecryptfs_inode);\n\tloff_t data_offset = 0;\n\tloff_t pos;\n\tint rc = 0;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\t/*\n\t * if we are writing beyond current size, then start pos\n\t * at the current size - we'll fill in zeros from there.\n\t */\n\tif (offset > ecryptfs_file_size)\n\t\tpos = ecryptfs_file_size;\n\telse\n\t\tpos = offset;\n\twhile (pos < (offset + size)) {\n\t\tpgoff_t ecryptfs_page_idx = (pos >> PAGE_CACHE_SHIFT);\n\t\tsize_t start_offset_in_page = (pos & ~PAGE_CACHE_MASK);\n\t\tsize_t num_bytes = (PAGE_CACHE_SIZE - start_offset_in_page);\n\t\tloff_t total_remaining_bytes = ((offset + size) - pos);\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (num_bytes > total_remaining_bytes)\n\t\t\tnum_bytes = total_remaining_bytes;\n\t\tif (pos < offset) {\n\t\t\t/* remaining zeros to write, up to destination offset */\n\t\t\tloff_t total_remaining_zeros = (offset - pos);\n\n\t\t\tif (num_bytes > total_remaining_zeros)\n\t\t\t\tnum_bytes = total_remaining_zeros;\n\t\t}\n\t\tecryptfs_page = ecryptfs_get_locked_page(ecryptfs_inode,\n\t\t\t\t\t\t\t ecryptfs_page_idx);\n\t\tif (IS_ERR(ecryptfs_page)) {\n\t\t\trc = PTR_ERR(ecryptfs_page);\n\t\t\tprintk(KERN_ERR \"%s: Error getting page at \"\n\t\t\t       \"index [%ld] from eCryptfs inode \"\n\t\t\t       \"mapping; rc = [%d]\\n\", __func__,\n\t\t\t       ecryptfs_page_idx, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_page_virt = kmap_atomic(ecryptfs_page);\n\n\t\t/*\n\t\t * pos: where we're now writing, offset: where the request was\n\t\t * If current pos is before request, we are filling zeros\n\t\t * If we are at or beyond request, we are writing the *data*\n\t\t * If we're in a fresh page beyond eof, zero it in either case\n\t\t */\n\t\tif (pos < offset || !start_offset_in_page) {\n\t\t\t/* We are extending past the previous end of the file.\n\t\t\t * Fill in zero values to the end of the page */\n\t\t\tmemset(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page), 0,\n\t\t\t\tPAGE_CACHE_SIZE - start_offset_in_page);\n\t\t}\n\n\t\t/* pos >= offset, we are now writing the data request */\n\t\tif (pos >= offset) {\n\t\t\tmemcpy(((char *)ecryptfs_page_virt\n\t\t\t\t+ start_offset_in_page),\n\t\t\t       (data + data_offset), num_bytes);\n\t\t\tdata_offset += num_bytes;\n\t\t}\n\t\tkunmap_atomic(ecryptfs_page_virt);\n\t\tflush_dcache_page(ecryptfs_page);\n\t\tSetPageUptodate(ecryptfs_page);\n\t\tunlock_page(ecryptfs_page);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED)\n\t\t\trc = ecryptfs_encrypt_page(ecryptfs_page);\n\t\telse\n\t\t\trc = ecryptfs_write_lower_page_segment(ecryptfs_inode,\n\t\t\t\t\t\tecryptfs_page,\n\t\t\t\t\t\tstart_offset_in_page,\n\t\t\t\t\t\tdata_offset);\n\t\tpage_cache_release(ecryptfs_page);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting \"\n\t\t\t       \"page; rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t\tpos += num_bytes;\n\t}\n\tif (pos > ecryptfs_file_size) {\n\t\ti_size_write(ecryptfs_inode, pos);\n\t\tif (crypt_stat->flags & ECRYPTFS_ENCRYPTED) {\n\t\t\tint rc2;\n\n\t\t\trc2 = ecryptfs_write_inode_size_to_metadata(\n\t\t\t\t\t\t\t\tecryptfs_inode);\n\t\t\tif (rc2) {\n\t\t\t\tprintk(KERN_ERR\t\"Problem with \"\n\t\t\t\t       \"ecryptfs_write_inode_size_to_metadata; \"\n\t\t\t\t       \"rc = [%d]\\n\", rc2);\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = rc2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_lower_page_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
    "lines": "69-85",
    "snippet": "int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page_for_lower"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_lower",
          "args": [
            "ecryptfs_inode",
            "virt",
            "offset",
            "size"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "69-85",
          "snippet": "int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page_for_lower"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
    "lines": "39-51",
    "snippet": "int ecryptfs_write_lower(struct inode *ecryptfs_inode, char *data,\n\t\t\t loff_t offset, size_t size)\n{\n\tstruct file *lower_file;\n\tssize_t rc;\n\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\trc = kernel_write(lower_file, data, size, offset);\n\tmark_inode_dirty_sync(ecryptfs_inode);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "lower_file",
            "data",
            "size",
            "offset"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "__kernel_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "545-572",
          "snippet": "ssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->aio_write)\n\t\tret = do_sync_write(file, p, count, pos);\n\telse\n\t\tret = new_sync_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->aio_write)\n\t\tret = do_sync_write(file, p, count, pos);\n\telse\n\t\tret = new_sync_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_lower(struct inode *ecryptfs_inode, char *data,\n\t\t\t loff_t offset, size_t size)\n{\n\tstruct file *lower_file;\n\tssize_t rc;\n\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\trc = kernel_write(lower_file, data, size, offset);\n\tmark_inode_dirty_sync(ecryptfs_inode);\n\treturn rc;\n}"
  }
]