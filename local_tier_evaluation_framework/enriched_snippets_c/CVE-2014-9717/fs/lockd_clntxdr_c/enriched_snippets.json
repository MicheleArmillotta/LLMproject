[
  {
    "function_name": "nlm_xdr_dec_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "544-556",
    "snippet": "static int nlm_xdr_dec_res(struct rpc_rqst *req,\n\t\t\t   struct xdr_stream *xdr,\n\t\t\t   struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_cookie(xdr, &result->cookie);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nlm_stat(xdr, &result->status);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_nlm_stat",
          "args": [
            "xdr",
            "&result->status"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "decode_nlm_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "226-245",
          "snippet": "static int decode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t   __be32 *stat)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tif (unlikely(ntohl(*p) > ntohl(nlm_lck_denied_grace_period)))\n\t\tgoto out_enum;\n\t*stat = *p;\n\treturn 0;\nout_enum:\n\tdprintk(\"%s: server returned invalid nlm_stats value: %u\\n\",\n\t\t__func__, be32_to_cpup(p));\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t   __be32 *stat)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tif (unlikely(ntohl(*p) > ntohl(nlm_lck_denied_grace_period)))\n\t\tgoto out_enum;\n\t*stat = *p;\n\treturn 0;\nout_enum:\n\tdprintk(\"%s: server returned invalid nlm_stats value: %u\\n\",\n\t\t__func__, be32_to_cpup(p));\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cookie",
          "args": [
            "xdr",
            "&result->cookie"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "156-187",
          "snippet": "static int decode_cookie(struct xdr_stream *xdr,\n\t\t\t struct nlm_cookie *cookie)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\t/* apparently HPUX can return empty cookies */\n\tif (length == 0)\n\t\tgoto out_hpux;\n\tif (length > NLM_MAXCOOKIELEN)\n\t\tgoto out_size;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tcookie->len = length;\n\tmemcpy(cookie->data, p, length);\n\treturn 0;\nout_hpux:\n\tcookie->len = 4;\n\tmemset(cookie->data, 0, 4);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned cookie was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_cookie(struct xdr_stream *xdr,\n\t\t\t struct nlm_cookie *cookie)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\t/* apparently HPUX can return empty cookies */\n\tif (length == 0)\n\t\tgoto out_hpux;\n\tif (length > NLM_MAXCOOKIELEN)\n\t\tgoto out_size;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tcookie->len = length;\n\tmemcpy(cookie->data, p, length);\n\treturn 0;\nout_hpux:\n\tcookie->len = 4;\n\tmemset(cookie->data, 0, 4);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned cookie was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int nlm_xdr_dec_res(struct rpc_rqst *req,\n\t\t\t   struct xdr_stream *xdr,\n\t\t\t   struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_cookie(xdr, &result->cookie);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nlm_stat(xdr, &result->status);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "nlm_xdr_dec_testres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "524-536",
    "snippet": "static int nlm_xdr_dec_testres(struct rpc_rqst *req,\n\t\t\t       struct xdr_stream *xdr,\n\t\t\t       struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_cookie(xdr, &result->cookie);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nlm_testrply(xdr, result);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_nlm_testrply",
          "args": [
            "xdr",
            "result"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "decode_nlm_testrply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "510-522",
          "snippet": "static int decode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t       struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_nlm_stat(xdr, &result->status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (result->status == nlm_lck_denied)\n\t\terror = decode_nlm_holder(xdr, result);\nout:\n\treturn error;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t       struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_nlm_stat(xdr, &result->status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (result->status == nlm_lck_denied)\n\t\terror = decode_nlm_holder(xdr, result);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cookie",
          "args": [
            "xdr",
            "&result->cookie"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "156-187",
          "snippet": "static int decode_cookie(struct xdr_stream *xdr,\n\t\t\t struct nlm_cookie *cookie)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\t/* apparently HPUX can return empty cookies */\n\tif (length == 0)\n\t\tgoto out_hpux;\n\tif (length > NLM_MAXCOOKIELEN)\n\t\tgoto out_size;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tcookie->len = length;\n\tmemcpy(cookie->data, p, length);\n\treturn 0;\nout_hpux:\n\tcookie->len = 4;\n\tmemset(cookie->data, 0, 4);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned cookie was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_cookie(struct xdr_stream *xdr,\n\t\t\t struct nlm_cookie *cookie)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\t/* apparently HPUX can return empty cookies */\n\tif (length == 0)\n\t\tgoto out_hpux;\n\tif (length > NLM_MAXCOOKIELEN)\n\t\tgoto out_size;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tcookie->len = length;\n\tmemcpy(cookie->data, p, length);\n\treturn 0;\nout_hpux:\n\tcookie->len = 4;\n\tmemset(cookie->data, 0, 4);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned cookie was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int nlm_xdr_dec_testres(struct rpc_rqst *req,\n\t\t\t       struct xdr_stream *xdr,\n\t\t\t       struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_cookie(xdr, &result->cookie);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = decode_nlm_testrply(xdr, result);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "decode_nlm_testrply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "510-522",
    "snippet": "static int decode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t       struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_nlm_stat(xdr, &result->status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (result->status == nlm_lck_denied)\n\t\terror = decode_nlm_holder(xdr, result);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_nlm_holder",
          "args": [
            "xdr",
            "result"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "decode_nlm_holder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "273-317",
          "snippet": "static int decode_nlm_holder(struct xdr_stream *xdr, struct nlm_res *result)\n{\n\tstruct nlm_lock *lock = &result->lock;\n\tstruct file_lock *fl = &lock->fl;\n\tu32 exclusive, l_offset, l_len;\n\tint error;\n\t__be32 *p;\n\ts32 end;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(fl);\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\texclusive = be32_to_cpup(p++);\n\tlock->svid = be32_to_cpup(p);\n\tfl->fl_pid = (pid_t)lock->svid;\n\n\terror = decode_netobj(xdr, &lock->oh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = exclusive != 0 ? F_WRLCK : F_RDLCK;\n\tl_offset = be32_to_cpup(p++);\n\tl_len = be32_to_cpup(p);\n\tend = l_offset + l_len - 1;\n\n\tfl->fl_start = (loff_t)l_offset;\n\tif (l_len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = (loff_t)end;\n\terror = 0;\nout:\n\treturn error;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_nlm_holder(struct xdr_stream *xdr, struct nlm_res *result)\n{\n\tstruct nlm_lock *lock = &result->lock;\n\tstruct file_lock *fl = &lock->fl;\n\tu32 exclusive, l_offset, l_len;\n\tint error;\n\t__be32 *p;\n\ts32 end;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(fl);\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\texclusive = be32_to_cpup(p++);\n\tlock->svid = be32_to_cpup(p);\n\tfl->fl_pid = (pid_t)lock->svid;\n\n\terror = decode_netobj(xdr, &lock->oh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = exclusive != 0 ? F_WRLCK : F_RDLCK;\n\tl_offset = be32_to_cpup(p++);\n\tl_len = be32_to_cpup(p);\n\tend = l_offset + l_len - 1;\n\n\tfl->fl_start = (loff_t)l_offset;\n\tif (l_len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = (loff_t)end;\n\terror = 0;\nout:\n\treturn error;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_nlm_stat",
          "args": [
            "xdr",
            "&result->status"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "decode_nlm_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "226-245",
          "snippet": "static int decode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t   __be32 *stat)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tif (unlikely(ntohl(*p) > ntohl(nlm_lck_denied_grace_period)))\n\t\tgoto out_enum;\n\t*stat = *p;\n\treturn 0;\nout_enum:\n\tdprintk(\"%s: server returned invalid nlm_stats value: %u\\n\",\n\t\t__func__, be32_to_cpup(p));\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t   __be32 *stat)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tif (unlikely(ntohl(*p) > ntohl(nlm_lck_denied_grace_period)))\n\t\tgoto out_enum;\n\t*stat = *p;\n\treturn 0;\nout_enum:\n\tdprintk(\"%s: server returned invalid nlm_stats value: %u\\n\",\n\t\t__func__, be32_to_cpup(p));\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t       struct nlm_res *result)\n{\n\tint error;\n\n\terror = decode_nlm_stat(xdr, &result->status);\n\tif (unlikely(error))\n\t\tgoto out;\n\tif (result->status == nlm_lck_denied)\n\t\terror = decode_nlm_holder(xdr, result);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "nlm_xdr_enc_testres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "480-487",
    "snippet": "static void nlm_xdr_enc_testres(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tconst struct nlm_res *result)\n{\n\tencode_cookie(xdr, &result->cookie);\n\tencode_nlm_stat(xdr, result->status);\n\tencode_nlm_testrply(xdr, result);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_nlm_testrply",
          "args": [
            "xdr",
            "result"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nlm_testrply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "473-478",
          "snippet": "static void encode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t\tconst struct nlm_res *result)\n{\n\tif (result->status == nlm_lck_denied)\n\t\tencode_nlm_holder(xdr, result);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t\tconst struct nlm_res *result)\n{\n\tif (result->status == nlm_lck_denied)\n\t\tencode_nlm_holder(xdr, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_nlm_stat",
          "args": [
            "xdr",
            "result->status"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nlm_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "216-224",
          "snippet": "static void encode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t    const __be32 stat)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = stat;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t    const __be32 stat)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = stat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cookie",
          "args": [
            "xdr",
            "&result->cookie"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "150-154",
          "snippet": "static void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_xdr_enc_testres(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tconst struct nlm_res *result)\n{\n\tencode_cookie(xdr, &result->cookie);\n\tencode_nlm_stat(xdr, result->status);\n\tencode_nlm_testrply(xdr, result);\n}"
  },
  {
    "function_name": "encode_nlm_testrply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "473-478",
    "snippet": "static void encode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t\tconst struct nlm_res *result)\n{\n\tif (result->status == nlm_lck_denied)\n\t\tencode_nlm_holder(xdr, result);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_nlm_holder",
          "args": [
            "xdr",
            "result"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nlm_holder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "256-271",
          "snippet": "static void encode_nlm_holder(struct xdr_stream *xdr,\n\t\t\t      const struct nlm_res *result)\n{\n\tconst struct nlm_lock *lock = &result->lock;\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_bool(xdr, lock->fl.fl_type == F_RDLCK);\n\tencode_int32(xdr, lock->svid);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4);\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_holder(struct xdr_stream *xdr,\n\t\t\t      const struct nlm_res *result)\n{\n\tconst struct nlm_lock *lock = &result->lock;\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_bool(xdr, lock->fl.fl_type == F_RDLCK);\n\tencode_int32(xdr, lock->svid);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4);\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_testrply(struct xdr_stream *xdr,\n\t\t\t\tconst struct nlm_res *result)\n{\n\tif (result->status == nlm_lck_denied)\n\t\tencode_nlm_holder(xdr, result);\n}"
  },
  {
    "function_name": "nlm_xdr_enc_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "452-458",
    "snippet": "static void nlm_xdr_enc_res(struct rpc_rqst *req,\n\t\t\t    struct xdr_stream *xdr,\n\t\t\t    const struct nlm_res *result)\n{\n\tencode_cookie(xdr, &result->cookie);\n\tencode_nlm_stat(xdr, result->status);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_nlm_stat",
          "args": [
            "xdr",
            "result->status"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nlm_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "216-224",
          "snippet": "static void encode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t    const __be32 stat)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = stat;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t    const __be32 stat)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = stat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cookie",
          "args": [
            "xdr",
            "&result->cookie"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "150-154",
          "snippet": "static void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_xdr_enc_res(struct rpc_rqst *req,\n\t\t\t    struct xdr_stream *xdr,\n\t\t\t    const struct nlm_res *result)\n{\n\tencode_cookie(xdr, &result->cookie);\n\tencode_nlm_stat(xdr, result->status);\n}"
  },
  {
    "function_name": "nlm_xdr_enc_unlockargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "436-444",
    "snippet": "static void nlm_xdr_enc_unlockargs(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const struct nlm_args *args)\n{\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_nlm_lock(xdr, lock);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_nlm_lock",
          "args": [
            "xdr",
            "lock"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "342-358",
          "snippet": "static void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cookie",
          "args": [
            "xdr",
            "&args->cookie"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "150-154",
          "snippet": "static void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_xdr_enc_unlockargs(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const struct nlm_args *args)\n{\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_nlm_lock(xdr, lock);\n}"
  },
  {
    "function_name": "nlm_xdr_enc_cancargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "418-428",
    "snippet": "static void nlm_xdr_enc_cancargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const struct nlm_args *args)\n{\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, args->block);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_nlm_lock",
          "args": [
            "xdr",
            "lock"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "342-358",
          "snippet": "static void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_bool",
          "args": [
            "xdr",
            "lock->fl.fl_type == F_WRLCK"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "encode_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "96-102",
          "snippet": "static void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cookie",
          "args": [
            "xdr",
            "&args->cookie"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "150-154",
          "snippet": "static void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_xdr_enc_cancargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const struct nlm_args *args)\n{\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, args->block);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n}"
  },
  {
    "function_name": "nlm_xdr_enc_lockargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "396-408",
    "snippet": "static void nlm_xdr_enc_lockargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const struct nlm_args *args)\n{\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, args->block);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n\tencode_bool(xdr, args->reclaim);\n\tencode_int32(xdr, args->state);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_int32",
          "args": [
            "xdr",
            "args->state"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "encode_int32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "104-110",
          "snippet": "static void encode_int32(struct xdr_stream *xdr, const s32 value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_int32(struct xdr_stream *xdr, const s32 value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_bool",
          "args": [
            "xdr",
            "args->reclaim"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "encode_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "96-102",
          "snippet": "static void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_nlm_lock",
          "args": [
            "xdr",
            "lock"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "342-358",
          "snippet": "static void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cookie",
          "args": [
            "xdr",
            "&args->cookie"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "150-154",
          "snippet": "static void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_xdr_enc_lockargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const struct nlm_args *args)\n{\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, args->block);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n\tencode_bool(xdr, args->reclaim);\n\tencode_int32(xdr, args->state);\n}"
  },
  {
    "function_name": "nlm_xdr_enc_testargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "375-384",
    "snippet": "static void nlm_xdr_enc_testargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const struct nlm_args *args)\n{\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_nlm_lock",
          "args": [
            "xdr",
            "lock"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "342-358",
          "snippet": "static void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_bool",
          "args": [
            "xdr",
            "lock->fl.fl_type == F_WRLCK"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "encode_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "96-102",
          "snippet": "static void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cookie",
          "args": [
            "xdr",
            "&args->cookie"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "150-154",
          "snippet": "static void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_xdr_enc_testargs(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const struct nlm_args *args)\n{\n\tconst struct nlm_lock *lock = &args->lock;\n\n\tencode_cookie(xdr, &args->cookie);\n\tencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\n\tencode_nlm_lock(xdr, lock);\n}"
  },
  {
    "function_name": "encode_nlm_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "342-358",
    "snippet": "static void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "l_len"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "l_offset"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_compute_offsets",
          "args": [
            "lock",
            "&l_offset",
            "&l_len"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_compute_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "60-70",
          "snippet": "static void nlm_compute_offsets(const struct nlm_lock *lock,\n\t\t\t\tu32 *l_offset, u32 *l_len)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\n\t*l_offset = loff_t_to_s32(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\t*l_len = 0;\n\telse\n\t\t*l_len = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_compute_offsets(const struct nlm_lock *lock,\n\t\t\t\tu32 *l_offset, u32 *l_len)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\n\t*l_offset = loff_t_to_s32(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\t*l_len = 0;\n\telse\n\t\t*l_len = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lock->svid"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + 4 + 4"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_netobj",
          "args": [
            "xdr",
            "lock->oh.data",
            "lock->oh.len"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "encode_netobj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "115-122",
          "snippet": "static void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_fh",
          "args": [
            "xdr",
            "&lock->fh"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "192-195",
          "snippet": "static void encode_fh(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\tencode_netobj(xdr, (u8 *)&fh->data, NFS2_FHSIZE);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_fh(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\tencode_netobj(xdr, (u8 *)&fh->data, NFS2_FHSIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_caller_name",
          "args": [
            "xdr",
            "lock->caller"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "encode_caller_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "322-330",
          "snippet": "static void encode_caller_name(struct xdr_stream *xdr, const char *name)\n{\n\t/* NB: client-side does not set lock->len */\n\tu32 length = strlen(name);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, name, length);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_caller_name(struct xdr_stream *xdr, const char *name)\n{\n\t/* NB: client-side does not set lock->len */\n\tu32 length = strlen(name);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, name, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_lock(struct xdr_stream *xdr,\n\t\t\t    const struct nlm_lock *lock)\n{\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_caller_name(xdr, lock->caller);\n\tencode_fh(xdr, &lock->fh);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4);\n\t*p++ = cpu_to_be32(lock->svid);\n\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}"
  },
  {
    "function_name": "encode_caller_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "322-330",
    "snippet": "static void encode_caller_name(struct xdr_stream *xdr, const char *name)\n{\n\t/* NB: client-side does not set lock->len */\n\tu32 length = strlen(name);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, name, length);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "name",
            "length"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + length"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_caller_name(struct xdr_stream *xdr, const char *name)\n{\n\t/* NB: client-side does not set lock->len */\n\tu32 length = strlen(name);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, name, length);\n}"
  },
  {
    "function_name": "decode_nlm_holder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "273-317",
    "snippet": "static int decode_nlm_holder(struct xdr_stream *xdr, struct nlm_res *result)\n{\n\tstruct nlm_lock *lock = &result->lock;\n\tstruct file_lock *fl = &lock->fl;\n\tu32 exclusive, l_offset, l_len;\n\tint error;\n\t__be32 *p;\n\ts32 end;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(fl);\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\texclusive = be32_to_cpup(p++);\n\tlock->svid = be32_to_cpup(p);\n\tfl->fl_pid = (pid_t)lock->svid;\n\n\terror = decode_netobj(xdr, &lock->oh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = exclusive != 0 ? F_WRLCK : F_RDLCK;\n\tl_offset = be32_to_cpup(p++);\n\tl_len = be32_to_cpup(p);\n\tend = l_offset + l_len - 1;\n\n\tfl->fl_start = (loff_t)l_offset;\n\tif (l_len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = (loff_t)end;\n\terror = 0;\nout:\n\treturn error;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_overflow_msg",
          "args": [
            "__func__",
            "xdr"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "print_overflow_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "75-80",
          "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4 + 4"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_netobj",
          "args": [
            "xdr",
            "&lock->oh"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "decode_netobj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "124-145",
          "snippet": "static int decode_netobj(struct xdr_stream *xdr,\n\t\t\t struct xdr_netobj *obj)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\tif (unlikely(length > XDR_MAX_NETOBJ))\n\t\tgoto out_size;\n\tobj->len = length;\n\tobj->data = (u8 *)p;\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned netobj was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_netobj(struct xdr_stream *xdr,\n\t\t\t struct xdr_netobj *obj)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\tif (unlikely(length > XDR_MAX_NETOBJ))\n\t\tgoto out_size;\n\tobj->len = length;\n\tobj->data = (u8 *)p;\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned netobj was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4 + 4"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "fl"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "locks_init_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "311-315",
          "snippet": "void locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nvoid locks_init_lock(struct file_lock *fl)\n{\n\tmemset(fl, 0, sizeof(struct file_lock));\n\tlocks_init_lock_heads(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lock",
            "0",
            "sizeof(*lock)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_nlm_holder(struct xdr_stream *xdr, struct nlm_res *result)\n{\n\tstruct nlm_lock *lock = &result->lock;\n\tstruct file_lock *fl = &lock->fl;\n\tu32 exclusive, l_offset, l_len;\n\tint error;\n\t__be32 *p;\n\ts32 end;\n\n\tmemset(lock, 0, sizeof(*lock));\n\tlocks_init_lock(fl);\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\texclusive = be32_to_cpup(p++);\n\tlock->svid = be32_to_cpup(p);\n\tfl->fl_pid = (pid_t)lock->svid;\n\n\terror = decode_netobj(xdr, &lock->oh);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\n\tfl->fl_flags = FL_POSIX;\n\tfl->fl_type  = exclusive != 0 ? F_WRLCK : F_RDLCK;\n\tl_offset = be32_to_cpup(p++);\n\tl_len = be32_to_cpup(p);\n\tend = l_offset + l_len - 1;\n\n\tfl->fl_start = (loff_t)l_offset;\n\tif (l_len == 0 || end < 0)\n\t\tfl->fl_end = OFFSET_MAX;\n\telse\n\t\tfl->fl_end = (loff_t)end;\n\terror = 0;\nout:\n\treturn error;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "encode_nlm_holder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "256-271",
    "snippet": "static void encode_nlm_holder(struct xdr_stream *xdr,\n\t\t\t      const struct nlm_res *result)\n{\n\tconst struct nlm_lock *lock = &result->lock;\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_bool(xdr, lock->fl.fl_type == F_RDLCK);\n\tencode_int32(xdr, lock->svid);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4);\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "l_len"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "l_offset"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlm_compute_offsets",
          "args": [
            "lock",
            "&l_offset",
            "&l_len"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "nlm_compute_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "60-70",
          "snippet": "static void nlm_compute_offsets(const struct nlm_lock *lock,\n\t\t\t\tu32 *l_offset, u32 *l_len)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\n\t*l_offset = loff_t_to_s32(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\t*l_len = 0;\n\telse\n\t\t*l_len = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_compute_offsets(const struct nlm_lock *lock,\n\t\t\t\tu32 *l_offset, u32 *l_len)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\n\t*l_offset = loff_t_to_s32(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\t*l_len = 0;\n\telse\n\t\t*l_len = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + 4"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_netobj",
          "args": [
            "xdr",
            "lock->oh.data",
            "lock->oh.len"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "encode_netobj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "115-122",
          "snippet": "static void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_int32",
          "args": [
            "xdr",
            "lock->svid"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "encode_int32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "104-110",
          "snippet": "static void encode_int32(struct xdr_stream *xdr, const s32 value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_int32(struct xdr_stream *xdr, const s32 value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_bool",
          "args": [
            "xdr",
            "lock->fl.fl_type == F_RDLCK"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "encode_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "96-102",
          "snippet": "static void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_holder(struct xdr_stream *xdr,\n\t\t\t      const struct nlm_res *result)\n{\n\tconst struct nlm_lock *lock = &result->lock;\n\tu32 l_offset, l_len;\n\t__be32 *p;\n\n\tencode_bool(xdr, lock->fl.fl_type == F_RDLCK);\n\tencode_int32(xdr, lock->svid);\n\tencode_netobj(xdr, lock->oh.data, lock->oh.len);\n\n\tp = xdr_reserve_space(xdr, 4 + 4);\n\tnlm_compute_offsets(lock, &l_offset, &l_len);\n\t*p++ = cpu_to_be32(l_offset);\n\t*p   = cpu_to_be32(l_len);\n}"
  },
  {
    "function_name": "decode_nlm_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "226-245",
    "snippet": "static int decode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t   __be32 *stat)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tif (unlikely(ntohl(*p) > ntohl(nlm_lck_denied_grace_period)))\n\t\tgoto out_enum;\n\t*stat = *p;\n\treturn 0;\nout_enum:\n\tdprintk(\"%s: server returned invalid nlm_stats value: %u\\n\",\n\t\t__func__, be32_to_cpup(p));\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_overflow_msg",
          "args": [
            "__func__",
            "xdr"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "print_overflow_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "75-80",
          "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: server returned invalid nlm_stats value: %u\\n\"",
            "__func__",
            "be32_to_cpup(p)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ntohl(*p) > ntohl(nlm_lck_denied_grace_period)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "nlm_lck_denied_grace_period"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t   __be32 *stat)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tif (unlikely(ntohl(*p) > ntohl(nlm_lck_denied_grace_period)))\n\t\tgoto out_enum;\n\t*stat = *p;\n\treturn 0;\nout_enum:\n\tdprintk(\"%s: server returned invalid nlm_stats value: %u\\n\",\n\t\t__func__, be32_to_cpup(p));\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "encode_nlm_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "216-224",
    "snippet": "static void encode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t    const __be32 stat)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = stat;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "stat"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_nlm_stat(struct xdr_stream *xdr,\n\t\t\t    const __be32 stat)\n{\n\t__be32 *p;\n\n\tWARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = stat;\n}"
  },
  {
    "function_name": "encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "192-195",
    "snippet": "static void encode_fh(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\tencode_netobj(xdr, (u8 *)&fh->data, NFS2_FHSIZE);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_netobj",
          "args": [
            "xdr",
            "(u8 *)&fh->data",
            "NFS2_FHSIZE"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "encode_netobj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "115-122",
          "snippet": "static void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_fh(struct xdr_stream *xdr, const struct nfs_fh *fh)\n{\n\tencode_netobj(xdr, (u8 *)&fh->data, NFS2_FHSIZE);\n}"
  },
  {
    "function_name": "decode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "156-187",
    "snippet": "static int decode_cookie(struct xdr_stream *xdr,\n\t\t\t struct nlm_cookie *cookie)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\t/* apparently HPUX can return empty cookies */\n\tif (length == 0)\n\t\tgoto out_hpux;\n\tif (length > NLM_MAXCOOKIELEN)\n\t\tgoto out_size;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tcookie->len = length;\n\tmemcpy(cookie->data, p, length);\n\treturn 0;\nout_hpux:\n\tcookie->len = 4;\n\tmemset(cookie->data, 0, 4);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned cookie was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_overflow_msg",
          "args": [
            "__func__",
            "xdr"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "print_overflow_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "75-80",
          "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: returned cookie was too long: %u\\n\"",
            "length"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cookie->data",
            "0",
            "4"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cookie->data",
            "p",
            "length"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "length"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_cookie(struct xdr_stream *xdr,\n\t\t\t struct nlm_cookie *cookie)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\t/* apparently HPUX can return empty cookies */\n\tif (length == 0)\n\t\tgoto out_hpux;\n\tif (length > NLM_MAXCOOKIELEN)\n\t\tgoto out_size;\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tcookie->len = length;\n\tmemcpy(cookie->data, p, length);\n\treturn 0;\nout_hpux:\n\tcookie->len = 4;\n\tmemset(cookie->data, 0, 4);\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned cookie was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "encode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "150-154",
    "snippet": "static void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_netobj",
          "args": [
            "xdr",
            "(u8 *)&cookie->data",
            "cookie->len"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "encode_netobj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "115-122",
          "snippet": "static void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_cookie(struct xdr_stream *xdr,\n\t\t\t  const struct nlm_cookie *cookie)\n{\n\tencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\n}"
  },
  {
    "function_name": "decode_netobj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "124-145",
    "snippet": "static int decode_netobj(struct xdr_stream *xdr,\n\t\t\t struct xdr_netobj *obj)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\tif (unlikely(length > XDR_MAX_NETOBJ))\n\t\tgoto out_size;\n\tobj->len = length;\n\tobj->data = (u8 *)p;\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned netobj was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_overflow_msg",
          "args": [
            "__func__",
            "xdr"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "print_overflow_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "75-80",
          "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: returned netobj was too long: %u\\n\"",
            "length"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "length > XDR_MAX_NETOBJ"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic int decode_netobj(struct xdr_stream *xdr,\n\t\t\t struct xdr_netobj *obj)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tlength = be32_to_cpup(p++);\n\tif (unlikely(length > XDR_MAX_NETOBJ))\n\t\tgoto out_size;\n\tobj->len = length;\n\tobj->data = (u8 *)p;\n\treturn 0;\nout_size:\n\tdprintk(\"NFS: returned netobj was too long: %u\\n\", length);\n\treturn -EIO;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "encode_netobj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "115-122",
    "snippet": "static void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "data",
            "length"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + length"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_netobj(struct xdr_stream *xdr,\n\t\t\t  const u8 *data, const unsigned int length)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, data, length);\n}"
  },
  {
    "function_name": "encode_int32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "104-110",
    "snippet": "static void encode_int32(struct xdr_stream *xdr, const s32 value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "value"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_int32(struct xdr_stream *xdr, const s32 value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(value);\n}"
  },
  {
    "function_name": "encode_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "96-102",
    "snippet": "static void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = value ? xdr_one : xdr_zero;\n}"
  },
  {
    "function_name": "print_overflow_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "75-80",
    "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\"",
            "func",
            "xdr->end - xdr->p"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"lockd: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
  },
  {
    "function_name": "nlm_compute_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "60-70",
    "snippet": "static void nlm_compute_offsets(const struct nlm_lock *lock,\n\t\t\t\tu32 *l_offset, u32 *l_len)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\n\t*l_offset = loff_t_to_s32(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\t*l_len = 0;\n\telse\n\t\t*l_len = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loff_t_to_s32",
          "args": [
            "fl->fl_end - fl->fl_start + 1"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "loff_t_to_s32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
          "lines": "47-58",
          "snippet": "static s32 loff_t_to_s32(loff_t offset)\n{\n\ts32 res;\n\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}",
          "includes": [
            "#include <uapi/linux/nfs2.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/xdr.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic s32 loff_t_to_s32(loff_t offset)\n{\n\ts32 res;\n\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic void nlm_compute_offsets(const struct nlm_lock *lock,\n\t\t\t\tu32 *l_offset, u32 *l_len)\n{\n\tconst struct file_lock *fl = &lock->fl;\n\n\t*l_offset = loff_t_to_s32(fl->fl_start);\n\tif (fl->fl_end == OFFSET_MAX)\n\t\t*l_len = 0;\n\telse\n\t\t*l_len = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\n}"
  },
  {
    "function_name": "loff_t_to_s32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/clntxdr.c",
    "lines": "47-58",
    "snippet": "static s32 loff_t_to_s32(loff_t offset)\n{\n\ts32 res;\n\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}",
    "includes": [
      "#include <uapi/linux/nfs2.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/xdr.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/nfs2.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/types.h>\n\nstatic s32 loff_t_to_s32(loff_t offset)\n{\n\ts32 res;\n\n\tif (offset >= NLM_OFFSET_MAX)\n\t\tres = NLM_OFFSET_MAX;\n\telse if (offset <= -NLM_OFFSET_MAX)\n\t\tres = -NLM_OFFSET_MAX;\n\telse\n\t\tres = offset;\n\treturn res;\n}"
  }
]