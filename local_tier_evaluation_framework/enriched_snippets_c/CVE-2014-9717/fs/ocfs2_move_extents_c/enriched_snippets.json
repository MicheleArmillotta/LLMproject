[
  {
    "function_name": "ocfs2_ioctl_move_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "979-1075",
    "snippet": "int ocfs2_ioctl_move_extents(struct file *filp, void __user *argp)\n{\n\tint status;\n\n\tstruct inode *inode = file_inode(filp);\n\tstruct ocfs2_move_extents range;\n\tstruct ocfs2_move_extents_context *context;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tstatus = mnt_want_write_file(filp);\n\tif (status)\n\t\treturn status;\n\n\tif ((!S_ISREG(inode->i_mode)) || !(filp->f_mode & FMODE_WRITE)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tcontext = kzalloc(sizeof(struct ocfs2_move_extents_context), GFP_NOFS);\n\tif (!context) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_drop;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->file = filp;\n\n\tif (copy_from_user(&range, argp, sizeof(range))) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start > i_size_read(inode)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start + range.me_len > i_size_read(inode))\n\t\t\trange.me_len = i_size_read(inode) - range.me_start;\n\n\tcontext->range = &range;\n\n\tif (range.me_flags & OCFS2_MOVE_EXT_FL_AUTO_DEFRAG) {\n\t\tcontext->auto_defrag = 1;\n\t\t/*\n\t\t * ok, the default theshold for the defragmentation\n\t\t * is 1M, since our maximum clustersize was 1M also.\n\t\t * any thought?\n\t\t */\n\t\tif (!range.me_threshold)\n\t\t\trange.me_threshold = 1024 * 1024;\n\n\t\tif (range.me_threshold > i_size_read(inode))\n\t\t\trange.me_threshold = i_size_read(inode);\n\n\t\tif (range.me_flags & OCFS2_MOVE_EXT_FL_PART_DEFRAG)\n\t\t\tcontext->partial = 1;\n\t} else {\n\t\t/*\n\t\t * first best-effort attempt to validate and adjust the goal\n\t\t * (physical address in block), while it can't guarantee later\n\t\t * operation can succeed all the time since global_bitmap may\n\t\t * change a bit over time.\n\t\t */\n\n\t\tstatus = ocfs2_validate_and_adjust_move_goal(inode, &range);\n\t\tif (status)\n\t\t\tgoto out_copy;\n\t}\n\n\tstatus = ocfs2_move_extents(context);\n\tif (status)\n\t\tmlog_errno(status);\nout_copy:\n\t/*\n\t * movement/defragmentation may end up being partially completed,\n\t * that's the reason why we need to return userspace the finished\n\t * length and new_offset even if failure happens somewhere.\n\t */\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\tstatus = -EFAULT;\n\nout_free:\n\tkfree(context);\nout_drop:\n\tmnt_drop_write_file(filp);\n\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&range",
            "sizeof(range)"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_move_extents",
          "args": [
            "context"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_move_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "898-977",
          "snippet": "static int ocfs2_move_extents(struct ocfs2_move_extents_context *context)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes from other nodes\n\t */\n\tstatus = ocfs2_rw_lock(inode, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_rw_unlock;\n\t}\n\n\t/*\n\t * rememer ip_xattr_sem also needs to be held if necessary\n\t */\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tstatus = __ocfs2_move_extents_range(di_bh, context);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update ctime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn status;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_move_extents(struct ocfs2_move_extents_context *context)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes from other nodes\n\t */\n\tstatus = ocfs2_rw_lock(inode, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_rw_unlock;\n\t}\n\n\t/*\n\t * rememer ip_xattr_sem also needs to be held if necessary\n\t */\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tstatus = __ocfs2_move_extents_range(di_bh, context);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update ctime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_and_adjust_move_goal",
          "args": [
            "inode",
            "&range"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_and_adjust_move_goal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "469-524",
          "snippet": "static int ocfs2_validate_and_adjust_move_goal(struct inode *inode,\n\t\t\t\t\t       struct ocfs2_move_extents *range)\n{\n\tint ret, goal_bit = 0;\n\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint c_to_b = 1 << (osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits);\n\n\t/*\n\t * make goal become cluster aligned.\n\t */\n\trange->me_goal = ocfs2_block_to_cluster_start(inode->i_sb,\n\t\t\t\t\t\t      range->me_goal);\n\t/*\n\t * validate goal sits within global_bitmap, and return the victim\n\t * group desc\n\t */\n\tret = ocfs2_find_victim_alloc_group(inode, range->me_goal,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t/*\n\t * moving goal is not allowd to start with a group desc blok(#0 blk)\n\t * let's compromise to the latter cluster.\n\t */\n\tif (range->me_goal == le64_to_cpu(bg->bg_blkno))\n\t\trange->me_goal += c_to_b;\n\n\t/*\n\t * movement is not gonna cross two groups.\n\t */\n\tif ((le16_to_cpu(bg->bg_bits) - goal_bit) * osb->s_clustersize <\n\t\t\t\t\t\t\t\trange->me_len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t * more exact validations/adjustments will be performed later during\n\t * moving operation for each extent range.\n\t */\n\tmlog(0, \"extents get ready to be moved to #%llu block\\n\",\n\t     range->me_goal);\n\nout:\n\tbrelse(gd_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_and_adjust_move_goal(struct inode *inode,\n\t\t\t\t\t       struct ocfs2_move_extents *range)\n{\n\tint ret, goal_bit = 0;\n\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint c_to_b = 1 << (osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits);\n\n\t/*\n\t * make goal become cluster aligned.\n\t */\n\trange->me_goal = ocfs2_block_to_cluster_start(inode->i_sb,\n\t\t\t\t\t\t      range->me_goal);\n\t/*\n\t * validate goal sits within global_bitmap, and return the victim\n\t * group desc\n\t */\n\tret = ocfs2_find_victim_alloc_group(inode, range->me_goal,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t/*\n\t * moving goal is not allowd to start with a group desc blok(#0 blk)\n\t * let's compromise to the latter cluster.\n\t */\n\tif (range->me_goal == le64_to_cpu(bg->bg_blkno))\n\t\trange->me_goal += c_to_b;\n\n\t/*\n\t * movement is not gonna cross two groups.\n\t */\n\tif ((le16_to_cpu(bg->bg_bits) - goal_bit) * osb->s_clustersize <\n\t\t\t\t\t\t\t\trange->me_len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t * more exact validations/adjustments will be performed later during\n\t * moving operation for each extent range.\n\t */\n\tmlog(0, \"extents get ready to be moved to #%llu block\\n\",\n\t     range->me_goal);\n\nout:\n\tbrelse(gd_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "argp",
            "sizeof(range)"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_move_extents_context)",
            "GFP_NOFS"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_ioctl_move_extents(struct file *filp, void __user *argp)\n{\n\tint status;\n\n\tstruct inode *inode = file_inode(filp);\n\tstruct ocfs2_move_extents range;\n\tstruct ocfs2_move_extents_context *context;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tstatus = mnt_want_write_file(filp);\n\tif (status)\n\t\treturn status;\n\n\tif ((!S_ISREG(inode->i_mode)) || !(filp->f_mode & FMODE_WRITE)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_drop;\n\t}\n\n\tcontext = kzalloc(sizeof(struct ocfs2_move_extents_context), GFP_NOFS);\n\tif (!context) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_drop;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->file = filp;\n\n\tif (copy_from_user(&range, argp, sizeof(range))) {\n\t\tstatus = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start > i_size_read(inode)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (range.me_start + range.me_len > i_size_read(inode))\n\t\t\trange.me_len = i_size_read(inode) - range.me_start;\n\n\tcontext->range = &range;\n\n\tif (range.me_flags & OCFS2_MOVE_EXT_FL_AUTO_DEFRAG) {\n\t\tcontext->auto_defrag = 1;\n\t\t/*\n\t\t * ok, the default theshold for the defragmentation\n\t\t * is 1M, since our maximum clustersize was 1M also.\n\t\t * any thought?\n\t\t */\n\t\tif (!range.me_threshold)\n\t\t\trange.me_threshold = 1024 * 1024;\n\n\t\tif (range.me_threshold > i_size_read(inode))\n\t\t\trange.me_threshold = i_size_read(inode);\n\n\t\tif (range.me_flags & OCFS2_MOVE_EXT_FL_PART_DEFRAG)\n\t\t\tcontext->partial = 1;\n\t} else {\n\t\t/*\n\t\t * first best-effort attempt to validate and adjust the goal\n\t\t * (physical address in block), while it can't guarantee later\n\t\t * operation can succeed all the time since global_bitmap may\n\t\t * change a bit over time.\n\t\t */\n\n\t\tstatus = ocfs2_validate_and_adjust_move_goal(inode, &range);\n\t\tif (status)\n\t\t\tgoto out_copy;\n\t}\n\n\tstatus = ocfs2_move_extents(context);\n\tif (status)\n\t\tmlog_errno(status);\nout_copy:\n\t/*\n\t * movement/defragmentation may end up being partially completed,\n\t * that's the reason why we need to return userspace the finished\n\t * length and new_offset even if failure happens somewhere.\n\t */\n\tif (copy_to_user(argp, &range, sizeof(range)))\n\t\tstatus = -EFAULT;\n\nout_free:\n\tkfree(context);\nout_drop:\n\tmnt_drop_write_file(filp);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_move_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "898-977",
    "snippet": "static int ocfs2_move_extents(struct ocfs2_move_extents_context *context)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes from other nodes\n\t */\n\tstatus = ocfs2_rw_lock(inode, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_rw_unlock;\n\t}\n\n\t/*\n\t * rememer ip_xattr_sem also needs to be held if necessary\n\t */\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tstatus = __ocfs2_move_extents_range(di_bh, context);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update ctime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn status;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1692-1704",
          "snippet": "void ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_move_extents_range",
          "args": [
            "di_bh",
            "context"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_move_extents_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "763-896",
          "snippet": "static int __ocfs2_move_extents_range(struct buffer_head *di_bh,\n\t\t\t\tstruct ocfs2_move_extents_context *context)\n{\n\tint ret = 0, flags, do_defrag, skip = 0;\n\tu32 cpos, phys_cpos, move_start, len_to_move, alloc_size;\n\tu32 len_defraged = 0, defrag_thresh = 0, new_phys_cpos = 0;\n\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_move_extents *range = context->range;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif ((i_size_read(inode) == 0) || (range->me_len == 0))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcontext->refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&context->et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\t/*\n\t * TO-DO XXX:\n\t *\n\t * - xattr extents.\n\t */\n\n\tdo_defrag = context->auto_defrag;\n\n\t/*\n\t * extents moving happens in unit of clusters, for the sake\n\t * of simplicity, we may ignore two clusters where 'byte_start'\n\t * and 'byte_start + len' were within.\n\t */\n\tmove_start = ocfs2_clusters_for_bytes(osb->sb, range->me_start);\n\tlen_to_move = (range->me_start + range->me_len) >>\n\t\t\t\t\t\tosb->s_clustersize_bits;\n\tif (len_to_move >= move_start)\n\t\tlen_to_move -= move_start;\n\telse\n\t\tlen_to_move = 0;\n\n\tif (do_defrag) {\n\t\tdefrag_thresh = range->me_threshold >> osb->s_clustersize_bits;\n\t\tif (defrag_thresh <= 1)\n\t\t\tgoto done;\n\t} else\n\t\tnew_phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t range->me_goal);\n\n\tmlog(0, \"Inode: %llu, start: %llu, len: %llu, cstart: %u, clen: %u, \"\n\t     \"thresh: %u\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)range->me_start,\n\t     (unsigned long long)range->me_len,\n\t     move_start, len_to_move, defrag_thresh);\n\n\tcpos = move_start;\n\twhile (len_to_move) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &alloc_size,\n\t\t\t\t\t &flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > len_to_move)\n\t\t\talloc_size = len_to_move;\n\n\t\t/*\n\t\t * XXX: how to deal with a hole:\n\t\t *\n\t\t * - skip the hole of course\n\t\t * - force a new defragmentation\n\t\t */\n\t\tif (!phys_cpos) {\n\t\t\tif (do_defrag)\n\t\t\t\tlen_defraged = 0;\n\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (do_defrag) {\n\t\t\tocfs2_calc_extent_defrag_len(&alloc_size, &len_defraged,\n\t\t\t\t\t\t     defrag_thresh, &skip);\n\t\t\t/*\n\t\t\t * skip large extents\n\t\t\t */\n\t\t\tif (skip) {\n\t\t\t\tskip = 0;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tmlog(0, \"#Defrag: cpos: %u, phys_cpos: %u, \"\n\t\t\t     \"alloc_size: %u, len_defraged: %u\\n\",\n\t\t\t     cpos, phys_cpos, alloc_size, len_defraged);\n\n\t\t\tret = ocfs2_defrag_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t  &alloc_size, flags);\n\t\t} else {\n\t\t\tret = ocfs2_move_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t&new_phys_cpos, alloc_size,\n\t\t\t\t\t\tflags);\n\n\t\t\tnew_phys_cpos += alloc_size;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->clusters_moved += alloc_size;\nnext:\n\t\tcpos += alloc_size;\n\t\tlen_to_move -= alloc_size;\n\t}\n\ndone:\n\trange->me_flags |= OCFS2_MOVE_EXT_FL_COMPLETE;\n\nout:\n\trange->me_moved_len = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t      context->clusters_moved);\n\trange->me_new_offset = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t       context->new_phys_cpos);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &context->dealloc);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_move_extents_range(struct buffer_head *di_bh,\n\t\t\t\tstruct ocfs2_move_extents_context *context)\n{\n\tint ret = 0, flags, do_defrag, skip = 0;\n\tu32 cpos, phys_cpos, move_start, len_to_move, alloc_size;\n\tu32 len_defraged = 0, defrag_thresh = 0, new_phys_cpos = 0;\n\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_move_extents *range = context->range;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif ((i_size_read(inode) == 0) || (range->me_len == 0))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcontext->refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&context->et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\t/*\n\t * TO-DO XXX:\n\t *\n\t * - xattr extents.\n\t */\n\n\tdo_defrag = context->auto_defrag;\n\n\t/*\n\t * extents moving happens in unit of clusters, for the sake\n\t * of simplicity, we may ignore two clusters where 'byte_start'\n\t * and 'byte_start + len' were within.\n\t */\n\tmove_start = ocfs2_clusters_for_bytes(osb->sb, range->me_start);\n\tlen_to_move = (range->me_start + range->me_len) >>\n\t\t\t\t\t\tosb->s_clustersize_bits;\n\tif (len_to_move >= move_start)\n\t\tlen_to_move -= move_start;\n\telse\n\t\tlen_to_move = 0;\n\n\tif (do_defrag) {\n\t\tdefrag_thresh = range->me_threshold >> osb->s_clustersize_bits;\n\t\tif (defrag_thresh <= 1)\n\t\t\tgoto done;\n\t} else\n\t\tnew_phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t range->me_goal);\n\n\tmlog(0, \"Inode: %llu, start: %llu, len: %llu, cstart: %u, clen: %u, \"\n\t     \"thresh: %u\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)range->me_start,\n\t     (unsigned long long)range->me_len,\n\t     move_start, len_to_move, defrag_thresh);\n\n\tcpos = move_start;\n\twhile (len_to_move) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &alloc_size,\n\t\t\t\t\t &flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > len_to_move)\n\t\t\talloc_size = len_to_move;\n\n\t\t/*\n\t\t * XXX: how to deal with a hole:\n\t\t *\n\t\t * - skip the hole of course\n\t\t * - force a new defragmentation\n\t\t */\n\t\tif (!phys_cpos) {\n\t\t\tif (do_defrag)\n\t\t\t\tlen_defraged = 0;\n\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (do_defrag) {\n\t\t\tocfs2_calc_extent_defrag_len(&alloc_size, &len_defraged,\n\t\t\t\t\t\t     defrag_thresh, &skip);\n\t\t\t/*\n\t\t\t * skip large extents\n\t\t\t */\n\t\t\tif (skip) {\n\t\t\t\tskip = 0;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tmlog(0, \"#Defrag: cpos: %u, phys_cpos: %u, \"\n\t\t\t     \"alloc_size: %u, len_defraged: %u\\n\",\n\t\t\t     cpos, phys_cpos, alloc_size, len_defraged);\n\n\t\t\tret = ocfs2_defrag_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t  &alloc_size, flags);\n\t\t} else {\n\t\t\tret = ocfs2_move_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t&new_phys_cpos, alloc_size,\n\t\t\t\t\t\tflags);\n\n\t\t\tnew_phys_cpos += alloc_size;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->clusters_moved += alloc_size;\nnext:\n\t\tcpos += alloc_size;\n\t\tlen_to_move -= alloc_size;\n\t}\n\ndone:\n\trange->me_flags |= OCFS2_MOVE_EXT_FL_COMPLETE;\n\nout:\n\trange->me_moved_len = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t      context->clusters_moved);\n\trange->me_new_offset = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t       context->new_phys_cpos);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &context->dealloc);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_lock",
          "args": [
            "inode",
            "1"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1665-1690",
          "snippet": "int ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_soft_readonly",
          "args": [
            "osb"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_soft_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "626-635",
          "snippet": "static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_move_extents(struct ocfs2_move_extents_context *context)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes from other nodes\n\t */\n\tstatus = ocfs2_rw_lock(inode, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_rw_unlock;\n\t}\n\n\t/*\n\t * rememer ip_xattr_sem also needs to be held if necessary\n\t */\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tstatus = __ocfs2_move_extents_range(di_bh, context);\n\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update ctime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn status;\n}"
  },
  {
    "function_name": "__ocfs2_move_extents_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "763-896",
    "snippet": "static int __ocfs2_move_extents_range(struct buffer_head *di_bh,\n\t\t\t\tstruct ocfs2_move_extents_context *context)\n{\n\tint ret = 0, flags, do_defrag, skip = 0;\n\tu32 cpos, phys_cpos, move_start, len_to_move, alloc_size;\n\tu32 len_defraged = 0, defrag_thresh = 0, new_phys_cpos = 0;\n\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_move_extents *range = context->range;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif ((i_size_read(inode) == 0) || (range->me_len == 0))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcontext->refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&context->et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\t/*\n\t * TO-DO XXX:\n\t *\n\t * - xattr extents.\n\t */\n\n\tdo_defrag = context->auto_defrag;\n\n\t/*\n\t * extents moving happens in unit of clusters, for the sake\n\t * of simplicity, we may ignore two clusters where 'byte_start'\n\t * and 'byte_start + len' were within.\n\t */\n\tmove_start = ocfs2_clusters_for_bytes(osb->sb, range->me_start);\n\tlen_to_move = (range->me_start + range->me_len) >>\n\t\t\t\t\t\tosb->s_clustersize_bits;\n\tif (len_to_move >= move_start)\n\t\tlen_to_move -= move_start;\n\telse\n\t\tlen_to_move = 0;\n\n\tif (do_defrag) {\n\t\tdefrag_thresh = range->me_threshold >> osb->s_clustersize_bits;\n\t\tif (defrag_thresh <= 1)\n\t\t\tgoto done;\n\t} else\n\t\tnew_phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t range->me_goal);\n\n\tmlog(0, \"Inode: %llu, start: %llu, len: %llu, cstart: %u, clen: %u, \"\n\t     \"thresh: %u\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)range->me_start,\n\t     (unsigned long long)range->me_len,\n\t     move_start, len_to_move, defrag_thresh);\n\n\tcpos = move_start;\n\twhile (len_to_move) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &alloc_size,\n\t\t\t\t\t &flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > len_to_move)\n\t\t\talloc_size = len_to_move;\n\n\t\t/*\n\t\t * XXX: how to deal with a hole:\n\t\t *\n\t\t * - skip the hole of course\n\t\t * - force a new defragmentation\n\t\t */\n\t\tif (!phys_cpos) {\n\t\t\tif (do_defrag)\n\t\t\t\tlen_defraged = 0;\n\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (do_defrag) {\n\t\t\tocfs2_calc_extent_defrag_len(&alloc_size, &len_defraged,\n\t\t\t\t\t\t     defrag_thresh, &skip);\n\t\t\t/*\n\t\t\t * skip large extents\n\t\t\t */\n\t\t\tif (skip) {\n\t\t\t\tskip = 0;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tmlog(0, \"#Defrag: cpos: %u, phys_cpos: %u, \"\n\t\t\t     \"alloc_size: %u, len_defraged: %u\\n\",\n\t\t\t     cpos, phys_cpos, alloc_size, len_defraged);\n\n\t\t\tret = ocfs2_defrag_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t  &alloc_size, flags);\n\t\t} else {\n\t\t\tret = ocfs2_move_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t&new_phys_cpos, alloc_size,\n\t\t\t\t\t\tflags);\n\n\t\t\tnew_phys_cpos += alloc_size;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->clusters_moved += alloc_size;\nnext:\n\t\tcpos += alloc_size;\n\t\tlen_to_move -= alloc_size;\n\t}\n\ndone:\n\trange->me_flags |= OCFS2_MOVE_EXT_FL_COMPLETE;\n\nout:\n\trange->me_moved_len = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t      context->clusters_moved);\n\trange->me_new_offset = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t       context->new_phys_cpos);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &context->dealloc);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&context->dealloc"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "osb->sb",
            "context->new_phys_cpos"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_move_extent",
          "args": [
            "context",
            "cpos",
            "phys_cpos",
            "&new_phys_cpos",
            "alloc_size",
            "flags"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_move_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "565-731",
          "snippet": "static int ocfs2_move_extent(struct ocfs2_move_extents_context *context,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 *new_phys_cpos,\n\t\t\t     u32 len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, goal_bit = 0;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *gb_inode = NULL;\n\tstruct buffer_head *gb_bh = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 move_max_hop = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    context->range->me_threshold);\n\tu64 phys_blkno, new_phys_blkno;\n\n\tphys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && len) {\n\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\tlen,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_allocators_move_extents(inode, &context->et, len, 1,\n\t\t\t\t\t\t &context->meta_ac,\n\t\t\t\t\t\t NULL, extra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * need to count 2 extra credits for global_bitmap inode and\n\t * group descriptor.\n\t */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS + 1;\n\n\t/*\n\t * ocfs2_move_extent() didn't reserve any clusters in lock_allocators()\n\t * logic, while we still need to lock the global_bitmap.\n\t */\n\tgb_inode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!gb_inode) {\n\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&gb_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(gb_inode, &gb_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_gb_mutex;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_tl_inode;\n\t}\n\n\tnew_phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *new_phys_cpos);\n\tret = ocfs2_find_victim_alloc_group(inode, new_phys_blkno,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * probe the victim cluster group to find a proper\n\t * region to fit wanted movement, it even will perfrom\n\t * a best-effort attempt by compromising to a threshold\n\t * around the goal.\n\t */\n\tocfs2_probe_alloc_group(inode, gd_bh, &goal_bit, len, move_max_hop,\n\t\t\t\tnew_phys_cpos);\n\tif (!*new_phys_cpos) {\n\t\tret = -ENOSPC;\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_move_extent(handle, context, cpos, len, phys_cpos,\n\t\t\t\t  *new_phys_cpos, ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\tret = ocfs2_alloc_dinode_update_counts(gb_inode, handle, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, gb_inode, gd, gd_bh,\n\t\t\t\t\t goal_bit, len);\n\tif (ret) {\n\t\tocfs2_rollback_alloc_dinode_counts(gb_inode, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\tbrelse(gd_bh);\n\nout_unlock_tl_inode:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tocfs2_inode_unlock(gb_inode, 1);\nout_unlock_gb_mutex:\n\tmutex_unlock(&gb_inode->i_mutex);\n\tbrelse(gb_bh);\n\tiput(gb_inode);\n\nout:\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_move_extent(struct ocfs2_move_extents_context *context,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 *new_phys_cpos,\n\t\t\t     u32 len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, goal_bit = 0;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *gb_inode = NULL;\n\tstruct buffer_head *gb_bh = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 move_max_hop = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    context->range->me_threshold);\n\tu64 phys_blkno, new_phys_blkno;\n\n\tphys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && len) {\n\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\tlen,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_allocators_move_extents(inode, &context->et, len, 1,\n\t\t\t\t\t\t &context->meta_ac,\n\t\t\t\t\t\t NULL, extra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * need to count 2 extra credits for global_bitmap inode and\n\t * group descriptor.\n\t */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS + 1;\n\n\t/*\n\t * ocfs2_move_extent() didn't reserve any clusters in lock_allocators()\n\t * logic, while we still need to lock the global_bitmap.\n\t */\n\tgb_inode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!gb_inode) {\n\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&gb_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(gb_inode, &gb_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_gb_mutex;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_tl_inode;\n\t}\n\n\tnew_phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *new_phys_cpos);\n\tret = ocfs2_find_victim_alloc_group(inode, new_phys_blkno,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * probe the victim cluster group to find a proper\n\t * region to fit wanted movement, it even will perfrom\n\t * a best-effort attempt by compromising to a threshold\n\t * around the goal.\n\t */\n\tocfs2_probe_alloc_group(inode, gd_bh, &goal_bit, len, move_max_hop,\n\t\t\t\tnew_phys_cpos);\n\tif (!*new_phys_cpos) {\n\t\tret = -ENOSPC;\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_move_extent(handle, context, cpos, len, phys_cpos,\n\t\t\t\t  *new_phys_cpos, ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\tret = ocfs2_alloc_dinode_update_counts(gb_inode, handle, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, gb_inode, gd, gd_bh,\n\t\t\t\t\t goal_bit, len);\n\tif (ret) {\n\t\tocfs2_rollback_alloc_dinode_counts(gb_inode, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\tbrelse(gd_bh);\n\nout_unlock_tl_inode:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tocfs2_inode_unlock(gb_inode, 1);\nout_unlock_gb_mutex:\n\tmutex_unlock(&gb_inode->i_mutex);\n\tbrelse(gb_bh);\n\tiput(gb_inode);\n\nout:\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_defrag_extent",
          "args": [
            "context",
            "cpos",
            "phys_cpos",
            "&alloc_size",
            "flags"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_defrag_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "227-360",
          "snippet": "static int ocfs2_defrag_extent(struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 phys_cpos, u32 *len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, partial = context->partial;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 new_phys_cpos, new_len;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && *len) {\n\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\t*len,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_allocators_move_extents(inode, &context->et, *len, 1,\n\t\t\t\t\t\t &context->meta_ac,\n\t\t\t\t\t\t &context->data_ac,\n\t\t\t\t\t\t extra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * should be using allocation reservation strategy there?\n\t *\n\t * if (context->data_ac)\n\t *\tcontext->data_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\t */\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock_mutex;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_mutex;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, context->data_ac, 1, *len,\n\t\t\t\t     &new_phys_cpos, &new_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * allowing partial extent moving is kind of 'pros and cons', it makes\n\t * whole defragmentation less likely to fail, on the contrary, the bad\n\t * thing is it may make the fs even more fragmented after moving, let\n\t * userspace make a good decision here.\n\t */\n\tif (new_len != *len) {\n\t\tmlog(0, \"len_claimed: %u, len: %u\\n\", new_len, *len);\n\t\tif (!partial) {\n\t\t\tcontext->range->me_flags &= ~OCFS2_MOVE_EXT_FL_COMPLETE;\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tmlog(0, \"cpos: %u, phys_cpos: %u, new_phys_cpos: %u\\n\", cpos,\n\t     phys_cpos, new_phys_cpos);\n\n\tret = __ocfs2_move_extent(handle, context, cpos, new_len, phys_cpos,\n\t\t\t\t  new_phys_cpos, ext_flags);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (partial && (new_len != *len))\n\t\t*len = new_len;\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, *len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock_mutex:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_defrag_extent(struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 phys_cpos, u32 *len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, partial = context->partial;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 new_phys_cpos, new_len;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && *len) {\n\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\t*len,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_allocators_move_extents(inode, &context->et, *len, 1,\n\t\t\t\t\t\t &context->meta_ac,\n\t\t\t\t\t\t &context->data_ac,\n\t\t\t\t\t\t extra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * should be using allocation reservation strategy there?\n\t *\n\t * if (context->data_ac)\n\t *\tcontext->data_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\t */\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock_mutex;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_mutex;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, context->data_ac, 1, *len,\n\t\t\t\t     &new_phys_cpos, &new_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * allowing partial extent moving is kind of 'pros and cons', it makes\n\t * whole defragmentation less likely to fail, on the contrary, the bad\n\t * thing is it may make the fs even more fragmented after moving, let\n\t * userspace make a good decision here.\n\t */\n\tif (new_len != *len) {\n\t\tmlog(0, \"len_claimed: %u, len: %u\\n\", new_len, *len);\n\t\tif (!partial) {\n\t\t\tcontext->range->me_flags &= ~OCFS2_MOVE_EXT_FL_COMPLETE;\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tmlog(0, \"cpos: %u, phys_cpos: %u, new_phys_cpos: %u\\n\", cpos,\n\t     phys_cpos, new_phys_cpos);\n\n\tret = __ocfs2_move_extent(handle, context, cpos, new_len, phys_cpos,\n\t\t\t\t  new_phys_cpos, ext_flags);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (partial && (new_len != *len))\n\t\t*len = new_len;\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, *len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock_mutex:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"#Defrag: cpos: %u, phys_cpos: %u, \"\n\t\t\t     \"alloc_size: %u, len_defraged: %u\\n\"",
            "cpos",
            "phys_cpos",
            "alloc_size",
            "len_defraged"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extent_defrag_len",
          "args": [
            "&alloc_size",
            "&len_defraged",
            "defrag_thresh",
            "&skip"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extent_defrag_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "736-761",
          "snippet": "static void ocfs2_calc_extent_defrag_len(u32 *alloc_size, u32 *len_defraged,\n\t\t\t\t\t u32 threshold, int *skip)\n{\n\tif ((*alloc_size + *len_defraged) < threshold) {\n\t\t/*\n\t\t * proceed defragmentation until we meet the thresh\n\t\t */\n\t\t*len_defraged += *alloc_size;\n\t} else if (*len_defraged == 0) {\n\t\t/*\n\t\t * XXX: skip a large extent.\n\t\t */\n\t\t*skip = 1;\n\t} else {\n\t\t/*\n\t\t * split this extent to coalesce with former pieces as\n\t\t * to reach the threshold.\n\t\t *\n\t\t * we're done here with one cycle of defragmentation\n\t\t * in a size of 'thresh', resetting 'len_defraged'\n\t\t * forces a new defragmentation.\n\t\t */\n\t\t*alloc_size = threshold - *len_defraged;\n\t\t*len_defraged = 0;\n\t}\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_calc_extent_defrag_len(u32 *alloc_size, u32 *len_defraged,\n\t\t\t\t\t u32 threshold, int *skip)\n{\n\tif ((*alloc_size + *len_defraged) < threshold) {\n\t\t/*\n\t\t * proceed defragmentation until we meet the thresh\n\t\t */\n\t\t*len_defraged += *alloc_size;\n\t} else if (*len_defraged == 0) {\n\t\t/*\n\t\t * XXX: skip a large extent.\n\t\t */\n\t\t*skip = 1;\n\t} else {\n\t\t/*\n\t\t * split this extent to coalesce with former pieces as\n\t\t * to reach the threshold.\n\t\t *\n\t\t * we're done here with one cycle of defragmentation\n\t\t * in a size of 'thresh', resetting 'len_defraged'\n\t\t * forces a new defragmentation.\n\t\t */\n\t\t*alloc_size = threshold - *len_defraged;\n\t\t*len_defraged = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&phys_cpos",
            "&alloc_size",
            "&flags"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Inode: %llu, start: %llu, len: %llu, cstart: %u, clen: %u, \"\n\t     \"thresh: %u\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)range->me_start",
            "(unsigned long long)range->me_len",
            "move_start",
            "len_to_move",
            "defrag_thresh"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "range->me_goal"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "osb->sb",
            "range->me_start"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&context->dealloc"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&context->et",
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_refcount_loc"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_move_extents_range(struct buffer_head *di_bh,\n\t\t\t\tstruct ocfs2_move_extents_context *context)\n{\n\tint ret = 0, flags, do_defrag, skip = 0;\n\tu32 cpos, phys_cpos, move_start, len_to_move, alloc_size;\n\tu32 len_defraged = 0, defrag_thresh = 0, new_phys_cpos = 0;\n\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_move_extents *range = context->range;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif ((i_size_read(inode) == 0) || (range->me_len == 0))\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcontext->refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&context->et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\t/*\n\t * TO-DO XXX:\n\t *\n\t * - xattr extents.\n\t */\n\n\tdo_defrag = context->auto_defrag;\n\n\t/*\n\t * extents moving happens in unit of clusters, for the sake\n\t * of simplicity, we may ignore two clusters where 'byte_start'\n\t * and 'byte_start + len' were within.\n\t */\n\tmove_start = ocfs2_clusters_for_bytes(osb->sb, range->me_start);\n\tlen_to_move = (range->me_start + range->me_len) >>\n\t\t\t\t\t\tosb->s_clustersize_bits;\n\tif (len_to_move >= move_start)\n\t\tlen_to_move -= move_start;\n\telse\n\t\tlen_to_move = 0;\n\n\tif (do_defrag) {\n\t\tdefrag_thresh = range->me_threshold >> osb->s_clustersize_bits;\n\t\tif (defrag_thresh <= 1)\n\t\t\tgoto done;\n\t} else\n\t\tnew_phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t\t range->me_goal);\n\n\tmlog(0, \"Inode: %llu, start: %llu, len: %llu, cstart: %u, clen: %u, \"\n\t     \"thresh: %u\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     (unsigned long long)range->me_start,\n\t     (unsigned long long)range->me_len,\n\t     move_start, len_to_move, defrag_thresh);\n\n\tcpos = move_start;\n\twhile (len_to_move) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &alloc_size,\n\t\t\t\t\t &flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (alloc_size > len_to_move)\n\t\t\talloc_size = len_to_move;\n\n\t\t/*\n\t\t * XXX: how to deal with a hole:\n\t\t *\n\t\t * - skip the hole of course\n\t\t * - force a new defragmentation\n\t\t */\n\t\tif (!phys_cpos) {\n\t\t\tif (do_defrag)\n\t\t\t\tlen_defraged = 0;\n\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (do_defrag) {\n\t\t\tocfs2_calc_extent_defrag_len(&alloc_size, &len_defraged,\n\t\t\t\t\t\t     defrag_thresh, &skip);\n\t\t\t/*\n\t\t\t * skip large extents\n\t\t\t */\n\t\t\tif (skip) {\n\t\t\t\tskip = 0;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tmlog(0, \"#Defrag: cpos: %u, phys_cpos: %u, \"\n\t\t\t     \"alloc_size: %u, len_defraged: %u\\n\",\n\t\t\t     cpos, phys_cpos, alloc_size, len_defraged);\n\n\t\t\tret = ocfs2_defrag_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t  &alloc_size, flags);\n\t\t} else {\n\t\t\tret = ocfs2_move_extent(context, cpos, phys_cpos,\n\t\t\t\t\t\t&new_phys_cpos, alloc_size,\n\t\t\t\t\t\tflags);\n\n\t\t\tnew_phys_cpos += alloc_size;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->clusters_moved += alloc_size;\nnext:\n\t\tcpos += alloc_size;\n\t\tlen_to_move -= alloc_size;\n\t}\n\ndone:\n\trange->me_flags |= OCFS2_MOVE_EXT_FL_COMPLETE;\n\nout:\n\trange->me_moved_len = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t      context->clusters_moved);\n\trange->me_new_offset = ocfs2_clusters_to_bytes(osb->sb,\n\t\t\t\t\t\t       context->new_phys_cpos);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &context->dealloc);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_calc_extent_defrag_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "736-761",
    "snippet": "static void ocfs2_calc_extent_defrag_len(u32 *alloc_size, u32 *len_defraged,\n\t\t\t\t\t u32 threshold, int *skip)\n{\n\tif ((*alloc_size + *len_defraged) < threshold) {\n\t\t/*\n\t\t * proceed defragmentation until we meet the thresh\n\t\t */\n\t\t*len_defraged += *alloc_size;\n\t} else if (*len_defraged == 0) {\n\t\t/*\n\t\t * XXX: skip a large extent.\n\t\t */\n\t\t*skip = 1;\n\t} else {\n\t\t/*\n\t\t * split this extent to coalesce with former pieces as\n\t\t * to reach the threshold.\n\t\t *\n\t\t * we're done here with one cycle of defragmentation\n\t\t * in a size of 'thresh', resetting 'len_defraged'\n\t\t * forces a new defragmentation.\n\t\t */\n\t\t*alloc_size = threshold - *len_defraged;\n\t\t*len_defraged = 0;\n\t}\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_calc_extent_defrag_len(u32 *alloc_size, u32 *len_defraged,\n\t\t\t\t\t u32 threshold, int *skip)\n{\n\tif ((*alloc_size + *len_defraged) < threshold) {\n\t\t/*\n\t\t * proceed defragmentation until we meet the thresh\n\t\t */\n\t\t*len_defraged += *alloc_size;\n\t} else if (*len_defraged == 0) {\n\t\t/*\n\t\t * XXX: skip a large extent.\n\t\t */\n\t\t*skip = 1;\n\t} else {\n\t\t/*\n\t\t * split this extent to coalesce with former pieces as\n\t\t * to reach the threshold.\n\t\t *\n\t\t * we're done here with one cycle of defragmentation\n\t\t * in a size of 'thresh', resetting 'len_defraged'\n\t\t * forces a new defragmentation.\n\t\t */\n\t\t*alloc_size = threshold - *len_defraged;\n\t\t*len_defraged = 0;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_move_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "565-731",
    "snippet": "static int ocfs2_move_extent(struct ocfs2_move_extents_context *context,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 *new_phys_cpos,\n\t\t\t     u32 len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, goal_bit = 0;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *gb_inode = NULL;\n\tstruct buffer_head *gb_bh = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 move_max_hop = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    context->range->me_threshold);\n\tu64 phys_blkno, new_phys_blkno;\n\n\tphys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && len) {\n\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\tlen,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_allocators_move_extents(inode, &context->et, len, 1,\n\t\t\t\t\t\t &context->meta_ac,\n\t\t\t\t\t\t NULL, extra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * need to count 2 extra credits for global_bitmap inode and\n\t * group descriptor.\n\t */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS + 1;\n\n\t/*\n\t * ocfs2_move_extent() didn't reserve any clusters in lock_allocators()\n\t * logic, while we still need to lock the global_bitmap.\n\t */\n\tgb_inode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!gb_inode) {\n\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&gb_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(gb_inode, &gb_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_gb_mutex;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_tl_inode;\n\t}\n\n\tnew_phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *new_phys_cpos);\n\tret = ocfs2_find_victim_alloc_group(inode, new_phys_blkno,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * probe the victim cluster group to find a proper\n\t * region to fit wanted movement, it even will perfrom\n\t * a best-effort attempt by compromising to a threshold\n\t * around the goal.\n\t */\n\tocfs2_probe_alloc_group(inode, gd_bh, &goal_bit, len, move_max_hop,\n\t\t\t\tnew_phys_cpos);\n\tif (!*new_phys_cpos) {\n\t\tret = -ENOSPC;\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_move_extent(handle, context, cpos, len, phys_cpos,\n\t\t\t\t  *new_phys_cpos, ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\tret = ocfs2_alloc_dinode_update_counts(gb_inode, handle, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, gb_inode, gd, gd_bh,\n\t\t\t\t\t goal_bit, len);\n\tif (ret) {\n\t\tocfs2_rollback_alloc_dinode_counts(gb_inode, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\tbrelse(gd_bh);\n\nout_unlock_tl_inode:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tocfs2_inode_unlock(gb_inode, 1);\nout_unlock_gb_mutex:\n\tmutex_unlock(&gb_inode->i_mutex);\n\tbrelse(gb_bh);\n\tiput(gb_inode);\n\nout:\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "context->meta_ac"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "gb_inode"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "gb_bh"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&gb_inode->i_mutex"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "gb_inode",
            "1"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_sync_writeback",
          "args": [
            "inode->i_sb",
            "context->inode",
            "cpos",
            "len"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_sync_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3161-3209",
          "snippet": "int ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret = 0;\n\tloff_t offset, end, map_end;\n\tpgoff_t page_index;\n\tstruct page *page;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\n\n\tret = filemap_fdatawrite_range(inode->i_mapping,\n\t\t\t\t       offset, end - 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   page_index, GFP_NOFS);\n\t\tBUG_ON(!page);\n\n\t\twait_on_page_writeback(page);\n\t\tif (PageError(page)) {\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tmark_page_accessed(page);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret = 0;\n\tloff_t offset, end, map_end;\n\tpgoff_t page_index;\n\tstruct page *page;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\n\n\tret = filemap_fdatawrite_range(inode->i_mapping,\n\t\t\t\t       offset, end - 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   page_index, GFP_NOFS);\n\t\tBUG_ON(!page);\n\n\t\twait_on_page_writeback(page);\n\t\tif (PageError(page)) {\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tmark_page_accessed(page);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rollback_alloc_dinode_counts",
          "args": [
            "gb_inode",
            "gb_bh",
            "len",
            "le16_to_cpu(gd->bg_chain)"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rollback_alloc_dinode_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1611-1624",
          "snippet": "void ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nvoid ocfs2_rollback_alloc_dinode_counts(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl;\n\n\tcl = (struct ocfs2_chain_list *)&di->id2.i_chain;\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(tmp_used - num_bits);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, num_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_chain"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_group_set_bits",
          "args": [
            "handle",
            "gb_inode",
            "gd",
            "gd_bh",
            "goal_bit",
            "len"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_group_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1341-1387",
          "snippet": "int ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_bg(struct ocfs2_group_desc *bg);\n\nint ocfs2_block_group_set_bits(handle_t *handle,\n\t\t\t\t\t     struct inode *alloc_inode,\n\t\t\t\t\t     struct ocfs2_group_desc *bg,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     unsigned int bit_off,\n\t\t\t\t\t     unsigned int num_bits)\n{\n\tint status;\n\tvoid *bitmap = bg->bg_bitmap;\n\tint journal_type = OCFS2_JOURNAL_ACCESS_WRITE;\n\n\t/* All callers get the descriptor via\n\t * ocfs2_read_group_descriptor().  Any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_GROUP_DESC(bg));\n\tBUG_ON(le16_to_cpu(bg->bg_free_bits_count) < num_bits);\n\n\ttrace_ocfs2_block_group_set_bits(bit_off, num_bits);\n\n\tif (ocfs2_is_cluster_bitmap(alloc_inode))\n\t\tjournal_type = OCFS2_JOURNAL_ACCESS_UNDO;\n\n\tstatus = ocfs2_journal_access_gd(handle,\n\t\t\t\t\t INODE_CACHE(alloc_inode),\n\t\t\t\t\t group_bh,\n\t\t\t\t\t journal_type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tle16_add_cpu(&bg->bg_free_bits_count, -num_bits);\n\tif (le16_to_cpu(bg->bg_free_bits_count) > le16_to_cpu(bg->bg_bits)) {\n\t\tocfs2_error(alloc_inode->i_sb, \"Group descriptor # %llu has bit\"\n\t\t\t    \" count %u but claims %u are freed. num_bits %d\",\n\t\t\t    (unsigned long long)le64_to_cpu(bg->bg_blkno),\n\t\t\t    le16_to_cpu(bg->bg_bits),\n\t\t\t    le16_to_cpu(bg->bg_free_bits_count), num_bits);\n\t\treturn -EROFS;\n\t}\n\twhile(num_bits--)\n\t\tocfs2_set_bit(bit_off++, bitmap);\n\n\tocfs2_journal_dirty(handle, group_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_dinode_update_counts",
          "args": [
            "gb_inode",
            "handle",
            "gb_bh",
            "len",
            "le16_to_cpu(gd->bg_chain)"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_dinode_update_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1584-1609",
          "snippet": "int ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);",
            "static int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);",
            "static int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline u16 ocfs2_find_victim_chain(struct ocfs2_chain_list *cl);\nstatic int ocfs2_block_group_fill(handle_t *handle,\n\t\t\t\t  struct inode *alloc_inode,\n\t\t\t\t  struct buffer_head *bg_bh,\n\t\t\t\t  u64 group_blkno,\n\t\t\t\t  unsigned int group_clusters,\n\t\t\t\t  u16 my_chain,\n\t\t\t\t  struct ocfs2_chain_list *cl);\nstatic int ocfs2_relink_block_group(handle_t *handle,\n\t\t\t\t    struct inode *alloc_inode,\n\t\t\t\t    struct buffer_head *fe_bh,\n\t\t\t\t    struct buffer_head *bg_bh,\n\t\t\t\t    struct buffer_head *prev_bg_bh,\n\t\t\t\t    u16 chain);\n\nint ocfs2_alloc_dinode_update_counts(struct inode *inode,\n\t\t\t\t       handle_t *handle,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u32 num_bits,\n\t\t\t\t       u16 chain)\n{\n\tint ret;\n\tu32 tmp_used;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) di_bh->b_data;\n\tstruct ocfs2_chain_list *cl = (struct ocfs2_chain_list *) &di->id2.i_chain;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttmp_used = le32_to_cpu(di->id1.bitmap1.i_used);\n\tdi->id1.bitmap1.i_used = cpu_to_le32(num_bits + tmp_used);\n\tle32_add_cpu(&cl->cl_recs[chain].c_free, -num_bits);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_move_extent",
          "args": [
            "handle",
            "context",
            "cpos",
            "len",
            "phys_cpos",
            "*new_phys_cpos",
            "ext_flags"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_move_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "58-158",
          "snippet": "static int __ocfs2_move_extent(handle_t *handle,\n\t\t\t       struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 len, u32 p_cpos, u32 new_p_cpos,\n\t\t\t       int ext_flags)\n{\n\tint ret = 0, index;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_rec *rec, replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tu64 ino = ocfs2_metadata_cache_owner(context->et.et_ci);\n\tu64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);\n\n\tret = ocfs2_duplicate_clusters_by_page(handle, inode, cpos,\n\t\t\t\t\t       p_cpos, new_p_cpos, len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t\t   new_p_cpos));\n\n\tpath = ocfs2_new_path_from_et(&context->et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(INODE_CACHE(inode), path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\trec = &el->l_recs[index];\n\n\tBUG_ON(ext_flags != rec->e_flags);\n\t/*\n\t * after moving/defraging to new location, the extent is not going\n\t * to be refcounted anymore.\n\t */\n\treplace_rec.e_flags = ext_flags & ~OCFS2_EXT_REFCOUNTED;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t      context->et.et_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, &context->et, path, index,\n\t\t\t\t &replace_rec, context->meta_ac,\n\t\t\t\t &context->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, context->et.et_root_bh);\n\n\tcontext->new_phys_cpos = new_p_cpos;\n\n\t/*\n\t * need I to append truncate log for old clusters?\n\t */\n\tif (old_blkno) {\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t old_blkno),\n\t\t\t\t\tlen, context->meta_ac,\n\t\t\t\t\t&context->dealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\told_blkno, len);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_move_extent(handle_t *handle,\n\t\t\t       struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 len, u32 p_cpos, u32 new_p_cpos,\n\t\t\t       int ext_flags)\n{\n\tint ret = 0, index;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_rec *rec, replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tu64 ino = ocfs2_metadata_cache_owner(context->et.et_ci);\n\tu64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);\n\n\tret = ocfs2_duplicate_clusters_by_page(handle, inode, cpos,\n\t\t\t\t\t       p_cpos, new_p_cpos, len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t\t   new_p_cpos));\n\n\tpath = ocfs2_new_path_from_et(&context->et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(INODE_CACHE(inode), path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\trec = &el->l_recs[index];\n\n\tBUG_ON(ext_flags != rec->e_flags);\n\t/*\n\t * after moving/defraging to new location, the extent is not going\n\t * to be refcounted anymore.\n\t */\n\treplace_rec.e_flags = ext_flags & ~OCFS2_EXT_REFCOUNTED;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t      context->et.et_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, &context->et, path, index,\n\t\t\t\t &replace_rec, context->meta_ac,\n\t\t\t\t &context->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, context->et.et_root_bh);\n\n\tcontext->new_phys_cpos = new_p_cpos;\n\n\t/*\n\t * need I to append truncate log for old clusters?\n\t */\n\tif (old_blkno) {\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t old_blkno),\n\t\t\t\t\tlen, context->meta_ac,\n\t\t\t\t\t&context->dealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\told_blkno, len);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_probe_alloc_group",
          "args": [
            "inode",
            "gd_bh",
            "&goal_bit",
            "len",
            "move_max_hop",
            "new_phys_cpos"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_probe_alloc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "526-563",
          "snippet": "static void ocfs2_probe_alloc_group(struct inode *inode, struct buffer_head *bh,\n\t\t\t\t    int *goal_bit, u32 move_len, u32 max_hop,\n\t\t\t\t    u32 *phys_cpos)\n{\n\tint i, used, last_free_bits = 0, base_bit = *goal_bit;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\tu32 base_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t le64_to_cpu(gd->bg_blkno));\n\n\tfor (i = base_bit; i < le16_to_cpu(gd->bg_bits); i++) {\n\n\t\tused = ocfs2_test_bit(i, (unsigned long *)gd->bg_bitmap);\n\t\tif (used) {\n\t\t\t/*\n\t\t\t * we even tried searching the free chunk by jumping\n\t\t\t * a 'max_hop' distance, but still failed.\n\t\t\t */\n\t\t\tif ((i - base_bit) > max_hop) {\n\t\t\t\t*phys_cpos = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (last_free_bits)\n\t\t\t\tlast_free_bits = 0;\n\n\t\t\tcontinue;\n\t\t} else\n\t\t\tlast_free_bits++;\n\n\t\tif (last_free_bits == move_len) {\n\t\t\t*goal_bit = i;\n\t\t\t*phys_cpos = base_cpos + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmlog(0, \"found phys_cpos: %u to fit the wanted moving.\\n\", *phys_cpos);\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_probe_alloc_group(struct inode *inode, struct buffer_head *bh,\n\t\t\t\t    int *goal_bit, u32 move_len, u32 max_hop,\n\t\t\t\t    u32 *phys_cpos)\n{\n\tint i, used, last_free_bits = 0, base_bit = *goal_bit;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\tu32 base_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t le64_to_cpu(gd->bg_blkno));\n\n\tfor (i = base_bit; i < le16_to_cpu(gd->bg_bits); i++) {\n\n\t\tused = ocfs2_test_bit(i, (unsigned long *)gd->bg_bitmap);\n\t\tif (used) {\n\t\t\t/*\n\t\t\t * we even tried searching the free chunk by jumping\n\t\t\t * a 'max_hop' distance, but still failed.\n\t\t\t */\n\t\t\tif ((i - base_bit) > max_hop) {\n\t\t\t\t*phys_cpos = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (last_free_bits)\n\t\t\t\tlast_free_bits = 0;\n\n\t\t\tcontinue;\n\t\t} else\n\t\t\tlast_free_bits++;\n\n\t\tif (last_free_bits == move_len) {\n\t\t\t*goal_bit = i;\n\t\t\t*phys_cpos = base_cpos + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmlog(0, \"found phys_cpos: %u to fit the wanted moving.\\n\", *phys_cpos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_victim_alloc_group",
          "args": [
            "inode",
            "new_phys_blkno",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT",
            "&goal_bit",
            "&gd_bh"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_victim_alloc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "365-464",
          "snippet": "static int ocfs2_find_victim_alloc_group(struct inode *inode,\n\t\t\t\t\t u64 vict_blkno,\n\t\t\t\t\t int type, int slot,\n\t\t\t\t\t int *vict_bit,\n\t\t\t\t\t struct buffer_head **ret_bh)\n{\n\tint ret, i, bits_per_unit = 0;\n\tu64 blkno;\n\tchar namebuf[40];\n\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ac_bh = NULL, *gd_bh = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *rec;\n\tstruct ocfs2_dinode *ac_dinode;\n\tstruct ocfs2_group_desc *bg;\n\n\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type, slot);\n\tret = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t strlen(namebuf), &blkno);\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &ac_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac_dinode = (struct ocfs2_dinode *)ac_bh->b_data;\n\tcl = &(ac_dinode->id2.i_chain);\n\trec = &(cl->cl_recs[0]);\n\n\tif (type == GLOBAL_BITMAP_SYSTEM_INODE)\n\t\tbits_per_unit = osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits;\n\t/*\n\t * 'vict_blkno' was out of the valid range.\n\t */\n\tif ((vict_blkno < le64_to_cpu(rec->c_blkno)) ||\n\t    (vict_blkno >= ((u64)le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<\n\t\t\t\tbits_per_unit))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\n\t\trec = &(cl->cl_recs[i]);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\tbg = NULL;\n\n\t\tdo {\n\t\t\tif (!bg)\n\t\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\t\telse\n\t\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\t\tif (gd_bh) {\n\t\t\t\tbrelse(gd_bh);\n\t\t\t\tgd_bh = NULL;\n\t\t\t}\n\n\t\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &gd_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t\t\tif (vict_blkno < (le64_to_cpu(bg->bg_blkno) +\n\t\t\t\t\t\tle16_to_cpu(bg->bg_bits))) {\n\n\t\t\t\t*ret_bh = gd_bh;\n\t\t\t\t*vict_bit = (vict_blkno - blkno) >>\n\t\t\t\t\t\t\tbits_per_unit;\n\t\t\t\tmlog(0, \"find the victim group: #%llu, \"\n\t\t\t\t     \"total_bits: %u, vict_bit: %u\\n\",\n\t\t\t\t     blkno, le16_to_cpu(bg->bg_bits),\n\t\t\t\t     *vict_bit);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} while (le64_to_cpu(bg->bg_next_group));\n\t}\n\n\tret = -EINVAL;\nout:\n\tbrelse(ac_bh);\n\n\t/*\n\t * caller has to release the gd_bh properly.\n\t */\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_find_victim_alloc_group(struct inode *inode,\n\t\t\t\t\t u64 vict_blkno,\n\t\t\t\t\t int type, int slot,\n\t\t\t\t\t int *vict_bit,\n\t\t\t\t\t struct buffer_head **ret_bh)\n{\n\tint ret, i, bits_per_unit = 0;\n\tu64 blkno;\n\tchar namebuf[40];\n\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ac_bh = NULL, *gd_bh = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *rec;\n\tstruct ocfs2_dinode *ac_dinode;\n\tstruct ocfs2_group_desc *bg;\n\n\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type, slot);\n\tret = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t strlen(namebuf), &blkno);\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &ac_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac_dinode = (struct ocfs2_dinode *)ac_bh->b_data;\n\tcl = &(ac_dinode->id2.i_chain);\n\trec = &(cl->cl_recs[0]);\n\n\tif (type == GLOBAL_BITMAP_SYSTEM_INODE)\n\t\tbits_per_unit = osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits;\n\t/*\n\t * 'vict_blkno' was out of the valid range.\n\t */\n\tif ((vict_blkno < le64_to_cpu(rec->c_blkno)) ||\n\t    (vict_blkno >= ((u64)le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<\n\t\t\t\tbits_per_unit))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\n\t\trec = &(cl->cl_recs[i]);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\tbg = NULL;\n\n\t\tdo {\n\t\t\tif (!bg)\n\t\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\t\telse\n\t\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\t\tif (gd_bh) {\n\t\t\t\tbrelse(gd_bh);\n\t\t\t\tgd_bh = NULL;\n\t\t\t}\n\n\t\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &gd_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t\t\tif (vict_blkno < (le64_to_cpu(bg->bg_blkno) +\n\t\t\t\t\t\tle16_to_cpu(bg->bg_bits))) {\n\n\t\t\t\t*ret_bh = gd_bh;\n\t\t\t\t*vict_bit = (vict_blkno - blkno) >>\n\t\t\t\t\t\t\tbits_per_unit;\n\t\t\t\tmlog(0, \"find the victim group: #%llu, \"\n\t\t\t\t     \"total_bits: %u, vict_bit: %u\\n\",\n\t\t\t\t     blkno, le16_to_cpu(bg->bg_bits),\n\t\t\t\t     *vict_bit);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} while (le64_to_cpu(bg->bg_next_group));\n\t}\n\n\tret = -EINVAL;\nout:\n\tbrelse(ac_bh);\n\n\t/*\n\t * caller has to release the gd_bh properly.\n\t */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "*new_phys_cpos"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "gb_inode",
            "&gb_bh",
            "1"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&gb_inode->i_mutex"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"unable to get global_bitmap inode\\n\""
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_allocators_move_extents",
          "args": [
            "inode",
            "&context->et",
            "len",
            "1",
            "&context->meta_ac",
            "NULL",
            "extra_blocks",
            "&credits"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_allocators_move_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "167-218",
          "snippet": "static int ocfs2_lock_allocators_move_extents(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tu32 clusters_to_move,\n\t\t\t\t\tu32 extents_to_split,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint extra_blocks,\n\t\t\t\t\tint *credits)\n{\n\tint ret, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split + clusters_to_move;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_to_move, data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb, et->et_root_el);\n\n\tmlog(0, \"reserve metadata_blocks: %d, data_clusters: %u, credits: %d\\n\",\n\t     extra_blocks, clusters_to_move, *credits);\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_lock_allocators_move_extents(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tu32 clusters_to_move,\n\t\t\t\t\tu32 extents_to_split,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint extra_blocks,\n\t\t\t\t\tint *credits)\n{\n\tint ret, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split + clusters_to_move;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_to_move, data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb, et->et_root_el);\n\n\tmlog(0, \"reserve metadata_blocks: %d, data_clusters: %u, credits: %d\\n\",\n\t     extra_blocks, clusters_to_move, *credits);\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_refcount_change_for_del",
          "args": [
            "inode",
            "context->refcount_loc",
            "phys_blkno",
            "len",
            "&credits",
            "&extra_blocks"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_refcount_change_for_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2536-2588",
          "snippet": "int ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "context->refcount_loc",
            "1",
            "&ref_tree",
            "NULL"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!context->refcount_loc"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "context->range->me_threshold"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_move_extent(struct ocfs2_move_extents_context *context,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 *new_phys_cpos,\n\t\t\t     u32 len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, goal_bit = 0;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *gb_inode = NULL;\n\tstruct buffer_head *gb_bh = NULL;\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *gd;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 move_max_hop = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    context->range->me_threshold);\n\tu64 phys_blkno, new_phys_blkno;\n\n\tphys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && len) {\n\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\tlen,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_allocators_move_extents(inode, &context->et, len, 1,\n\t\t\t\t\t\t &context->meta_ac,\n\t\t\t\t\t\t NULL, extra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * need to count 2 extra credits for global_bitmap inode and\n\t * group descriptor.\n\t */\n\tcredits += OCFS2_INODE_UPDATE_CREDITS + 1;\n\n\t/*\n\t * ocfs2_move_extent() didn't reserve any clusters in lock_allocators()\n\t * logic, while we still need to lock the global_bitmap.\n\t */\n\tgb_inode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!gb_inode) {\n\t\tmlog(ML_ERROR, \"unable to get global_bitmap inode\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&gb_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(gb_inode, &gb_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_gb_mutex;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_tl_inode;\n\t}\n\n\tnew_phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *new_phys_cpos);\n\tret = ocfs2_find_victim_alloc_group(inode, new_phys_blkno,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * probe the victim cluster group to find a proper\n\t * region to fit wanted movement, it even will perfrom\n\t * a best-effort attempt by compromising to a threshold\n\t * around the goal.\n\t */\n\tocfs2_probe_alloc_group(inode, gd_bh, &goal_bit, len, move_max_hop,\n\t\t\t\tnew_phys_cpos);\n\tif (!*new_phys_cpos) {\n\t\tret = -ENOSPC;\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_move_extent(handle, context, cpos, len, phys_cpos,\n\t\t\t\t  *new_phys_cpos, ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgd = (struct ocfs2_group_desc *)gd_bh->b_data;\n\tret = ocfs2_alloc_dinode_update_counts(gb_inode, handle, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_block_group_set_bits(handle, gb_inode, gd, gd_bh,\n\t\t\t\t\t goal_bit, len);\n\tif (ret) {\n\t\tocfs2_rollback_alloc_dinode_counts(gb_inode, gb_bh, len,\n\t\t\t\t\t       le16_to_cpu(gd->bg_chain));\n\t\tmlog_errno(ret);\n\t}\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\tbrelse(gd_bh);\n\nout_unlock_tl_inode:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tocfs2_inode_unlock(gb_inode, 1);\nout_unlock_gb_mutex:\n\tmutex_unlock(&gb_inode->i_mutex);\n\tbrelse(gb_bh);\n\tiput(gb_inode);\n\nout:\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_probe_alloc_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "526-563",
    "snippet": "static void ocfs2_probe_alloc_group(struct inode *inode, struct buffer_head *bh,\n\t\t\t\t    int *goal_bit, u32 move_len, u32 max_hop,\n\t\t\t\t    u32 *phys_cpos)\n{\n\tint i, used, last_free_bits = 0, base_bit = *goal_bit;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\tu32 base_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t le64_to_cpu(gd->bg_blkno));\n\n\tfor (i = base_bit; i < le16_to_cpu(gd->bg_bits); i++) {\n\n\t\tused = ocfs2_test_bit(i, (unsigned long *)gd->bg_bitmap);\n\t\tif (used) {\n\t\t\t/*\n\t\t\t * we even tried searching the free chunk by jumping\n\t\t\t * a 'max_hop' distance, but still failed.\n\t\t\t */\n\t\t\tif ((i - base_bit) > max_hop) {\n\t\t\t\t*phys_cpos = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (last_free_bits)\n\t\t\t\tlast_free_bits = 0;\n\n\t\t\tcontinue;\n\t\t} else\n\t\t\tlast_free_bits++;\n\n\t\tif (last_free_bits == move_len) {\n\t\t\t*goal_bit = i;\n\t\t\t*phys_cpos = base_cpos + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmlog(0, \"found phys_cpos: %u to fit the wanted moving.\\n\", *phys_cpos);\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"found phys_cpos: %u to fit the wanted moving.\\n\"",
            "*phys_cpos"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_test_bit",
          "args": [
            "i",
            "(unsigned long *)gd->bg_bitmap"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_bits"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "le64_to_cpu(gd->bg_blkno)"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_probe_alloc_group(struct inode *inode, struct buffer_head *bh,\n\t\t\t\t    int *goal_bit, u32 move_len, u32 max_hop,\n\t\t\t\t    u32 *phys_cpos)\n{\n\tint i, used, last_free_bits = 0, base_bit = *goal_bit;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\tu32 base_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t le64_to_cpu(gd->bg_blkno));\n\n\tfor (i = base_bit; i < le16_to_cpu(gd->bg_bits); i++) {\n\n\t\tused = ocfs2_test_bit(i, (unsigned long *)gd->bg_bitmap);\n\t\tif (used) {\n\t\t\t/*\n\t\t\t * we even tried searching the free chunk by jumping\n\t\t\t * a 'max_hop' distance, but still failed.\n\t\t\t */\n\t\t\tif ((i - base_bit) > max_hop) {\n\t\t\t\t*phys_cpos = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (last_free_bits)\n\t\t\t\tlast_free_bits = 0;\n\n\t\t\tcontinue;\n\t\t} else\n\t\t\tlast_free_bits++;\n\n\t\tif (last_free_bits == move_len) {\n\t\t\t*goal_bit = i;\n\t\t\t*phys_cpos = base_cpos + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmlog(0, \"found phys_cpos: %u to fit the wanted moving.\\n\", *phys_cpos);\n}"
  },
  {
    "function_name": "ocfs2_validate_and_adjust_move_goal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "469-524",
    "snippet": "static int ocfs2_validate_and_adjust_move_goal(struct inode *inode,\n\t\t\t\t\t       struct ocfs2_move_extents *range)\n{\n\tint ret, goal_bit = 0;\n\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint c_to_b = 1 << (osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits);\n\n\t/*\n\t * make goal become cluster aligned.\n\t */\n\trange->me_goal = ocfs2_block_to_cluster_start(inode->i_sb,\n\t\t\t\t\t\t      range->me_goal);\n\t/*\n\t * validate goal sits within global_bitmap, and return the victim\n\t * group desc\n\t */\n\tret = ocfs2_find_victim_alloc_group(inode, range->me_goal,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t/*\n\t * moving goal is not allowd to start with a group desc blok(#0 blk)\n\t * let's compromise to the latter cluster.\n\t */\n\tif (range->me_goal == le64_to_cpu(bg->bg_blkno))\n\t\trange->me_goal += c_to_b;\n\n\t/*\n\t * movement is not gonna cross two groups.\n\t */\n\tif ((le16_to_cpu(bg->bg_bits) - goal_bit) * osb->s_clustersize <\n\t\t\t\t\t\t\t\trange->me_len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t * more exact validations/adjustments will be performed later during\n\t * moving operation for each extent range.\n\t */\n\tmlog(0, \"extents get ready to be moved to #%llu block\\n\",\n\t     range->me_goal);\n\nout:\n\tbrelse(gd_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "gd_bh"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"extents get ready to be moved to #%llu block\\n\"",
            "range->me_goal"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_bits"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "bg->bg_blkno"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_victim_alloc_group",
          "args": [
            "inode",
            "range->me_goal",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT",
            "&goal_bit",
            "&gd_bh"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_victim_alloc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "365-464",
          "snippet": "static int ocfs2_find_victim_alloc_group(struct inode *inode,\n\t\t\t\t\t u64 vict_blkno,\n\t\t\t\t\t int type, int slot,\n\t\t\t\t\t int *vict_bit,\n\t\t\t\t\t struct buffer_head **ret_bh)\n{\n\tint ret, i, bits_per_unit = 0;\n\tu64 blkno;\n\tchar namebuf[40];\n\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ac_bh = NULL, *gd_bh = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *rec;\n\tstruct ocfs2_dinode *ac_dinode;\n\tstruct ocfs2_group_desc *bg;\n\n\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type, slot);\n\tret = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t strlen(namebuf), &blkno);\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &ac_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac_dinode = (struct ocfs2_dinode *)ac_bh->b_data;\n\tcl = &(ac_dinode->id2.i_chain);\n\trec = &(cl->cl_recs[0]);\n\n\tif (type == GLOBAL_BITMAP_SYSTEM_INODE)\n\t\tbits_per_unit = osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits;\n\t/*\n\t * 'vict_blkno' was out of the valid range.\n\t */\n\tif ((vict_blkno < le64_to_cpu(rec->c_blkno)) ||\n\t    (vict_blkno >= ((u64)le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<\n\t\t\t\tbits_per_unit))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\n\t\trec = &(cl->cl_recs[i]);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\tbg = NULL;\n\n\t\tdo {\n\t\t\tif (!bg)\n\t\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\t\telse\n\t\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\t\tif (gd_bh) {\n\t\t\t\tbrelse(gd_bh);\n\t\t\t\tgd_bh = NULL;\n\t\t\t}\n\n\t\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &gd_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t\t\tif (vict_blkno < (le64_to_cpu(bg->bg_blkno) +\n\t\t\t\t\t\tle16_to_cpu(bg->bg_bits))) {\n\n\t\t\t\t*ret_bh = gd_bh;\n\t\t\t\t*vict_bit = (vict_blkno - blkno) >>\n\t\t\t\t\t\t\tbits_per_unit;\n\t\t\t\tmlog(0, \"find the victim group: #%llu, \"\n\t\t\t\t     \"total_bits: %u, vict_bit: %u\\n\",\n\t\t\t\t     blkno, le16_to_cpu(bg->bg_bits),\n\t\t\t\t     *vict_bit);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} while (le64_to_cpu(bg->bg_next_group));\n\t}\n\n\tret = -EINVAL;\nout:\n\tbrelse(ac_bh);\n\n\t/*\n\t * caller has to release the gd_bh properly.\n\t */\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_find_victim_alloc_group(struct inode *inode,\n\t\t\t\t\t u64 vict_blkno,\n\t\t\t\t\t int type, int slot,\n\t\t\t\t\t int *vict_bit,\n\t\t\t\t\t struct buffer_head **ret_bh)\n{\n\tint ret, i, bits_per_unit = 0;\n\tu64 blkno;\n\tchar namebuf[40];\n\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ac_bh = NULL, *gd_bh = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *rec;\n\tstruct ocfs2_dinode *ac_dinode;\n\tstruct ocfs2_group_desc *bg;\n\n\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type, slot);\n\tret = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t strlen(namebuf), &blkno);\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &ac_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac_dinode = (struct ocfs2_dinode *)ac_bh->b_data;\n\tcl = &(ac_dinode->id2.i_chain);\n\trec = &(cl->cl_recs[0]);\n\n\tif (type == GLOBAL_BITMAP_SYSTEM_INODE)\n\t\tbits_per_unit = osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits;\n\t/*\n\t * 'vict_blkno' was out of the valid range.\n\t */\n\tif ((vict_blkno < le64_to_cpu(rec->c_blkno)) ||\n\t    (vict_blkno >= ((u64)le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<\n\t\t\t\tbits_per_unit))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\n\t\trec = &(cl->cl_recs[i]);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\tbg = NULL;\n\n\t\tdo {\n\t\t\tif (!bg)\n\t\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\t\telse\n\t\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\t\tif (gd_bh) {\n\t\t\t\tbrelse(gd_bh);\n\t\t\t\tgd_bh = NULL;\n\t\t\t}\n\n\t\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &gd_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t\t\tif (vict_blkno < (le64_to_cpu(bg->bg_blkno) +\n\t\t\t\t\t\tle16_to_cpu(bg->bg_bits))) {\n\n\t\t\t\t*ret_bh = gd_bh;\n\t\t\t\t*vict_bit = (vict_blkno - blkno) >>\n\t\t\t\t\t\t\tbits_per_unit;\n\t\t\t\tmlog(0, \"find the victim group: #%llu, \"\n\t\t\t\t     \"total_bits: %u, vict_bit: %u\\n\",\n\t\t\t\t     blkno, le16_to_cpu(bg->bg_bits),\n\t\t\t\t     *vict_bit);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} while (le64_to_cpu(bg->bg_next_group));\n\t}\n\n\tret = -EINVAL;\nout:\n\tbrelse(ac_bh);\n\n\t/*\n\t * caller has to release the gd_bh properly.\n\t */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_to_cluster_start",
          "args": [
            "inode->i_sb",
            "range->me_goal"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_to_cluster_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "765-773",
          "snippet": "static inline u64 ocfs2_block_to_cluster_start(struct super_block *sb,\n\t\t\t\t\t       u64 blocks)\n{\n\tint bits = OCFS2_SB(sb)->s_clustersize_bits - sb->s_blocksize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_blocks_to_clusters(sb, blocks);\n\treturn (u64)clusters << bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_block_to_cluster_start(struct super_block *sb,\n\t\t\t\t\t       u64 blocks)\n{\n\tint bits = OCFS2_SB(sb)->s_clustersize_bits - sb->s_blocksize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_blocks_to_clusters(sb, blocks);\n\treturn (u64)clusters << bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_validate_and_adjust_move_goal(struct inode *inode,\n\t\t\t\t\t       struct ocfs2_move_extents *range)\n{\n\tint ret, goal_bit = 0;\n\n\tstruct buffer_head *gd_bh = NULL;\n\tstruct ocfs2_group_desc *bg;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint c_to_b = 1 << (osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits);\n\n\t/*\n\t * make goal become cluster aligned.\n\t */\n\trange->me_goal = ocfs2_block_to_cluster_start(inode->i_sb,\n\t\t\t\t\t\t      range->me_goal);\n\t/*\n\t * validate goal sits within global_bitmap, and return the victim\n\t * group desc\n\t */\n\tret = ocfs2_find_victim_alloc_group(inode, range->me_goal,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT,\n\t\t\t\t\t    &goal_bit, &gd_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t/*\n\t * moving goal is not allowd to start with a group desc blok(#0 blk)\n\t * let's compromise to the latter cluster.\n\t */\n\tif (range->me_goal == le64_to_cpu(bg->bg_blkno))\n\t\trange->me_goal += c_to_b;\n\n\t/*\n\t * movement is not gonna cross two groups.\n\t */\n\tif ((le16_to_cpu(bg->bg_bits) - goal_bit) * osb->s_clustersize <\n\t\t\t\t\t\t\t\trange->me_len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t * more exact validations/adjustments will be performed later during\n\t * moving operation for each extent range.\n\t */\n\tmlog(0, \"extents get ready to be moved to #%llu block\\n\",\n\t     range->me_goal);\n\nout:\n\tbrelse(gd_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_find_victim_alloc_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "365-464",
    "snippet": "static int ocfs2_find_victim_alloc_group(struct inode *inode,\n\t\t\t\t\t u64 vict_blkno,\n\t\t\t\t\t int type, int slot,\n\t\t\t\t\t int *vict_bit,\n\t\t\t\t\t struct buffer_head **ret_bh)\n{\n\tint ret, i, bits_per_unit = 0;\n\tu64 blkno;\n\tchar namebuf[40];\n\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ac_bh = NULL, *gd_bh = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *rec;\n\tstruct ocfs2_dinode *ac_dinode;\n\tstruct ocfs2_group_desc *bg;\n\n\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type, slot);\n\tret = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t strlen(namebuf), &blkno);\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &ac_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac_dinode = (struct ocfs2_dinode *)ac_bh->b_data;\n\tcl = &(ac_dinode->id2.i_chain);\n\trec = &(cl->cl_recs[0]);\n\n\tif (type == GLOBAL_BITMAP_SYSTEM_INODE)\n\t\tbits_per_unit = osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits;\n\t/*\n\t * 'vict_blkno' was out of the valid range.\n\t */\n\tif ((vict_blkno < le64_to_cpu(rec->c_blkno)) ||\n\t    (vict_blkno >= ((u64)le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<\n\t\t\t\tbits_per_unit))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\n\t\trec = &(cl->cl_recs[i]);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\tbg = NULL;\n\n\t\tdo {\n\t\t\tif (!bg)\n\t\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\t\telse\n\t\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\t\tif (gd_bh) {\n\t\t\t\tbrelse(gd_bh);\n\t\t\t\tgd_bh = NULL;\n\t\t\t}\n\n\t\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &gd_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t\t\tif (vict_blkno < (le64_to_cpu(bg->bg_blkno) +\n\t\t\t\t\t\tle16_to_cpu(bg->bg_bits))) {\n\n\t\t\t\t*ret_bh = gd_bh;\n\t\t\t\t*vict_bit = (vict_blkno - blkno) >>\n\t\t\t\t\t\t\tbits_per_unit;\n\t\t\t\tmlog(0, \"find the victim group: #%llu, \"\n\t\t\t\t     \"total_bits: %u, vict_bit: %u\\n\",\n\t\t\t\t     blkno, le16_to_cpu(bg->bg_bits),\n\t\t\t\t     *vict_bit);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} while (le64_to_cpu(bg->bg_next_group));\n\t}\n\n\tret = -EINVAL;\nout:\n\tbrelse(ac_bh);\n\n\t/*\n\t * caller has to release the gd_bh properly.\n\t */\n\treturn ret;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ac_bh"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "bg->bg_next_group"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"find the victim group: #%llu, \"\n\t\t\t\t     \"total_bits: %u, vict_bit: %u\\n\"",
            "blkno",
            "le16_to_cpu(bg->bg_bits)",
            "*vict_bit"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bg->bg_bits"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "blkno",
            "1",
            "&gd_bh"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ac_dinode->id1.bitmap1.i_total"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lookup_ino_from_name",
          "args": [
            "osb->sys_root_inode",
            "namebuf",
            "strlen(namebuf)",
            "&blkno"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lookup_ino_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2027-2037",
          "snippet": "int ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_lookup_ino_from_name(struct inode *dir, const char *name,\n\t\t\t       int namelen, u64 *blkno)\n{\n\tint ret;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\tret = ocfs2_find_files_on_disk(name, namelen, blkno, dir, &lookup);\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "namebuf"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sprintf_system_inode_name",
          "args": [
            "namebuf",
            "sizeof(namebuf)",
            "type",
            "slot"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_find_victim_alloc_group(struct inode *inode,\n\t\t\t\t\t u64 vict_blkno,\n\t\t\t\t\t int type, int slot,\n\t\t\t\t\t int *vict_bit,\n\t\t\t\t\t struct buffer_head **ret_bh)\n{\n\tint ret, i, bits_per_unit = 0;\n\tu64 blkno;\n\tchar namebuf[40];\n\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ac_bh = NULL, *gd_bh = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *rec;\n\tstruct ocfs2_dinode *ac_dinode;\n\tstruct ocfs2_group_desc *bg;\n\n\tocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type, slot);\n\tret = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t strlen(namebuf), &blkno);\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &ac_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tac_dinode = (struct ocfs2_dinode *)ac_bh->b_data;\n\tcl = &(ac_dinode->id2.i_chain);\n\trec = &(cl->cl_recs[0]);\n\n\tif (type == GLOBAL_BITMAP_SYSTEM_INODE)\n\t\tbits_per_unit = osb->s_clustersize_bits -\n\t\t\t\t\tinode->i_sb->s_blocksize_bits;\n\t/*\n\t * 'vict_blkno' was out of the valid range.\n\t */\n\tif ((vict_blkno < le64_to_cpu(rec->c_blkno)) ||\n\t    (vict_blkno >= ((u64)le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<\n\t\t\t\tbits_per_unit))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\n\n\t\trec = &(cl->cl_recs[i]);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\tbg = NULL;\n\n\t\tdo {\n\t\t\tif (!bg)\n\t\t\t\tblkno = le64_to_cpu(rec->c_blkno);\n\t\t\telse\n\t\t\t\tblkno = le64_to_cpu(bg->bg_next_group);\n\n\t\t\tif (gd_bh) {\n\t\t\t\tbrelse(gd_bh);\n\t\t\t\tgd_bh = NULL;\n\t\t\t}\n\n\t\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &gd_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbg = (struct ocfs2_group_desc *)gd_bh->b_data;\n\n\t\t\tif (vict_blkno < (le64_to_cpu(bg->bg_blkno) +\n\t\t\t\t\t\tle16_to_cpu(bg->bg_bits))) {\n\n\t\t\t\t*ret_bh = gd_bh;\n\t\t\t\t*vict_bit = (vict_blkno - blkno) >>\n\t\t\t\t\t\t\tbits_per_unit;\n\t\t\t\tmlog(0, \"find the victim group: #%llu, \"\n\t\t\t\t     \"total_bits: %u, vict_bit: %u\\n\",\n\t\t\t\t     blkno, le16_to_cpu(bg->bg_bits),\n\t\t\t\t     *vict_bit);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t} while (le64_to_cpu(bg->bg_next_group));\n\t}\n\n\tret = -EINVAL;\nout:\n\tbrelse(ac_bh);\n\n\t/*\n\t * caller has to release the gd_bh properly.\n\t */\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_defrag_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "227-360",
    "snippet": "static int ocfs2_defrag_extent(struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 phys_cpos, u32 *len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, partial = context->partial;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 new_phys_cpos, new_len;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && *len) {\n\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\t*len,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_allocators_move_extents(inode, &context->et, *len, 1,\n\t\t\t\t\t\t &context->meta_ac,\n\t\t\t\t\t\t &context->data_ac,\n\t\t\t\t\t\t extra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * should be using allocation reservation strategy there?\n\t *\n\t * if (context->data_ac)\n\t *\tcontext->data_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\t */\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock_mutex;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_mutex;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, context->data_ac, 1, *len,\n\t\t\t\t     &new_phys_cpos, &new_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * allowing partial extent moving is kind of 'pros and cons', it makes\n\t * whole defragmentation less likely to fail, on the contrary, the bad\n\t * thing is it may make the fs even more fragmented after moving, let\n\t * userspace make a good decision here.\n\t */\n\tif (new_len != *len) {\n\t\tmlog(0, \"len_claimed: %u, len: %u\\n\", new_len, *len);\n\t\tif (!partial) {\n\t\t\tcontext->range->me_flags &= ~OCFS2_MOVE_EXT_FL_COMPLETE;\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tmlog(0, \"cpos: %u, phys_cpos: %u, new_phys_cpos: %u\\n\", cpos,\n\t     phys_cpos, new_phys_cpos);\n\n\tret = __ocfs2_move_extent(handle, context, cpos, new_len, phys_cpos,\n\t\t\t\t  new_phys_cpos, ext_flags);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (partial && (new_len != *len))\n\t\t*len = new_len;\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, *len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock_mutex:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "context->meta_ac"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_sync_writeback",
          "args": [
            "inode->i_sb",
            "context->inode",
            "cpos",
            "*len"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_sync_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3161-3209",
          "snippet": "int ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret = 0;\n\tloff_t offset, end, map_end;\n\tpgoff_t page_index;\n\tstruct page *page;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\n\n\tret = filemap_fdatawrite_range(inode->i_mapping,\n\t\t\t\t       offset, end - 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   page_index, GFP_NOFS);\n\t\tBUG_ON(!page);\n\n\t\twait_on_page_writeback(page);\n\t\tif (PageError(page)) {\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tmark_page_accessed(page);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret = 0;\n\tloff_t offset, end, map_end;\n\tpgoff_t page_index;\n\tstruct page *page;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\n\n\tret = filemap_fdatawrite_range(inode->i_mapping,\n\t\t\t\t       offset, end - 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   page_index, GFP_NOFS);\n\t\tBUG_ON(!page);\n\n\t\twait_on_page_writeback(page);\n\t\tif (PageError(page)) {\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tmark_page_accessed(page);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_move_extent",
          "args": [
            "handle",
            "context",
            "cpos",
            "new_len",
            "phys_cpos",
            "new_phys_cpos",
            "ext_flags"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_move_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "58-158",
          "snippet": "static int __ocfs2_move_extent(handle_t *handle,\n\t\t\t       struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 len, u32 p_cpos, u32 new_p_cpos,\n\t\t\t       int ext_flags)\n{\n\tint ret = 0, index;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_rec *rec, replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tu64 ino = ocfs2_metadata_cache_owner(context->et.et_ci);\n\tu64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);\n\n\tret = ocfs2_duplicate_clusters_by_page(handle, inode, cpos,\n\t\t\t\t\t       p_cpos, new_p_cpos, len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t\t   new_p_cpos));\n\n\tpath = ocfs2_new_path_from_et(&context->et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(INODE_CACHE(inode), path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\trec = &el->l_recs[index];\n\n\tBUG_ON(ext_flags != rec->e_flags);\n\t/*\n\t * after moving/defraging to new location, the extent is not going\n\t * to be refcounted anymore.\n\t */\n\treplace_rec.e_flags = ext_flags & ~OCFS2_EXT_REFCOUNTED;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t      context->et.et_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, &context->et, path, index,\n\t\t\t\t &replace_rec, context->meta_ac,\n\t\t\t\t &context->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, context->et.et_root_bh);\n\n\tcontext->new_phys_cpos = new_p_cpos;\n\n\t/*\n\t * need I to append truncate log for old clusters?\n\t */\n\tif (old_blkno) {\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t old_blkno),\n\t\t\t\t\tlen, context->meta_ac,\n\t\t\t\t\t&context->dealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\told_blkno, len);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_move_extent(handle_t *handle,\n\t\t\t       struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 len, u32 p_cpos, u32 new_p_cpos,\n\t\t\t       int ext_flags)\n{\n\tint ret = 0, index;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_rec *rec, replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tu64 ino = ocfs2_metadata_cache_owner(context->et.et_ci);\n\tu64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);\n\n\tret = ocfs2_duplicate_clusters_by_page(handle, inode, cpos,\n\t\t\t\t\t       p_cpos, new_p_cpos, len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t\t   new_p_cpos));\n\n\tpath = ocfs2_new_path_from_et(&context->et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(INODE_CACHE(inode), path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\trec = &el->l_recs[index];\n\n\tBUG_ON(ext_flags != rec->e_flags);\n\t/*\n\t * after moving/defraging to new location, the extent is not going\n\t * to be refcounted anymore.\n\t */\n\treplace_rec.e_flags = ext_flags & ~OCFS2_EXT_REFCOUNTED;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t      context->et.et_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, &context->et, path, index,\n\t\t\t\t &replace_rec, context->meta_ac,\n\t\t\t\t &context->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, context->et.et_root_bh);\n\n\tcontext->new_phys_cpos = new_p_cpos;\n\n\t/*\n\t * need I to append truncate log for old clusters?\n\t */\n\tif (old_blkno) {\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t old_blkno),\n\t\t\t\t\tlen, context->meta_ac,\n\t\t\t\t\t&context->dealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\told_blkno, len);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"cpos: %u, phys_cpos: %u, new_phys_cpos: %u\\n\"",
            "cpos",
            "phys_cpos",
            "new_phys_cpos"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"len_claimed: %u, len: %u\\n\"",
            "new_len",
            "*len"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_claim_clusters",
          "args": [
            "handle",
            "context->data_ac",
            "1",
            "*len",
            "&new_phys_cpos",
            "&new_len"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2302-2371",
          "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5956-6028",
          "snippet": "int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint __ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tunsigned int num_to_flush;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct inode *data_alloc_inode = NULL;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct buffer_head *data_alloc_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tnum_to_flush = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_flush_truncate_log(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\tnum_to_flush);\n\tif (!num_to_flush) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tdata_alloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t       OCFS2_INVALID_SLOT);\n\tif (!data_alloc_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Could not get bitmap inode!\\n\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&data_alloc_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\tstatus = ocfs2_replay_truncate_records(osb, handle, data_alloc_inode,\n\t\t\t\t\t       data_alloc_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(data_alloc_bh);\n\tocfs2_inode_unlock(data_alloc_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&data_alloc_inode->i_mutex);\n\tiput(data_alloc_inode);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_needs_flush",
          "args": [
            "osb"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_needs_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5775-5789",
          "snippet": "int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)\n{\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\n\tmlog_bug_on_msg(le16_to_cpu(tl->tl_used) > le16_to_cpu(tl->tl_count),\n\t\t\t\"slot %d, invalid truncate log parameters: used = \"\n\t\t\t\"%u, count = %u\\n\", osb->slot_num,\n\t\t\tle16_to_cpu(tl->tl_used), le16_to_cpu(tl->tl_count));\n\treturn le16_to_cpu(tl->tl_used) == le16_to_cpu(tl->tl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tl_inode->i_mutex"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_allocators_move_extents",
          "args": [
            "inode",
            "&context->et",
            "*len",
            "1",
            "&context->meta_ac",
            "&context->data_ac",
            "extra_blocks",
            "&credits"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_allocators_move_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
          "lines": "167-218",
          "snippet": "static int ocfs2_lock_allocators_move_extents(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tu32 clusters_to_move,\n\t\t\t\t\tu32 extents_to_split,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint extra_blocks,\n\t\t\t\t\tint *credits)\n{\n\tint ret, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split + clusters_to_move;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_to_move, data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb, et->et_root_el);\n\n\tmlog(0, \"reserve metadata_blocks: %d, data_clusters: %u, credits: %d\\n\",\n\t     extra_blocks, clusters_to_move, *credits);\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"refcounttree.h\"",
            "#include \"sysfile.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_lock_allocators_move_extents(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tu32 clusters_to_move,\n\t\t\t\t\tu32 extents_to_split,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint extra_blocks,\n\t\t\t\t\tint *credits)\n{\n\tint ret, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split + clusters_to_move;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_to_move, data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb, et->et_root_el);\n\n\tmlog(0, \"reserve metadata_blocks: %d, data_clusters: %u, credits: %d\\n\",\n\t     extra_blocks, clusters_to_move, *credits);\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_refcount_change_for_del",
          "args": [
            "inode",
            "context->refcount_loc",
            "phys_blkno",
            "*len",
            "&credits",
            "&extra_blocks"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_refcount_change_for_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2536-2588",
          "snippet": "int ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "context->refcount_loc",
            "1",
            "&ref_tree",
            "NULL"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!context->refcount_loc"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "phys_cpos"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_defrag_extent(struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 phys_cpos, u32 *len, int ext_flags)\n{\n\tint ret, credits = 0, extra_blocks = 0, partial = context->partial;\n\thandle_t *handle;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\tu32 new_phys_cpos, new_len;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\n\tif ((ext_flags & OCFS2_EXT_REFCOUNTED) && *len) {\n\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tBUG_ON(!context->refcount_loc);\n\n\t\tret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\n\t\t\t\t\t       &ref_tree, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\tcontext->refcount_loc,\n\t\t\t\t\t\t\tphys_blkno,\n\t\t\t\t\t\t\t*len,\n\t\t\t\t\t\t\t&credits,\n\t\t\t\t\t\t\t&extra_blocks);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_lock_allocators_move_extents(inode, &context->et, *len, 1,\n\t\t\t\t\t\t &context->meta_ac,\n\t\t\t\t\t\t &context->data_ac,\n\t\t\t\t\t\t extra_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * should be using allocation reservation strategy there?\n\t *\n\t * if (context->data_ac)\n\t *\tcontext->data_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\t */\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock_mutex;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_mutex;\n\t}\n\n\tret = __ocfs2_claim_clusters(handle, context->data_ac, 1, *len,\n\t\t\t\t     &new_phys_cpos, &new_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * allowing partial extent moving is kind of 'pros and cons', it makes\n\t * whole defragmentation less likely to fail, on the contrary, the bad\n\t * thing is it may make the fs even more fragmented after moving, let\n\t * userspace make a good decision here.\n\t */\n\tif (new_len != *len) {\n\t\tmlog(0, \"len_claimed: %u, len: %u\\n\", new_len, *len);\n\t\tif (!partial) {\n\t\t\tcontext->range->me_flags &= ~OCFS2_MOVE_EXT_FL_COMPLETE;\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\tmlog(0, \"cpos: %u, phys_cpos: %u, new_phys_cpos: %u\\n\", cpos,\n\t     phys_cpos, new_phys_cpos);\n\n\tret = __ocfs2_move_extent(handle, context, cpos, new_len, phys_cpos,\n\t\t\t\t  new_phys_cpos, ext_flags);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (partial && (new_len != *len))\n\t\t*len = new_len;\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, *len);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock_mutex:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\nout:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_lock_allocators_move_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "167-218",
    "snippet": "static int ocfs2_lock_allocators_move_extents(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tu32 clusters_to_move,\n\t\t\t\t\tu32 extents_to_split,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint extra_blocks,\n\t\t\t\t\tint *credits)\n{\n\tint ret, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split + clusters_to_move;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_to_move, data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb, et->et_root_el);\n\n\tmlog(0, \"reserve metadata_blocks: %d, data_clusters: %u, credits: %d\\n\",\n\t     extra_blocks, clusters_to_move, *credits);\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*meta_ac"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"reserve metadata_blocks: %d, data_clusters: %u, credits: %d\\n\"",
            "extra_blocks",
            "clusters_to_move",
            "*credits"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "osb->sb",
            "et->et_root_el"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "osb",
            "clusters_to_move",
            "data_ac"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "extra_blocks",
            "meta_ac"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et->et_root_el"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "osb",
            "et"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "959-990",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_lock_allocators_move_extents(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tu32 clusters_to_move,\n\t\t\t\t\tu32 extents_to_split,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint extra_blocks,\n\t\t\t\t\tint *credits)\n{\n\tint ret, num_free_extents;\n\tunsigned int max_recs_needed = 2 * extents_to_split + clusters_to_move;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\n\t\textra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(osb, clusters_to_move, data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*credits += ocfs2_calc_extend_credits(osb->sb, et->et_root_el);\n\n\tmlog(0, \"reserve metadata_blocks: %d, data_clusters: %u, credits: %d\\n\",\n\t     extra_blocks, clusters_to_move, *credits);\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_move_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/move_extents.c",
    "lines": "58-158",
    "snippet": "static int __ocfs2_move_extent(handle_t *handle,\n\t\t\t       struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 len, u32 p_cpos, u32 new_p_cpos,\n\t\t\t       int ext_flags)\n{\n\tint ret = 0, index;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_rec *rec, replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tu64 ino = ocfs2_metadata_cache_owner(context->et.et_ci);\n\tu64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);\n\n\tret = ocfs2_duplicate_clusters_by_page(handle, inode, cpos,\n\t\t\t\t\t       p_cpos, new_p_cpos, len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t\t   new_p_cpos));\n\n\tpath = ocfs2_new_path_from_et(&context->et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(INODE_CACHE(inode), path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\trec = &el->l_recs[index];\n\n\tBUG_ON(ext_flags != rec->e_flags);\n\t/*\n\t * after moving/defraging to new location, the extent is not going\n\t * to be refcounted anymore.\n\t */\n\treplace_rec.e_flags = ext_flags & ~OCFS2_EXT_REFCOUNTED;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t      context->et.et_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, &context->et, path, index,\n\t\t\t\t &replace_rec, context->meta_ac,\n\t\t\t\t &context->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, context->et.et_root_bh);\n\n\tcontext->new_phys_cpos = new_p_cpos;\n\n\t/*\n\t * need I to append truncate log for old clusters?\n\t */\n\tif (old_blkno) {\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t old_blkno),\n\t\t\t\t\tlen, context->meta_ac,\n\t\t\t\t\t&context->dealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\told_blkno, len);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"move_extents.h\"",
      "#include \"refcounttree.h\"",
      "#include \"sysfile.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"dir.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"suballoc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2_ioctl.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_append",
          "args": [
            "osb",
            "handle",
            "old_blkno",
            "len"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5808-5882",
          "snippet": "int ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_append(struct ocfs2_super *osb,\n\t\t\t      handle_t *handle,\n\t\t\t      u64 start_blk,\n\t\t\t      unsigned int num_clusters)\n{\n\tint status, index;\n\tunsigned int start_cluster, tl_count;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\tBUG_ON(mutex_trylock(&tl_inode->i_mutex));\n\n\tstart_cluster = ocfs2_blocks_to_clusters(osb->sb, start_blk);\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated\n\t * by the underlying call to ocfs2_read_inode_block(), so any\n\t * corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\ttl_count = le16_to_cpu(tl->tl_count);\n\tmlog_bug_on_msg(tl_count > ocfs2_truncate_recs_per_inode(osb->sb) ||\n\t\t\ttl_count == 0,\n\t\t\t\"Truncate record count on #%llu invalid \"\n\t\t\t\"wanted %u, actual %u\\n\",\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tocfs2_truncate_recs_per_inode(osb->sb),\n\t\t\tle16_to_cpu(tl->tl_count));\n\n\t/* Caller should have known to flush before calling us. */\n\tindex = le16_to_cpu(tl->tl_used);\n\tif (index >= tl_count) {\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_truncate_log_append(\n\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index,\n\t\tstart_cluster, num_clusters);\n\tif (ocfs2_truncate_log_can_coalesce(tl, start_cluster)) {\n\t\t/*\n\t\t * Move index back to the record we are coalescing with.\n\t\t * ocfs2_truncate_log_can_coalesce() guarantees nonzero\n\t\t */\n\t\tindex--;\n\n\t\tnum_clusters += le32_to_cpu(tl->tl_recs[index].t_clusters);\n\t\ttrace_ocfs2_truncate_log_append(\n\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\tindex, le32_to_cpu(tl->tl_recs[index].t_start),\n\t\t\tnum_clusters);\n\t} else {\n\t\ttl->tl_recs[index].t_start = cpu_to_le32(start_cluster);\n\t\ttl->tl_used = cpu_to_le16(index + 1);\n\t}\n\ttl->tl_recs[index].t_clusters = cpu_to_le32(num_clusters);\n\n\tocfs2_journal_dirty(handle, tl_bh);\n\n\tosb->truncated_clusters += num_clusters;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_decrease_refcount",
          "args": [
            "inode",
            "handle",
            "ocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t old_blkno)",
            "len",
            "context->meta_ac",
            "&context->dealloc",
            "1"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_decrease_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2300-2340",
          "snippet": "int ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "osb->sb",
            "old_blkno"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "context->et.et_root_bh"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_extent",
          "args": [
            "handle",
            "&context->et",
            "path",
            "index",
            "&replace_rec",
            "context->meta_ac",
            "&context->dealloc"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5022-5103",
          "snippet": "int ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\tstruct ocfs2_extent_list *rightmost_el;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tctxt.c_contig_type = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t\t\t    split_index,\n\t\t\t\t\t\t\t    split_rec);\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tstruct ocfs2_extent_block *eb;\n\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_root_el(path);\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\tstruct ocfs2_extent_list *rightmost_el;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tctxt.c_contig_type = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t\t\t    split_index,\n\t\t\t\t\t\t\t    split_rec);\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tstruct ocfs2_extent_block *eb;\n\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_root_el(path);\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "context->et.et_root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ext_flags != rec->e_flags"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\"",
            "(unsigned long long)ino",
            "cpos"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "INODE_CACHE(inode)",
            "path",
            "cpos"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "&context->et"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t\t   new_p_cpos)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "new_p_cpos"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&replace_rec",
            "0",
            "sizeof(replace_rec)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_duplicate_clusters_by_page",
          "args": [
            "handle",
            "inode",
            "cpos",
            "p_cpos",
            "new_p_cpos",
            "len"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_duplicate_clusters_by_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2924-3012",
          "snippet": "int ocfs2_duplicate_clusters_by_page(handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u32 cpos, u32 old_cluster,\n\t\t\t\t     u32 new_cluster, u32 new_len)\n{\n\tint ret = 0, partial;\n\tstruct super_block *sb = inode->i_sb;\n\tu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\n\tstruct page *page;\n\tpgoff_t page_index;\n\tunsigned int from, to, readahead_pages;\n\tloff_t offset, end, map_end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\ttrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\n\t\t\t\t\t       new_cluster, new_len);\n\n\treadahead_pages =\n\t\t(ocfs2_cow_contig_clusters(sb) <<\n\t\t OCFS2_SB(sb)->s_clustersize_bits) >> PAGE_CACHE_SHIFT;\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (new_len << OCFS2_SB(sb)->s_clustersize_bits);\n\t/*\n\t * We only duplicate pages until we reach the page contains i_size - 1.\n\t * So trim 'end' to i_size.\n\t */\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\t/* from, to is the offset within the page. */\n\t\tfrom = offset & (PAGE_CACHE_SIZE - 1);\n\t\tto = PAGE_CACHE_SIZE;\n\t\tif (map_end & (PAGE_CACHE_SIZE - 1))\n\t\t\tto = map_end & (PAGE_CACHE_SIZE - 1);\n\n\t\tpage = find_or_create_page(mapping, page_index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * In case PAGE_CACHE_SIZE <= CLUSTER_SIZE, This page\n\t\t * can't be dirtied before we CoW it out.\n\t\t */\n\t\tif (PAGE_CACHE_SIZE <= OCFS2_SB(sb)->s_clustersize)\n\t\t\tBUG_ON(PageDirty(page));\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = block_read_full_page(page, ocfs2_get_block);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tlock_page(page);\n\t\t}\n\n\t\tif (page_has_buffers(page)) {\n\t\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t\tfrom, to, &partial,\n\t\t\t\t\t\tocfs2_clear_cow_buffer);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_map_and_dirty_page(inode,\n\t\t\t\t\t handle, from, to,\n\t\t\t\t\t page, 0, &new_block);\n\t\tmark_page_accessed(page);\nunlock:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_duplicate_clusters_by_page(handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u32 cpos, u32 old_cluster,\n\t\t\t\t     u32 new_cluster, u32 new_len)\n{\n\tint ret = 0, partial;\n\tstruct super_block *sb = inode->i_sb;\n\tu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\n\tstruct page *page;\n\tpgoff_t page_index;\n\tunsigned int from, to, readahead_pages;\n\tloff_t offset, end, map_end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\ttrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\n\t\t\t\t\t       new_cluster, new_len);\n\n\treadahead_pages =\n\t\t(ocfs2_cow_contig_clusters(sb) <<\n\t\t OCFS2_SB(sb)->s_clustersize_bits) >> PAGE_CACHE_SHIFT;\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (new_len << OCFS2_SB(sb)->s_clustersize_bits);\n\t/*\n\t * We only duplicate pages until we reach the page contains i_size - 1.\n\t * So trim 'end' to i_size.\n\t */\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\t/* from, to is the offset within the page. */\n\t\tfrom = offset & (PAGE_CACHE_SIZE - 1);\n\t\tto = PAGE_CACHE_SIZE;\n\t\tif (map_end & (PAGE_CACHE_SIZE - 1))\n\t\t\tto = map_end & (PAGE_CACHE_SIZE - 1);\n\n\t\tpage = find_or_create_page(mapping, page_index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * In case PAGE_CACHE_SIZE <= CLUSTER_SIZE, This page\n\t\t * can't be dirtied before we CoW it out.\n\t\t */\n\t\tif (PAGE_CACHE_SIZE <= OCFS2_SB(sb)->s_clustersize)\n\t\t\tBUG_ON(PageDirty(page));\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = block_read_full_page(page, ocfs2_get_block);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tlock_page(page);\n\t\t}\n\n\t\tif (page_has_buffers(page)) {\n\t\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t\tfrom, to, &partial,\n\t\t\t\t\t\tocfs2_clear_cow_buffer);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_map_and_dirty_page(inode,\n\t\t\t\t\t handle, from, to,\n\t\t\t\t\t page, 0, &new_block);\n\t\tmark_page_accessed(page);\nunlock:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "context->et.et_ci"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"move_extents.h\"\n#include \"refcounttree.h\"\n#include \"sysfile.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_move_extent(handle_t *handle,\n\t\t\t       struct ocfs2_move_extents_context *context,\n\t\t\t       u32 cpos, u32 len, u32 p_cpos, u32 new_p_cpos,\n\t\t\t       int ext_flags)\n{\n\tint ret = 0, index;\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_rec *rec, replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tu64 ino = ocfs2_metadata_cache_owner(context->et.et_ci);\n\tu64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);\n\n\tret = ocfs2_duplicate_clusters_by_page(handle, inode, cpos,\n\t\t\t\t\t       p_cpos, new_p_cpos, len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\t\t\t\t   new_p_cpos));\n\n\tpath = ocfs2_new_path_from_et(&context->et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(INODE_CACHE(inode), path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\trec = &el->l_recs[index];\n\n\tBUG_ON(ext_flags != rec->e_flags);\n\t/*\n\t * after moving/defraging to new location, the extent is not going\n\t * to be refcounted anymore.\n\t */\n\treplace_rec.e_flags = ext_flags & ~OCFS2_EXT_REFCOUNTED;\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t      context->et.et_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, &context->et, path, index,\n\t\t\t\t &replace_rec, context->meta_ac,\n\t\t\t\t &context->dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, context->et.et_root_bh);\n\n\tcontext->new_phys_cpos = new_p_cpos;\n\n\t/*\n\t * need I to append truncate log for old clusters?\n\t */\n\tif (old_blkno) {\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t old_blkno),\n\t\t\t\t\tlen, context->meta_ac,\n\t\t\t\t\t&context->dealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\told_blkno, len);\n\t}\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
  }
]