[
  {
    "function_name": "ceph_queue_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "176-178",
    "snippet": "static inline void ceph_queue_revalidate(struct inode *inode)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_queue_revalidate(struct inode *inode)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_readpages_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "171-174",
    "snippet": "static inline void ceph_fscache_readpages_cancel(struct inode *inode,\n\t\t\t\t\t\t struct list_head *pages)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_readpages_cancel(struct inode *inode,\n\t\t\t\t\t\t struct list_head *pages)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_readpage_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "166-169",
    "snippet": "static inline void ceph_fscache_readpage_cancel(struct inode *inode,\n\t\t\t\t\t\tstruct page *page)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_readpage_cancel(struct inode *inode,\n\t\t\t\t\t\tstruct page *page)\n{\n}"
  },
  {
    "function_name": "ceph_release_fscache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "161-164",
    "snippet": "static inline int ceph_release_fscache_page(struct page *page, gfp_t gfp)\n{\n\treturn 1;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int ceph_release_fscache_page(struct page *page, gfp_t gfp)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "ceph_fscache_unregister_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "157-159",
    "snippet": "static inline void ceph_fscache_unregister_inode_cookie(struct ceph_inode_info* ci)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_unregister_inode_cookie(struct ceph_inode_info* ci)\n{\n}"
  },
  {
    "function_name": "ceph_invalidate_fscache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "152-155",
    "snippet": "static inline void ceph_invalidate_fscache_page(struct inode *inode,\n\t\t\t\t\t\tstruct page *page)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_invalidate_fscache_page(struct inode *inode,\n\t\t\t\t\t\tstruct page *page)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "148-150",
    "snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_update_objectsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "144-146",
    "snippet": "static inline void ceph_fscache_update_objectsize(struct inode *inode)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_update_objectsize(struct inode *inode)\n{\n}"
  },
  {
    "function_name": "ceph_readpage_to_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "139-142",
    "snippet": "static inline void ceph_readpage_to_fscache(struct inode *inode,\n\t\t\t\t\t    struct page *page)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_readpage_to_fscache(struct inode *inode,\n\t\t\t\t\t    struct page *page)\n{\n}"
  },
  {
    "function_name": "ceph_readpages_from_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "131-137",
    "snippet": "static inline int ceph_readpages_from_fscache(struct inode *inode,\n\t\t\t\t\t      struct address_space *mapping,\n\t\t\t\t\t      struct list_head *pages,\n\t\t\t\t\t      unsigned *nr_pages)\n{\n\treturn -ENOBUFS;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int ceph_readpages_from_fscache(struct inode *inode,\n\t\t\t\t\t      struct address_space *mapping,\n\t\t\t\t\t      struct list_head *pages,\n\t\t\t\t\t      unsigned *nr_pages)\n{\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "ceph_readpage_from_fscache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "125-129",
    "snippet": "static inline int ceph_readpage_from_fscache(struct inode* inode,\n\t\t\t\t\t     struct page *page)\n{\n\treturn -ENOBUFS;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int ceph_readpage_from_fscache(struct inode* inode,\n\t\t\t\t\t     struct page *page)\n{\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "ceph_fscache_uncache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "120-123",
    "snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_register_inode_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "115-118",
    "snippet": "static inline void ceph_fscache_register_inode_cookie(struct ceph_fs_client* parent_fsc,\n\t\t\t\t\t\t      struct ceph_inode_info* ci)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_register_inode_cookie(struct ceph_fs_client* parent_fsc,\n\t\t\t\t\t\t      struct ceph_inode_info* ci)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_inode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "111-113",
    "snippet": "static inline void ceph_fscache_inode_init(struct ceph_inode_info *ci)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_inode_init(struct ceph_inode_info *ci)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_unregister_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "107-109",
    "snippet": "static inline void ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_unregister_fs(struct ceph_fs_client* fsc)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_register_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "102-105",
    "snippet": "static inline int ceph_fscache_register_fs(struct ceph_fs_client* fsc)\n{\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int ceph_fscache_register_fs(struct ceph_fs_client* fsc)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_fscache_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "98-100",
    "snippet": "static inline void ceph_fscache_unregister(void)\n{\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ceph_fscache_unregister(void)\n{\n}"
  },
  {
    "function_name": "ceph_fscache_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "93-96",
    "snippet": "static inline int ceph_fscache_register(void)\n{\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int ceph_fscache_register(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_fscache_readpages_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "84-89",
    "snippet": "static inline void ceph_fscache_readpages_cancel(struct inode *inode,\n\t\t\t\t\t\t struct list_head *pages)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\treturn fscache_readpages_cancel(ci->fscache, pages);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_readpages_cancel",
          "args": [
            "ci->fscache",
            "pages"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_readpages_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "171-174",
          "snippet": "static inline void ceph_fscache_readpages_cancel(struct inode *inode,\n\t\t\t\t\t\t struct list_head *pages)\n{\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void ceph_fscache_readpages_cancel(struct inode *inode,\n\t\t\t\t\t\t struct list_head *pages)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\treturn fscache_readpages_cancel(ci->fscache, pages);\n}"
  },
  {
    "function_name": "ceph_fscache_readpage_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "76-82",
    "snippet": "static inline void ceph_fscache_readpage_cancel(struct inode *inode,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tif (fscache_cookie_valid(ci->fscache) && PageFsCache(page))\n\t\t__fscache_uncache_page(ci->fscache, page);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fscache_uncache_page",
          "args": [
            "ci->fscache",
            "page"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_valid",
          "args": [
            "ci->fscache"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void ceph_fscache_readpage_cancel(struct inode *inode,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tif (fscache_cookie_valid(ci->fscache) && PageFsCache(page))\n\t\t__fscache_uncache_page(ci->fscache, page);\n}"
  },
  {
    "function_name": "ceph_release_fscache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "69-74",
    "snippet": "static inline int ceph_release_fscache_page(struct page *page, gfp_t gfp)\n{\n\tstruct inode* inode = page->mapping->host;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\treturn fscache_maybe_release_page(ci->fscache, page, gfp);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_maybe_release_page",
          "args": [
            "ci->fscache",
            "page",
            "gfp"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_maybe_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "63-137",
          "snippet": "bool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nbool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline int ceph_release_fscache_page(struct page *page, gfp_t gfp)\n{\n\tstruct inode* inode = page->mapping->host;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\treturn fscache_maybe_release_page(ci->fscache, page, gfp);\n}"
  },
  {
    "function_name": "ceph_fscache_uncache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "62-67",
    "snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\treturn fscache_uncache_page(ci->fscache, page);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "ci->fscache",
            "page"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "120-123",
          "snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\treturn fscache_uncache_page(ci->fscache, page);\n}"
  },
  {
    "function_name": "ceph_fscache_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "57-60",
    "snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n\tfscache_invalidate(ceph_inode(inode)->fscache);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_invalidate",
          "args": [
            "ceph_inode(inode)->fscache"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "148-150",
          "snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n\tfscache_invalidate(ceph_inode(inode)->fscache);\n}"
  },
  {
    "function_name": "ceph_fscache_update_objectsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
    "lines": "51-55",
    "snippet": "static inline void ceph_fscache_update_objectsize(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tfscache_attr_changed(ci->fscache);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_attr_changed",
          "args": [
            "ci->fscache"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_attr_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "197-248",
          "snippet": "int __fscache_attr_changed(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\n\t_enter(\"%p\", cookie);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\n\tfscache_stat(&fscache_n_attr_changed);\n\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_attr_changed_nomem);\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfscache_operation_init(op, fscache_attr_changed_op, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto nobufs_dec;\n\tspin_unlock(&cookie->lock);\n\tfscache_stat(&fscache_n_attr_changed_ok);\n\tfscache_put_operation(op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nnobufs_dec:\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_attr_changed_nobufs);\n\t_leave(\" = %d\", -ENOBUFS);\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_attr_changed(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\n\t_enter(\"%p\", cookie);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\n\tfscache_stat(&fscache_n_attr_changed);\n\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_attr_changed_nomem);\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfscache_operation_init(op, fscache_attr_changed_op, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto nobufs_dec;\n\tspin_unlock(&cookie->lock);\n\tfscache_stat(&fscache_n_attr_changed_ok);\n\tfscache_put_operation(op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nnobufs_dec:\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_attr_changed_nobufs);\n\t_leave(\" = %d\", -ENOBUFS);\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void ceph_fscache_update_objectsize(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tfscache_attr_changed(ci->fscache);\n}"
  }
]