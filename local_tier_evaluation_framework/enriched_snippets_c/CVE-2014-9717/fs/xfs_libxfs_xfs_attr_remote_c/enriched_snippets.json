[
  {
    "function_name": "xfs_attr_rmtval_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "533-626",
    "snippet": "int\nxfs_attr_rmtval_remove(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\tint\t\t\tdone;\n\n\ttrace_xfs_attr_rmtval_remove(args);\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's blocks.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tstruct xfs_buf\t\t*bp;\n\t\txfs_daddr_t\t\tdblkno;\n\t\tint\t\t\tdblkcnt;\n\t\tint\t\t\tnmap;\n\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\t/*\n\t\t * If the \"remote\" value is in the cache, remove it.\n\t\t */\n\t\tbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\n\t\tif (bp) {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tbp = NULL;\n\t\t}\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\t/*\n\t * Keep de-allocating extents until the remote-value region is gone.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tdone = 0;\n\twhile (!done) {\n\t\tint committed;\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\n\t\t\t\t    XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t    1, args->firstblock, args->flist,\n\t\t\t\t    &done);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, args->dp, 0);\n\n\t\t/*\n\t\t * Close out trans and start the next one in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, args->dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "&args->trans",
            "args->dp"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "args->trans",
            "args->dp",
            "0"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "args->flist"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&args->trans",
            "args->flist",
            "&committed"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bunmapi",
          "args": [
            "args->trans",
            "args->dp",
            "lblkno",
            "blkcnt",
            "XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA",
            "1",
            "args->firstblock",
            "args->flist",
            "&done"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bunmapi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5030-5403",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "args->flist",
            "args->firstblock"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_incore",
          "args": [
            "mp->m_ddev_targp",
            "dblkno",
            "dblkcnt",
            "XBF_TRYLOCK"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_incore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "196-205",
          "snippet": "static inline struct xfs_buf *\nxfs_incore(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn _xfs_buf_find(target, &map, 1, flags, NULL);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_incore(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn _xfs_buf_find(target, &map, 1, flags, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "map.br_blockcount"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "map.br_startblock"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmap == 1"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "args->dp",
            "(xfs_fileoff_t)lblkno",
            "blkcnt",
            "&map",
            "&nmap",
            "XFS_BMAPI_ATTRFORK"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_rmtval_remove",
          "args": [
            "args"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_rmtval_remove(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\txfs_dablk_t\t\tlblkno;\n\tint\t\t\tblkcnt;\n\tint\t\t\terror;\n\tint\t\t\tdone;\n\n\ttrace_xfs_attr_rmtval_remove(args);\n\n\t/*\n\t * Roll through the \"value\", invalidating the attribute value's blocks.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\twhile (blkcnt > 0) {\n\t\tstruct xfs_bmbt_irec\tmap;\n\t\tstruct xfs_buf\t\t*bp;\n\t\txfs_daddr_t\t\tdblkno;\n\t\tint\t\t\tdblkcnt;\n\t\tint\t\t\tnmap;\n\n\t\t/*\n\t\t * Try to remember where we decided to put the value.\n\t\t */\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap, XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\t/*\n\t\t * If the \"remote\" value is in the cache, remove it.\n\t\t */\n\t\tbp = xfs_incore(mp->m_ddev_targp, dblkno, dblkcnt, XBF_TRYLOCK);\n\t\tif (bp) {\n\t\t\txfs_buf_stale(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t\tbp = NULL;\n\t\t}\n\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\n\t/*\n\t * Keep de-allocating extents until the remote-value region is gone.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tdone = 0;\n\twhile (!done) {\n\t\tint committed;\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,\n\t\t\t\t    XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t    1, args->firstblock, args->flist,\n\t\t\t\t    &done);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, args->dp, 0);\n\n\t\t/*\n\t\t * Close out trans and start the next one in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, args->dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_rmtval_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "396-527",
    "snippet": "int\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "valuelen == 0"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bwrite",
          "args": [
            "bp"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1077-1095",
          "snippet": "int\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_copyin",
          "args": [
            "mp",
            "bp",
            "args->dp->i_ino",
            "&offset",
            "&valuelen",
            "&src"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_copyin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "278-325",
          "snippet": "STATIC void\nxfs_attr_rmtval_copyin(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\t__uint8_t\t**src)\n{\n\tchar\t\t*dst = bp->b_addr;\n\txfs_daddr_t\tbno = bp->b_bn;\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\t\thdr_size = xfs_attr3_rmt_hdr_set(mp, dst, ino, *offset,\n\t\t\t\t\t\t byte_cnt, bno);\n\n\t\tmemcpy(dst + hdr_size, *src, byte_cnt);\n\n\t\t/*\n\t\t * If this is the last block, zero the remainder of it.\n\t\t * Check that we are actually the last block, too.\n\t\t */\n\t\tif (byte_cnt + hdr_size < blksize) {\n\t\t\tASSERT(*valuelen - byte_cnt == 0);\n\t\t\tASSERT(len == blksize);\n\t\t\tmemset(dst + hdr_size + byte_cnt, 0,\n\t\t\t\t\tblksize - hdr_size - byte_cnt);\n\t\t}\n\n\t\t/* roll buffer forwards */\n\t\tlen -= blksize;\n\t\tdst += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t/* roll attribute data forwards */\n\t\t*valuelen -= byte_cnt;\n\t\t*src += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_attr_rmtval_copyin(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\t__uint8_t\t**src)\n{\n\tchar\t\t*dst = bp->b_addr;\n\txfs_daddr_t\tbno = bp->b_bn;\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\t\thdr_size = xfs_attr3_rmt_hdr_set(mp, dst, ino, *offset,\n\t\t\t\t\t\t byte_cnt, bno);\n\n\t\tmemcpy(dst + hdr_size, *src, byte_cnt);\n\n\t\t/*\n\t\t * If this is the last block, zero the remainder of it.\n\t\t * Check that we are actually the last block, too.\n\t\t */\n\t\tif (byte_cnt + hdr_size < blksize) {\n\t\t\tASSERT(*valuelen - byte_cnt == 0);\n\t\t\tASSERT(len == blksize);\n\t\t\tmemset(dst + hdr_size + byte_cnt, 0,\n\t\t\t\t\tblksize - hdr_size - byte_cnt);\n\t\t}\n\n\t\t/* roll buffer forwards */\n\t\tlen -= blksize;\n\t\tdst += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t/* roll attribute data forwards */\n\t\t*valuelen -= byte_cnt;\n\t\t*src += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_get",
          "args": [
            "mp->m_ddev_targp",
            "dblkno",
            "dblkcnt",
            "0"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "233-242",
          "snippet": "static inline struct xfs_buf *\nxfs_buf_get(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_get_map(target, &map, 1, flags);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_buf_get(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_get_map(target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "map.br_blockcount"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "map.br_startblock"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmap == 1"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "dp",
            "(xfs_fileoff_t)lblkno",
            "blkcnt",
            "&map",
            "&nmap",
            "XFS_BMAPI_ATTRFORK"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "args->flist",
            "args->firstblock"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blkcnt > 0"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_roll",
          "args": [
            "&args->trans",
            "dp"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_roll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "995-1055",
          "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmap == 1"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "args->trans",
            "dp",
            "0"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "args->flist"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&args->trans",
            "args->flist",
            "&committed"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_write",
          "args": [
            "args->trans",
            "dp",
            "(xfs_fileoff_t)lblkno",
            "blkcnt",
            "XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA",
            "args->firstblock",
            "args->total",
            "&map",
            "&nmap",
            "args->flist"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4483-4700",
          "snippet": "int\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_first_unused",
          "args": [
            "args->trans",
            "args->dp",
            "blkcnt",
            "&lfileoff",
            "XFS_ATTR_FORK"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_first_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1502-1547",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_first_unused(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_extlen_t\tlen,\t\t\t/* size of hole to find */\n\txfs_fileoff_t\t*first_unused,\t\t/* unused block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_fileoff_t\tlastaddr;\t\t/* last block number seen */\n\txfs_fileoff_t\tlowest;\t\t\t/* lowest useful block */\n\txfs_fileoff_t\tmax;\t\t\t/* starting useful block */\n\txfs_fileoff_t\toff;\t\t\t/* offset for this block */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*first_unused = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tlowest = *first_unused;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0, lastaddr = 0, max = lowest; idx < nextents; idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\toff = xfs_bmbt_get_startoff(ep);\n\t\t/*\n\t\t * See if the hole before this extent will work.\n\t\t */\n\t\tif (off >= lowest + len && off - max >= len) {\n\t\t\t*first_unused = max;\n\t\t\treturn 0;\n\t\t}\n\t\tlastaddr = off + xfs_bmbt_get_blockcount(ep);\n\t\tmax = XFS_FILEOFF_MAX(lastaddr, lowest);\n\t}\n\t*first_unused = max;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_first_unused(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_extlen_t\tlen,\t\t\t/* size of hole to find */\n\txfs_fileoff_t\t*first_unused,\t\t/* unused block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_fileoff_t\tlastaddr;\t\t/* last block number seen */\n\txfs_fileoff_t\tlowest;\t\t\t/* lowest useful block */\n\txfs_fileoff_t\tmax;\t\t\t/* starting useful block */\n\txfs_fileoff_t\toff;\t\t\t/* offset for this block */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*first_unused = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tlowest = *first_unused;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0, lastaddr = 0, max = lowest; idx < nextents; idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\toff = xfs_bmbt_get_startoff(ep);\n\t\t/*\n\t\t * See if the hole before this extent will work.\n\t\t */\n\t\tif (off >= lowest + len && off - max >= len) {\n\t\t\t*first_unused = max;\n\t\t\treturn 0;\n\t\t}\n\t\tlastaddr = off + xfs_bmbt_get_blockcount(ep);\n\t\tmax = XFS_FILEOFF_MAX(lastaddr, lowest);\n\t}\n\t*first_unused = max;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_blocks",
          "args": [
            "mp",
            "args->rmtvaluelen"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "50-60",
          "snippet": "int\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_rmtval_set",
          "args": [
            "args"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};\n\nint\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn error;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_rmtval_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "331-390",
    "snippet": "int\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define ATTR_RMTVALUE_MAPSIZE\t1\t/* # of map entries at once */"
    ],
    "globals_used": [
      "const struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "valuelen == 0"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_rmtval_copyout",
          "args": [
            "mp",
            "bp",
            "args->dp->i_ino",
            "&offset",
            "&valuelen",
            "&dst"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_rmtval_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "230-276",
          "snippet": "STATIC int\nxfs_attr_rmtval_copyout(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\t__uint8_t\t**dst)\n{\n\tchar\t\t*src = bp->b_addr;\n\txfs_daddr_t\tbno = bp->b_bn;\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size = 0;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tif (!xfs_attr3_rmt_hdr_ok(src, ino, *offset,\n\t\t\t\t\t\t  byte_cnt, bno)) {\n\t\t\t\txfs_alert(mp,\n\"remote attribute header mismatch bno/off/len/owner (0x%llx/0x%x/Ox%x/0x%llx)\",\n\t\t\t\t\tbno, *offset, byte_cnt, ino);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\thdr_size = sizeof(struct xfs_attr3_rmt_hdr);\n\t\t}\n\n\t\tmemcpy(*dst, src + hdr_size, byte_cnt);\n\n\t\t/* roll buffer forwards */\n\t\tlen -= blksize;\n\t\tsrc += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t/* roll attribute data forwards */\n\t\t*valuelen -= byte_cnt;\n\t\t*dst += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_rmtval_copyout(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\t__uint8_t\t**dst)\n{\n\tchar\t\t*src = bp->b_addr;\n\txfs_daddr_t\tbno = bp->b_bn;\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size = 0;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tif (!xfs_attr3_rmt_hdr_ok(src, ino, *offset,\n\t\t\t\t\t\t  byte_cnt, bno)) {\n\t\t\t\txfs_alert(mp,\n\"remote attribute header mismatch bno/off/len/owner (0x%llx/0x%x/Ox%x/0x%llx)\",\n\t\t\t\t\tbno, *offset, byte_cnt, ino);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\thdr_size = sizeof(struct xfs_attr3_rmt_hdr);\n\t\t}\n\n\t\tmemcpy(*dst, src + hdr_size, byte_cnt);\n\n\t\t/* roll buffer forwards */\n\t\tlen -= blksize;\n\t\tsrc += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t/* roll attribute data forwards */\n\t\t*valuelen -= byte_cnt;\n\t\t*dst += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "NULL",
            "mp->m_ddev_targp",
            "dblkno",
            "dblkcnt",
            "0",
            "&bp",
            "&xfs_attr3_rmt_buf_ops"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "map[i].br_blockcount"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "map[i].br_startblock"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmap >= 1"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "args->dp",
            "(xfs_fileoff_t)lblkno",
            "blkcnt",
            "map",
            "&nmap",
            "XFS_BMAPI_ATTRFORK"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->rmtvaluelen == args->valuelen"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(args->flags & ATTR_KERNOVAL)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_attr_rmtval_get",
          "args": [
            "args"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define ATTR_RMTVALUE_MAPSIZE\t1\t/* # of map entries at once */\n\nconst struct xfs_buf_ops xfs_attr3_rmt_buf_ops = {\n\t.verify_read = xfs_attr3_rmt_read_verify,\n\t.verify_write = xfs_attr3_rmt_write_verify,\n};\n\nint\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr_rmtval_copyin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "278-325",
    "snippet": "STATIC void\nxfs_attr_rmtval_copyin(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\t__uint8_t\t**src)\n{\n\tchar\t\t*dst = bp->b_addr;\n\txfs_daddr_t\tbno = bp->b_bn;\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\t\thdr_size = xfs_attr3_rmt_hdr_set(mp, dst, ino, *offset,\n\t\t\t\t\t\t byte_cnt, bno);\n\n\t\tmemcpy(dst + hdr_size, *src, byte_cnt);\n\n\t\t/*\n\t\t * If this is the last block, zero the remainder of it.\n\t\t * Check that we are actually the last block, too.\n\t\t */\n\t\tif (byte_cnt + hdr_size < blksize) {\n\t\t\tASSERT(*valuelen - byte_cnt == 0);\n\t\t\tASSERT(len == blksize);\n\t\t\tmemset(dst + hdr_size + byte_cnt, 0,\n\t\t\t\t\tblksize - hdr_size - byte_cnt);\n\t\t}\n\n\t\t/* roll buffer forwards */\n\t\tlen -= blksize;\n\t\tdst += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t/* roll attribute data forwards */\n\t\t*valuelen -= byte_cnt;\n\t\t*src += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "blksize"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst + hdr_size + byte_cnt",
            "0",
            "blksize - hdr_size - byte_cnt"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len == blksize"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*valuelen - byte_cnt == 0"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst + hdr_size",
            "*src",
            "byte_cnt"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_hdr_set",
          "args": [
            "mp",
            "dst",
            "ino",
            "*offset",
            "byte_cnt",
            "bno"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_hdr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "203-225",
          "snippet": "STATIC int\nxfs_attr3_rmt_hdr_set(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn 0;\n\n\trmt->rm_magic = cpu_to_be32(XFS_ATTR3_RMT_MAGIC);\n\trmt->rm_offset = cpu_to_be32(offset);\n\trmt->rm_bytes = cpu_to_be32(size);\n\tuuid_copy(&rmt->rm_uuid, &mp->m_sb.sb_uuid);\n\trmt->rm_owner = cpu_to_be64(ino);\n\trmt->rm_blkno = cpu_to_be64(bno);\n\n\treturn sizeof(struct xfs_attr3_rmt_hdr);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_rmt_hdr_set(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn 0;\n\n\trmt->rm_magic = cpu_to_be32(XFS_ATTR3_RMT_MAGIC);\n\trmt->rm_offset = cpu_to_be32(offset);\n\trmt->rm_bytes = cpu_to_be32(size);\n\tuuid_copy(&rmt->rm_uuid, &mp->m_sb.sb_uuid);\n\trmt->rm_owner = cpu_to_be64(ino);\n\trmt->rm_blkno = cpu_to_be64(bno);\n\n\treturn sizeof(struct xfs_attr3_rmt_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*valuelen",
            "byte_cnt"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_get_minrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "189-195",
          "snippet": "STATIC int\nxfs_allocbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mnr[level != 0];\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mnr[level != 0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR3_RMT_BUF_SPACE",
          "args": [
            "mp",
            "blksize"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len >= blksize"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_attr_rmtval_copyin(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\t__uint8_t\t**src)\n{\n\tchar\t\t*dst = bp->b_addr;\n\txfs_daddr_t\tbno = bp->b_bn;\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\t\thdr_size = xfs_attr3_rmt_hdr_set(mp, dst, ino, *offset,\n\t\t\t\t\t\t byte_cnt, bno);\n\n\t\tmemcpy(dst + hdr_size, *src, byte_cnt);\n\n\t\t/*\n\t\t * If this is the last block, zero the remainder of it.\n\t\t * Check that we are actually the last block, too.\n\t\t */\n\t\tif (byte_cnt + hdr_size < blksize) {\n\t\t\tASSERT(*valuelen - byte_cnt == 0);\n\t\t\tASSERT(len == blksize);\n\t\t\tmemset(dst + hdr_size + byte_cnt, 0,\n\t\t\t\t\tblksize - hdr_size - byte_cnt);\n\t\t}\n\n\t\t/* roll buffer forwards */\n\t\tlen -= blksize;\n\t\tdst += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t/* roll attribute data forwards */\n\t\t*valuelen -= byte_cnt;\n\t\t*src += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n}"
  },
  {
    "function_name": "xfs_attr_rmtval_copyout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "230-276",
    "snippet": "STATIC int\nxfs_attr_rmtval_copyout(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\t__uint8_t\t**dst)\n{\n\tchar\t\t*src = bp->b_addr;\n\txfs_daddr_t\tbno = bp->b_bn;\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size = 0;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tif (!xfs_attr3_rmt_hdr_ok(src, ino, *offset,\n\t\t\t\t\t\t  byte_cnt, bno)) {\n\t\t\t\txfs_alert(mp,\n\"remote attribute header mismatch bno/off/len/owner (0x%llx/0x%x/Ox%x/0x%llx)\",\n\t\t\t\t\tbno, *offset, byte_cnt, ino);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\thdr_size = sizeof(struct xfs_attr3_rmt_hdr);\n\t\t}\n\n\t\tmemcpy(*dst, src + hdr_size, byte_cnt);\n\n\t\t/* roll buffer forwards */\n\t\tlen -= blksize;\n\t\tsrc += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t/* roll attribute data forwards */\n\t\t*valuelen -= byte_cnt;\n\t\t*dst += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "blksize"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*dst",
            "src + hdr_size",
            "byte_cnt"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"remote attribute header mismatch bno/off/len/owner (0x%llx/0x%x/Ox%x/0x%llx)\"",
            "bno",
            "*offset",
            "byte_cnt",
            "ino"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_hdr_ok",
          "args": [
            "src",
            "ino",
            "*offset",
            "byte_cnt",
            "bno"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_hdr_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "67-88",
          "snippet": "static bool\nxfs_attr3_rmt_hdr_ok(\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (bno != be64_to_cpu(rmt->rm_blkno))\n\t\treturn false;\n\tif (offset != be32_to_cpu(rmt->rm_offset))\n\t\treturn false;\n\tif (size != be32_to_cpu(rmt->rm_bytes))\n\t\treturn false;\n\tif (ino != be64_to_cpu(rmt->rm_owner))\n\t\treturn false;\n\n\t/* ok */\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_attr3_rmt_hdr_ok(\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (bno != be64_to_cpu(rmt->rm_blkno))\n\t\treturn false;\n\tif (offset != be32_to_cpu(rmt->rm_offset))\n\t\treturn false;\n\tif (size != be32_to_cpu(rmt->rm_bytes))\n\t\treturn false;\n\tif (ino != be64_to_cpu(rmt->rm_owner))\n\t\treturn false;\n\n\t/* ok */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "*valuelen",
            "byte_cnt"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_get_minrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "189-195",
          "snippet": "STATIC int\nxfs_allocbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mnr[level != 0];\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mnr[level != 0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ATTR3_RMT_BUF_SPACE",
          "args": [
            "mp",
            "blksize"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len >= blksize"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr_rmtval_copyout(\n\tstruct xfs_mount *mp,\n\tstruct xfs_buf\t*bp,\n\txfs_ino_t\tino,\n\tint\t\t*offset,\n\tint\t\t*valuelen,\n\t__uint8_t\t**dst)\n{\n\tchar\t\t*src = bp->b_addr;\n\txfs_daddr_t\tbno = bp->b_bn;\n\tint\t\tlen = BBTOB(bp->b_length);\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\tASSERT(len >= blksize);\n\n\twhile (len > 0 && *valuelen > 0) {\n\t\tint hdr_size = 0;\n\t\tint byte_cnt = XFS_ATTR3_RMT_BUF_SPACE(mp, blksize);\n\n\t\tbyte_cnt = min(*valuelen, byte_cnt);\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tif (!xfs_attr3_rmt_hdr_ok(src, ino, *offset,\n\t\t\t\t\t\t  byte_cnt, bno)) {\n\t\t\t\txfs_alert(mp,\n\"remote attribute header mismatch bno/off/len/owner (0x%llx/0x%x/Ox%x/0x%llx)\",\n\t\t\t\t\tbno, *offset, byte_cnt, ino);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\thdr_size = sizeof(struct xfs_attr3_rmt_hdr);\n\t\t}\n\n\t\tmemcpy(*dst, src + hdr_size, byte_cnt);\n\n\t\t/* roll buffer forwards */\n\t\tlen -= blksize;\n\t\tsrc += blksize;\n\t\tbno += BTOBB(blksize);\n\n\t\t/* roll attribute data forwards */\n\t\t*valuelen -= byte_cnt;\n\t\t*dst += byte_cnt;\n\t\t*offset += byte_cnt;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_attr3_rmt_hdr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "203-225",
    "snippet": "STATIC int\nxfs_attr3_rmt_hdr_set(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn 0;\n\n\trmt->rm_magic = cpu_to_be32(XFS_ATTR3_RMT_MAGIC);\n\trmt->rm_offset = cpu_to_be32(offset);\n\trmt->rm_bytes = cpu_to_be32(size);\n\tuuid_copy(&rmt->rm_uuid, &mp->m_sb.sb_uuid);\n\trmt->rm_owner = cpu_to_be64(ino);\n\trmt->rm_blkno = cpu_to_be64(bno);\n\n\treturn sizeof(struct xfs_attr3_rmt_hdr);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bno"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ino"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&rmt->rm_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "size"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "offset"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_ATTR3_RMT_MAGIC"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_attr3_rmt_hdr_set(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn 0;\n\n\trmt->rm_magic = cpu_to_be32(XFS_ATTR3_RMT_MAGIC);\n\trmt->rm_offset = cpu_to_be32(offset);\n\trmt->rm_bytes = cpu_to_be32(size);\n\tuuid_copy(&rmt->rm_uuid, &mp->m_sb.sb_uuid);\n\trmt->rm_owner = cpu_to_be64(ino);\n\trmt->rm_blkno = cpu_to_be64(bno);\n\n\treturn sizeof(struct xfs_attr3_rmt_hdr);\n}"
  },
  {
    "function_name": "xfs_attr3_rmt_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "157-196",
    "snippet": "static void\nxfs_attr3_rmt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tchar\t\t*ptr;\n\tint\t\tlen;\n\txfs_daddr_t\tbno;\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\t/* no verification of non-crc buffers */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tptr = bp->b_addr;\n\tbno = bp->b_bn;\n\tlen = BBTOB(bp->b_length);\n\tASSERT(len >= blksize);\n\n\twhile (len > 0) {\n\t\tif (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n\t\t\treturn;\n\t\t}\n\t\tif (bip) {\n\t\t\tstruct xfs_attr3_rmt_hdr *rmt;\n\n\t\t\trmt = (struct xfs_attr3_rmt_hdr *)ptr;\n\t\t\trmt->rm_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\t\t}\n\t\txfs_update_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF);\n\n\t\tlen -= blksize;\n\t\tptr += blksize;\n\t\tbno += BTOBB(blksize);\n\t}\n\tASSERT(len == 0);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len == 0"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "blksize"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_update_cksum",
          "args": [
            "ptr",
            "blksize",
            "XFS_ATTR3_RMT_CRC_OFF"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "44-50",
          "snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_verify",
          "args": [
            "mp",
            "ptr",
            "blksize",
            "bno"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "90-116",
          "snippet": "static bool\nxfs_attr3_rmt_verify(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\tint\t\t\tfsbsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (rmt->rm_magic != cpu_to_be32(XFS_ATTR3_RMT_MAGIC))\n\t\treturn false;\n\tif (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be64_to_cpu(rmt->rm_blkno) != bno)\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_offset) +\n\t\t\t\tbe32_to_cpu(rmt->rm_bytes) > XATTR_SIZE_MAX)\n\t\treturn false;\n\tif (rmt->rm_owner == 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_attr3_rmt_verify(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\tint\t\t\tfsbsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (rmt->rm_magic != cpu_to_be32(XFS_ATTR3_RMT_MAGIC))\n\t\treturn false;\n\tif (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be64_to_cpu(rmt->rm_blkno) != bno)\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_offset) +\n\t\t\t\tbe32_to_cpu(rmt->rm_bytes) > XATTR_SIZE_MAX)\n\t\treturn false;\n\tif (rmt->rm_owner == 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len >= blksize"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_attr3_rmt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tchar\t\t*ptr;\n\tint\t\tlen;\n\txfs_daddr_t\tbno;\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\t/* no verification of non-crc buffers */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tptr = bp->b_addr;\n\tbno = bp->b_bn;\n\tlen = BBTOB(bp->b_length);\n\tASSERT(len >= blksize);\n\n\twhile (len > 0) {\n\t\tif (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\txfs_verifier_error(bp);\n\t\t\treturn;\n\t\t}\n\t\tif (bip) {\n\t\t\tstruct xfs_attr3_rmt_hdr *rmt;\n\n\t\t\trmt = (struct xfs_attr3_rmt_hdr *)ptr;\n\t\t\trmt->rm_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\t\t}\n\t\txfs_update_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF);\n\n\t\tlen -= blksize;\n\t\tptr += blksize;\n\t\tbno += BTOBB(blksize);\n\t}\n\tASSERT(len == 0);\n}"
  },
  {
    "function_name": "xfs_attr3_rmt_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "118-155",
    "snippet": "static void\nxfs_attr3_rmt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tchar\t\t*ptr;\n\tint\t\tlen;\n\txfs_daddr_t\tbno;\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\t/* no verification of non-crc buffers */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tptr = bp->b_addr;\n\tbno = bp->b_bn;\n\tlen = BBTOB(bp->b_length);\n\tASSERT(len >= blksize);\n\n\twhile (len > 0) {\n\t\tif (!xfs_verify_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF)) {\n\t\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\t\t\tbreak;\n\t\t}\n\t\tif (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\tbreak;\n\t\t}\n\t\tlen -= blksize;\n\t\tptr += blksize;\n\t\tbno += BTOBB(blksize);\n\t}\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n\telse\n\t\tASSERT(len == 0);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len == 0"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "blksize"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr3_rmt_verify",
          "args": [
            "mp",
            "ptr",
            "blksize",
            "bno"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr3_rmt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
          "lines": "90-116",
          "snippet": "static bool\nxfs_attr3_rmt_verify(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\tint\t\t\tfsbsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (rmt->rm_magic != cpu_to_be32(XFS_ATTR3_RMT_MAGIC))\n\t\treturn false;\n\tif (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be64_to_cpu(rmt->rm_blkno) != bno)\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_offset) +\n\t\t\t\tbe32_to_cpu(rmt->rm_bytes) > XATTR_SIZE_MAX)\n\t\treturn false;\n\tif (rmt->rm_owner == 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_attr3_rmt_verify(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\tint\t\t\tfsbsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (rmt->rm_magic != cpu_to_be32(XFS_ATTR3_RMT_MAGIC))\n\t\treturn false;\n\tif (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be64_to_cpu(rmt->rm_blkno) != bno)\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_offset) +\n\t\t\t\tbe32_to_cpu(rmt->rm_bytes) > XATTR_SIZE_MAX)\n\t\treturn false;\n\tif (rmt->rm_owner == 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verify_cksum",
          "args": [
            "ptr",
            "blksize",
            "XFS_ATTR3_RMT_CRC_OFF"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "55-61",
          "snippet": "static inline int\nxfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\treturn *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\treturn *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len >= blksize"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_attr3_rmt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tchar\t\t*ptr;\n\tint\t\tlen;\n\txfs_daddr_t\tbno;\n\tint\t\tblksize = mp->m_attr_geo->blksize;\n\n\t/* no verification of non-crc buffers */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tptr = bp->b_addr;\n\tbno = bp->b_bn;\n\tlen = BBTOB(bp->b_length);\n\tASSERT(len >= blksize);\n\n\twhile (len > 0) {\n\t\tif (!xfs_verify_cksum(ptr, blksize, XFS_ATTR3_RMT_CRC_OFF)) {\n\t\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\t\t\tbreak;\n\t\t}\n\t\tif (!xfs_attr3_rmt_verify(mp, ptr, blksize, bno)) {\n\t\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\t\tbreak;\n\t\t}\n\t\tlen -= blksize;\n\t\tptr += blksize;\n\t\tbno += BTOBB(blksize);\n\t}\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n\telse\n\t\tASSERT(len == 0);\n}"
  },
  {
    "function_name": "xfs_attr3_rmt_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "90-116",
    "snippet": "static bool\nxfs_attr3_rmt_verify(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\tint\t\t\tfsbsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (rmt->rm_magic != cpu_to_be32(XFS_ATTR3_RMT_MAGIC))\n\t\treturn false;\n\tif (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be64_to_cpu(rmt->rm_blkno) != bno)\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_offset) +\n\t\t\t\tbe32_to_cpu(rmt->rm_bytes) > XATTR_SIZE_MAX)\n\t\treturn false;\n\tif (rmt->rm_owner == 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rmt->rm_bytes"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rmt->rm_offset"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rmt->rm_bytes"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rmt->rm_blkno"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&rmt->rm_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_ATTR3_RMT_MAGIC"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_attr3_rmt_verify(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t*ptr,\n\tint\t\t\tfsbsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn false;\n\tif (rmt->rm_magic != cpu_to_be32(XFS_ATTR3_RMT_MAGIC))\n\t\treturn false;\n\tif (!uuid_equal(&rmt->rm_uuid, &mp->m_sb.sb_uuid))\n\t\treturn false;\n\tif (be64_to_cpu(rmt->rm_blkno) != bno)\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_bytes) > fsbsize - sizeof(*rmt))\n\t\treturn false;\n\tif (be32_to_cpu(rmt->rm_offset) +\n\t\t\t\tbe32_to_cpu(rmt->rm_bytes) > XATTR_SIZE_MAX)\n\t\treturn false;\n\tif (rmt->rm_owner == 0)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_attr3_rmt_hdr_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "67-88",
    "snippet": "static bool\nxfs_attr3_rmt_hdr_ok(\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (bno != be64_to_cpu(rmt->rm_blkno))\n\t\treturn false;\n\tif (offset != be32_to_cpu(rmt->rm_offset))\n\t\treturn false;\n\tif (size != be32_to_cpu(rmt->rm_bytes))\n\t\treturn false;\n\tif (ino != be64_to_cpu(rmt->rm_owner))\n\t\treturn false;\n\n\t/* ok */\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rmt->rm_owner"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rmt->rm_bytes"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rmt->rm_offset"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rmt->rm_blkno"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_attr3_rmt_hdr_ok(\n\tvoid\t\t\t*ptr,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\txfs_daddr_t\t\tbno)\n{\n\tstruct xfs_attr3_rmt_hdr *rmt = ptr;\n\n\tif (bno != be64_to_cpu(rmt->rm_blkno))\n\t\treturn false;\n\tif (offset != be32_to_cpu(rmt->rm_offset))\n\t\treturn false;\n\tif (size != be32_to_cpu(rmt->rm_bytes))\n\t\treturn false;\n\tif (ino != be64_to_cpu(rmt->rm_owner))\n\t\treturn false;\n\n\t/* ok */\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_attr3_rmt_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_remote.c",
    "lines": "50-60",
    "snippet": "int\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_attr_remote.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "attrlen"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ATTR3_RMT_BUF_SPACE",
          "args": [
            "mp",
            "mp->m_sb.sb_blocksize"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr3_rmt_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tattrlen)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tint buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\t\treturn (attrlen + buflen - 1) / buflen;\n\t}\n\treturn XFS_B_TO_FSB(mp, attrlen);\n}"
  }
]