[
  {
    "function_name": "logfs_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "640-646",
    "snippet": "static void __exit logfs_exit(void)\n{\n\tunregister_filesystem(&logfs_fs_type);\n\tlogfs_destroy_inode_cache();\n\tlogfs_compr_exit();\n\t__free_pages(emergency_page, 0);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page *emergency_page;",
      "static struct file_system_type logfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"logfs\",\n\t.mount\t\t= logfs_mount,\n\t.kill_sb\t= logfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "emergency_page",
            "0"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_compr_exit",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_compr_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/compr.c",
          "lines": "92-95",
          "snippet": "void logfs_compr_exit(void)\n{\n\tvfree(stream.workspace);\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include \"logfs.h\"\n\nstatic struct z_stream_s stream;\n\nvoid logfs_compr_exit(void)\n{\n\tvfree(stream.workspace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_destroy_inode_cache",
          "args": [],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_destroy_inode_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "418-426",
          "snippet": "void logfs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(logfs_inode_cache);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *logfs_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct kmem_cache *logfs_inode_cache;\n\nvoid logfs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(logfs_inode_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&logfs_fs_type"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct page *emergency_page;\nstatic struct file_system_type logfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"logfs\",\n\t.mount\t\t= logfs_mount,\n\t.kill_sb\t= logfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n\n};\n\nstatic void __exit logfs_exit(void)\n{\n\tunregister_filesystem(&logfs_fs_type);\n\tlogfs_destroy_inode_cache();\n\tlogfs_compr_exit();\n\t__free_pages(emergency_page, 0);\n}"
  },
  {
    "function_name": "logfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "613-638",
    "snippet": "static int __init logfs_init(void)\n{\n\tint ret;\n\n\temergency_page = alloc_pages(GFP_KERNEL, 0);\n\tif (!emergency_page)\n\t\treturn -ENOMEM;\n\n\tret = logfs_compr_init();\n\tif (ret)\n\t\tgoto out1;\n\n\tret = logfs_init_inode_cache();\n\tif (ret)\n\t\tgoto out2;\n\n\tret = register_filesystem(&logfs_fs_type);\n\tif (!ret)\n\t\treturn 0;\n\tlogfs_destroy_inode_cache();\nout2:\n\tlogfs_compr_exit();\nout1:\n\t__free_pages(emergency_page, 0);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page *emergency_page;",
      "static struct file_system_type logfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"logfs\",\n\t.mount\t\t= logfs_mount,\n\t.kill_sb\t= logfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "emergency_page",
            "0"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_compr_exit",
          "args": [],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_compr_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/compr.c",
          "lines": "92-95",
          "snippet": "void logfs_compr_exit(void)\n{\n\tvfree(stream.workspace);\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include \"logfs.h\"\n\nstatic struct z_stream_s stream;\n\nvoid logfs_compr_exit(void)\n{\n\tvfree(stream.workspace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_destroy_inode_cache",
          "args": [],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_destroy_inode_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "418-426",
          "snippet": "void logfs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(logfs_inode_cache);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *logfs_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct kmem_cache *logfs_inode_cache;\n\nvoid logfs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(logfs_inode_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&logfs_fs_type"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_init_inode_cache",
          "args": [],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_inode_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "408-416",
          "snippet": "int logfs_init_inode_cache(void)\n{\n\tlogfs_inode_cache = kmem_cache_create(\"logfs_inode_cache\",\n\t\t\tsizeof(struct logfs_inode), 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\tlogfs_init_once);\n\tif (!logfs_inode_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *logfs_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct kmem_cache *logfs_inode_cache;\n\nint logfs_init_inode_cache(void)\n{\n\tlogfs_inode_cache = kmem_cache_create(\"logfs_inode_cache\",\n\t\t\tsizeof(struct logfs_inode), 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\tlogfs_init_once);\n\tif (!logfs_inode_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_compr_init",
          "args": [],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_compr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/compr.c",
          "lines": "82-90",
          "snippet": "int __init logfs_compr_init(void)\n{\n\tsize_t size = max(zlib_deflate_workspacesize(MAX_WBITS, MAX_MEM_LEVEL),\n\t\t\tzlib_inflate_workspacesize());\n\tstream.workspace = vmalloc(size);\n\tif (!stream.workspace)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include \"logfs.h\"\n\nstatic struct z_stream_s stream;\n\nint __init logfs_compr_init(void)\n{\n\tsize_t size = max(zlib_deflate_workspacesize(MAX_WBITS, MAX_MEM_LEVEL),\n\t\t\tzlib_inflate_workspacesize());\n\tstream.workspace = vmalloc(size);\n\tif (!stream.workspace)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL",
            "0"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7735-7756",
          "snippet": "static struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct page *emergency_page;\nstatic struct file_system_type logfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"logfs\",\n\t.mount\t\t= logfs_mount,\n\t.kill_sb\t= logfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n\n};\n\nstatic int __init logfs_init(void)\n{\n\tint ret;\n\n\temergency_page = alloc_pages(GFP_KERNEL, 0);\n\tif (!emergency_page)\n\t\treturn -ENOMEM;\n\n\tret = logfs_compr_init();\n\tif (ret)\n\t\tgoto out1;\n\n\tret = logfs_init_inode_cache();\n\tif (ret)\n\t\tgoto out2;\n\n\tret = register_filesystem(&logfs_fs_type);\n\tif (!ret)\n\t\treturn 0;\n\tlogfs_destroy_inode_cache();\nout2:\n\tlogfs_compr_exit();\nout1:\n\t__free_pages(emergency_page, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "567-601",
    "snippet": "static struct dentry *logfs_mount(struct file_system_type *type, int flags,\n\t\tconst char *devname, void *data)\n{\n\tulong mtdnr;\n\tstruct logfs_super *super;\n\tint err;\n\n\tsuper = kzalloc(sizeof(*super), GFP_KERNEL);\n\tif (!super)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&super->s_dirop_mutex);\n\tmutex_init(&super->s_object_alias_mutex);\n\tINIT_LIST_HEAD(&super->s_freeing_list);\n\n\tif (!devname)\n\t\terr = logfs_get_sb_bdev(super, type, devname);\n\telse if (strncmp(devname, \"mtd\", 3))\n\t\terr = logfs_get_sb_bdev(super, type, devname);\n\telse {\n\t\tchar *garbage;\n\t\tmtdnr = simple_strtoul(devname+3, &garbage, 0);\n\t\tif (*garbage)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\terr = logfs_get_sb_mtd(super, mtdnr);\n\t}\n\n\tif (err) {\n\t\tkfree(super);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn logfs_get_sb_device(super, type, flags);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_get_sb_device",
          "args": [
            "super",
            "type",
            "flags"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_sb_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "512-565",
          "snippet": "static struct dentry *logfs_get_sb_device(struct logfs_super *super,\n\t\tstruct file_system_type *type, int flags)\n{\n\tstruct super_block *sb;\n\tint err = -ENOMEM;\n\tstatic int mount_count;\n\n\tlog_super(\"LogFS: Start mount %x\\n\", mount_count++);\n\n\terr = -EINVAL;\n\tsb = sget(type, logfs_sb_test, logfs_sb_set, flags | MS_NOATIME, super);\n\tif (IS_ERR(sb)) {\n\t\tsuper->s_devops->put_device(super);\n\t\tkfree(super);\n\t\treturn ERR_CAST(sb);\n\t}\n\n\tif (sb->s_root) {\n\t\t/* Device is already in use */\n\t\tsuper->s_devops->put_device(super);\n\t\tkfree(super);\n\t\treturn dget(sb->s_root);\n\t}\n\n\t/*\n\t * sb->s_maxbytes is limited to 8TB.  On 32bit systems, the page cache\n\t * only covers 16TB and the upper 8TB are used for indirect blocks.\n\t * On 64bit system we could bump up the limit, but that would make\n\t * the filesystem incompatible with 32bit systems.\n\t */\n\tsb->s_maxbytes\t= (1ull << 43) - 1;\n\tsb->s_max_links = LOGFS_LINK_MAX;\n\tsb->s_op\t= &logfs_super_operations;\n\n\terr = logfs_read_sb(sb, sb->s_flags & MS_RDONLY);\n\tif (err)\n\t\tgoto err1;\n\n\tsb->s_flags |= MS_ACTIVE;\n\terr = logfs_get_sb_final(sb);\n\tif (err) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn dget(sb->s_root);\n\nerr1:\n\t/* no ->s_root, no ->put_super() */\n\tiput(super->s_master_inode);\n\tiput(super->s_segfile_inode);\n\tiput(super->s_mapping_inode);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct dentry *logfs_get_sb_device(struct logfs_super *super,\n\t\tstruct file_system_type *type, int flags)\n{\n\tstruct super_block *sb;\n\tint err = -ENOMEM;\n\tstatic int mount_count;\n\n\tlog_super(\"LogFS: Start mount %x\\n\", mount_count++);\n\n\terr = -EINVAL;\n\tsb = sget(type, logfs_sb_test, logfs_sb_set, flags | MS_NOATIME, super);\n\tif (IS_ERR(sb)) {\n\t\tsuper->s_devops->put_device(super);\n\t\tkfree(super);\n\t\treturn ERR_CAST(sb);\n\t}\n\n\tif (sb->s_root) {\n\t\t/* Device is already in use */\n\t\tsuper->s_devops->put_device(super);\n\t\tkfree(super);\n\t\treturn dget(sb->s_root);\n\t}\n\n\t/*\n\t * sb->s_maxbytes is limited to 8TB.  On 32bit systems, the page cache\n\t * only covers 16TB and the upper 8TB are used for indirect blocks.\n\t * On 64bit system we could bump up the limit, but that would make\n\t * the filesystem incompatible with 32bit systems.\n\t */\n\tsb->s_maxbytes\t= (1ull << 43) - 1;\n\tsb->s_max_links = LOGFS_LINK_MAX;\n\tsb->s_op\t= &logfs_super_operations;\n\n\terr = logfs_read_sb(sb, sb->s_flags & MS_RDONLY);\n\tif (err)\n\t\tgoto err1;\n\n\tsb->s_flags |= MS_ACTIVE;\n\terr = logfs_get_sb_final(sb);\n\tif (err) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn dget(sb->s_root);\n\nerr1:\n\t/* no ->s_root, no ->put_super() */\n\tiput(super->s_master_inode);\n\tiput(super->s_segfile_inode);\n\tiput(super->s_mapping_inode);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "super"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_sb_mtd",
          "args": [
            "super",
            "mtdnr"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_sb_mtd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "264-274",
          "snippet": "int logfs_get_sb_mtd(struct logfs_super *s, int mtdnr)\n{\n\tstruct mtd_info *mtd = get_mtd_device(NULL, mtdnr);\n\tif (IS_ERR(mtd))\n\t\treturn PTR_ERR(mtd);\n\n\ts->s_bdev = NULL;\n\ts->s_mtd = mtd;\n\ts->s_devops = &mtd_devops;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/completion.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct logfs_device_ops mtd_devops = {\n\t.find_first_sb\t= logfs_mtd_find_first_sb,\n\t.find_last_sb\t= logfs_mtd_find_last_sb,\n\t.readpage\t= logfs_mtd_readpage,\n\t.writeseg\t= logfs_mtd_writeseg,\n\t.erase\t\t= logfs_mtd_erase,\n\t.can_write_buf\t= logfs_mtd_can_write_buf,\n\t.sync\t\t= logfs_mtd_sync,\n\t.put_device\t= logfs_mtd_put_device,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic const struct logfs_device_ops mtd_devops = {\n\t.find_first_sb\t= logfs_mtd_find_first_sb,\n\t.find_last_sb\t= logfs_mtd_find_last_sb,\n\t.readpage\t= logfs_mtd_readpage,\n\t.writeseg\t= logfs_mtd_writeseg,\n\t.erase\t\t= logfs_mtd_erase,\n\t.can_write_buf\t= logfs_mtd_can_write_buf,\n\t.sync\t\t= logfs_mtd_sync,\n\t.put_device\t= logfs_mtd_put_device,\n};\n\nint logfs_get_sb_mtd(struct logfs_super *s, int mtdnr)\n{\n\tstruct mtd_info *mtd = get_mtd_device(NULL, mtdnr);\n\tif (IS_ERR(mtd))\n\t\treturn PTR_ERR(mtd);\n\n\ts->s_bdev = NULL;\n\ts->s_mtd = mtd;\n\ts->s_devops = &mtd_devops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "devname+3",
            "&garbage",
            "0"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_sb_bdev",
          "args": [
            "super",
            "type",
            "devname"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_sb_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "479-484",
          "snippet": "static inline int logfs_get_sb_bdev(struct logfs_super *s,\n\t\tstruct file_system_type *type,\n\t\tconst char *devname)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline int logfs_get_sb_bdev(struct logfs_super *s,\n\t\tstruct file_system_type *type,\n\t\tconst char *devname)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "devname",
            "\"mtd\"",
            "3"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&super->s_freeing_list"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&super->s_object_alias_mutex"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&super->s_dirop_mutex"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*super)",
            "GFP_KERNEL"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct dentry *logfs_mount(struct file_system_type *type, int flags,\n\t\tconst char *devname, void *data)\n{\n\tulong mtdnr;\n\tstruct logfs_super *super;\n\tint err;\n\n\tsuper = kzalloc(sizeof(*super), GFP_KERNEL);\n\tif (!super)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&super->s_dirop_mutex);\n\tmutex_init(&super->s_object_alias_mutex);\n\tINIT_LIST_HEAD(&super->s_freeing_list);\n\n\tif (!devname)\n\t\terr = logfs_get_sb_bdev(super, type, devname);\n\telse if (strncmp(devname, \"mtd\", 3))\n\t\terr = logfs_get_sb_bdev(super, type, devname);\n\telse {\n\t\tchar *garbage;\n\t\tmtdnr = simple_strtoul(devname+3, &garbage, 0);\n\t\tif (*garbage)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\terr = logfs_get_sb_mtd(super, mtdnr);\n\t}\n\n\tif (err) {\n\t\tkfree(super);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn logfs_get_sb_device(super, type, flags);\n}"
  },
  {
    "function_name": "logfs_get_sb_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "512-565",
    "snippet": "static struct dentry *logfs_get_sb_device(struct logfs_super *super,\n\t\tstruct file_system_type *type, int flags)\n{\n\tstruct super_block *sb;\n\tint err = -ENOMEM;\n\tstatic int mount_count;\n\n\tlog_super(\"LogFS: Start mount %x\\n\", mount_count++);\n\n\terr = -EINVAL;\n\tsb = sget(type, logfs_sb_test, logfs_sb_set, flags | MS_NOATIME, super);\n\tif (IS_ERR(sb)) {\n\t\tsuper->s_devops->put_device(super);\n\t\tkfree(super);\n\t\treturn ERR_CAST(sb);\n\t}\n\n\tif (sb->s_root) {\n\t\t/* Device is already in use */\n\t\tsuper->s_devops->put_device(super);\n\t\tkfree(super);\n\t\treturn dget(sb->s_root);\n\t}\n\n\t/*\n\t * sb->s_maxbytes is limited to 8TB.  On 32bit systems, the page cache\n\t * only covers 16TB and the upper 8TB are used for indirect blocks.\n\t * On 64bit system we could bump up the limit, but that would make\n\t * the filesystem incompatible with 32bit systems.\n\t */\n\tsb->s_maxbytes\t= (1ull << 43) - 1;\n\tsb->s_max_links = LOGFS_LINK_MAX;\n\tsb->s_op\t= &logfs_super_operations;\n\n\terr = logfs_read_sb(sb, sb->s_flags & MS_RDONLY);\n\tif (err)\n\t\tgoto err1;\n\n\tsb->s_flags |= MS_ACTIVE;\n\terr = logfs_get_sb_final(sb);\n\tif (err) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn dget(sb->s_root);\n\nerr1:\n\t/* no ->s_root, no ->put_super() */\n\tiput(super->s_master_inode);\n\tiput(super->s_segfile_inode);\n\tiput(super->s_mapping_inode);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "super->s_mapping_inode"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_sb_final",
          "args": [
            "sb"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_sb_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "307-343",
          "snippet": "static int logfs_get_sb_final(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *rootdir;\n\tint err;\n\n\t/* root dir */\n\trootdir = logfs_iget(sb, LOGFS_INO_ROOT);\n\tif (IS_ERR(rootdir))\n\t\tgoto fail;\n\n\tsb->s_root = d_make_root(rootdir);\n\tif (!sb->s_root)\n\t\tgoto fail;\n\n\t/* at that point we know that ->put_super() will be called */\n\tsuper->s_erase_page = alloc_pages(GFP_KERNEL, 0);\n\tif (!super->s_erase_page)\n\t\treturn -ENOMEM;\n\tmemset(page_address(super->s_erase_page), 0xFF, PAGE_SIZE);\n\n\t/* FIXME: check for read-only mounts */\n\terr = logfs_make_writeable(sb);\n\tif (err) {\n\t\t__free_page(super->s_erase_page);\n\t\treturn err;\n\t}\n\n\tlog_super(\"LogFS: Finished mounting\\n\");\n\treturn 0;\n\nfail:\n\tiput(super->s_master_inode);\n\tiput(super->s_segfile_inode);\n\tiput(super->s_mapping_inode);\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_get_sb_final(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *rootdir;\n\tint err;\n\n\t/* root dir */\n\trootdir = logfs_iget(sb, LOGFS_INO_ROOT);\n\tif (IS_ERR(rootdir))\n\t\tgoto fail;\n\n\tsb->s_root = d_make_root(rootdir);\n\tif (!sb->s_root)\n\t\tgoto fail;\n\n\t/* at that point we know that ->put_super() will be called */\n\tsuper->s_erase_page = alloc_pages(GFP_KERNEL, 0);\n\tif (!super->s_erase_page)\n\t\treturn -ENOMEM;\n\tmemset(page_address(super->s_erase_page), 0xFF, PAGE_SIZE);\n\n\t/* FIXME: check for read-only mounts */\n\terr = logfs_make_writeable(sb);\n\tif (err) {\n\t\t__free_page(super->s_erase_page);\n\t\treturn err;\n\t}\n\n\tlog_super(\"LogFS: Finished mounting\\n\");\n\treturn 0;\n\nfail:\n\tiput(super->s_master_inode);\n\tiput(super->s_segfile_inode);\n\tiput(super->s_mapping_inode);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_sb",
          "args": [
            "sb",
            "sb->s_flags & MS_RDONLY"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "432-477",
          "snippet": "static int logfs_read_sb(struct super_block *sb, int read_only)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint ret;\n\n\tsuper->s_btree_pool = mempool_create(32, btree_alloc, btree_free, NULL);\n\tif (!super->s_btree_pool)\n\t\treturn -ENOMEM;\n\n\tbtree_init_mempool64(&super->s_shadow_tree.new, super->s_btree_pool);\n\tbtree_init_mempool64(&super->s_shadow_tree.old, super->s_btree_pool);\n\tbtree_init_mempool32(&super->s_shadow_tree.segment_map,\n\t\t\tsuper->s_btree_pool);\n\n\tret = logfs_init_mapping(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __logfs_read_sb(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (super->s_feature_incompat & ~LOGFS_FEATURES_INCOMPAT)\n\t\treturn -EIO;\n\tif ((super->s_feature_ro_compat & ~LOGFS_FEATURES_RO_COMPAT) &&\n\t\t\t!read_only)\n\t\treturn -EIO;\n\n\tret = logfs_init_rw(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_areas(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_gc(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_journal(sb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_sb(struct super_block *sb, int read_only)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint ret;\n\n\tsuper->s_btree_pool = mempool_create(32, btree_alloc, btree_free, NULL);\n\tif (!super->s_btree_pool)\n\t\treturn -ENOMEM;\n\n\tbtree_init_mempool64(&super->s_shadow_tree.new, super->s_btree_pool);\n\tbtree_init_mempool64(&super->s_shadow_tree.old, super->s_btree_pool);\n\tbtree_init_mempool32(&super->s_shadow_tree.segment_map,\n\t\t\tsuper->s_btree_pool);\n\n\tret = logfs_init_mapping(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __logfs_read_sb(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (super->s_feature_incompat & ~LOGFS_FEATURES_INCOMPAT)\n\t\treturn -EIO;\n\tif ((super->s_feature_ro_compat & ~LOGFS_FEATURES_RO_COMPAT) &&\n\t\t\t!read_only)\n\t\treturn -EIO;\n\n\tret = logfs_init_rw(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_areas(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_gc(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_journal(sb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "super"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "super->s_devops->put_device",
          "args": [
            "super"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "sb"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "super"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "super->s_devops->put_device",
          "args": [
            "super"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "type",
            "logfs_sb_test",
            "logfs_sb_set",
            "flags | MS_NOATIME",
            "super"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_super",
          "args": [
            "\"LogFS: Start mount %x\\n\"",
            "mount_count++"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct dentry *logfs_get_sb_device(struct logfs_super *super,\n\t\tstruct file_system_type *type, int flags)\n{\n\tstruct super_block *sb;\n\tint err = -ENOMEM;\n\tstatic int mount_count;\n\n\tlog_super(\"LogFS: Start mount %x\\n\", mount_count++);\n\n\terr = -EINVAL;\n\tsb = sget(type, logfs_sb_test, logfs_sb_set, flags | MS_NOATIME, super);\n\tif (IS_ERR(sb)) {\n\t\tsuper->s_devops->put_device(super);\n\t\tkfree(super);\n\t\treturn ERR_CAST(sb);\n\t}\n\n\tif (sb->s_root) {\n\t\t/* Device is already in use */\n\t\tsuper->s_devops->put_device(super);\n\t\tkfree(super);\n\t\treturn dget(sb->s_root);\n\t}\n\n\t/*\n\t * sb->s_maxbytes is limited to 8TB.  On 32bit systems, the page cache\n\t * only covers 16TB and the upper 8TB are used for indirect blocks.\n\t * On 64bit system we could bump up the limit, but that would make\n\t * the filesystem incompatible with 32bit systems.\n\t */\n\tsb->s_maxbytes\t= (1ull << 43) - 1;\n\tsb->s_max_links = LOGFS_LINK_MAX;\n\tsb->s_op\t= &logfs_super_operations;\n\n\terr = logfs_read_sb(sb, sb->s_flags & MS_RDONLY);\n\tif (err)\n\t\tgoto err1;\n\n\tsb->s_flags |= MS_ACTIVE;\n\terr = logfs_get_sb_final(sb);\n\tif (err) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn dget(sb->s_root);\n\nerr1:\n\t/* no ->s_root, no ->put_super() */\n\tiput(super->s_master_inode);\n\tiput(super->s_segfile_inode);\n\tiput(super->s_mapping_inode);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "logfs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "479-510",
    "snippet": "static void logfs_kill_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tlog_super(\"LogFS: Start unmounting\\n\");\n\t/* Alias entries slow down mount, so evict as many as possible */\n\tsync_filesystem(sb);\n\tlogfs_write_anchor(sb);\n\tfree_areas(sb);\n\n\t/*\n\t * From this point on alias entries are simply dropped - and any\n\t * writes to the object store are considered bugs.\n\t */\n\tlog_super(\"LogFS: Now in shutdown\\n\");\n\tgeneric_shutdown_super(sb);\n\tsuper->s_flags |= LOGFS_SB_FLAG_SHUTDOWN;\n\n\tBUG_ON(super->s_dirty_used_bytes || super->s_dirty_free_bytes);\n\n\tlogfs_cleanup_gc(sb);\n\tlogfs_cleanup_journal(sb);\n\tlogfs_cleanup_areas(sb);\n\tlogfs_cleanup_rw(sb);\n\tif (super->s_erase_page)\n\t\t__free_page(super->s_erase_page);\n\tsuper->s_devops->put_device(super);\n\tlogfs_mempool_destroy(super->s_btree_pool);\n\tlogfs_mempool_destroy(super->s_alias_pool);\n\tkfree(super);\n\tlog_super(\"LogFS: Finished unmounting\\n\");\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_super",
          "args": [
            "\"LogFS: Finished unmounting\\n\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "super"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_mempool_destroy",
          "args": [
            "super->s_alias_pool"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "super->s_devops->put_device",
          "args": [
            "super"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "super->s_erase_page"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_cleanup_rw",
          "args": [
            "sb"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_cleanup_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2292-2298",
          "snippet": "void logfs_cleanup_rw(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tlogfs_mempool_destroy(super->s_block_pool);\n\tlogfs_mempool_destroy(super->s_shadow_pool);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_cleanup_rw(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tlogfs_mempool_destroy(super->s_block_pool);\n\tlogfs_mempool_destroy(super->s_shadow_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_cleanup_areas",
          "args": [
            "sb"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_cleanup_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "956-961",
          "snippet": "void logfs_cleanup_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_grim_visitor128(&super->s_object_alias_tree, 0, kill_alias);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_cleanup_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_grim_visitor128(&super->s_object_alias_tree, 0, kill_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_cleanup_journal",
          "args": [
            "sb"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_cleanup_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "886-894",
          "snippet": "void logfs_cleanup_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_grim_visitor32(&super->s_reserved_segments, 0, NULL);\n\n\tkfree(super->s_compressed_je);\n\tkfree(super->s_je);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_cleanup_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_grim_visitor32(&super->s_reserved_segments, 0, NULL);\n\n\tkfree(super->s_compressed_je);\n\tkfree(super->s_je);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_cleanup_gc",
          "args": [
            "sb"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_cleanup_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "713-732",
          "snippet": "void logfs_cleanup_gc(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tif (!super->s_free_list.count)\n\t\treturn;\n\n\t/*\n\t * FIXME: The btree may still contain a single empty node.  So we\n\t * call the grim visitor to clean up that mess.  Btree code should\n\t * do it for us, really.\n\t */\n\tbtree_grim_visitor32(&super->s_cand_tree, 0, NULL);\n\tlogfs_cleanup_list(sb, &super->s_free_list);\n\tlogfs_cleanup_list(sb, &super->s_reserve_list);\n\tfor_each_area(i)\n\t\tlogfs_cleanup_list(sb, &super->s_low_list[i]);\n\tlogfs_cleanup_list(sb, &super->s_ec_list);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_cleanup_gc(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tif (!super->s_free_list.count)\n\t\treturn;\n\n\t/*\n\t * FIXME: The btree may still contain a single empty node.  So we\n\t * call the grim visitor to clean up that mess.  Btree code should\n\t * do it for us, really.\n\t */\n\tbtree_grim_visitor32(&super->s_cand_tree, 0, NULL);\n\tlogfs_cleanup_list(sb, &super->s_free_list);\n\tlogfs_cleanup_list(sb, &super->s_reserve_list);\n\tfor_each_area(i)\n\t\tlogfs_cleanup_list(sb, &super->s_low_list[i]);\n\tlogfs_cleanup_list(sb, &super->s_ec_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_dirty_used_bytes || super->s_dirty_free_bytes"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_shutdown_super",
          "args": [
            "sb"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_super",
          "args": [
            "\"LogFS: Now in shutdown\\n\""
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_areas",
          "args": [
            "sb"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "free_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "866-874",
          "snippet": "void free_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid free_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_anchor",
          "args": [
            "sb"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "734-803",
          "snippet": "void logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_super",
          "args": [
            "\"LogFS: Start unmounting\\n\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void logfs_kill_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tlog_super(\"LogFS: Start unmounting\\n\");\n\t/* Alias entries slow down mount, so evict as many as possible */\n\tsync_filesystem(sb);\n\tlogfs_write_anchor(sb);\n\tfree_areas(sb);\n\n\t/*\n\t * From this point on alias entries are simply dropped - and any\n\t * writes to the object store are considered bugs.\n\t */\n\tlog_super(\"LogFS: Now in shutdown\\n\");\n\tgeneric_shutdown_super(sb);\n\tsuper->s_flags |= LOGFS_SB_FLAG_SHUTDOWN;\n\n\tBUG_ON(super->s_dirty_used_bytes || super->s_dirty_free_bytes);\n\n\tlogfs_cleanup_gc(sb);\n\tlogfs_cleanup_journal(sb);\n\tlogfs_cleanup_areas(sb);\n\tlogfs_cleanup_rw(sb);\n\tif (super->s_erase_page)\n\t\t__free_page(super->s_erase_page);\n\tsuper->s_devops->put_device(super);\n\tlogfs_mempool_destroy(super->s_btree_pool);\n\tlogfs_mempool_destroy(super->s_alias_pool);\n\tkfree(super);\n\tlog_super(\"LogFS: Finished unmounting\\n\");\n}"
  },
  {
    "function_name": "logfs_read_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "432-477",
    "snippet": "static int logfs_read_sb(struct super_block *sb, int read_only)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint ret;\n\n\tsuper->s_btree_pool = mempool_create(32, btree_alloc, btree_free, NULL);\n\tif (!super->s_btree_pool)\n\t\treturn -ENOMEM;\n\n\tbtree_init_mempool64(&super->s_shadow_tree.new, super->s_btree_pool);\n\tbtree_init_mempool64(&super->s_shadow_tree.old, super->s_btree_pool);\n\tbtree_init_mempool32(&super->s_shadow_tree.segment_map,\n\t\t\tsuper->s_btree_pool);\n\n\tret = logfs_init_mapping(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __logfs_read_sb(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (super->s_feature_incompat & ~LOGFS_FEATURES_INCOMPAT)\n\t\treturn -EIO;\n\tif ((super->s_feature_ro_compat & ~LOGFS_FEATURES_RO_COMPAT) &&\n\t\t\t!read_only)\n\t\treturn -EIO;\n\n\tret = logfs_init_rw(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_areas(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_gc(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_journal(sb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_init_journal",
          "args": [
            "sb"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "853-884",
          "snippet": "int logfs_init_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tint ret = -ENOMEM;\n\n\tmutex_init(&super->s_journal_mutex);\n\tbtree_init_mempool32(&super->s_reserved_segments, super->s_btree_pool);\n\n\tsuper->s_je = kzalloc(bufsize, GFP_KERNEL);\n\tif (!super->s_je)\n\t\treturn ret;\n\n\tsuper->s_compressed_je = kzalloc(bufsize, GFP_KERNEL);\n\tif (!super->s_compressed_je)\n\t\treturn ret;\n\n\tsuper->s_master_inode = logfs_new_meta_inode(sb, LOGFS_INO_MASTER);\n\tif (IS_ERR(super->s_master_inode))\n\t\treturn PTR_ERR(super->s_master_inode);\n\n\tret = logfs_read_journal(sb);\n\tif (ret)\n\t\treturn -EIO;\n\n\treserve_sb_and_journal(sb);\n\tlogfs_calc_free(sb);\n\n\tsuper->s_journal_area->a_ops = &journal_area_ops;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct logfs_area_ops journal_area_ops = {\n\t.get_free_segment\t= journal_get_free_segment,\n\t.get_erase_count\t= journal_get_erase_count,\n\t.erase_segment\t\t= journal_erase_segment,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic const struct logfs_area_ops journal_area_ops = {\n\t.get_free_segment\t= journal_get_free_segment,\n\t.get_erase_count\t= journal_get_erase_count,\n\t.erase_segment\t\t= journal_erase_segment,\n};\n\nint logfs_init_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tint ret = -ENOMEM;\n\n\tmutex_init(&super->s_journal_mutex);\n\tbtree_init_mempool32(&super->s_reserved_segments, super->s_btree_pool);\n\n\tsuper->s_je = kzalloc(bufsize, GFP_KERNEL);\n\tif (!super->s_je)\n\t\treturn ret;\n\n\tsuper->s_compressed_je = kzalloc(bufsize, GFP_KERNEL);\n\tif (!super->s_compressed_je)\n\t\treturn ret;\n\n\tsuper->s_master_inode = logfs_new_meta_inode(sb, LOGFS_INO_MASTER);\n\tif (IS_ERR(super->s_master_inode))\n\t\treturn PTR_ERR(super->s_master_inode);\n\n\tret = logfs_read_journal(sb);\n\tif (ret)\n\t\treturn -EIO;\n\n\treserve_sb_and_journal(sb);\n\tlogfs_calc_free(sb);\n\n\tsuper->s_journal_area->a_ops = &journal_area_ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_init_gc",
          "args": [
            "sb"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "684-697",
          "snippet": "int logfs_init_gc(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tbtree_init_mempool32(&super->s_cand_tree, super->s_btree_pool);\n\tlogfs_init_candlist(&super->s_free_list, LIST_SIZE + SCAN_RATIO, 1);\n\tlogfs_init_candlist(&super->s_reserve_list,\n\t\t\tsuper->s_bad_seg_reserve, 1);\n\tfor_each_area(i)\n\t\tlogfs_init_candlist(&super->s_low_list[i], LIST_SIZE, 0);\n\tlogfs_init_candlist(&super->s_ec_list, LIST_SIZE, 1);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define LIST_SIZE 64\t/* base size of candidate lists */",
            "#define SCAN_RATIO 512\t/* number of scanned segments per gc'd segment */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\n#define LIST_SIZE 64\t/* base size of candidate lists */\n#define SCAN_RATIO 512\t/* number of scanned segments per gc'd segment */\n\nint logfs_init_gc(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tbtree_init_mempool32(&super->s_cand_tree, super->s_btree_pool);\n\tlogfs_init_candlist(&super->s_free_list, LIST_SIZE + SCAN_RATIO, 1);\n\tlogfs_init_candlist(&super->s_reserve_list,\n\t\t\tsuper->s_bad_seg_reserve, 1);\n\tfor_each_area(i)\n\t\tlogfs_init_candlist(&super->s_low_list[i], LIST_SIZE, 0);\n\tlogfs_init_candlist(&super->s_ec_list, LIST_SIZE, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_init_areas",
          "args": [
            "sb"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "923-954",
          "snippet": "int logfs_init_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i = -1;\n\n\tsuper->s_alias_pool = mempool_create_kmalloc_pool(600,\n\t\t\tsizeof(struct object_alias_item));\n\tif (!super->s_alias_pool)\n\t\treturn -ENOMEM;\n\n\tsuper->s_journal_area = alloc_area(sb);\n\tif (!super->s_journal_area)\n\t\tgoto err;\n\n\tfor_each_area(i) {\n\t\tsuper->s_area[i] = alloc_area(sb);\n\t\tif (!super->s_area[i])\n\t\t\tgoto err;\n\t\tsuper->s_area[i]->a_level = GC_LEVEL(i);\n\t\tsuper->s_area[i]->a_ops = &ostore_area_ops;\n\t}\n\tbtree_init_mempool128(&super->s_object_alias_tree,\n\t\t\tsuper->s_btree_pool);\n\treturn 0;\n\nerr:\n\tfor (i--; i >= 0; i--)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n\tlogfs_mempool_destroy(super->s_alias_pool);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct logfs_area_ops ostore_area_ops = {\n\t.get_free_segment\t= ostore_get_free_segment,\n\t.get_erase_count\t= ostore_get_erase_count,\n\t.erase_segment\t\t= ostore_erase_segment,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic const struct logfs_area_ops ostore_area_ops = {\n\t.get_free_segment\t= ostore_get_free_segment,\n\t.get_erase_count\t= ostore_get_erase_count,\n\t.erase_segment\t\t= ostore_erase_segment,\n};\n\nint logfs_init_areas(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i = -1;\n\n\tsuper->s_alias_pool = mempool_create_kmalloc_pool(600,\n\t\t\tsizeof(struct object_alias_item));\n\tif (!super->s_alias_pool)\n\t\treturn -ENOMEM;\n\n\tsuper->s_journal_area = alloc_area(sb);\n\tif (!super->s_journal_area)\n\t\tgoto err;\n\n\tfor_each_area(i) {\n\t\tsuper->s_area[i] = alloc_area(sb);\n\t\tif (!super->s_area[i])\n\t\t\tgoto err;\n\t\tsuper->s_area[i]->a_level = GC_LEVEL(i);\n\t\tsuper->s_area[i]->a_ops = &ostore_area_ops;\n\t}\n\tbtree_init_mempool128(&super->s_object_alias_tree,\n\t\t\tsuper->s_btree_pool);\n\treturn 0;\n\nerr:\n\tfor (i--; i >= 0; i--)\n\t\tfree_area(super->s_area[i]);\n\tfree_area(super->s_journal_area);\n\tlogfs_mempool_destroy(super->s_alias_pool);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_init_rw",
          "args": [
            "sb"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2277-2290",
          "snippet": "int logfs_init_rw(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint min_fill = 3 * super->s_no_blocks;\n\n\tINIT_LIST_HEAD(&super->s_object_alias);\n\tINIT_LIST_HEAD(&super->s_writeback_list);\n\tmutex_init(&super->s_write_mutex);\n\tsuper->s_block_pool = mempool_create_kmalloc_pool(min_fill,\n\t\t\tsizeof(struct logfs_block));\n\tsuper->s_shadow_pool = mempool_create_kmalloc_pool(min_fill,\n\t\t\tsizeof(struct logfs_shadow));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_init_rw(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint min_fill = 3 * super->s_no_blocks;\n\n\tINIT_LIST_HEAD(&super->s_object_alias);\n\tINIT_LIST_HEAD(&super->s_writeback_list);\n\tmutex_init(&super->s_write_mutex);\n\tsuper->s_block_pool = mempool_create_kmalloc_pool(min_fill,\n\t\t\tsizeof(struct logfs_block));\n\tsuper->s_shadow_pool = mempool_create_kmalloc_pool(min_fill,\n\t\t\tsizeof(struct logfs_shadow));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_read_sb",
          "args": [
            "sb"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_read_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "390-430",
          "snippet": "static int __logfs_read_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct page *page;\n\tstruct logfs_disk_super *ds;\n\tint i;\n\n\tpage = find_super_block(sb);\n\tif (!page)\n\t\treturn -EINVAL;\n\n\tds = page_address(page);\n\tsuper->s_size = be64_to_cpu(ds->ds_filesystem_size);\n\tsuper->s_root_reserve = be64_to_cpu(ds->ds_root_reserve);\n\tsuper->s_speed_reserve = be64_to_cpu(ds->ds_speed_reserve);\n\tsuper->s_bad_seg_reserve = be32_to_cpu(ds->ds_bad_seg_reserve);\n\tsuper->s_segsize = 1 << ds->ds_segment_shift;\n\tsuper->s_segmask = (1 << ds->ds_segment_shift) - 1;\n\tsuper->s_segshift = ds->ds_segment_shift;\n\tsb->s_blocksize = 1 << ds->ds_block_shift;\n\tsb->s_blocksize_bits = ds->ds_block_shift;\n\tsuper->s_writesize = 1 << ds->ds_write_shift;\n\tsuper->s_writeshift = ds->ds_write_shift;\n\tsuper->s_no_segs = super->s_size >> super->s_segshift;\n\tsuper->s_no_blocks = super->s_segsize >> sb->s_blocksize_bits;\n\tsuper->s_feature_incompat = be64_to_cpu(ds->ds_feature_incompat);\n\tsuper->s_feature_ro_compat = be64_to_cpu(ds->ds_feature_ro_compat);\n\tsuper->s_feature_compat = be64_to_cpu(ds->ds_feature_compat);\n\tsuper->s_feature_flags = be64_to_cpu(ds->ds_feature_flags);\n\n\tjournal_for_each(i)\n\t\tsuper->s_journal_seg[i] = be32_to_cpu(ds->ds_journal_seg[i]);\n\n\tsuper->s_ifile_levels = ds->ds_ifile_levels;\n\tsuper->s_iblock_levels = ds->ds_iblock_levels;\n\tsuper->s_data_levels = ds->ds_data_levels;\n\tsuper->s_total_levels = super->s_ifile_levels + super->s_iblock_levels\n\t\t+ super->s_data_levels;\n\tpage_cache_release(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int __logfs_read_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct page *page;\n\tstruct logfs_disk_super *ds;\n\tint i;\n\n\tpage = find_super_block(sb);\n\tif (!page)\n\t\treturn -EINVAL;\n\n\tds = page_address(page);\n\tsuper->s_size = be64_to_cpu(ds->ds_filesystem_size);\n\tsuper->s_root_reserve = be64_to_cpu(ds->ds_root_reserve);\n\tsuper->s_speed_reserve = be64_to_cpu(ds->ds_speed_reserve);\n\tsuper->s_bad_seg_reserve = be32_to_cpu(ds->ds_bad_seg_reserve);\n\tsuper->s_segsize = 1 << ds->ds_segment_shift;\n\tsuper->s_segmask = (1 << ds->ds_segment_shift) - 1;\n\tsuper->s_segshift = ds->ds_segment_shift;\n\tsb->s_blocksize = 1 << ds->ds_block_shift;\n\tsb->s_blocksize_bits = ds->ds_block_shift;\n\tsuper->s_writesize = 1 << ds->ds_write_shift;\n\tsuper->s_writeshift = ds->ds_write_shift;\n\tsuper->s_no_segs = super->s_size >> super->s_segshift;\n\tsuper->s_no_blocks = super->s_segsize >> sb->s_blocksize_bits;\n\tsuper->s_feature_incompat = be64_to_cpu(ds->ds_feature_incompat);\n\tsuper->s_feature_ro_compat = be64_to_cpu(ds->ds_feature_ro_compat);\n\tsuper->s_feature_compat = be64_to_cpu(ds->ds_feature_compat);\n\tsuper->s_feature_flags = be64_to_cpu(ds->ds_feature_flags);\n\n\tjournal_for_each(i)\n\t\tsuper->s_journal_seg[i] = be32_to_cpu(ds->ds_journal_seg[i]);\n\n\tsuper->s_ifile_levels = ds->ds_ifile_levels;\n\tsuper->s_iblock_levels = ds->ds_iblock_levels;\n\tsuper->s_data_levels = ds->ds_data_levels;\n\tsuper->s_total_levels = super->s_ifile_levels + super->s_iblock_levels\n\t\t+ super->s_data_levels;\n\tpage_cache_release(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_init_mapping",
          "args": [
            "sb"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "906-921",
          "snippet": "int logfs_init_mapping(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\n\tinode = logfs_new_meta_inode(sb, LOGFS_INO_MAPPING);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tsuper->s_mapping_inode = inode;\n\tmapping = inode->i_mapping;\n\tmapping->a_ops = &mapping_aops;\n\t/* Would it be possible to use __GFP_HIGHMEM as well? */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations mapping_aops = {\n\t.invalidatepage = map_invalidatepage,\n\t.releasepage\t= map_releasepage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic const struct address_space_operations mapping_aops = {\n\t.invalidatepage = map_invalidatepage,\n\t.releasepage\t= map_releasepage,\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n};\n\nint logfs_init_mapping(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping;\n\tstruct inode *inode;\n\n\tinode = logfs_new_meta_inode(sb, LOGFS_INO_MAPPING);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tsuper->s_mapping_inode = inode;\n\tmapping = inode->i_mapping;\n\tmapping->a_ops = &mapping_aops;\n\t/* Would it be possible to use __GFP_HIGHMEM as well? */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_init_mempool32",
          "args": [
            "&super->s_shadow_tree.segment_map",
            "super->s_btree_pool"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_init_mempool64",
          "args": [
            "&super->s_shadow_tree.old",
            "super->s_btree_pool"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_init_mempool64",
          "args": [
            "&super->s_shadow_tree.new",
            "super->s_btree_pool"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_create",
          "args": [
            "32",
            "btree_alloc",
            "btree_free",
            "NULL"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_sb(struct super_block *sb, int read_only)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint ret;\n\n\tsuper->s_btree_pool = mempool_create(32, btree_alloc, btree_free, NULL);\n\tif (!super->s_btree_pool)\n\t\treturn -ENOMEM;\n\n\tbtree_init_mempool64(&super->s_shadow_tree.new, super->s_btree_pool);\n\tbtree_init_mempool64(&super->s_shadow_tree.old, super->s_btree_pool);\n\tbtree_init_mempool32(&super->s_shadow_tree.segment_map,\n\t\t\tsuper->s_btree_pool);\n\n\tret = logfs_init_mapping(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __logfs_read_sb(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (super->s_feature_incompat & ~LOGFS_FEATURES_INCOMPAT)\n\t\treturn -EIO;\n\tif ((super->s_feature_ro_compat & ~LOGFS_FEATURES_RO_COMPAT) &&\n\t\t\t!read_only)\n\t\treturn -EIO;\n\n\tret = logfs_init_rw(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_areas(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_gc(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = logfs_init_journal(sb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__logfs_read_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "390-430",
    "snippet": "static int __logfs_read_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct page *page;\n\tstruct logfs_disk_super *ds;\n\tint i;\n\n\tpage = find_super_block(sb);\n\tif (!page)\n\t\treturn -EINVAL;\n\n\tds = page_address(page);\n\tsuper->s_size = be64_to_cpu(ds->ds_filesystem_size);\n\tsuper->s_root_reserve = be64_to_cpu(ds->ds_root_reserve);\n\tsuper->s_speed_reserve = be64_to_cpu(ds->ds_speed_reserve);\n\tsuper->s_bad_seg_reserve = be32_to_cpu(ds->ds_bad_seg_reserve);\n\tsuper->s_segsize = 1 << ds->ds_segment_shift;\n\tsuper->s_segmask = (1 << ds->ds_segment_shift) - 1;\n\tsuper->s_segshift = ds->ds_segment_shift;\n\tsb->s_blocksize = 1 << ds->ds_block_shift;\n\tsb->s_blocksize_bits = ds->ds_block_shift;\n\tsuper->s_writesize = 1 << ds->ds_write_shift;\n\tsuper->s_writeshift = ds->ds_write_shift;\n\tsuper->s_no_segs = super->s_size >> super->s_segshift;\n\tsuper->s_no_blocks = super->s_segsize >> sb->s_blocksize_bits;\n\tsuper->s_feature_incompat = be64_to_cpu(ds->ds_feature_incompat);\n\tsuper->s_feature_ro_compat = be64_to_cpu(ds->ds_feature_ro_compat);\n\tsuper->s_feature_compat = be64_to_cpu(ds->ds_feature_compat);\n\tsuper->s_feature_flags = be64_to_cpu(ds->ds_feature_flags);\n\n\tjournal_for_each(i)\n\t\tsuper->s_journal_seg[i] = be32_to_cpu(ds->ds_journal_seg[i]);\n\n\tsuper->s_ifile_levels = ds->ds_ifile_levels;\n\tsuper->s_iblock_levels = ds->ds_iblock_levels;\n\tsuper->s_data_levels = ds->ds_data_levels;\n\tsuper->s_total_levels = super->s_ifile_levels + super->s_iblock_levels\n\t\t+ super->s_data_levels;\n\tpage_cache_release(page);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ds->ds_journal_seg[i]"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ds->ds_feature_flags"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ds->ds_feature_compat"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ds->ds_feature_ro_compat"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ds->ds_feature_incompat"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ds->ds_bad_seg_reserve"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ds->ds_speed_reserve"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ds->ds_root_reserve"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ds->ds_filesystem_size"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_super_block",
          "args": [
            "sb"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "find_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "359-388",
          "snippet": "static struct page *find_super_block(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct page *first, *last;\n\n\tfirst = super->s_devops->find_first_sb(sb, &super->s_sb_ofs[0]);\n\tif (!first || IS_ERR(first))\n\t\treturn NULL;\n\tlast = super->s_devops->find_last_sb(sb, &super->s_sb_ofs[1]);\n\tif (!last || IS_ERR(last)) {\n\t\tpage_cache_release(first);\n\t\treturn NULL;\n\t}\n\n\tif (!logfs_check_ds(page_address(first))) {\n\t\tpage_cache_release(last);\n\t\treturn first;\n\t}\n\n\t/* First one didn't work, try the second superblock */\n\tif (!logfs_check_ds(page_address(last))) {\n\t\tpage_cache_release(first);\n\t\treturn last;\n\t}\n\n\t/* Neither worked, sorry folks */\n\tpage_cache_release(first);\n\tpage_cache_release(last);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct page *find_super_block(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct page *first, *last;\n\n\tfirst = super->s_devops->find_first_sb(sb, &super->s_sb_ofs[0]);\n\tif (!first || IS_ERR(first))\n\t\treturn NULL;\n\tlast = super->s_devops->find_last_sb(sb, &super->s_sb_ofs[1]);\n\tif (!last || IS_ERR(last)) {\n\t\tpage_cache_release(first);\n\t\treturn NULL;\n\t}\n\n\tif (!logfs_check_ds(page_address(first))) {\n\t\tpage_cache_release(last);\n\t\treturn first;\n\t}\n\n\t/* First one didn't work, try the second superblock */\n\tif (!logfs_check_ds(page_address(last))) {\n\t\tpage_cache_release(first);\n\t\treturn last;\n\t}\n\n\t/* Neither worked, sorry folks */\n\tpage_cache_release(first);\n\tpage_cache_release(last);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int __logfs_read_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct page *page;\n\tstruct logfs_disk_super *ds;\n\tint i;\n\n\tpage = find_super_block(sb);\n\tif (!page)\n\t\treturn -EINVAL;\n\n\tds = page_address(page);\n\tsuper->s_size = be64_to_cpu(ds->ds_filesystem_size);\n\tsuper->s_root_reserve = be64_to_cpu(ds->ds_root_reserve);\n\tsuper->s_speed_reserve = be64_to_cpu(ds->ds_speed_reserve);\n\tsuper->s_bad_seg_reserve = be32_to_cpu(ds->ds_bad_seg_reserve);\n\tsuper->s_segsize = 1 << ds->ds_segment_shift;\n\tsuper->s_segmask = (1 << ds->ds_segment_shift) - 1;\n\tsuper->s_segshift = ds->ds_segment_shift;\n\tsb->s_blocksize = 1 << ds->ds_block_shift;\n\tsb->s_blocksize_bits = ds->ds_block_shift;\n\tsuper->s_writesize = 1 << ds->ds_write_shift;\n\tsuper->s_writeshift = ds->ds_write_shift;\n\tsuper->s_no_segs = super->s_size >> super->s_segshift;\n\tsuper->s_no_blocks = super->s_segsize >> sb->s_blocksize_bits;\n\tsuper->s_feature_incompat = be64_to_cpu(ds->ds_feature_incompat);\n\tsuper->s_feature_ro_compat = be64_to_cpu(ds->ds_feature_ro_compat);\n\tsuper->s_feature_compat = be64_to_cpu(ds->ds_feature_compat);\n\tsuper->s_feature_flags = be64_to_cpu(ds->ds_feature_flags);\n\n\tjournal_for_each(i)\n\t\tsuper->s_journal_seg[i] = be32_to_cpu(ds->ds_journal_seg[i]);\n\n\tsuper->s_ifile_levels = ds->ds_ifile_levels;\n\tsuper->s_iblock_levels = ds->ds_iblock_levels;\n\tsuper->s_data_levels = ds->ds_data_levels;\n\tsuper->s_total_levels = super->s_ifile_levels + super->s_iblock_levels\n\t\t+ super->s_data_levels;\n\tpage_cache_release(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "find_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "359-388",
    "snippet": "static struct page *find_super_block(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct page *first, *last;\n\n\tfirst = super->s_devops->find_first_sb(sb, &super->s_sb_ofs[0]);\n\tif (!first || IS_ERR(first))\n\t\treturn NULL;\n\tlast = super->s_devops->find_last_sb(sb, &super->s_sb_ofs[1]);\n\tif (!last || IS_ERR(last)) {\n\t\tpage_cache_release(first);\n\t\treturn NULL;\n\t}\n\n\tif (!logfs_check_ds(page_address(first))) {\n\t\tpage_cache_release(last);\n\t\treturn first;\n\t}\n\n\t/* First one didn't work, try the second superblock */\n\tif (!logfs_check_ds(page_address(last))) {\n\t\tpage_cache_release(first);\n\t\treturn last;\n\t}\n\n\t/* Neither worked, sorry folks */\n\tpage_cache_release(first);\n\tpage_cache_release(last);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "last"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "first"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "first"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_check_ds",
          "args": [
            "page_address(last)"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_check_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "345-357",
          "snippet": "int logfs_check_ds(struct logfs_disk_super *ds)\n{\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\n\tif (ds->ds_magic != cpu_to_be64(LOGFS_MAGIC))\n\t\treturn -EINVAL;\n\tif (sh->crc != logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4))\n\t\treturn -EINVAL;\n\tif (ds->ds_crc != logfs_crc32(ds, sizeof(*ds),\n\t\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nint logfs_check_ds(struct logfs_disk_super *ds)\n{\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\n\tif (ds->ds_magic != cpu_to_be64(LOGFS_MAGIC))\n\t\treturn -EINVAL;\n\tif (sh->crc != logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4))\n\t\treturn -EINVAL;\n\tif (ds->ds_crc != logfs_crc32(ds, sizeof(*ds),\n\t\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "last"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "last"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "first"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "first"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "last"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "super->s_devops->find_last_sb",
          "args": [
            "sb",
            "&super->s_sb_ofs[1]"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "first"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "super->s_devops->find_first_sb",
          "args": [
            "sb",
            "&super->s_sb_ofs[0]"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct page *find_super_block(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct page *first, *last;\n\n\tfirst = super->s_devops->find_first_sb(sb, &super->s_sb_ofs[0]);\n\tif (!first || IS_ERR(first))\n\t\treturn NULL;\n\tlast = super->s_devops->find_last_sb(sb, &super->s_sb_ofs[1]);\n\tif (!last || IS_ERR(last)) {\n\t\tpage_cache_release(first);\n\t\treturn NULL;\n\t}\n\n\tif (!logfs_check_ds(page_address(first))) {\n\t\tpage_cache_release(last);\n\t\treturn first;\n\t}\n\n\t/* First one didn't work, try the second superblock */\n\tif (!logfs_check_ds(page_address(last))) {\n\t\tpage_cache_release(first);\n\t\treturn last;\n\t}\n\n\t/* Neither worked, sorry folks */\n\tpage_cache_release(first);\n\tpage_cache_release(last);\n\treturn NULL;\n}"
  },
  {
    "function_name": "logfs_check_ds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "345-357",
    "snippet": "int logfs_check_ds(struct logfs_disk_super *ds)\n{\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\n\tif (ds->ds_magic != cpu_to_be64(LOGFS_MAGIC))\n\t\treturn -EINVAL;\n\tif (sh->crc != logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4))\n\t\treturn -EINVAL;\n\tif (ds->ds_crc != logfs_crc32(ds, sizeof(*ds),\n\t\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "ds",
            "sizeof(*ds)",
            "LOGFS_SEGMENT_HEADERSIZE + 12"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "LOGFS_MAGIC"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nint logfs_check_ds(struct logfs_disk_super *ds)\n{\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\n\tif (ds->ds_magic != cpu_to_be64(LOGFS_MAGIC))\n\t\treturn -EINVAL;\n\tif (sh->crc != logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4))\n\t\treturn -EINVAL;\n\tif (ds->ds_crc != logfs_crc32(ds, sizeof(*ds),\n\t\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_get_sb_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "307-343",
    "snippet": "static int logfs_get_sb_final(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *rootdir;\n\tint err;\n\n\t/* root dir */\n\trootdir = logfs_iget(sb, LOGFS_INO_ROOT);\n\tif (IS_ERR(rootdir))\n\t\tgoto fail;\n\n\tsb->s_root = d_make_root(rootdir);\n\tif (!sb->s_root)\n\t\tgoto fail;\n\n\t/* at that point we know that ->put_super() will be called */\n\tsuper->s_erase_page = alloc_pages(GFP_KERNEL, 0);\n\tif (!super->s_erase_page)\n\t\treturn -ENOMEM;\n\tmemset(page_address(super->s_erase_page), 0xFF, PAGE_SIZE);\n\n\t/* FIXME: check for read-only mounts */\n\terr = logfs_make_writeable(sb);\n\tif (err) {\n\t\t__free_page(super->s_erase_page);\n\t\treturn err;\n\t}\n\n\tlog_super(\"LogFS: Finished mounting\\n\");\n\treturn 0;\n\nfail:\n\tiput(super->s_master_inode);\n\tiput(super->s_segfile_inode);\n\tiput(super->s_mapping_inode);\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "super->s_mapping_inode"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_super",
          "args": [
            "\"LogFS: Finished mounting\\n\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "super->s_erase_page"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_make_writeable",
          "args": [
            "sb"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_make_writeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "277-305",
          "snippet": "static int logfs_make_writeable(struct super_block *sb)\n{\n\tint err;\n\n\terr = logfs_open_segfile(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Repair any broken superblock copies */\n\terr = logfs_recover_sb(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Check areas for trailing unaccounted data */\n\terr = logfs_check_areas(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Do one GC pass before any data gets dirtied */\n\tlogfs_gc_pass(sb);\n\n\t/* after all initializations are done, replay the journal\n\t * for rw-mounts, if necessary */\n\terr = logfs_replay_journal(sb);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_make_writeable(struct super_block *sb)\n{\n\tint err;\n\n\terr = logfs_open_segfile(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Repair any broken superblock copies */\n\terr = logfs_recover_sb(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Check areas for trailing unaccounted data */\n\terr = logfs_check_areas(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Do one GC pass before any data gets dirtied */\n\tlogfs_gc_pass(sb);\n\n\t/* after all initializations are done, replay the journal\n\t * for rw-mounts, if necessary */\n\terr = logfs_replay_journal(sb);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(super->s_erase_page)",
            "0xFF",
            "PAGE_SIZE"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "super->s_erase_page"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL",
            "0"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7735-7756",
          "snippet": "static struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "rootdir"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rootdir"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_iget",
          "args": [
            "sb",
            "LOGFS_INO_ROOT"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "109-114",
          "snippet": "struct inode *logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tBUG_ON(ino == LOGFS_INO_MASTER);\n\tBUG_ON(ino == LOGFS_INO_SEGFILE);\n\treturn __logfs_iget(sb, ino);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tBUG_ON(ino == LOGFS_INO_MASTER);\n\tBUG_ON(ino == LOGFS_INO_SEGFILE);\n\treturn __logfs_iget(sb, ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_get_sb_final(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *rootdir;\n\tint err;\n\n\t/* root dir */\n\trootdir = logfs_iget(sb, LOGFS_INO_ROOT);\n\tif (IS_ERR(rootdir))\n\t\tgoto fail;\n\n\tsb->s_root = d_make_root(rootdir);\n\tif (!sb->s_root)\n\t\tgoto fail;\n\n\t/* at that point we know that ->put_super() will be called */\n\tsuper->s_erase_page = alloc_pages(GFP_KERNEL, 0);\n\tif (!super->s_erase_page)\n\t\treturn -ENOMEM;\n\tmemset(page_address(super->s_erase_page), 0xFF, PAGE_SIZE);\n\n\t/* FIXME: check for read-only mounts */\n\terr = logfs_make_writeable(sb);\n\tif (err) {\n\t\t__free_page(super->s_erase_page);\n\t\treturn err;\n\t}\n\n\tlog_super(\"LogFS: Finished mounting\\n\");\n\treturn 0;\n\nfail:\n\tiput(super->s_master_inode);\n\tiput(super->s_segfile_inode);\n\tiput(super->s_mapping_inode);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "logfs_make_writeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "277-305",
    "snippet": "static int logfs_make_writeable(struct super_block *sb)\n{\n\tint err;\n\n\terr = logfs_open_segfile(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Repair any broken superblock copies */\n\terr = logfs_recover_sb(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Check areas for trailing unaccounted data */\n\terr = logfs_check_areas(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Do one GC pass before any data gets dirtied */\n\tlogfs_gc_pass(sb);\n\n\t/* after all initializations are done, replay the journal\n\t * for rw-mounts, if necessary */\n\terr = logfs_replay_journal(sb);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_replay_journal",
          "args": [
            "sb"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_replay_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dir.c",
          "lines": "729-777",
          "snippet": "int logfs_replay_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tu64 ino, pos;\n\tint err;\n\n\tif (super->s_victim_ino) {\n\t\t/* delete victim inode */\n\t\tino = super->s_victim_ino;\n\t\tprintk(KERN_INFO\"LogFS: delete unmapped inode #%llx\\n\", ino);\n\t\tinode = logfs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto fail;\n\n\t\tLOGFS_BUG_ON(i_size_read(inode) > 0, sb);\n\t\tsuper->s_victim_ino = 0;\n\t\terr = logfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tif (err) {\n\t\t\tsuper->s_victim_ino = ino;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (super->s_rename_dir) {\n\t\t/* delete old dd from rename */\n\t\tino = super->s_rename_dir;\n\t\tpos = super->s_rename_pos;\n\t\tprintk(KERN_INFO\"LogFS: delete unbacked dentry (%llx, %llx)\\n\",\n\t\t\t\tino, pos);\n\t\tinode = logfs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto fail;\n\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\terr = logfs_delete_dd(inode, pos);\n\t\tiput(inode);\n\t\tif (err) {\n\t\t\tsuper->s_rename_dir = ino;\n\t\t\tsuper->s_rename_pos = pos;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\tLOGFS_BUG(sb);\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_replay_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\tu64 ino, pos;\n\tint err;\n\n\tif (super->s_victim_ino) {\n\t\t/* delete victim inode */\n\t\tino = super->s_victim_ino;\n\t\tprintk(KERN_INFO\"LogFS: delete unmapped inode #%llx\\n\", ino);\n\t\tinode = logfs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto fail;\n\n\t\tLOGFS_BUG_ON(i_size_read(inode) > 0, sb);\n\t\tsuper->s_victim_ino = 0;\n\t\terr = logfs_remove_inode(inode);\n\t\tiput(inode);\n\t\tif (err) {\n\t\t\tsuper->s_victim_ino = ino;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (super->s_rename_dir) {\n\t\t/* delete old dd from rename */\n\t\tino = super->s_rename_dir;\n\t\tpos = super->s_rename_pos;\n\t\tprintk(KERN_INFO\"LogFS: delete unbacked dentry (%llx, %llx)\\n\",\n\t\t\t\tino, pos);\n\t\tinode = logfs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\tgoto fail;\n\n\t\tsuper->s_rename_dir = 0;\n\t\tsuper->s_rename_pos = 0;\n\t\terr = logfs_delete_dd(inode, pos);\n\t\tiput(inode);\n\t\tif (err) {\n\t\t\tsuper->s_rename_dir = ino;\n\t\t\tsuper->s_rename_pos = pos;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\tLOGFS_BUG(sb);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_gc_pass",
          "args": [
            "sb"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_gc_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "615-629",
          "snippet": "void logfs_gc_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t//BUG_ON(mutex_trylock(&logfs_super(sb)->s_w_mutex));\n\t/* Write journal before free space is getting saturated with dirty\n\t * objects.\n\t */\n\tif (super->s_dirty_used_bytes + super->s_dirty_free_bytes\n\t\t\t+ LOGFS_MAX_OBJECTSIZE >= super->s_free_bytes)\n\t\tlogfs_write_anchor(sb);\n\t__logfs_gc_pass(sb, super->s_total_levels);\n\tlogfs_wl_pass(sb);\n\tlogfs_journal_wl_pass(sb);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_gc_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t//BUG_ON(mutex_trylock(&logfs_super(sb)->s_w_mutex));\n\t/* Write journal before free space is getting saturated with dirty\n\t * objects.\n\t */\n\tif (super->s_dirty_used_bytes + super->s_dirty_free_bytes\n\t\t\t+ LOGFS_MAX_OBJECTSIZE >= super->s_free_bytes)\n\t\tlogfs_write_anchor(sb);\n\t__logfs_gc_pass(sb, super->s_total_levels);\n\tlogfs_wl_pass(sb);\n\tlogfs_journal_wl_pass(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_check_areas",
          "args": [
            "sb"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_check_areas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "663-673",
          "snippet": "int logfs_check_areas(struct super_block *sb)\n{\n\tint i, err;\n\n\tfor_each_area(i) {\n\t\terr = check_area(sb, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_check_areas(struct super_block *sb)\n{\n\tint i, err;\n\n\tfor_each_area(i) {\n\t\terr = check_area(sb, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_recover_sb",
          "args": [
            "sb"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_recover_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "241-275",
          "snippet": "static int logfs_recover_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super _ds0, *ds0 = &_ds0;\n\tstruct logfs_disk_super _ds1, *ds1 = &_ds1;\n\tint err, valid0, valid1;\n\n\t/* read first superblock */\n\terr = wbuf_read(sb, super->s_sb_ofs[0], sizeof(*ds0), ds0);\n\tif (err)\n\t\treturn err;\n\t/* read last superblock */\n\terr = wbuf_read(sb, super->s_sb_ofs[1], sizeof(*ds1), ds1);\n\tif (err)\n\t\treturn err;\n\tvalid0 = logfs_check_ds(ds0) == 0;\n\tvalid1 = logfs_check_ds(ds1) == 0;\n\n\tif (!valid0 && valid1) {\n\t\tprintk(KERN_INFO\"First superblock is invalid - fixing.\\n\");\n\t\treturn write_one_sb(sb, super->s_devops->find_first_sb);\n\t}\n\tif (valid0 && !valid1) {\n\t\tprintk(KERN_INFO\"Last superblock is invalid - fixing.\\n\");\n\t\treturn write_one_sb(sb, super->s_devops->find_last_sb);\n\t}\n\tif (valid0 && valid1 && ds_cmp(ds0, ds1)) {\n\t\tprintk(KERN_INFO\"Superblocks don't match - fixing.\\n\");\n\t\treturn logfs_write_sb(sb);\n\t}\n\t/* If neither is valid now, something's wrong.  Didn't we properly\n\t * check them before?!? */\n\tBUG_ON(!valid0 && !valid1);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_recover_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super _ds0, *ds0 = &_ds0;\n\tstruct logfs_disk_super _ds1, *ds1 = &_ds1;\n\tint err, valid0, valid1;\n\n\t/* read first superblock */\n\terr = wbuf_read(sb, super->s_sb_ofs[0], sizeof(*ds0), ds0);\n\tif (err)\n\t\treturn err;\n\t/* read last superblock */\n\terr = wbuf_read(sb, super->s_sb_ofs[1], sizeof(*ds1), ds1);\n\tif (err)\n\t\treturn err;\n\tvalid0 = logfs_check_ds(ds0) == 0;\n\tvalid1 = logfs_check_ds(ds1) == 0;\n\n\tif (!valid0 && valid1) {\n\t\tprintk(KERN_INFO\"First superblock is invalid - fixing.\\n\");\n\t\treturn write_one_sb(sb, super->s_devops->find_first_sb);\n\t}\n\tif (valid0 && !valid1) {\n\t\tprintk(KERN_INFO\"Last superblock is invalid - fixing.\\n\");\n\t\treturn write_one_sb(sb, super->s_devops->find_last_sb);\n\t}\n\tif (valid0 && valid1 && ds_cmp(ds0, ds1)) {\n\t\tprintk(KERN_INFO\"Superblocks don't match - fixing.\\n\");\n\t\treturn logfs_write_sb(sb);\n\t}\n\t/* If neither is valid now, something's wrong.  Didn't we properly\n\t * check them before?!? */\n\tBUG_ON(!valid0 && !valid1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_open_segfile",
          "args": [
            "sb"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_open_segfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2265-2275",
          "snippet": "int logfs_open_segfile(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\n\tinode = logfs_read_meta_inode(sb, LOGFS_INO_SEGFILE);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tsuper->s_segfile_inode = inode;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_open_segfile(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode;\n\n\tinode = logfs_read_meta_inode(sb, LOGFS_INO_SEGFILE);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tsuper->s_segfile_inode = inode;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_make_writeable(struct super_block *sb)\n{\n\tint err;\n\n\terr = logfs_open_segfile(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Repair any broken superblock copies */\n\terr = logfs_recover_sb(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Check areas for trailing unaccounted data */\n\terr = logfs_check_areas(sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Do one GC pass before any data gets dirtied */\n\tlogfs_gc_pass(sb);\n\n\t/* after all initializations are done, replay the journal\n\t * for rw-mounts, if necessary */\n\terr = logfs_replay_journal(sb);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_recover_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "241-275",
    "snippet": "static int logfs_recover_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super _ds0, *ds0 = &_ds0;\n\tstruct logfs_disk_super _ds1, *ds1 = &_ds1;\n\tint err, valid0, valid1;\n\n\t/* read first superblock */\n\terr = wbuf_read(sb, super->s_sb_ofs[0], sizeof(*ds0), ds0);\n\tif (err)\n\t\treturn err;\n\t/* read last superblock */\n\terr = wbuf_read(sb, super->s_sb_ofs[1], sizeof(*ds1), ds1);\n\tif (err)\n\t\treturn err;\n\tvalid0 = logfs_check_ds(ds0) == 0;\n\tvalid1 = logfs_check_ds(ds1) == 0;\n\n\tif (!valid0 && valid1) {\n\t\tprintk(KERN_INFO\"First superblock is invalid - fixing.\\n\");\n\t\treturn write_one_sb(sb, super->s_devops->find_first_sb);\n\t}\n\tif (valid0 && !valid1) {\n\t\tprintk(KERN_INFO\"Last superblock is invalid - fixing.\\n\");\n\t\treturn write_one_sb(sb, super->s_devops->find_last_sb);\n\t}\n\tif (valid0 && valid1 && ds_cmp(ds0, ds1)) {\n\t\tprintk(KERN_INFO\"Superblocks don't match - fixing.\\n\");\n\t\treturn logfs_write_sb(sb);\n\t}\n\t/* If neither is valid now, something's wrong.  Didn't we properly\n\t * check them before?!? */\n\tBUG_ON(!valid0 && !valid1);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!valid0 && !valid1"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_write_sb",
          "args": [
            "sb"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "213-228",
          "snippet": "int logfs_write_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\t/* First superblock */\n\terr = write_one_sb(sb, super->s_devops->find_first_sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Last superblock */\n\terr = write_one_sb(sb, super->s_devops->find_last_sb);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nint logfs_write_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\t/* First superblock */\n\terr = write_one_sb(sb, super->s_devops->find_first_sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Last superblock */\n\terr = write_one_sb(sb, super->s_devops->find_last_sb);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\"Superblocks don't match - fixing.\\n\""
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ds_cmp",
          "args": [
            "ds0",
            "ds1"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ds_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "230-239",
          "snippet": "static int ds_cmp(const void *ds0, const void *ds1)\n{\n\tsize_t len = sizeof(struct logfs_disk_super);\n\n\t/* We know the segment headers differ, so ignore them */\n\tlen -= LOGFS_SEGMENT_HEADERSIZE;\n\tds0 += LOGFS_SEGMENT_HEADERSIZE;\n\tds1 += LOGFS_SEGMENT_HEADERSIZE;\n\treturn memcmp(ds0, ds1, len);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int ds_cmp(const void *ds0, const void *ds1)\n{\n\tsize_t len = sizeof(struct logfs_disk_super);\n\n\t/* We know the segment headers differ, so ignore them */\n\tlen -= LOGFS_SEGMENT_HEADERSIZE;\n\tds0 += LOGFS_SEGMENT_HEADERSIZE;\n\tds1 += LOGFS_SEGMENT_HEADERSIZE;\n\treturn memcmp(ds0, ds1, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_sb",
          "args": [
            "sb",
            "super->s_devops->find_last_sb"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "write_one_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "187-211",
          "snippet": "static int write_one_sb(struct super_block *sb,\n\t\tstruct page *(*find_sb)(struct super_block *sb, u64 *ofs))\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super *ds;\n\tstruct logfs_segment_entry se;\n\tstruct page *page;\n\tu64 ofs;\n\tu32 ec, segno;\n\tint err;\n\n\tpage = find_sb(sb, &ofs);\n\tif (!page)\n\t\treturn -EIO;\n\tds = page_address(page);\n\tsegno = seg_no(sb, ofs);\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tec = be32_to_cpu(se.ec_level) >> 4;\n\tec++;\n\tlogfs_set_segment_erased(sb, segno, ec, 0);\n\tlogfs_write_ds(sb, ds, segno, ec);\n\terr = super->s_devops->write_sb(sb, page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int write_one_sb(struct super_block *sb,\n\t\tstruct page *(*find_sb)(struct super_block *sb, u64 *ofs))\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super *ds;\n\tstruct logfs_segment_entry se;\n\tstruct page *page;\n\tu64 ofs;\n\tu32 ec, segno;\n\tint err;\n\n\tpage = find_sb(sb, &ofs);\n\tif (!page)\n\t\treturn -EIO;\n\tds = page_address(page);\n\tsegno = seg_no(sb, ofs);\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tec = be32_to_cpu(se.ec_level) >> 4;\n\tec++;\n\tlogfs_set_segment_erased(sb, segno, ec, 0);\n\tlogfs_write_ds(sb, ds, segno, ec);\n\terr = super->s_devops->write_sb(sb, page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_check_ds",
          "args": [
            "ds1"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_check_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "345-357",
          "snippet": "int logfs_check_ds(struct logfs_disk_super *ds)\n{\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\n\tif (ds->ds_magic != cpu_to_be64(LOGFS_MAGIC))\n\t\treturn -EINVAL;\n\tif (sh->crc != logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4))\n\t\treturn -EINVAL;\n\tif (ds->ds_crc != logfs_crc32(ds, sizeof(*ds),\n\t\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nint logfs_check_ds(struct logfs_disk_super *ds)\n{\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\n\tif (ds->ds_magic != cpu_to_be64(LOGFS_MAGIC))\n\t\treturn -EINVAL;\n\tif (sh->crc != logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4))\n\t\treturn -EINVAL;\n\tif (ds->ds_crc != logfs_crc32(ds, sizeof(*ds),\n\t\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbuf_read",
          "args": [
            "sb",
            "super->s_sb_ofs[1]",
            "sizeof(*ds1)",
            "ds1"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "wbuf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "400-422",
          "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_recover_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super _ds0, *ds0 = &_ds0;\n\tstruct logfs_disk_super _ds1, *ds1 = &_ds1;\n\tint err, valid0, valid1;\n\n\t/* read first superblock */\n\terr = wbuf_read(sb, super->s_sb_ofs[0], sizeof(*ds0), ds0);\n\tif (err)\n\t\treturn err;\n\t/* read last superblock */\n\terr = wbuf_read(sb, super->s_sb_ofs[1], sizeof(*ds1), ds1);\n\tif (err)\n\t\treturn err;\n\tvalid0 = logfs_check_ds(ds0) == 0;\n\tvalid1 = logfs_check_ds(ds1) == 0;\n\n\tif (!valid0 && valid1) {\n\t\tprintk(KERN_INFO\"First superblock is invalid - fixing.\\n\");\n\t\treturn write_one_sb(sb, super->s_devops->find_first_sb);\n\t}\n\tif (valid0 && !valid1) {\n\t\tprintk(KERN_INFO\"Last superblock is invalid - fixing.\\n\");\n\t\treturn write_one_sb(sb, super->s_devops->find_last_sb);\n\t}\n\tif (valid0 && valid1 && ds_cmp(ds0, ds1)) {\n\t\tprintk(KERN_INFO\"Superblocks don't match - fixing.\\n\");\n\t\treturn logfs_write_sb(sb);\n\t}\n\t/* If neither is valid now, something's wrong.  Didn't we properly\n\t * check them before?!? */\n\tBUG_ON(!valid0 && !valid1);\n\treturn 0;\n}"
  },
  {
    "function_name": "ds_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "230-239",
    "snippet": "static int ds_cmp(const void *ds0, const void *ds1)\n{\n\tsize_t len = sizeof(struct logfs_disk_super);\n\n\t/* We know the segment headers differ, so ignore them */\n\tlen -= LOGFS_SEGMENT_HEADERSIZE;\n\tds0 += LOGFS_SEGMENT_HEADERSIZE;\n\tds1 += LOGFS_SEGMENT_HEADERSIZE;\n\treturn memcmp(ds0, ds1, len);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ds0",
            "ds1",
            "len"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int ds_cmp(const void *ds0, const void *ds1)\n{\n\tsize_t len = sizeof(struct logfs_disk_super);\n\n\t/* We know the segment headers differ, so ignore them */\n\tlen -= LOGFS_SEGMENT_HEADERSIZE;\n\tds0 += LOGFS_SEGMENT_HEADERSIZE;\n\tds1 += LOGFS_SEGMENT_HEADERSIZE;\n\treturn memcmp(ds0, ds1, len);\n}"
  },
  {
    "function_name": "logfs_write_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "213-228",
    "snippet": "int logfs_write_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\t/* First superblock */\n\terr = write_one_sb(sb, super->s_devops->find_first_sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Last superblock */\n\terr = write_one_sb(sb, super->s_devops->find_last_sb);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_one_sb",
          "args": [
            "sb",
            "super->s_devops->find_last_sb"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "write_one_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "187-211",
          "snippet": "static int write_one_sb(struct super_block *sb,\n\t\tstruct page *(*find_sb)(struct super_block *sb, u64 *ofs))\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super *ds;\n\tstruct logfs_segment_entry se;\n\tstruct page *page;\n\tu64 ofs;\n\tu32 ec, segno;\n\tint err;\n\n\tpage = find_sb(sb, &ofs);\n\tif (!page)\n\t\treturn -EIO;\n\tds = page_address(page);\n\tsegno = seg_no(sb, ofs);\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tec = be32_to_cpu(se.ec_level) >> 4;\n\tec++;\n\tlogfs_set_segment_erased(sb, segno, ec, 0);\n\tlogfs_write_ds(sb, ds, segno, ec);\n\terr = super->s_devops->write_sb(sb, page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int write_one_sb(struct super_block *sb,\n\t\tstruct page *(*find_sb)(struct super_block *sb, u64 *ofs))\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super *ds;\n\tstruct logfs_segment_entry se;\n\tstruct page *page;\n\tu64 ofs;\n\tu32 ec, segno;\n\tint err;\n\n\tpage = find_sb(sb, &ofs);\n\tif (!page)\n\t\treturn -EIO;\n\tds = page_address(page);\n\tsegno = seg_no(sb, ofs);\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tec = be32_to_cpu(se.ec_level) >> 4;\n\tec++;\n\tlogfs_set_segment_erased(sb, segno, ec, 0);\n\tlogfs_write_ds(sb, ds, segno, ec);\n\terr = super->s_devops->write_sb(sb, page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nint logfs_write_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\t/* First superblock */\n\terr = write_one_sb(sb, super->s_devops->find_first_sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Last superblock */\n\terr = write_one_sb(sb, super->s_devops->find_last_sb);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}"
  },
  {
    "function_name": "write_one_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "187-211",
    "snippet": "static int write_one_sb(struct super_block *sb,\n\t\tstruct page *(*find_sb)(struct super_block *sb, u64 *ofs))\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super *ds;\n\tstruct logfs_segment_entry se;\n\tstruct page *page;\n\tu64 ofs;\n\tu32 ec, segno;\n\tint err;\n\n\tpage = find_sb(sb, &ofs);\n\tif (!page)\n\t\treturn -EIO;\n\tds = page_address(page);\n\tsegno = seg_no(sb, ofs);\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tec = be32_to_cpu(se.ec_level) >> 4;\n\tec++;\n\tlogfs_set_segment_erased(sb, segno, ec, 0);\n\tlogfs_write_ds(sb, ds, segno, ec);\n\terr = super->s_devops->write_sb(sb, page);\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "super->s_devops->write_sb",
          "args": [
            "sb",
            "page"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_write_ds",
          "args": [
            "sb",
            "ds",
            "segno",
            "ec"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "155-185",
          "snippet": "static void logfs_write_ds(struct super_block *sb, struct logfs_disk_super *ds,\n\t\tu32 segno, u32 ec)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\tint i;\n\n\tmemset(ds, 0, sizeof(*ds));\n\tset_segment_header(sh, SEG_SUPER, 0, segno, ec);\n\n\tds->ds_ifile_levels\t= super->s_ifile_levels;\n\tds->ds_iblock_levels\t= super->s_iblock_levels;\n\tds->ds_data_levels\t= super->s_data_levels; /* XXX: Remove */\n\tds->ds_segment_shift\t= super->s_segshift;\n\tds->ds_block_shift\t= sb->s_blocksize_bits;\n\tds->ds_write_shift\t= super->s_writeshift;\n\tds->ds_filesystem_size\t= cpu_to_be64(super->s_size);\n\tds->ds_segment_size\t= cpu_to_be32(super->s_segsize);\n\tds->ds_bad_seg_reserve\t= cpu_to_be32(super->s_bad_seg_reserve);\n\tds->ds_feature_incompat\t= cpu_to_be64(super->s_feature_incompat);\n\tds->ds_feature_ro_compat= cpu_to_be64(super->s_feature_ro_compat);\n\tds->ds_feature_compat\t= cpu_to_be64(super->s_feature_compat);\n\tds->ds_feature_flags\t= cpu_to_be64(super->s_feature_flags);\n\tds->ds_root_reserve\t= cpu_to_be64(super->s_root_reserve);\n\tds->ds_speed_reserve\t= cpu_to_be64(super->s_speed_reserve);\n\tjournal_for_each(i)\n\t\tds->ds_journal_seg[i] = cpu_to_be32(super->s_journal_seg[i]);\n\tds->ds_magic\t\t= cpu_to_be64(LOGFS_MAGIC);\n\tds->ds_crc = logfs_crc32(ds, sizeof(*ds),\n\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void logfs_write_ds(struct super_block *sb, struct logfs_disk_super *ds,\n\t\tu32 segno, u32 ec)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\tint i;\n\n\tmemset(ds, 0, sizeof(*ds));\n\tset_segment_header(sh, SEG_SUPER, 0, segno, ec);\n\n\tds->ds_ifile_levels\t= super->s_ifile_levels;\n\tds->ds_iblock_levels\t= super->s_iblock_levels;\n\tds->ds_data_levels\t= super->s_data_levels; /* XXX: Remove */\n\tds->ds_segment_shift\t= super->s_segshift;\n\tds->ds_block_shift\t= sb->s_blocksize_bits;\n\tds->ds_write_shift\t= super->s_writeshift;\n\tds->ds_filesystem_size\t= cpu_to_be64(super->s_size);\n\tds->ds_segment_size\t= cpu_to_be32(super->s_segsize);\n\tds->ds_bad_seg_reserve\t= cpu_to_be32(super->s_bad_seg_reserve);\n\tds->ds_feature_incompat\t= cpu_to_be64(super->s_feature_incompat);\n\tds->ds_feature_ro_compat= cpu_to_be64(super->s_feature_ro_compat);\n\tds->ds_feature_compat\t= cpu_to_be64(super->s_feature_compat);\n\tds->ds_feature_flags\t= cpu_to_be64(super->s_feature_flags);\n\tds->ds_root_reserve\t= cpu_to_be64(super->s_root_reserve);\n\tds->ds_speed_reserve\t= cpu_to_be64(super->s_speed_reserve);\n\tjournal_for_each(i)\n\t\tds->ds_journal_seg[i] = cpu_to_be32(super->s_journal_seg[i]);\n\tds->ds_magic\t\t= cpu_to_be64(LOGFS_MAGIC);\n\tds->ds_crc = logfs_crc32(ds, sizeof(*ds),\n\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_set_segment_erased",
          "args": [
            "sb",
            "segno",
            "ec",
            "0"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_segment_erased",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2099-2105",
          "snippet": "void logfs_set_segment_erased(struct super_block *sb, u32 segno, u32 ec,\n\t\tgc_level_t gc_level)\n{\n\tu32 ec_level = ec << 4 | (__force u8)gc_level;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_erased, ec_level);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_erased(struct super_block *sb, u32 segno, u32 ec,\n\t\tgc_level_t gc_level)\n{\n\tu32 ec_level = ec << 4 | (__force u8)gc_level;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_erased, ec_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.ec_level"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_segment_entry",
          "args": [
            "sb",
            "segno",
            "&se"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2068-2072",
          "snippet": "void logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seg_no",
          "args": [
            "sb",
            "ofs"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "seg_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "673-676",
          "snippet": "static inline u32 seg_no(struct super_block *sb, u64 ofs)\n{\n\treturn ofs >> logfs_super(sb)->s_segshift;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u32 seg_no(struct super_block *sb, u64 ofs)\n{\n\treturn ofs >> logfs_super(sb)->s_segshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_sb",
          "args": [
            "sb",
            "&ofs"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int write_one_sb(struct super_block *sb,\n\t\tstruct page *(*find_sb)(struct super_block *sb, u64 *ofs))\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_disk_super *ds;\n\tstruct logfs_segment_entry se;\n\tstruct page *page;\n\tu64 ofs;\n\tu32 ec, segno;\n\tint err;\n\n\tpage = find_sb(sb, &ofs);\n\tif (!page)\n\t\treturn -EIO;\n\tds = page_address(page);\n\tsegno = seg_no(sb, ofs);\n\tlogfs_get_segment_entry(sb, segno, &se);\n\tec = be32_to_cpu(se.ec_level) >> 4;\n\tec++;\n\tlogfs_set_segment_erased(sb, segno, ec, 0);\n\tlogfs_write_ds(sb, ds, segno, ec);\n\terr = super->s_devops->write_sb(sb, page);\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "logfs_write_ds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "155-185",
    "snippet": "static void logfs_write_ds(struct super_block *sb, struct logfs_disk_super *ds,\n\t\tu32 segno, u32 ec)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\tint i;\n\n\tmemset(ds, 0, sizeof(*ds));\n\tset_segment_header(sh, SEG_SUPER, 0, segno, ec);\n\n\tds->ds_ifile_levels\t= super->s_ifile_levels;\n\tds->ds_iblock_levels\t= super->s_iblock_levels;\n\tds->ds_data_levels\t= super->s_data_levels; /* XXX: Remove */\n\tds->ds_segment_shift\t= super->s_segshift;\n\tds->ds_block_shift\t= sb->s_blocksize_bits;\n\tds->ds_write_shift\t= super->s_writeshift;\n\tds->ds_filesystem_size\t= cpu_to_be64(super->s_size);\n\tds->ds_segment_size\t= cpu_to_be32(super->s_segsize);\n\tds->ds_bad_seg_reserve\t= cpu_to_be32(super->s_bad_seg_reserve);\n\tds->ds_feature_incompat\t= cpu_to_be64(super->s_feature_incompat);\n\tds->ds_feature_ro_compat= cpu_to_be64(super->s_feature_ro_compat);\n\tds->ds_feature_compat\t= cpu_to_be64(super->s_feature_compat);\n\tds->ds_feature_flags\t= cpu_to_be64(super->s_feature_flags);\n\tds->ds_root_reserve\t= cpu_to_be64(super->s_root_reserve);\n\tds->ds_speed_reserve\t= cpu_to_be64(super->s_speed_reserve);\n\tjournal_for_each(i)\n\t\tds->ds_journal_seg[i] = cpu_to_be32(super->s_journal_seg[i]);\n\tds->ds_magic\t\t= cpu_to_be64(LOGFS_MAGIC);\n\tds->ds_crc = logfs_crc32(ds, sizeof(*ds),\n\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "ds",
            "sizeof(*ds)",
            "LOGFS_SEGMENT_HEADERSIZE + 12"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "LOGFS_MAGIC"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "super->s_journal_seg[i]"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_speed_reserve"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_root_reserve"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_feature_flags"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_feature_compat"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_feature_ro_compat"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_feature_incompat"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "super->s_bad_seg_reserve"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "super->s_segsize"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_size"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_segment_header",
          "args": [
            "sh",
            "SEG_SUPER",
            "0",
            "segno",
            "ec"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "set_segment_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "143-153",
          "snippet": "static void set_segment_header(struct logfs_segment_header *sh, u8 type,\n\t\tu8 level, u32 segno, u32 ec)\n{\n\tsh->pad = 0;\n\tsh->type = type;\n\tsh->level = level;\n\tsh->segno = cpu_to_be32(segno);\n\tsh->ec = cpu_to_be32(ec);\n\tsh->gec = cpu_to_be64(segno);\n\tsh->crc = logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void set_segment_header(struct logfs_segment_header *sh, u8 type,\n\t\tu8 level, u32 segno, u32 ec)\n{\n\tsh->pad = 0;\n\tsh->type = type;\n\tsh->level = level;\n\tsh->segno = cpu_to_be32(segno);\n\tsh->ec = cpu_to_be32(ec);\n\tsh->gec = cpu_to_be64(segno);\n\tsh->crc = logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ds",
            "0",
            "sizeof(*ds)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void logfs_write_ds(struct super_block *sb, struct logfs_disk_super *ds,\n\t\tu32 segno, u32 ec)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_header *sh = &ds->ds_sh;\n\tint i;\n\n\tmemset(ds, 0, sizeof(*ds));\n\tset_segment_header(sh, SEG_SUPER, 0, segno, ec);\n\n\tds->ds_ifile_levels\t= super->s_ifile_levels;\n\tds->ds_iblock_levels\t= super->s_iblock_levels;\n\tds->ds_data_levels\t= super->s_data_levels; /* XXX: Remove */\n\tds->ds_segment_shift\t= super->s_segshift;\n\tds->ds_block_shift\t= sb->s_blocksize_bits;\n\tds->ds_write_shift\t= super->s_writeshift;\n\tds->ds_filesystem_size\t= cpu_to_be64(super->s_size);\n\tds->ds_segment_size\t= cpu_to_be32(super->s_segsize);\n\tds->ds_bad_seg_reserve\t= cpu_to_be32(super->s_bad_seg_reserve);\n\tds->ds_feature_incompat\t= cpu_to_be64(super->s_feature_incompat);\n\tds->ds_feature_ro_compat= cpu_to_be64(super->s_feature_ro_compat);\n\tds->ds_feature_compat\t= cpu_to_be64(super->s_feature_compat);\n\tds->ds_feature_flags\t= cpu_to_be64(super->s_feature_flags);\n\tds->ds_root_reserve\t= cpu_to_be64(super->s_root_reserve);\n\tds->ds_speed_reserve\t= cpu_to_be64(super->s_speed_reserve);\n\tjournal_for_each(i)\n\t\tds->ds_journal_seg[i] = cpu_to_be32(super->s_journal_seg[i]);\n\tds->ds_magic\t\t= cpu_to_be64(LOGFS_MAGIC);\n\tds->ds_crc = logfs_crc32(ds, sizeof(*ds),\n\t\t\tLOGFS_SEGMENT_HEADERSIZE + 12);\n}"
  },
  {
    "function_name": "set_segment_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "143-153",
    "snippet": "static void set_segment_header(struct logfs_segment_header *sh, u8 type,\n\t\tu8 level, u32 segno, u32 ec)\n{\n\tsh->pad = 0;\n\tsh->type = type;\n\tsh->level = level;\n\tsh->segno = cpu_to_be32(segno);\n\tsh->ec = cpu_to_be32(ec);\n\tsh->gec = cpu_to_be64(segno);\n\tsh->crc = logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "sh",
            "LOGFS_SEGMENT_HEADERSIZE",
            "4"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "segno"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ec"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "segno"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void set_segment_header(struct logfs_segment_header *sh, u8 type,\n\t\tu8 level, u32 segno, u32 ec)\n{\n\tsh->pad = 0;\n\tsh->type = type;\n\tsh->level = level;\n\tsh->segno = cpu_to_be32(segno);\n\tsh->ec = cpu_to_be32(ec);\n\tsh->gec = cpu_to_be64(segno);\n\tsh->crc = logfs_crc32(sh, LOGFS_SEGMENT_HEADERSIZE, 4);\n}"
  },
  {
    "function_name": "logfs_sb_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "131-141",
    "snippet": "static int logfs_sb_test(struct super_block *sb, void *_super)\n{\n\tstruct logfs_super *super = _super;\n\tstruct mtd_info *mtd = super->s_mtd;\n\n\tif (mtd && sb->s_mtd == mtd)\n\t\treturn 1;\n\tif (super->s_bdev && sb->s_bdev == super->s_bdev)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_sb_test(struct super_block *sb, void *_super)\n{\n\tstruct logfs_super *super = _super;\n\tstruct mtd_info *mtd = super->s_mtd;\n\n\tif (mtd && sb->s_mtd == mtd)\n\t\treturn 1;\n\tif (super->s_bdev && sb->s_bdev == super->s_bdev)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_sb_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "113-129",
    "snippet": "static int logfs_sb_set(struct super_block *sb, void *_super)\n{\n\tstruct logfs_super *super = _super;\n\n\tsb->s_fs_info = super;\n\tsb->s_mtd = super->s_mtd;\n\tsb->s_bdev = super->s_bdev;\n#ifdef CONFIG_BLOCK\n\tif (sb->s_bdev)\n\t\tsb->s_bdi = &bdev_get_queue(sb->s_bdev)->backing_dev_info;\n#endif\n#ifdef CONFIG_MTD\n\tif (sb->s_mtd)\n\t\tsb->s_bdi = sb->s_mtd->backing_dev_info;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sb->s_bdev"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int logfs_sb_set(struct super_block *sb, void *_super)\n{\n\tstruct logfs_super *super = _super;\n\n\tsb->s_fs_info = super;\n\tsb->s_mtd = super->s_mtd;\n\tsb->s_bdev = super->s_bdev;\n#ifdef CONFIG_BLOCK\n\tif (sb->s_bdev)\n\t\tsb->s_bdi = &bdev_get_queue(sb->s_bdev)->backing_dev_info;\n#endif\n#ifdef CONFIG_MTD\n\tif (sb->s_mtd)\n\t\tsb->s_bdi = sb->s_mtd->backing_dev_info;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "97-111",
    "snippet": "int logfs_statfs(struct dentry *dentry, struct kstatfs *stats)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tstats->f_type\t\t= LOGFS_MAGIC_U32;\n\tstats->f_bsize\t\t= sb->s_blocksize;\n\tstats->f_blocks\t\t= super->s_size >> LOGFS_BLOCK_BITS >> 3;\n\tstats->f_bfree\t\t= super->s_free_bytes >> sb->s_blocksize_bits;\n\tstats->f_bavail\t\t= super->s_free_bytes >> sb->s_blocksize_bits;\n\tstats->f_files\t\t= 0;\n\tstats->f_ffree\t\t= 0;\n\tstats->f_namelen\t= LOGFS_MAX_NAMELEN;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nint logfs_statfs(struct dentry *dentry, struct kstatfs *stats)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tstats->f_type\t\t= LOGFS_MAGIC_U32;\n\tstats->f_bsize\t\t= sb->s_blocksize;\n\tstats->f_blocks\t\t= super->s_size >> LOGFS_BLOCK_BITS >> 3;\n\tstats->f_bfree\t\t= super->s_free_bytes >> sb->s_blocksize_bits;\n\tstats->f_bavail\t\t= super->s_free_bytes >> sb->s_blocksize_bits;\n\tstats->f_files\t\t= 0;\n\tstats->f_ffree\t\t= 0;\n\tstats->f_namelen\t= LOGFS_MAX_NAMELEN;\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_crash_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "89-92",
    "snippet": "void logfs_crash_dump(struct super_block *sb)\n{\n\tdump_segfile(sb);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_segfile",
          "args": [
            "sb"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "dump_segfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "54-81",
          "snippet": "static void dump_segfile(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_entry se;\n\tu32 segno;\n\n\tfor (segno = 0; segno < super->s_no_segs; segno++) {\n\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\tprintk(\"%3x: %6x %8x\", segno, be32_to_cpu(se.ec_level),\n\t\t\t\tbe32_to_cpu(se.valid));\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void dump_segfile(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_entry se;\n\tu32 segno;\n\n\tfor (segno = 0; segno < super->s_no_segs; segno++) {\n\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\tprintk(\"%3x: %6x %8x\", segno, be32_to_cpu(se.ec_level),\n\t\t\t\tbe32_to_cpu(se.valid));\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nvoid logfs_crash_dump(struct super_block *sb)\n{\n\tdump_segfile(sb);\n}"
  },
  {
    "function_name": "dump_segfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "54-81",
    "snippet": "static void dump_segfile(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_entry se;\n\tu32 segno;\n\n\tfor (segno = 0; segno < super->s_no_segs; segno++) {\n\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\tprintk(\"%3x: %6x %8x\", segno, be32_to_cpu(se.ec_level),\n\t\t\t\tbe32_to_cpu(se.valid));\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" %6x %8x\"",
            "be32_to_cpu(se.ec_level)",
            "be32_to_cpu(se.valid)"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.valid"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.ec_level"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_get_segment_entry",
          "args": [
            "sb",
            "segno",
            "&se"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_segment_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2068-2072",
          "snippet": "void logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_segment_entry(struct super_block *sb, u32 segno,\n\t\tstruct logfs_segment_entry *se)\n{\n\tlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.valid"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.ec_level"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.valid"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.ec_level"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.valid"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "se.ec_level"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void dump_segfile(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_segment_entry se;\n\tu32 segno;\n\n\tfor (segno = 0; segno < super->s_no_segs; segno++) {\n\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\tprintk(\"%3x: %6x %8x\", segno, be32_to_cpu(se.ec_level),\n\t\t\t\tbe32_to_cpu(se.valid));\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tif (++segno < super->s_no_segs) {\n\t\t\tlogfs_get_segment_entry(sb, segno, &se);\n\t\t\tprintk(\" %6x %8x\", be32_to_cpu(se.ec_level),\n\t\t\t\t\tbe32_to_cpu(se.valid));\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "emergency_read_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "46-52",
    "snippet": "void emergency_read_end(struct page *page)\n{\n\tif (page == emergency_page)\n\t\tmutex_unlock(&emergency_mutex);\n\telse\n\t\tpage_cache_release(page);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(emergency_mutex);",
      "static struct page *emergency_page;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&emergency_mutex"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic DEFINE_MUTEX(emergency_mutex);\nstatic struct page *emergency_page;\n\nvoid emergency_read_end(struct page *page)\n{\n\tif (page == emergency_page)\n\t\tmutex_unlock(&emergency_mutex);\n\telse\n\t\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "emergency_read_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
    "lines": "24-44",
    "snippet": "struct page *emergency_read_begin(struct address_space *mapping, pgoff_t index)\n{\n\tfiller_t *filler = (filler_t *)mapping->a_ops->readpage;\n\tstruct page *page;\n\tint err;\n\n\tpage = read_cache_page(mapping, index, filler, NULL);\n\tif (page)\n\t\treturn page;\n\n\t/* No more pages available, switch to emergency page */\n\tprintk(KERN_INFO\"Logfs: Using emergency page\\n\");\n\tmutex_lock(&emergency_mutex);\n\terr = filler(NULL, emergency_page);\n\tif (err) {\n\t\tmutex_unlock(&emergency_mutex);\n\t\tprintk(KERN_EMERG\"Logfs: Error reading emergency page\\n\");\n\t\treturn ERR_PTR(err);\n\t}\n\treturn emergency_page;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include <linux/statfs.h>",
      "#include <linux/mtd/mtd.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(emergency_mutex);",
      "static struct page *emergency_page;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG\"Logfs: Error reading emergency page\\n\""
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&emergency_mutex"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filler",
          "args": [
            "NULL",
            "emergency_page"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "afs_page_filler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
          "lines": "127-211",
          "snippet": "int afs_page_filler(void *data, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key = data;\n\tsize_t len;\n\toff_t offset;\n\tint ret;\n\n\t_enter(\"{%x},{%lu},{%lu}\", key_serial(key), inode->i_ino, page->index);\n\n\tBUG_ON(!PageLocked(page));\n\n\tret = -ESTALE;\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto error;\n\n\t/* is it cached? */\n#ifdef CONFIG_AFS_FSCACHE\n\tret = fscache_read_or_alloc_page(vnode->cache,\n\t\t\t\t\t page,\n\t\t\t\t\t afs_file_readpage_read_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n#else\n\tret = -ENOBUFS;\n#endif\n\tswitch (ret) {\n\t\t/* read BIO submitted (page in cache) */\n\tcase 0:\n\t\tbreak;\n\n\t\t/* page not yet cached */\n\tcase -ENODATA:\n\t\t_debug(\"cache said ENODATA\");\n\t\tgoto go_on;\n\n\t\t/* page will not be cached */\n\tcase -ENOBUFS:\n\t\t_debug(\"cache said ENOBUFS\");\n\tdefault:\n\tgo_on:\n\t\toffset = page->index << PAGE_CACHE_SHIFT;\n\t\tlen = min_t(size_t, i_size_read(inode) - offset, PAGE_SIZE);\n\n\t\t/* read the contents of the file from the server into the\n\t\t * page */\n\t\tret = afs_vnode_fetch_data(vnode, key, offset, len, page);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\t_debug(\"got NOENT from server\"\n\t\t\t\t       \" - marking file deleted and stale\");\n\t\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t\tret = -ESTALE;\n\t\t\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\t\t\tfscache_uncache_page(vnode->cache, page);\n#endif\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t\tgoto error;\n\t\t}\n\n\t\tSetPageUptodate(page);\n\n\t\t/* send the page to the cache */\n#ifdef CONFIG_AFS_FSCACHE\n\t\tif (PageFsCache(page) &&\n\t\t    fscache_write_page(vnode->cache, page, GFP_KERNEL) != 0) {\n\t\t\tfscache_uncache_page(vnode->cache, page);\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t}\n#endif\n\t\tunlock_page(page);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_readpage(struct file *file, struct page *page);",
            "static int afs_launder_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpage(struct file *file, struct page *page);\nstatic int afs_launder_page(struct page *page);\n\nint afs_page_filler(void *data, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key = data;\n\tsize_t len;\n\toff_t offset;\n\tint ret;\n\n\t_enter(\"{%x},{%lu},{%lu}\", key_serial(key), inode->i_ino, page->index);\n\n\tBUG_ON(!PageLocked(page));\n\n\tret = -ESTALE;\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto error;\n\n\t/* is it cached? */\n#ifdef CONFIG_AFS_FSCACHE\n\tret = fscache_read_or_alloc_page(vnode->cache,\n\t\t\t\t\t page,\n\t\t\t\t\t afs_file_readpage_read_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n#else\n\tret = -ENOBUFS;\n#endif\n\tswitch (ret) {\n\t\t/* read BIO submitted (page in cache) */\n\tcase 0:\n\t\tbreak;\n\n\t\t/* page not yet cached */\n\tcase -ENODATA:\n\t\t_debug(\"cache said ENODATA\");\n\t\tgoto go_on;\n\n\t\t/* page will not be cached */\n\tcase -ENOBUFS:\n\t\t_debug(\"cache said ENOBUFS\");\n\tdefault:\n\tgo_on:\n\t\toffset = page->index << PAGE_CACHE_SHIFT;\n\t\tlen = min_t(size_t, i_size_read(inode) - offset, PAGE_SIZE);\n\n\t\t/* read the contents of the file from the server into the\n\t\t * page */\n\t\tret = afs_vnode_fetch_data(vnode, key, offset, len, page);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\t_debug(\"got NOENT from server\"\n\t\t\t\t       \" - marking file deleted and stale\");\n\t\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t\tret = -ESTALE;\n\t\t\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\t\t\tfscache_uncache_page(vnode->cache, page);\n#endif\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t\tgoto error;\n\t\t}\n\n\t\tSetPageUptodate(page);\n\n\t\t/* send the page to the cache */\n#ifdef CONFIG_AFS_FSCACHE\n\t\tif (PageFsCache(page) &&\n\t\t    fscache_write_page(vnode->cache, page, GFP_KERNEL) != 0) {\n\t\t\tfscache_uncache_page(vnode->cache, page);\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t}\n#endif\n\t\tunlock_page(page);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&emergency_mutex"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "mapping",
            "index",
            "filler",
            "NULL"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic DEFINE_MUTEX(emergency_mutex);\nstatic struct page *emergency_page;\n\nstruct page *emergency_read_begin(struct address_space *mapping, pgoff_t index)\n{\n\tfiller_t *filler = (filler_t *)mapping->a_ops->readpage;\n\tstruct page *page;\n\tint err;\n\n\tpage = read_cache_page(mapping, index, filler, NULL);\n\tif (page)\n\t\treturn page;\n\n\t/* No more pages available, switch to emergency page */\n\tprintk(KERN_INFO\"Logfs: Using emergency page\\n\");\n\tmutex_lock(&emergency_mutex);\n\terr = filler(NULL, emergency_page);\n\tif (err) {\n\t\tmutex_unlock(&emergency_mutex);\n\t\tprintk(KERN_EMERG\"Logfs: Error reading emergency page\\n\");\n\t\treturn ERR_PTR(err);\n\t}\n\treturn emergency_page;\n}"
  }
]