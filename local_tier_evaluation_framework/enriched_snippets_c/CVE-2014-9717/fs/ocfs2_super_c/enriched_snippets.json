[
  {
    "function_name": "ocfs2_unblock_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2632-2636",
    "snippet": "void ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rc"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "oldset",
            "NULL"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_unblock_signals(sigset_t *oldset)\n{\n\tint rc = sigprocmask(SIG_SETMASK, oldset, NULL);\n\tBUG_ON(rc);\n}"
  },
  {
    "function_name": "ocfs2_block_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2622-2630",
    "snippet": "void ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rc"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&blocked",
            "oldset"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&blocked"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid ocfs2_block_signals(sigset_t *oldset)\n{\n\tint rc;\n\tsigset_t blocked;\n\n\tsigfillset(&blocked);\n\trc = sigprocmask(SIG_BLOCK, &blocked, oldset);\n\tBUG_ON(rc);\n}"
  },
  {
    "function_name": "__ocfs2_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2589-2616",
    "snippet": "void __ocfs2_abort(struct super_block* sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"OCFS2: abort (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\t/* We don't have the cluster support yet to go straight to\n\t * hard readonly in here. Until then, we want to keep\n\t * ocfs2_abort() so that we can at least mark critical\n\t * errors.\n\t *\n\t * TODO: This should abort the journal and alert other nodes\n\t * that our slot needs recovery. */\n\n\t/* Force a panic(). This stinks, but it's better than letting\n\t * things continue without having a proper hard readonly\n\t * here. */\n\tif (!ocfs2_mount_local(OCFS2_SB(sb)))\n\t\tOCFS2_SB(sb)->s_mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\tocfs2_handle_error(sb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static char error_buf[1024];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_handle_error",
          "args": [
            "sb"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "OCFS2_SB(sb)"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"OCFS2: abort (device %s): %s: %s\\n\"",
            "sb->s_id",
            "function",
            "error_buf"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "error_buf",
            "sizeof(error_buf)",
            "fmt",
            "args"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_abort(struct super_block* sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"OCFS2: abort (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\t/* We don't have the cluster support yet to go straight to\n\t * hard readonly in here. Until then, we want to keep\n\t * ocfs2_abort() so that we can at least mark critical\n\t * errors.\n\t *\n\t * TODO: This should abort the journal and alert other nodes\n\t * that our slot needs recovery. */\n\n\t/* Force a panic(). This stinks, but it's better than letting\n\t * things continue without having a proper hard readonly\n\t * here. */\n\tif (!ocfs2_mount_local(OCFS2_SB(sb)))\n\t\tOCFS2_SB(sb)->s_mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\tocfs2_handle_error(sb);\n}"
  },
  {
    "function_name": "__ocfs2_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2568-2584",
    "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static char error_buf[1024];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_handle_error",
          "args": [
            "sb"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\"",
            "sb->s_id",
            "function",
            "error_buf"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "error_buf",
            "sizeof(error_buf)",
            "fmt",
            "args"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
  },
  {
    "function_name": "ocfs2_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2544-2564",
    "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_set_ro_flag",
          "args": [
            "osb",
            "0"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_ro_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "603-613",
          "snippet": "static inline void ocfs2_set_ro_flag(struct ocfs2_super *osb,\n\t\t\t\t     int hard)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_flags &= ~(OCFS2_OSB_SOFT_RO|OCFS2_OSB_HARD_RO);\n\tif (hard)\n\t\tosb->osb_flags |= OCFS2_OSB_HARD_RO;\n\telse\n\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002",
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline void ocfs2_set_ro_flag(struct ocfs2_super *osb,\n\t\t\t\t     int hard)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_flags &= ~(OCFS2_OSB_SOFT_RO|OCFS2_OSB_HARD_RO);\n\tif (hard)\n\t\tosb->osb_flags |= OCFS2_OSB_HARD_RO;\n\telse\n\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\""
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_soft_readonly",
          "args": [
            "osb"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_soft_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "626-635",
          "snippet": "static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_osb_flag",
          "args": [
            "osb",
            "OCFS2_OSB_ERROR_FS"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_osb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "595-601",
          "snippet": "static inline void ocfs2_set_osb_flag(struct ocfs2_super *osb,\n\t\t\t\t      unsigned long flag)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_flags |= flag;\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_osb_flag(struct ocfs2_super *osb,\n\t\t\t\t      unsigned long flag)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_flags |= flag;\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"OCFS2: (device %s): panic forced after error\\n\"",
            "sb->s_id"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
  },
  {
    "function_name": "ocfs2_delete_osb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2521-2540",
    "snippet": "static void ocfs2_delete_osb(struct ocfs2_super *osb)\n{\n\t/* This function assumes that the caller has the main osb resource */\n\n\tocfs2_free_slot_info(osb);\n\n\tkfree(osb->osb_orphan_wipes);\n\tkfree(osb->slot_recovery_generations);\n\t/* FIXME\n\t * This belongs in journal shutdown, but because we have to\n\t * allocate osb->journal at the start of ocfs2_initialize_osb(),\n\t * we free it here.\n\t */\n\tkfree(osb->journal);\n\tkfree(osb->local_alloc_copy);\n\tkfree(osb->uuid_str);\n\tkfree(osb->vol_label);\n\tocfs2_put_dlm_debug(osb->osb_dlm_debug);\n\tmemset(osb, 0, sizeof(struct ocfs2_super));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "osb",
            "0",
            "sizeof(struct ocfs2_super)"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_put_dlm_debug",
          "args": [
            "osb->osb_dlm_debug"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_put_dlm_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2698-2702",
          "snippet": "void ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\n{\n\tif (dlm_debug)\n\t\tkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osb->vol_label"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osb->uuid_str"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osb->local_alloc_copy"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osb->journal"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osb->slot_recovery_generations"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osb->osb_orphan_wipes"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_slot_info",
          "args": [
            "osb"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "461-467",
          "snippet": "void ocfs2_free_slot_info(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tosb->slot_info = NULL;\n\t__ocfs2_free_slot_info(si);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_free_slot_info(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tosb->slot_info = NULL;\n\t__ocfs2_free_slot_info(si);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb)\n{\n\t/* This function assumes that the caller has the main osb resource */\n\n\tocfs2_free_slot_info(osb);\n\n\tkfree(osb->osb_orphan_wipes);\n\tkfree(osb->slot_recovery_generations);\n\t/* FIXME\n\t * This belongs in journal shutdown, but because we have to\n\t * allocate osb->journal at the start of ocfs2_initialize_osb(),\n\t * we free it here.\n\t */\n\tkfree(osb->journal);\n\tkfree(osb->local_alloc_copy);\n\tkfree(osb->uuid_str);\n\tkfree(osb->vol_label);\n\tocfs2_put_dlm_debug(osb->osb_dlm_debug);\n\tmemset(osb, 0, sizeof(struct ocfs2_super));\n}"
  },
  {
    "function_name": "ocfs2_check_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2413-2513",
    "snippet": "static int ocfs2_check_volume(struct ocfs2_super *osb)\n{\n\tint status;\n\tint dirty;\n\tint local;\n\tstruct ocfs2_dinode *local_alloc = NULL; /* only used if we\n\t\t\t\t\t\t  * recover\n\t\t\t\t\t\t  * ourselves. */\n\n\t/* Init our journal object. */\n\tstatus = ocfs2_journal_init(osb->journal, &dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Could not initialize journal!\\n\");\n\t\tgoto finally;\n\t}\n\n\t/* Now that journal has been initialized, check to make sure\n\t   entire volume is addressable. */\n\tstatus = ocfs2_journal_addressable(osb);\n\tif (status)\n\t\tgoto finally;\n\n\t/* If the journal was unmounted cleanly then we don't want to\n\t * recover anything. Otherwise, journal_load will do that\n\t * dirty work for us :) */\n\tif (!dirty) {\n\t\tstatus = ocfs2_journal_wipe(osb->journal, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t} else {\n\t\tprintk(KERN_NOTICE \"ocfs2: File system on device (%s) was not \"\n\t\t       \"unmounted cleanly, recovering it.\\n\", osb->dev_str);\n\t}\n\n\tlocal = ocfs2_mount_local(osb);\n\n\t/* will play back anything left in the journal. */\n\tstatus = ocfs2_journal_load(osb->journal, local, dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"ocfs2 journal load failed! %d\\n\", status);\n\t\tgoto finally;\n\t}\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT)\n\t\tjbd2_journal_set_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\telse\n\t\tjbd2_journal_clear_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\n\tif (dirty) {\n\t\t/* recover my local alloc if we didn't unmount cleanly. */\n\t\tstatus = ocfs2_begin_local_alloc_recovery(osb,\n\t\t\t\t\t\t\t  osb->slot_num,\n\t\t\t\t\t\t\t  &local_alloc);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t\t/* we complete the recovery process after we've marked\n\t\t * ourselves as mounted. */\n\t}\n\n\tstatus = ocfs2_load_local_alloc(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tif (dirty) {\n\t\t/* Recovery will be completed after we've mounted the\n\t\t * rest of the volume. */\n\t\tosb->dirty = 1;\n\t\tosb->local_alloc_copy = local_alloc;\n\t\tlocal_alloc = NULL;\n\t}\n\n\t/* go through each journal, trylock it and if you get the\n\t * lock, and it's marked as dirty, set the bit in the recover\n\t * map and launch a recovery thread for it. */\n\tstatus = ocfs2_mark_dead_nodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tstatus = ocfs2_compute_replay_slots(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nfinally:\n\tkfree(local_alloc);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "local_alloc"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_compute_replay_slots",
          "args": [
            "osb"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_compute_replay_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "123-154",
          "snippet": "int ocfs2_compute_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map;\n\tint i, node_num;\n\n\t/* If replay map is already set, we don't do it again */\n\tif (osb->replay_map)\n\t\treturn 0;\n\n\treplay_map = kzalloc(sizeof(struct ocfs2_replay_map) +\n\t\t\t     (osb->max_slots * sizeof(char)), GFP_KERNEL);\n\n\tif (!replay_map) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&osb->osb_lock);\n\n\treplay_map->rm_slots = osb->max_slots;\n\treplay_map->rm_state = REPLAY_UNNEEDED;\n\n\t/* set rm_replay_slots for offline slot(s) */\n\tfor (i = 0; i < replay_map->rm_slots; i++) {\n\t\tif (ocfs2_slot_to_node_num_locked(osb, i, &node_num) == -ENOENT)\n\t\t\treplay_map->rm_replay_slots[i] = 1;\n\t}\n\n\tosb->replay_map = replay_map;\n\tspin_unlock(&osb->osb_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_compute_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map;\n\tint i, node_num;\n\n\t/* If replay map is already set, we don't do it again */\n\tif (osb->replay_map)\n\t\treturn 0;\n\n\treplay_map = kzalloc(sizeof(struct ocfs2_replay_map) +\n\t\t\t     (osb->max_slots * sizeof(char)), GFP_KERNEL);\n\n\tif (!replay_map) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&osb->osb_lock);\n\n\treplay_map->rm_slots = osb->max_slots;\n\treplay_map->rm_state = REPLAY_UNNEEDED;\n\n\t/* set rm_replay_slots for offline slot(s) */\n\tfor (i = 0; i < replay_map->rm_slots; i++) {\n\t\tif (ocfs2_slot_to_node_num_locked(osb, i, &node_num) == -ENOENT)\n\t\t\treplay_map->rm_replay_slots[i] = 1;\n\t}\n\n\tosb->replay_map = replay_map;\n\tspin_unlock(&osb->osb_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_dead_nodes",
          "args": [
            "osb"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_dead_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1780-1844",
          "snippet": "int ocfs2_mark_dead_nodes(struct ocfs2_super *osb)\n{\n\tunsigned int node_num;\n\tint status, i;\n\tu32 gen;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\t/* This is called with the super block cluster lock, so we\n\t * know that the slot map can't change underneath us. */\n\n\tfor (i = 0; i < osb->max_slots; i++) {\n\t\t/* Read journal inode to get the recovery generation */\n\t\tstatus = ocfs2_read_journal_inode(osb, i, &bh, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *)bh->b_data;\n\t\tgen = ocfs2_get_recovery_generation(di);\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->slot_recovery_generations[i] = gen;\n\n\t\ttrace_ocfs2_mark_dead_nodes(i,\n\t\t\t\t\t    osb->slot_recovery_generations[i]);\n\n\t\tif (i == osb->slot_num) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = ocfs2_slot_to_node_num_locked(osb, i, &node_num);\n\t\tif (status == -ENOENT) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&osb->osb_lock);\n\n\t\t/* Ok, we have a slot occupied by another node which\n\t\t * is not in the recovery map. We trylock his journal\n\t\t * file here to test if he's alive. */\n\t\tstatus = ocfs2_trylock_journal(osb, i);\n\t\tif (!status) {\n\t\t\t/* Since we're called from mount, we know that\n\t\t\t * the recovery thread can't race us on\n\t\t\t * setting / checking the recovery bits. */\n\t\t\tocfs2_recovery_thread(osb, node_num);\n\t\t} else if ((status < 0) && (status != -EAGAIN)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nint ocfs2_mark_dead_nodes(struct ocfs2_super *osb)\n{\n\tunsigned int node_num;\n\tint status, i;\n\tu32 gen;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\t/* This is called with the super block cluster lock, so we\n\t * know that the slot map can't change underneath us. */\n\n\tfor (i = 0; i < osb->max_slots; i++) {\n\t\t/* Read journal inode to get the recovery generation */\n\t\tstatus = ocfs2_read_journal_inode(osb, i, &bh, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *)bh->b_data;\n\t\tgen = ocfs2_get_recovery_generation(di);\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->slot_recovery_generations[i] = gen;\n\n\t\ttrace_ocfs2_mark_dead_nodes(i,\n\t\t\t\t\t    osb->slot_recovery_generations[i]);\n\n\t\tif (i == osb->slot_num) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = ocfs2_slot_to_node_num_locked(osb, i, &node_num);\n\t\tif (status == -ENOENT) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&osb->osb_lock);\n\n\t\t/* Ok, we have a slot occupied by another node which\n\t\t * is not in the recovery map. We trylock his journal\n\t\t * file here to test if he's alive. */\n\t\tstatus = ocfs2_trylock_journal(osb, i);\n\t\tif (!status) {\n\t\t\t/* Since we're called from mount, we know that\n\t\t\t * the recovery thread can't race us on\n\t\t\t * setting / checking the recovery bits. */\n\t\t\tocfs2_recovery_thread(osb, node_num);\n\t\t} else if ((status < 0) && (status != -EAGAIN)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_load_local_alloc",
          "args": [
            "osb"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_load_local_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "284-369",
          "snippet": "int ocfs2_load_local_alloc(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tu32 num_used;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\tif (osb->local_alloc_bits == 0)\n\t\tgoto bail;\n\n\tif (osb->local_alloc_bits >= osb->bitmap_cpg) {\n\t\tmlog(ML_NOTICE, \"Requested local alloc window %d is larger \"\n\t\t     \"than max possible %u. Using defaults.\\n\",\n\t\t     osb->local_alloc_bits, (osb->bitmap_cpg - 1));\n\t\tosb->local_alloc_bits =\n\t\t\tocfs2_megabytes_to_clusters(osb->sb,\n\t\t\t\t\t\t    ocfs2_la_default_mb(osb));\n\t}\n\n\t/* read the alloc off disk */\n\tinode = ocfs2_get_system_file_inode(osb, LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tif (!(le32_to_cpu(alloc->i_flags) &\n\t    (OCFS2_LOCAL_ALLOC_FL|OCFS2_BITMAP_FL))) {\n\t\tmlog(ML_ERROR, \"Invalid local alloc inode, %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif ((la->la_size == 0) ||\n\t    (le16_to_cpu(la->la_size) > ocfs2_local_alloc_size(inode->i_sb))) {\n\t\tmlog(ML_ERROR, \"Local alloc size is invalid (la_size = %u)\\n\",\n\t\t     le16_to_cpu(la->la_size));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t/* do a little verification. */\n\tnum_used = ocfs2_local_alloc_count_bits(alloc);\n\n\t/* hopefully the local alloc has always been recovered before\n\t * we load it. */\n\tif (num_used\n\t    || alloc->id1.bitmap1.i_used\n\t    || alloc->id1.bitmap1.i_total\n\t    || la->la_bm_off)\n\t\tmlog(ML_ERROR, \"Local alloc hasn't been recovered!\\n\"\n\t\t     \"found = %u, set = %u, taken = %u, off = %u\\n\",\n\t\t     num_used, le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bm_off);\n\n\tosb->local_alloc_bh = alloc_bh;\n\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\nbail:\n\tif (status < 0)\n\t\tbrelse(alloc_bh);\n\tif (inode)\n\t\tiput(inode);\n\n\ttrace_ocfs2_load_local_alloc(osb->local_alloc_bits);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nint ocfs2_load_local_alloc(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tu32 num_used;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\tif (osb->local_alloc_bits == 0)\n\t\tgoto bail;\n\n\tif (osb->local_alloc_bits >= osb->bitmap_cpg) {\n\t\tmlog(ML_NOTICE, \"Requested local alloc window %d is larger \"\n\t\t     \"than max possible %u. Using defaults.\\n\",\n\t\t     osb->local_alloc_bits, (osb->bitmap_cpg - 1));\n\t\tosb->local_alloc_bits =\n\t\t\tocfs2_megabytes_to_clusters(osb->sb,\n\t\t\t\t\t\t    ocfs2_la_default_mb(osb));\n\t}\n\n\t/* read the alloc off disk */\n\tinode = ocfs2_get_system_file_inode(osb, LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tif (!(le32_to_cpu(alloc->i_flags) &\n\t    (OCFS2_LOCAL_ALLOC_FL|OCFS2_BITMAP_FL))) {\n\t\tmlog(ML_ERROR, \"Invalid local alloc inode, %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif ((la->la_size == 0) ||\n\t    (le16_to_cpu(la->la_size) > ocfs2_local_alloc_size(inode->i_sb))) {\n\t\tmlog(ML_ERROR, \"Local alloc size is invalid (la_size = %u)\\n\",\n\t\t     le16_to_cpu(la->la_size));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t/* do a little verification. */\n\tnum_used = ocfs2_local_alloc_count_bits(alloc);\n\n\t/* hopefully the local alloc has always been recovered before\n\t * we load it. */\n\tif (num_used\n\t    || alloc->id1.bitmap1.i_used\n\t    || alloc->id1.bitmap1.i_total\n\t    || la->la_bm_off)\n\t\tmlog(ML_ERROR, \"Local alloc hasn't been recovered!\\n\"\n\t\t     \"found = %u, set = %u, taken = %u, off = %u\\n\",\n\t\t     num_used, le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bm_off);\n\n\tosb->local_alloc_bh = alloc_bh;\n\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\nbail:\n\tif (status < 0)\n\t\tbrelse(alloc_bh);\n\tif (inode)\n\t\tiput(inode);\n\n\ttrace_ocfs2_load_local_alloc(osb->local_alloc_bits);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_begin_local_alloc_recovery",
          "args": [
            "osb",
            "osb->slot_num",
            "&local_alloc"
          ],
          "line": 2469
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_begin_local_alloc_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "489-551",
          "snippet": "int ocfs2_begin_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t     int slot_num,\n\t\t\t\t     struct ocfs2_dinode **alloc_copy)\n{\n\tint status = 0;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *alloc;\n\n\ttrace_ocfs2_begin_local_alloc_recovery(slot_num);\n\n\t*alloc_copy = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*alloc_copy = kmalloc(alloc_bh->b_size, GFP_KERNEL);\n\tif (!(*alloc_copy)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tmemcpy((*alloc_copy), alloc_bh->b_data, alloc_bh->b_size);\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tocfs2_clear_local_alloc(alloc);\n\n\tocfs2_compute_meta_ecc(osb->sb, alloc_bh->b_data, &alloc->i_check);\n\tstatus = ocfs2_write_block(osb, alloc_bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status < 0) {\n\t\tkfree(*alloc_copy);\n\t\t*alloc_copy = NULL;\n\t}\n\n\tbrelse(alloc_bh);\n\n\tif (inode) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nint ocfs2_begin_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t     int slot_num,\n\t\t\t\t     struct ocfs2_dinode **alloc_copy)\n{\n\tint status = 0;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *alloc;\n\n\ttrace_ocfs2_begin_local_alloc_recovery(slot_num);\n\n\t*alloc_copy = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*alloc_copy = kmalloc(alloc_bh->b_size, GFP_KERNEL);\n\tif (!(*alloc_copy)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tmemcpy((*alloc_copy), alloc_bh->b_data, alloc_bh->b_size);\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tocfs2_clear_local_alloc(alloc);\n\n\tocfs2_compute_meta_ecc(osb->sb, alloc_bh->b_data, &alloc->i_check);\n\tstatus = ocfs2_write_block(osb, alloc_bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status < 0) {\n\t\tkfree(*alloc_copy);\n\t\t*alloc_copy = NULL;\n\t}\n\n\tbrelse(alloc_bh);\n\n\tif (inode) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_clear_features",
          "args": [
            "osb->journal->j_journal",
            "JBD2_FEATURE_COMPAT_CHECKSUM",
            "0",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_clear_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1889-1902",
          "snippet": "void jbd2_journal_clear_features(journal_t *journal, unsigned long compat,\n\t\t\t\tunsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tjbd_debug(1, \"Clear features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    &= ~cpu_to_be32(compat);\n\tsb->s_feature_ro_compat &= ~cpu_to_be32(ro);\n\tsb->s_feature_incompat  &= ~cpu_to_be32(incompat);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_clear_features(journal_t *journal, unsigned long compat,\n\t\t\t\tunsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tjbd_debug(1, \"Clear features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    &= ~cpu_to_be32(compat);\n\tsb->s_feature_ro_compat &= ~cpu_to_be32(ro);\n\tsb->s_feature_incompat  &= ~cpu_to_be32(incompat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_set_features",
          "args": [
            "osb->journal->j_journal",
            "JBD2_FEATURE_COMPAT_CHECKSUM",
            "0",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_set_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1808-1876",
          "snippet": "int jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"ocfs2 journal load failed! %d\\n\"",
            "status"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_load",
          "args": [
            "osb->journal",
            "local",
            "dirty"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1040-1079",
          "snippet": "int ocfs2_journal_load(struct ocfs2_journal *journal, int local, int replayed)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\tstatus = jbd2_journal_load(journal->j_journal);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Failed to load journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal->j_journal, osb->slot_num);\n\n\tstatus = ocfs2_journal_toggle_dirty(osb, 1, replayed);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* Launch the commit thread */\n\tif (!local) {\n\t\tosb->commit_task = kthread_run(ocfs2_commit_thread, osb,\n\t\t\t\t\t       \"ocfs2cmt\");\n\t\tif (IS_ERR(osb->commit_task)) {\n\t\t\tstatus = PTR_ERR(osb->commit_task);\n\t\t\tosb->commit_task = NULL;\n\t\t\tmlog(ML_ERROR, \"unable to launch ocfs2commit thread, \"\n\t\t\t     \"error=%d\", status);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tosb->commit_task = NULL;\n\ndone:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nint ocfs2_journal_load(struct ocfs2_journal *journal, int local, int replayed)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\tstatus = jbd2_journal_load(journal->j_journal);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Failed to load journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal->j_journal, osb->slot_num);\n\n\tstatus = ocfs2_journal_toggle_dirty(osb, 1, replayed);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* Launch the commit thread */\n\tif (!local) {\n\t\tosb->commit_task = kthread_run(ocfs2_commit_thread, osb,\n\t\t\t\t\t       \"ocfs2cmt\");\n\t\tif (IS_ERR(osb->commit_task)) {\n\t\t\tstatus = PTR_ERR(osb->commit_task);\n\t\t\tosb->commit_task = NULL;\n\t\t\tmlog(ML_ERROR, \"unable to launch ocfs2commit thread, \"\n\t\t\t     \"error=%d\", status);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tosb->commit_task = NULL;\n\ndone:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"ocfs2: File system on device (%s) was not \"\n\t\t       \"unmounted cleanly, recovering it.\\n\"",
            "osb->dev_str"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_wipe",
          "args": [
            "osb->journal",
            "0"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_wipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1084-1102",
          "snippet": "int ocfs2_journal_wipe(struct ocfs2_journal *journal, int full)\n{\n\tint status;\n\n\tBUG_ON(!journal);\n\n\tstatus = jbd2_journal_wipe(journal->j_journal, full);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(journal->j_osb, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_wipe(struct ocfs2_journal *journal, int full)\n{\n\tint status;\n\n\tBUG_ON(!journal);\n\n\tstatus = jbd2_journal_wipe(journal->j_journal, full);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(journal->j_osb, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_addressable",
          "args": [
            "osb"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_addressable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2011-2036",
          "snippet": "static int ocfs2_journal_addressable(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tu64 max_block =\n\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t osb->osb_clusters_at_boot) - 1;\n\n\t/* 32-bit block number is always OK. */\n\tif (max_block <= (u32)~0ULL)\n\t\tgoto out;\n\n\t/* Volume is \"huge\", so see if our journal is new enough to\n\t   support it. */\n\tif (!(OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t       OCFS2_FEATURE_COMPAT_JBD2_SB) &&\n\t      jbd2_journal_check_used_features(osb->journal->j_journal, 0, 0,\n\t\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT))) {\n\t\tmlog(ML_ERROR, \"The journal cannot address the entire volume. \"\n\t\t     \"Enable the 'block64' journal option with tunefs.ocfs2\");\n\t\tstatus = -EFBIG;\n\t\tgoto out;\n\t}\n\n out:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_journal_addressable(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tu64 max_block =\n\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t osb->osb_clusters_at_boot) - 1;\n\n\t/* 32-bit block number is always OK. */\n\tif (max_block <= (u32)~0ULL)\n\t\tgoto out;\n\n\t/* Volume is \"huge\", so see if our journal is new enough to\n\t   support it. */\n\tif (!(OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t       OCFS2_FEATURE_COMPAT_JBD2_SB) &&\n\t      jbd2_journal_check_used_features(osb->journal->j_journal, 0, 0,\n\t\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT))) {\n\t\tmlog(ML_ERROR, \"The journal cannot address the entire volume. \"\n\t\t     \"Enable the 'block64' journal option with tunefs.ocfs2\");\n\t\tstatus = -EFBIG;\n\t\tgoto out;\n\t}\n\n out:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Could not initialize journal!\\n\""
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_init",
          "args": [
            "osb->journal",
            "&dirty"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "800-891",
          "snippet": "int ocfs2_journal_init(struct ocfs2_journal *journal, int *dirty)\n{\n\tint status = -1;\n\tstruct inode *inode = NULL; /* the journal inode */\n\tjournal_t *j_journal = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_super *osb;\n\tint inode_lock = 0;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\t/* already have the inode for our journal */\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (inode == NULL) {\n\t\tstatus = -EACCES;\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto done;\n\t}\n\n\tSET_INODE_JOURNAL(inode);\n\tOCFS2_I(inode)->ip_open_count++;\n\n\t/* Skip recovery waits here - journal inode metadata never\n\t * changes in a live cluster so it can be considered an\n\t * exception to the rule. */\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not get lock on journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tinode_lock = 1;\n\tdi = (struct ocfs2_dinode *)bh->b_data;\n\n\tif (i_size_read(inode) <  OCFS2_MIN_JOURNAL_SIZE) {\n\t\tmlog(ML_ERROR, \"Journal file size (%lld) is too small!\\n\",\n\t\t     i_size_read(inode));\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init(i_size_read(inode),\n\t\t\t\t (unsigned long long)inode->i_blocks,\n\t\t\t\t OCFS2_I(inode)->ip_clusters);\n\n\t/* call the kernels journal init function now */\n\tj_journal = jbd2_journal_init_inode(inode);\n\tif (j_journal == NULL) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init_maxlen(j_journal->j_maxlen);\n\n\t*dirty = (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t  OCFS2_JOURNAL_DIRTY_FL);\n\n\tjournal->j_journal = j_journal;\n\tjournal->j_inode = inode;\n\tjournal->j_bh = bh;\n\n\tocfs2_set_journal_params(osb);\n\n\tjournal->j_state = OCFS2_JOURNAL_LOADED;\n\n\tstatus = 0;\ndone:\n\tif (status < 0) {\n\t\tif (inode_lock)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\tbrelse(bh);\n\t\tif (inode) {\n\t\t\tOCFS2_I(inode)->ip_open_count--;\n\t\t\tiput(inode);\n\t\t}\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nint ocfs2_journal_init(struct ocfs2_journal *journal, int *dirty)\n{\n\tint status = -1;\n\tstruct inode *inode = NULL; /* the journal inode */\n\tjournal_t *j_journal = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_super *osb;\n\tint inode_lock = 0;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\t/* already have the inode for our journal */\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (inode == NULL) {\n\t\tstatus = -EACCES;\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto done;\n\t}\n\n\tSET_INODE_JOURNAL(inode);\n\tOCFS2_I(inode)->ip_open_count++;\n\n\t/* Skip recovery waits here - journal inode metadata never\n\t * changes in a live cluster so it can be considered an\n\t * exception to the rule. */\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not get lock on journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tinode_lock = 1;\n\tdi = (struct ocfs2_dinode *)bh->b_data;\n\n\tif (i_size_read(inode) <  OCFS2_MIN_JOURNAL_SIZE) {\n\t\tmlog(ML_ERROR, \"Journal file size (%lld) is too small!\\n\",\n\t\t     i_size_read(inode));\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init(i_size_read(inode),\n\t\t\t\t (unsigned long long)inode->i_blocks,\n\t\t\t\t OCFS2_I(inode)->ip_clusters);\n\n\t/* call the kernels journal init function now */\n\tj_journal = jbd2_journal_init_inode(inode);\n\tif (j_journal == NULL) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init_maxlen(j_journal->j_maxlen);\n\n\t*dirty = (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t  OCFS2_JOURNAL_DIRTY_FL);\n\n\tjournal->j_journal = j_journal;\n\tjournal->j_inode = inode;\n\tjournal->j_bh = bh;\n\n\tocfs2_set_journal_params(osb);\n\n\tjournal->j_state = OCFS2_JOURNAL_LOADED;\n\n\tstatus = 0;\ndone:\n\tif (status < 0) {\n\t\tif (inode_lock)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\tbrelse(bh);\n\t\tif (inode) {\n\t\t\tOCFS2_I(inode)->ip_open_count--;\n\t\t\tiput(inode);\n\t\t}\n\t}\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_check_volume(struct ocfs2_super *osb)\n{\n\tint status;\n\tint dirty;\n\tint local;\n\tstruct ocfs2_dinode *local_alloc = NULL; /* only used if we\n\t\t\t\t\t\t  * recover\n\t\t\t\t\t\t  * ourselves. */\n\n\t/* Init our journal object. */\n\tstatus = ocfs2_journal_init(osb->journal, &dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Could not initialize journal!\\n\");\n\t\tgoto finally;\n\t}\n\n\t/* Now that journal has been initialized, check to make sure\n\t   entire volume is addressable. */\n\tstatus = ocfs2_journal_addressable(osb);\n\tif (status)\n\t\tgoto finally;\n\n\t/* If the journal was unmounted cleanly then we don't want to\n\t * recover anything. Otherwise, journal_load will do that\n\t * dirty work for us :) */\n\tif (!dirty) {\n\t\tstatus = ocfs2_journal_wipe(osb->journal, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t} else {\n\t\tprintk(KERN_NOTICE \"ocfs2: File system on device (%s) was not \"\n\t\t       \"unmounted cleanly, recovering it.\\n\", osb->dev_str);\n\t}\n\n\tlocal = ocfs2_mount_local(osb);\n\n\t/* will play back anything left in the journal. */\n\tstatus = ocfs2_journal_load(osb->journal, local, dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"ocfs2 journal load failed! %d\\n\", status);\n\t\tgoto finally;\n\t}\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT)\n\t\tjbd2_journal_set_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\telse\n\t\tjbd2_journal_clear_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\n\tif (dirty) {\n\t\t/* recover my local alloc if we didn't unmount cleanly. */\n\t\tstatus = ocfs2_begin_local_alloc_recovery(osb,\n\t\t\t\t\t\t\t  osb->slot_num,\n\t\t\t\t\t\t\t  &local_alloc);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t\t/* we complete the recovery process after we've marked\n\t\t * ourselves as mounted. */\n\t}\n\n\tstatus = ocfs2_load_local_alloc(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tif (dirty) {\n\t\t/* Recovery will be completed after we've mounted the\n\t\t * rest of the volume. */\n\t\tosb->dirty = 1;\n\t\tosb->local_alloc_copy = local_alloc;\n\t\tlocal_alloc = NULL;\n\t}\n\n\t/* go through each journal, trylock it and if you get the\n\t * lock, and it's marked as dirty, set the bit in the recover\n\t * map and launch a recovery thread for it. */\n\tstatus = ocfs2_mark_dead_nodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tstatus = ocfs2_compute_replay_slots(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nfinally:\n\tkfree(local_alloc);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_verify_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2347-2411",
    "snippet": "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 blksz,\n\t\t\t       struct ocfs2_blockcheck_stats *stats)\n{\n\tint status = -EAGAIN;\n\n\tif (memcmp(di->i_signature, OCFS2_SUPER_BLOCK_SIGNATURE,\n\t\t   strlen(OCFS2_SUPER_BLOCK_SIGNATURE)) == 0) {\n\t\t/* We have to do a raw check of the feature here */\n\t\tif (le32_to_cpu(di->id2.i_super.s_feature_incompat) &\n\t\t    OCFS2_FEATURE_INCOMPAT_META_ECC) {\n\t\t\tstatus = ocfs2_block_check_validate(bh->b_data,\n\t\t\t\t\t\t\t    bh->b_size,\n\t\t\t\t\t\t\t    &di->i_check,\n\t\t\t\t\t\t\t    stats);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tstatus = -EINVAL;\n\t\tif ((1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits)) != blksz) {\n\t\t\tmlog(ML_ERROR, \"found superblock with incorrect block \"\n\t\t\t     \"size: found %u, should be %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits),\n\t\t\t       blksz);\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_major_rev_level) !=\n\t\t\t   OCFS2_MAJOR_REV_LEVEL ||\n\t\t\t   le16_to_cpu(di->id2.i_super.s_minor_rev_level) !=\n\t\t\t   OCFS2_MINOR_REV_LEVEL) {\n\t\t\tmlog(ML_ERROR, \"found superblock with bad version: \"\n\t\t\t     \"found %u.%u, should be %u.%u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_major_rev_level),\n\t\t\t     le16_to_cpu(di->id2.i_super.s_minor_rev_level),\n\t\t\t     OCFS2_MAJOR_REV_LEVEL,\n\t\t\t     OCFS2_MINOR_REV_LEVEL);\n\t\t} else if (bh->b_blocknr != le64_to_cpu(di->i_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad block number on superblock: \"\n\t\t\t     \"found %llu, should be %llu\\n\",\n\t\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t} else if (le32_to_cpu(di->id2.i_super.s_clustersize_bits) < 12 ||\n\t\t\t    le32_to_cpu(di->id2.i_super.s_clustersize_bits) > 20) {\n\t\t\tmlog(ML_ERROR, \"bad cluster size found: %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_clustersize_bits));\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_root_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad root_blkno: 0\\n\");\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_system_dir_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad system_dir_blkno: 0\\n\");\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_max_slots) > OCFS2_MAX_SLOTS) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Superblock slots found greater than file system \"\n\t\t\t     \"maximum: found %u, max %u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_max_slots),\n\t\t\t     OCFS2_MAX_SLOTS);\n\t\t} else {\n\t\t\t/* found it! */\n\t\t\tstatus = 0;\n\t\t}\n\t}\n\nout:\n\tif (status && status != -EAGAIN)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
      "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Superblock slots found greater than file system \"\n\t\t\t     \"maximum: found %u, max %u\\n\"",
            "le16_to_cpu(di->id2.i_super.s_max_slots)",
            "OCFS2_MAX_SLOTS"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->id2.i_super.s_max_slots"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bad system_dir_blkno: 0\\n\""
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->id2.i_super.s_system_dir_blkno"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bad cluster size found: %u\\n\"",
            "1 << le32_to_cpu(di->id2.i_super.s_clustersize_bits)"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->id2.i_super.s_clustersize_bits"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"found superblock with bad version: \"\n\t\t\t     \"found %u.%u, should be %u.%u\\n\"",
            "le16_to_cpu(di->id2.i_super.s_major_rev_level)",
            "le16_to_cpu(di->id2.i_super.s_minor_rev_level)",
            "OCFS2_MAJOR_REV_LEVEL",
            "OCFS2_MINOR_REV_LEVEL"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_block_check_validate",
          "args": [
            "bh->b_data",
            "bh->b_size",
            "&di->i_check",
            "stats"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_check_validate_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "527-598",
          "snippet": "int ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t/*\n\t\t * Try the fix against each buffer.  It will only affect\n\t\t * one of them.\n\t\t */\n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t/* And check the crc32 again */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t/*\n\t\t * Try the fix against each buffer.  It will only affect\n\t\t * one of them.\n\t\t */\n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t/* And check the crc32 again */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "di->i_signature",
            "OCFS2_SUPER_BLOCK_SIGNATURE",
            "strlen(OCFS2_SUPER_BLOCK_SIGNATURE)"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "OCFS2_SUPER_BLOCK_SIGNATURE"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\n\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 blksz,\n\t\t\t       struct ocfs2_blockcheck_stats *stats)\n{\n\tint status = -EAGAIN;\n\n\tif (memcmp(di->i_signature, OCFS2_SUPER_BLOCK_SIGNATURE,\n\t\t   strlen(OCFS2_SUPER_BLOCK_SIGNATURE)) == 0) {\n\t\t/* We have to do a raw check of the feature here */\n\t\tif (le32_to_cpu(di->id2.i_super.s_feature_incompat) &\n\t\t    OCFS2_FEATURE_INCOMPAT_META_ECC) {\n\t\t\tstatus = ocfs2_block_check_validate(bh->b_data,\n\t\t\t\t\t\t\t    bh->b_size,\n\t\t\t\t\t\t\t    &di->i_check,\n\t\t\t\t\t\t\t    stats);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tstatus = -EINVAL;\n\t\tif ((1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits)) != blksz) {\n\t\t\tmlog(ML_ERROR, \"found superblock with incorrect block \"\n\t\t\t     \"size: found %u, should be %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits),\n\t\t\t       blksz);\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_major_rev_level) !=\n\t\t\t   OCFS2_MAJOR_REV_LEVEL ||\n\t\t\t   le16_to_cpu(di->id2.i_super.s_minor_rev_level) !=\n\t\t\t   OCFS2_MINOR_REV_LEVEL) {\n\t\t\tmlog(ML_ERROR, \"found superblock with bad version: \"\n\t\t\t     \"found %u.%u, should be %u.%u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_major_rev_level),\n\t\t\t     le16_to_cpu(di->id2.i_super.s_minor_rev_level),\n\t\t\t     OCFS2_MAJOR_REV_LEVEL,\n\t\t\t     OCFS2_MINOR_REV_LEVEL);\n\t\t} else if (bh->b_blocknr != le64_to_cpu(di->i_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad block number on superblock: \"\n\t\t\t     \"found %llu, should be %llu\\n\",\n\t\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t} else if (le32_to_cpu(di->id2.i_super.s_clustersize_bits) < 12 ||\n\t\t\t    le32_to_cpu(di->id2.i_super.s_clustersize_bits) > 20) {\n\t\t\tmlog(ML_ERROR, \"bad cluster size found: %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_clustersize_bits));\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_root_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad root_blkno: 0\\n\");\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_system_dir_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad system_dir_blkno: 0\\n\");\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_max_slots) > OCFS2_MAX_SLOTS) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Superblock slots found greater than file system \"\n\t\t\t     \"maximum: found %u, max %u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_max_slots),\n\t\t\t     OCFS2_MAX_SLOTS);\n\t\t} else {\n\t\t\t/* found it! */\n\t\t\tstatus = 0;\n\t\t}\n\t}\n\nout:\n\tif (status && status != -EAGAIN)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_initialize_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2038-2340",
    "snippet": "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status;\n\tint i, cbits, bbits;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_journal *journal;\n\tstruct ocfs2_super *osb;\n\tu64 total_blocks;\n\n\tosb = kzalloc(sizeof(struct ocfs2_super), GFP_KERNEL);\n\tif (!osb) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsb->s_fs_info = osb;\n\tsb->s_op = &ocfs2_sops;\n\tsb->s_d_op = &ocfs2_dentry_ops;\n\tsb->s_export_op = &ocfs2_export_ops;\n\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\tsb->dq_op = &ocfs2_quota_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb->s_xattr = ocfs2_xattr_handlers;\n\tsb->s_time_gran = 1;\n\tsb->s_flags |= MS_NOATIME;\n\t/* this is needed to support O_LARGEFILE */\n\tcbits = le32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tbbits = le32_to_cpu(di->id2.i_super.s_blocksize_bits);\n\tsb->s_maxbytes = ocfs2_max_file_offset(bbits, cbits);\n\n\tosb->osb_dx_mask = (1 << (cbits - bbits)) - 1;\n\n\tfor (i = 0; i < 3; i++)\n\t\tosb->osb_dx_seed[i] = le32_to_cpu(di->id2.i_super.s_dx_seed[i]);\n\tosb->osb_dx_seed[3] = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\n\tosb->sb = sb;\n\t/* Save off for ocfs2_rw_direct */\n\tosb->s_sectsize_bits = blksize_bits(sector_size);\n\tBUG_ON(!osb->s_sectsize_bits);\n\n\tspin_lock_init(&osb->dc_task_lock);\n\tinit_waitqueue_head(&osb->dc_event);\n\tosb->dc_work_sequence = 0;\n\tosb->dc_wake_sequence = 0;\n\tINIT_LIST_HEAD(&osb->blocked_lock_list);\n\tosb->blocked_lock_count = 0;\n\tspin_lock_init(&osb->osb_lock);\n\tspin_lock_init(&osb->osb_xattr_lock);\n\tocfs2_init_steal_slots(osb);\n\n\tmutex_init(&osb->system_file_mutex);\n\n\tatomic_set(&osb->alloc_stats.moves, 0);\n\tatomic_set(&osb->alloc_stats.local_data, 0);\n\tatomic_set(&osb->alloc_stats.bitmap_data, 0);\n\tatomic_set(&osb->alloc_stats.bg_allocs, 0);\n\tatomic_set(&osb->alloc_stats.bg_extends, 0);\n\n\t/* Copy the blockcheck stats from the superblock probe */\n\tosb->osb_ecc_stats = *stats;\n\n\tocfs2_init_node_maps(osb);\n\n\tsnprintf(osb->dev_str, sizeof(osb->dev_str), \"%u,%u\",\n\t\t MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\n\tosb->max_slots = le16_to_cpu(di->id2.i_super.s_max_slots);\n\tif (osb->max_slots > OCFS2_MAX_SLOTS || osb->max_slots == 0) {\n\t\tmlog(ML_ERROR, \"Invalid number of node slots (%u)\\n\",\n\t\t     osb->max_slots);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tocfs2_orphan_scan_init(osb);\n\n\tstatus = ocfs2_recovery_init(osb);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Unable to initialize recovery state\\n\");\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->checkpoint_event);\n\n\tosb->s_atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\n\tosb->s_xattr_inline_size = le16_to_cpu(\n\t\t\t\t\tdi->id2.i_super.s_xattr_inline_size);\n\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\tosb->local_alloc_bh = NULL;\n\tINIT_DELAYED_WORK(&osb->la_enable_wq, ocfs2_la_enable_worker);\n\n\tinit_waitqueue_head(&osb->osb_mount_event);\n\n\tstatus = ocfs2_resmap_init(osb, &osb->osb_la_resmap);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->vol_label = kmalloc(OCFS2_MAX_VOL_LABEL_LEN, GFP_KERNEL);\n\tif (!osb->vol_label) {\n\t\tmlog(ML_ERROR, \"unable to alloc vol label\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tosb->slot_recovery_generations =\n\t\tkcalloc(osb->max_slots, sizeof(*osb->slot_recovery_generations),\n\t\t\tGFP_KERNEL);\n\tif (!osb->slot_recovery_generations) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->osb_wipe_event);\n\tosb->osb_orphan_wipes = kcalloc(osb->max_slots,\n\t\t\t\t\tsizeof(*osb->osb_orphan_wipes),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!osb->osb_orphan_wipes) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->osb_rf_lock_tree = RB_ROOT;\n\n\tosb->s_feature_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_compat);\n\tosb->s_feature_ro_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_ro_compat);\n\tosb->s_feature_incompat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_incompat);\n\n\tif ((i = OCFS2_HAS_INCOMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_INCOMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount because of unsupported \"\n\t\t     \"optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (!(osb->sb->s_flags & MS_RDONLY) &&\n\t    (i = OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount RDWR because of \"\n\t\t     \"unsupported optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_clusterinfo_valid(osb)) {\n\t\tosb->osb_stackflags =\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_stackflags;\n\t\tstrlcpy(osb->osb_cluster_stack,\n\t\t       OCFS2_RAW_SB(di)->s_cluster_info.ci_stack,\n\t\t       OCFS2_STACK_LABEL_LEN + 1);\n\t\tif (strlen(osb->osb_cluster_stack) != OCFS2_STACK_LABEL_LEN) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"couldn't mount because of an invalid \"\n\t\t\t     \"cluster stack label (%s) \\n\",\n\t\t\t     osb->osb_cluster_stack);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\tstrlcpy(osb->osb_cluster_name,\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_cluster,\n\t\t\tOCFS2_CLUSTER_NAME_LEN + 1);\n\t} else {\n\t\t/* The empty string is identical with classic tools that\n\t\t * don't know about s_cluster_info. */\n\t\tosb->osb_cluster_stack[0] = '\\0';\n\t}\n\n\tget_random_bytes(&osb->s_next_generation, sizeof(u32));\n\n\t/* FIXME\n\t * This should be done in ocfs2_journal_init(), but unknown\n\t * ordering issues will cause the filesystem to crash.\n\t * If anyone wants to figure out what part of the code\n\t * refers to osb->journal before ocfs2_journal_init() is run,\n\t * be my guest.\n\t */\n\t/* initialize our journal structure */\n\n\tjournal = kzalloc(sizeof(struct ocfs2_journal), GFP_KERNEL);\n\tif (!journal) {\n\t\tmlog(ML_ERROR, \"unable to alloc journal\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tosb->journal = journal;\n\tjournal->j_osb = osb;\n\n\tatomic_set(&journal->j_num_trans, 0);\n\tinit_rwsem(&journal->j_trans_barrier);\n\tinit_waitqueue_head(&journal->j_checkpointed);\n\tspin_lock_init(&journal->j_lock);\n\tjournal->j_trans_id = (unsigned long) 1;\n\tINIT_LIST_HEAD(&journal->j_la_cleanups);\n\tINIT_WORK(&journal->j_recovery_work, ocfs2_complete_recovery);\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n\tINIT_WORK(&osb->dquot_drop_work, ocfs2_drop_dquot_refs);\n\tinit_llist_head(&osb->dquot_drop_list);\n\n\t/* get some pseudo constants for clustersize bits */\n\tosb->s_clustersize_bits =\n\t\tle32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tosb->s_clustersize = 1 << osb->s_clustersize_bits;\n\n\tif (osb->s_clustersize < OCFS2_MIN_CLUSTERSIZE ||\n\t    osb->s_clustersize > OCFS2_MAX_CLUSTERSIZE) {\n\t\tmlog(ML_ERROR, \"Volume has invalid cluster size (%d)\\n\",\n\t\t     osb->s_clustersize);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\ttotal_blocks = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(di->i_clusters));\n\n\tstatus = generic_check_addressable(osb->sb->s_blocksize_bits,\n\t\t\t\t\t   total_blocks);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Volume too large \"\n\t\t     \"to mount safely on this system\");\n\t\tstatus = -EFBIG;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_setup_osb_uuid(osb, di->id2.i_super.s_uuid,\n\t\t\t\t sizeof(di->id2.i_super.s_uuid))) {\n\t\tmlog(ML_ERROR, \"Out of memory trying to setup our uuid.\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tstrlcpy(osb->vol_label, di->id2.i_super.s_label,\n\t\tOCFS2_MAX_VOL_LABEL_LEN);\n\tosb->root_blkno = le64_to_cpu(di->id2.i_super.s_root_blkno);\n\tosb->system_dir_blkno = le64_to_cpu(di->id2.i_super.s_system_dir_blkno);\n\tosb->first_cluster_group_blkno =\n\t\tle64_to_cpu(di->id2.i_super.s_first_cluster_group);\n\tosb->fs_generation = le32_to_cpu(di->i_fs_generation);\n\tosb->uuid_hash = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\ttrace_ocfs2_initialize_super(osb->vol_label, osb->uuid_str,\n\t\t\t\t     (unsigned long long)osb->root_blkno,\n\t\t\t\t     (unsigned long long)osb->system_dir_blkno,\n\t\t\t\t     osb->s_clustersize_bits);\n\n\tosb->osb_dlm_debug = ocfs2_new_dlm_debug();\n\tif (!osb->osb_dlm_debug) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_set(&osb->vol_state, VOLUME_INIT);\n\n\t/* load root, system_dir, and all global system inodes */\n\tstatus = ocfs2_init_global_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * global bitmap\n\t */\n\tinode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->bitmap_blkno = OCFS2_I(inode)->ip_blkno;\n\tosb->osb_clusters_at_boot = OCFS2_I(inode)->ip_clusters;\n\tiput(inode);\n\n\tosb->bitmap_cpg = ocfs2_group_bitmap_size(sb, 0,\n\t\t\t\t osb->s_feature_incompat) * 8;\n\n\tstatus = ocfs2_init_slot_info(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tcleancache_init_shared_fs((char *)&di->id2.i_super.s_uuid, sb);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
      "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
      "static const struct super_operations ocfs2_sops = {\n\t.statfs\t\t= ocfs2_statfs,\n\t.alloc_inode\t= ocfs2_alloc_inode,\n\t.destroy_inode\t= ocfs2_destroy_inode,\n\t.drop_inode\t= ocfs2_drop_inode,\n\t.evict_inode\t= ocfs2_evict_inode,\n\t.sync_fs\t= ocfs2_sync_fs,\n\t.put_super\t= ocfs2_put_super,\n\t.remount_fs\t= ocfs2_remount,\n\t.show_options   = ocfs2_show_options,\n\t.quota_read\t= ocfs2_quota_read,\n\t.quota_write\t= ocfs2_quota_write,\n\t.get_dquots\t= ocfs2_get_dquots,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_init_shared_fs",
          "args": [
            "(char *)&di->id2.i_super.s_uuid",
            "sb"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_slot_info",
          "args": [
            "osb"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "418-459",
          "snippet": "int ocfs2_init_slot_info(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = kzalloc(sizeof(struct ocfs2_slot_info) +\n\t\t     (sizeof(struct ocfs2_slot) * osb->max_slots),\n\t\t     GFP_KERNEL);\n\tif (!si) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_extended = ocfs2_uses_extended_slot_map(osb);\n\tsi->si_num_slots = osb->max_slots;\n\tsi->si_slots = (struct ocfs2_slot *)((char *)si +\n\t\t\t\t\t     sizeof(struct ocfs2_slot_info));\n\n\tinode = ocfs2_get_system_file_inode(osb, SLOT_MAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_inode = inode;\n\tstatus = ocfs2_map_slot_buffers(osb, si);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->slot_info = (struct ocfs2_slot_info *)si;\nbail:\n\tif (status < 0 && si)\n\t\t__ocfs2_free_slot_info(si);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_init_slot_info(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = kzalloc(sizeof(struct ocfs2_slot_info) +\n\t\t     (sizeof(struct ocfs2_slot) * osb->max_slots),\n\t\t     GFP_KERNEL);\n\tif (!si) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_extended = ocfs2_uses_extended_slot_map(osb);\n\tsi->si_num_slots = osb->max_slots;\n\tsi->si_slots = (struct ocfs2_slot *)((char *)si +\n\t\t\t\t\t     sizeof(struct ocfs2_slot_info));\n\n\tinode = ocfs2_get_system_file_inode(osb, SLOT_MAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_inode = inode;\n\tstatus = ocfs2_map_slot_buffers(osb, si);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->slot_info = (struct ocfs2_slot_info *)si;\nbail:\n\tif (status < 0 && si)\n\t\t__ocfs2_free_slot_info(si);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_group_bitmap_size",
          "args": [
            "sb",
            "0",
            "osb->s_feature_incompat"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_group_bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1547-1565",
          "snippet": "static inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_MAX_BG_BITMAP_SIZE\t256",
            "#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_MAX_BG_BITMAP_SIZE\t256\n#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000\n\nstatic inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_global_system_inodes",
          "args": [
            "osb"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_global_system_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "449-493",
          "snippet": "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tnew = ocfs2_iget(osb, osb->root_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->root_inode = new;\n\n\tnew = ocfs2_iget(osb, osb->system_dir_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->sys_root_inode = new;\n\n\tfor (i = OCFS2_FIRST_ONLINE_SYSTEM_INODE;\n\t     i <= OCFS2_LAST_GLOBAL_SYSTEM_INODE; i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\t/* FIXME: Should ERROR_RO_FS */\n\t\t\tmlog(ML_ERROR, \"Unable to load system inode %d, \"\n\t\t\t     \"possibly corrupt fs?\", i);\n\t\t\tgoto bail;\n\t\t}\n\t\t// the array now has one ref, so drop this one\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tnew = ocfs2_iget(osb, osb->root_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->root_inode = new;\n\n\tnew = ocfs2_iget(osb, osb->system_dir_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->sys_root_inode = new;\n\n\tfor (i = OCFS2_FIRST_ONLINE_SYSTEM_INODE;\n\t     i <= OCFS2_LAST_GLOBAL_SYSTEM_INODE; i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\t/* FIXME: Should ERROR_RO_FS */\n\t\t\tmlog(ML_ERROR, \"Unable to load system inode %d, \"\n\t\t\t     \"possibly corrupt fs?\", i);\n\t\t\tgoto bail;\n\t\t}\n\t\t// the array now has one ref, so drop this one\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->vol_state",
            "VOLUME_INIT"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_dlm_debug",
          "args": [],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_dlm_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2709-2724",
          "snippet": "struct ocfs2_dlm_debug *ocfs2_new_dlm_debug(void)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug;\n\n\tdlm_debug = kmalloc(sizeof(struct ocfs2_dlm_debug), GFP_KERNEL);\n\tif (!dlm_debug) {\n\t\tmlog_errno(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tkref_init(&dlm_debug->d_refcnt);\n\tINIT_LIST_HEAD(&dlm_debug->d_lockres_tracking);\n\tdlm_debug->d_locking_state = NULL;\nout:\n\treturn dlm_debug;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct ocfs2_dlm_debug *ocfs2_new_dlm_debug(void)\n{\n\tstruct ocfs2_dlm_debug *dlm_debug;\n\n\tdlm_debug = kmalloc(sizeof(struct ocfs2_dlm_debug), GFP_KERNEL);\n\tif (!dlm_debug) {\n\t\tmlog_errno(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tkref_init(&dlm_debug->d_refcnt);\n\tINIT_LIST_HEAD(&dlm_debug->d_lockres_tracking);\n\tdlm_debug->d_locking_state = NULL;\nout:\n\treturn dlm_debug;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_initialize_super",
          "args": [
            "osb->vol_label",
            "osb->uuid_str",
            "(unsigned long long)osb->root_blkno",
            "(unsigned long long)osb->system_dir_blkno",
            "osb->s_clustersize_bits"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->id2.i_super.s_uuid_hash"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->id2.i_super.s_first_cluster_group"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "osb->vol_label",
            "di->id2.i_super.s_label",
            "OCFS2_MAX_VOL_LABEL_LEN"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Out of memory trying to setup our uuid.\\n\""
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_setup_osb_uuid",
          "args": [
            "osb",
            "di->id2.i_super.s_uuid",
            "sizeof(di->id2.i_super.s_uuid)"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_setup_osb_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1984-2006",
          "snippet": "static int ocfs2_setup_osb_uuid(struct ocfs2_super *osb, const unsigned char *uuid,\n\t\t\t\tunsigned uuid_bytes)\n{\n\tint i, ret;\n\tchar *ptr;\n\n\tBUG_ON(uuid_bytes != OCFS2_VOL_UUID_LEN);\n\n\tosb->uuid_str = kzalloc(OCFS2_VOL_UUID_LEN * 2 + 1, GFP_KERNEL);\n\tif (osb->uuid_str == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, ptr = osb->uuid_str; i < OCFS2_VOL_UUID_LEN; i++) {\n\t\t/* print with null */\n\t\tret = snprintf(ptr, 3, \"%02X\", uuid[i]);\n\t\tif (ret != 2) /* drop super cleans up */\n\t\t\treturn -EINVAL;\n\t\t/* then only advance past the last char */\n\t\tptr += 2;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_setup_osb_uuid(struct ocfs2_super *osb, const unsigned char *uuid,\n\t\t\t\tunsigned uuid_bytes)\n{\n\tint i, ret;\n\tchar *ptr;\n\n\tBUG_ON(uuid_bytes != OCFS2_VOL_UUID_LEN);\n\n\tosb->uuid_str = kzalloc(OCFS2_VOL_UUID_LEN * 2 + 1, GFP_KERNEL);\n\tif (osb->uuid_str == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, ptr = osb->uuid_str; i < OCFS2_VOL_UUID_LEN; i++) {\n\t\t/* print with null */\n\t\tret = snprintf(ptr, 3, \"%02X\", uuid[i]);\n\t\tif (ret != 2) /* drop super cleans up */\n\t\t\treturn -EINVAL;\n\t\t/* then only advance past the last char */\n\t\tptr += 2;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_check_addressable",
          "args": [
            "osb->sb->s_blocksize_bits",
            "total_blocks"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "generic_check_addressable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "998-1015",
          "snippet": "int generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_CACHE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\n{\n\tu64 last_fs_block = num_blocks - 1;\n\tu64 last_fs_page =\n\t\tlast_fs_block >> (PAGE_CACHE_SHIFT - blocksize_bits);\n\n\tif (unlikely(num_blocks == 0))\n\t\treturn 0;\n\n\tif ((blocksize_bits < 9) || (blocksize_bits > PAGE_CACHE_SHIFT))\n\t\treturn -EINVAL;\n\n\tif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\n\t    (last_fs_page > (pgoff_t)(~0ULL))) {\n\t\treturn -EFBIG;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "le32_to_cpu(di->i_clusters)"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Volume has invalid cluster size (%d)\\n\"",
            "osb->s_clustersize"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_llist_head",
          "args": [
            "&osb->dquot_drop_list"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&osb->dquot_drop_work",
            "ocfs2_drop_dquot_refs"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&journal->j_recovery_work",
            "ocfs2_complete_recovery"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&journal->j_la_cleanups"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_lock"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_checkpointed"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&journal->j_trans_barrier"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_num_trans",
            "0"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_journal)",
            "GFP_KERNEL"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&osb->s_next_generation",
            "sizeof(u32)"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "osb->osb_cluster_name",
            "OCFS2_RAW_SB(di)->s_cluster_info.ci_cluster",
            "OCFS2_CLUSTER_NAME_LEN + 1"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_RAW_SB",
          "args": [
            "di"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "osb->osb_cluster_stack"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "osb->osb_cluster_stack",
            "OCFS2_RAW_SB(di)->s_cluster_info.ci_stack",
            "OCFS2_STACK_LABEL_LEN + 1"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_RAW_SB",
          "args": [
            "di"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_RAW_SB",
          "args": [
            "di"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusterinfo_valid",
          "args": [
            "osb"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusterinfo_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "637-642",
          "snippet": "static inline int ocfs2_clusterinfo_valid(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat &\n\t\t(OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK |\n\t\t OCFS2_FEATURE_INCOMPAT_CLUSTERINFO));\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_clusterinfo_valid(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat &\n\t\t(OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK |\n\t\t OCFS2_FEATURE_INCOMPAT_CLUSTERINFO));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "osb->sb",
            "~OCFS2_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_INCOMPAT_FEATURE",
          "args": [
            "osb->sb",
            "~OCFS2_FEATURE_INCOMPAT_SUPP"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_RAW_SB",
          "args": [
            "di"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_RAW_SB",
          "args": [
            "di"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_RAW_SB",
          "args": [
            "di"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "osb->max_slots",
            "sizeof(*osb->osb_orphan_wipes)",
            "GFP_KERNEL"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&osb->osb_wipe_event"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "osb->max_slots",
            "sizeof(*osb->slot_recovery_generations)",
            "GFP_KERNEL"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "OCFS2_MAX_VOL_LABEL_LEN",
            "GFP_KERNEL"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_init",
          "args": [
            "osb",
            "&osb->osb_la_resmap"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "214-225",
          "snippet": "int ocfs2_resmap_init(struct ocfs2_super *osb,\n\t\t      struct ocfs2_reservation_map *resmap)\n{\n\tmemset(resmap, 0, sizeof(*resmap));\n\n\tresmap->m_osb = osb;\n\tresmap->m_reservations = RB_ROOT;\n\t/* m_bitmap_len is initialized to zero by the above memset. */\n\tINIT_LIST_HEAD(&resmap->m_lru);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_resmap_init(struct ocfs2_super *osb,\n\t\t      struct ocfs2_reservation_map *resmap)\n{\n\tmemset(resmap, 0, sizeof(*resmap));\n\n\tresmap->m_osb = osb;\n\tresmap->m_reservations = RB_ROOT;\n\t/* m_bitmap_len is initialized to zero by the above memset. */\n\tINIT_LIST_HEAD(&resmap->m_lru);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&osb->osb_mount_event"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&osb->la_enable_wq",
            "ocfs2_la_enable_worker"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->id2.i_super.s_xattr_inline_size"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&osb->checkpoint_event"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_init",
          "args": [
            "osb"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "187-209",
          "snippet": "int ocfs2_recovery_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\tmutex_init(&osb->recovery_lock);\n\tosb->disable_recovery = 0;\n\tosb->recovery_thread_task = NULL;\n\tinit_waitqueue_head(&osb->recovery_event);\n\n\trm = kzalloc(sizeof(struct ocfs2_recovery_map) +\n\t\t     osb->max_slots * sizeof(unsigned int),\n\t\t     GFP_KERNEL);\n\tif (!rm) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\trm->rm_entries = (unsigned int *)((char *)rm +\n\t\t\t\t\t  sizeof(struct ocfs2_recovery_map));\n\tosb->recovery_map = rm;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_recovery_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\tmutex_init(&osb->recovery_lock);\n\tosb->disable_recovery = 0;\n\tosb->recovery_thread_task = NULL;\n\tinit_waitqueue_head(&osb->recovery_event);\n\n\trm = kzalloc(sizeof(struct ocfs2_recovery_map) +\n\t\t     osb->max_slots * sizeof(unsigned int),\n\t\t     GFP_KERNEL);\n\tif (!rm) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\trm->rm_entries = (unsigned int *)((char *)rm +\n\t\t\t\t\t  sizeof(struct ocfs2_recovery_map));\n\tosb->recovery_map = rm;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_scan_init",
          "args": [
            "osb"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_scan_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1966-1976",
          "snippet": "void ocfs2_orphan_scan_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_osb = osb;\n\tos->os_count = 0;\n\tos->os_seqno = 0;\n\tmutex_init(&os->os_lock);\n\tINIT_DELAYED_WORK(&os->os_orphan_scan_work, ocfs2_orphan_scan_work);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_orphan_scan_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_osb = osb;\n\tos->os_count = 0;\n\tos->os_seqno = 0;\n\tmutex_init(&os->os_lock);\n\tINIT_DELAYED_WORK(&os->os_orphan_scan_work, ocfs2_orphan_scan_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "osb->dev_str",
            "sizeof(osb->dev_str)",
            "\"%u,%u\"",
            "MAJOR(osb->sb->s_dev)",
            "MINOR(osb->sb->s_dev)"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "osb->sb->s_dev"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "osb->sb->s_dev"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_node_maps",
          "args": [
            "osb"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_node_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/heartbeat.c",
          "lines": "57-61",
          "snippet": "void ocfs2_init_node_maps(struct ocfs2_super *osb)\n{\n\tspin_lock_init(&osb->node_map_lock);\n\tocfs2_node_map_init(&osb->osb_recovering_orphan_dirs);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_init_node_maps(struct ocfs2_super *osb)\n{\n\tspin_lock_init(&osb->node_map_lock);\n\tocfs2_node_map_init(&osb->osb_recovering_orphan_dirs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->alloc_stats.bg_extends",
            "0"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->alloc_stats.bg_allocs",
            "0"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->alloc_stats.bitmap_data",
            "0"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->alloc_stats.local_data",
            "0"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->alloc_stats.moves",
            "0"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&osb->system_file_mutex"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_steal_slots",
          "args": [
            "osb"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_steal_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "904-908",
          "snippet": "void ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&osb->osb_xattr_lock"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&osb->blocked_lock_list"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&osb->dc_event"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&osb->dc_task_lock"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!osb->s_sectsize_bits"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "sector_size"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_max_file_offset",
          "args": [
            "bbits",
            "cbits"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "591-636",
          "snippet": "static unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_super)",
            "GFP_KERNEL"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const struct super_operations ocfs2_sops = {\n\t.statfs\t\t= ocfs2_statfs,\n\t.alloc_inode\t= ocfs2_alloc_inode,\n\t.destroy_inode\t= ocfs2_destroy_inode,\n\t.drop_inode\t= ocfs2_drop_inode,\n\t.evict_inode\t= ocfs2_evict_inode,\n\t.sync_fs\t= ocfs2_sync_fs,\n\t.put_super\t= ocfs2_put_super,\n\t.remount_fs\t= ocfs2_remount,\n\t.show_options   = ocfs2_show_options,\n\t.quota_read\t= ocfs2_quota_read,\n\t.quota_write\t= ocfs2_quota_write,\n\t.get_dquots\t= ocfs2_get_dquots,\n};\n\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status;\n\tint i, cbits, bbits;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_journal *journal;\n\tstruct ocfs2_super *osb;\n\tu64 total_blocks;\n\n\tosb = kzalloc(sizeof(struct ocfs2_super), GFP_KERNEL);\n\tif (!osb) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsb->s_fs_info = osb;\n\tsb->s_op = &ocfs2_sops;\n\tsb->s_d_op = &ocfs2_dentry_ops;\n\tsb->s_export_op = &ocfs2_export_ops;\n\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\tsb->dq_op = &ocfs2_quota_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb->s_xattr = ocfs2_xattr_handlers;\n\tsb->s_time_gran = 1;\n\tsb->s_flags |= MS_NOATIME;\n\t/* this is needed to support O_LARGEFILE */\n\tcbits = le32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tbbits = le32_to_cpu(di->id2.i_super.s_blocksize_bits);\n\tsb->s_maxbytes = ocfs2_max_file_offset(bbits, cbits);\n\n\tosb->osb_dx_mask = (1 << (cbits - bbits)) - 1;\n\n\tfor (i = 0; i < 3; i++)\n\t\tosb->osb_dx_seed[i] = le32_to_cpu(di->id2.i_super.s_dx_seed[i]);\n\tosb->osb_dx_seed[3] = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\n\tosb->sb = sb;\n\t/* Save off for ocfs2_rw_direct */\n\tosb->s_sectsize_bits = blksize_bits(sector_size);\n\tBUG_ON(!osb->s_sectsize_bits);\n\n\tspin_lock_init(&osb->dc_task_lock);\n\tinit_waitqueue_head(&osb->dc_event);\n\tosb->dc_work_sequence = 0;\n\tosb->dc_wake_sequence = 0;\n\tINIT_LIST_HEAD(&osb->blocked_lock_list);\n\tosb->blocked_lock_count = 0;\n\tspin_lock_init(&osb->osb_lock);\n\tspin_lock_init(&osb->osb_xattr_lock);\n\tocfs2_init_steal_slots(osb);\n\n\tmutex_init(&osb->system_file_mutex);\n\n\tatomic_set(&osb->alloc_stats.moves, 0);\n\tatomic_set(&osb->alloc_stats.local_data, 0);\n\tatomic_set(&osb->alloc_stats.bitmap_data, 0);\n\tatomic_set(&osb->alloc_stats.bg_allocs, 0);\n\tatomic_set(&osb->alloc_stats.bg_extends, 0);\n\n\t/* Copy the blockcheck stats from the superblock probe */\n\tosb->osb_ecc_stats = *stats;\n\n\tocfs2_init_node_maps(osb);\n\n\tsnprintf(osb->dev_str, sizeof(osb->dev_str), \"%u,%u\",\n\t\t MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\n\tosb->max_slots = le16_to_cpu(di->id2.i_super.s_max_slots);\n\tif (osb->max_slots > OCFS2_MAX_SLOTS || osb->max_slots == 0) {\n\t\tmlog(ML_ERROR, \"Invalid number of node slots (%u)\\n\",\n\t\t     osb->max_slots);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tocfs2_orphan_scan_init(osb);\n\n\tstatus = ocfs2_recovery_init(osb);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Unable to initialize recovery state\\n\");\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->checkpoint_event);\n\n\tosb->s_atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\n\tosb->s_xattr_inline_size = le16_to_cpu(\n\t\t\t\t\tdi->id2.i_super.s_xattr_inline_size);\n\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\tosb->local_alloc_bh = NULL;\n\tINIT_DELAYED_WORK(&osb->la_enable_wq, ocfs2_la_enable_worker);\n\n\tinit_waitqueue_head(&osb->osb_mount_event);\n\n\tstatus = ocfs2_resmap_init(osb, &osb->osb_la_resmap);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->vol_label = kmalloc(OCFS2_MAX_VOL_LABEL_LEN, GFP_KERNEL);\n\tif (!osb->vol_label) {\n\t\tmlog(ML_ERROR, \"unable to alloc vol label\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tosb->slot_recovery_generations =\n\t\tkcalloc(osb->max_slots, sizeof(*osb->slot_recovery_generations),\n\t\t\tGFP_KERNEL);\n\tif (!osb->slot_recovery_generations) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->osb_wipe_event);\n\tosb->osb_orphan_wipes = kcalloc(osb->max_slots,\n\t\t\t\t\tsizeof(*osb->osb_orphan_wipes),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!osb->osb_orphan_wipes) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->osb_rf_lock_tree = RB_ROOT;\n\n\tosb->s_feature_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_compat);\n\tosb->s_feature_ro_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_ro_compat);\n\tosb->s_feature_incompat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_incompat);\n\n\tif ((i = OCFS2_HAS_INCOMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_INCOMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount because of unsupported \"\n\t\t     \"optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (!(osb->sb->s_flags & MS_RDONLY) &&\n\t    (i = OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount RDWR because of \"\n\t\t     \"unsupported optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_clusterinfo_valid(osb)) {\n\t\tosb->osb_stackflags =\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_stackflags;\n\t\tstrlcpy(osb->osb_cluster_stack,\n\t\t       OCFS2_RAW_SB(di)->s_cluster_info.ci_stack,\n\t\t       OCFS2_STACK_LABEL_LEN + 1);\n\t\tif (strlen(osb->osb_cluster_stack) != OCFS2_STACK_LABEL_LEN) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"couldn't mount because of an invalid \"\n\t\t\t     \"cluster stack label (%s) \\n\",\n\t\t\t     osb->osb_cluster_stack);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\tstrlcpy(osb->osb_cluster_name,\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_cluster,\n\t\t\tOCFS2_CLUSTER_NAME_LEN + 1);\n\t} else {\n\t\t/* The empty string is identical with classic tools that\n\t\t * don't know about s_cluster_info. */\n\t\tosb->osb_cluster_stack[0] = '\\0';\n\t}\n\n\tget_random_bytes(&osb->s_next_generation, sizeof(u32));\n\n\t/* FIXME\n\t * This should be done in ocfs2_journal_init(), but unknown\n\t * ordering issues will cause the filesystem to crash.\n\t * If anyone wants to figure out what part of the code\n\t * refers to osb->journal before ocfs2_journal_init() is run,\n\t * be my guest.\n\t */\n\t/* initialize our journal structure */\n\n\tjournal = kzalloc(sizeof(struct ocfs2_journal), GFP_KERNEL);\n\tif (!journal) {\n\t\tmlog(ML_ERROR, \"unable to alloc journal\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tosb->journal = journal;\n\tjournal->j_osb = osb;\n\n\tatomic_set(&journal->j_num_trans, 0);\n\tinit_rwsem(&journal->j_trans_barrier);\n\tinit_waitqueue_head(&journal->j_checkpointed);\n\tspin_lock_init(&journal->j_lock);\n\tjournal->j_trans_id = (unsigned long) 1;\n\tINIT_LIST_HEAD(&journal->j_la_cleanups);\n\tINIT_WORK(&journal->j_recovery_work, ocfs2_complete_recovery);\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n\tINIT_WORK(&osb->dquot_drop_work, ocfs2_drop_dquot_refs);\n\tinit_llist_head(&osb->dquot_drop_list);\n\n\t/* get some pseudo constants for clustersize bits */\n\tosb->s_clustersize_bits =\n\t\tle32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tosb->s_clustersize = 1 << osb->s_clustersize_bits;\n\n\tif (osb->s_clustersize < OCFS2_MIN_CLUSTERSIZE ||\n\t    osb->s_clustersize > OCFS2_MAX_CLUSTERSIZE) {\n\t\tmlog(ML_ERROR, \"Volume has invalid cluster size (%d)\\n\",\n\t\t     osb->s_clustersize);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\ttotal_blocks = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(di->i_clusters));\n\n\tstatus = generic_check_addressable(osb->sb->s_blocksize_bits,\n\t\t\t\t\t   total_blocks);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Volume too large \"\n\t\t     \"to mount safely on this system\");\n\t\tstatus = -EFBIG;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_setup_osb_uuid(osb, di->id2.i_super.s_uuid,\n\t\t\t\t sizeof(di->id2.i_super.s_uuid))) {\n\t\tmlog(ML_ERROR, \"Out of memory trying to setup our uuid.\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tstrlcpy(osb->vol_label, di->id2.i_super.s_label,\n\t\tOCFS2_MAX_VOL_LABEL_LEN);\n\tosb->root_blkno = le64_to_cpu(di->id2.i_super.s_root_blkno);\n\tosb->system_dir_blkno = le64_to_cpu(di->id2.i_super.s_system_dir_blkno);\n\tosb->first_cluster_group_blkno =\n\t\tle64_to_cpu(di->id2.i_super.s_first_cluster_group);\n\tosb->fs_generation = le32_to_cpu(di->i_fs_generation);\n\tosb->uuid_hash = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\ttrace_ocfs2_initialize_super(osb->vol_label, osb->uuid_str,\n\t\t\t\t     (unsigned long long)osb->root_blkno,\n\t\t\t\t     (unsigned long long)osb->system_dir_blkno,\n\t\t\t\t     osb->s_clustersize_bits);\n\n\tosb->osb_dlm_debug = ocfs2_new_dlm_debug();\n\tif (!osb->osb_dlm_debug) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_set(&osb->vol_state, VOLUME_INIT);\n\n\t/* load root, system_dir, and all global system inodes */\n\tstatus = ocfs2_init_global_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * global bitmap\n\t */\n\tinode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->bitmap_blkno = OCFS2_I(inode)->ip_blkno;\n\tosb->osb_clusters_at_boot = OCFS2_I(inode)->ip_clusters;\n\tiput(inode);\n\n\tosb->bitmap_cpg = ocfs2_group_bitmap_size(sb, 0,\n\t\t\t\t osb->s_feature_incompat) * 8;\n\n\tstatus = ocfs2_init_slot_info(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tcleancache_init_shared_fs((char *)&di->id2.i_super.s_uuid, sb);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_journal_addressable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "2011-2036",
    "snippet": "static int ocfs2_journal_addressable(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tu64 max_block =\n\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t osb->osb_clusters_at_boot) - 1;\n\n\t/* 32-bit block number is always OK. */\n\tif (max_block <= (u32)~0ULL)\n\t\tgoto out;\n\n\t/* Volume is \"huge\", so see if our journal is new enough to\n\t   support it. */\n\tif (!(OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t       OCFS2_FEATURE_COMPAT_JBD2_SB) &&\n\t      jbd2_journal_check_used_features(osb->journal->j_journal, 0, 0,\n\t\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT))) {\n\t\tmlog(ML_ERROR, \"The journal cannot address the entire volume. \"\n\t\t     \"Enable the 'block64' journal option with tunefs.ocfs2\");\n\t\tstatus = -EFBIG;\n\t\tgoto out;\n\t}\n\n out:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"The journal cannot address the entire volume. \"\n\t\t     \"Enable the 'block64' journal option with tunefs.ocfs2\""
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_check_used_features",
          "args": [
            "osb->journal->j_journal",
            "0",
            "0",
            "JBD2_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_check_used_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1740-1762",
          "snippet": "int jbd2_journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\t/* Load journal superblock if it is not loaded yet. */\n\tif (journal->j_format_version == 0 &&\n\t    journal_get_superblock(journal) != 0)\n\t\treturn 0;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\t/* Load journal superblock if it is not loaded yet. */\n\tif (journal->j_format_version == 0 &&\n\t    journal_get_superblock(journal) != 0)\n\t\treturn 0;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_COMPAT_FEATURE",
          "args": [
            "osb->sb",
            "OCFS2_FEATURE_COMPAT_JBD2_SB"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "osb->osb_clusters_at_boot"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_journal_addressable(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tu64 max_block =\n\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t osb->osb_clusters_at_boot) - 1;\n\n\t/* 32-bit block number is always OK. */\n\tif (max_block <= (u32)~0ULL)\n\t\tgoto out;\n\n\t/* Volume is \"huge\", so see if our journal is new enough to\n\t   support it. */\n\tif (!(OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t       OCFS2_FEATURE_COMPAT_JBD2_SB) &&\n\t      jbd2_journal_check_used_features(osb->journal->j_journal, 0, 0,\n\t\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT))) {\n\t\tmlog(ML_ERROR, \"The journal cannot address the entire volume. \"\n\t\t     \"Enable the 'block64' journal option with tunefs.ocfs2\");\n\t\tstatus = -EFBIG;\n\t\tgoto out;\n\t}\n\n out:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_setup_osb_uuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1984-2006",
    "snippet": "static int ocfs2_setup_osb_uuid(struct ocfs2_super *osb, const unsigned char *uuid,\n\t\t\t\tunsigned uuid_bytes)\n{\n\tint i, ret;\n\tchar *ptr;\n\n\tBUG_ON(uuid_bytes != OCFS2_VOL_UUID_LEN);\n\n\tosb->uuid_str = kzalloc(OCFS2_VOL_UUID_LEN * 2 + 1, GFP_KERNEL);\n\tif (osb->uuid_str == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, ptr = osb->uuid_str; i < OCFS2_VOL_UUID_LEN; i++) {\n\t\t/* print with null */\n\t\tret = snprintf(ptr, 3, \"%02X\", uuid[i]);\n\t\tif (ret != 2) /* drop super cleans up */\n\t\t\treturn -EINVAL;\n\t\t/* then only advance past the last char */\n\t\tptr += 2;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ptr",
            "3",
            "\"%02X\"",
            "uuid[i]"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "OCFS2_VOL_UUID_LEN * 2 + 1",
            "GFP_KERNEL"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "uuid_bytes != OCFS2_VOL_UUID_LEN"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_setup_osb_uuid(struct ocfs2_super *osb, const unsigned char *uuid,\n\t\t\t\tunsigned uuid_bytes)\n{\n\tint i, ret;\n\tchar *ptr;\n\n\tBUG_ON(uuid_bytes != OCFS2_VOL_UUID_LEN);\n\n\tosb->uuid_str = kzalloc(OCFS2_VOL_UUID_LEN * 2 + 1, GFP_KERNEL);\n\tif (osb->uuid_str == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, ptr = osb->uuid_str; i < OCFS2_VOL_UUID_LEN; i++) {\n\t\t/* print with null */\n\t\tret = snprintf(ptr, 3, \"%02X\", uuid[i]);\n\t\tif (ret != 2) /* drop super cleans up */\n\t\t\treturn -EINVAL;\n\t\t/* then only advance past the last char */\n\t\tptr += 2;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dismount_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1894-1982",
    "snippet": "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osb"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_delete_osb",
          "args": [
            "osb"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_delete_osb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2521-2540",
          "snippet": "static void ocfs2_delete_osb(struct ocfs2_super *osb)\n{\n\t/* This function assumes that the caller has the main osb resource */\n\n\tocfs2_free_slot_info(osb);\n\n\tkfree(osb->osb_orphan_wipes);\n\tkfree(osb->slot_recovery_generations);\n\t/* FIXME\n\t * This belongs in journal shutdown, but because we have to\n\t * allocate osb->journal at the start of ocfs2_initialize_osb(),\n\t * we free it here.\n\t */\n\tkfree(osb->journal);\n\tkfree(osb->local_alloc_copy);\n\tkfree(osb->uuid_str);\n\tkfree(osb->vol_label);\n\tocfs2_put_dlm_debug(osb->osb_dlm_debug);\n\tmemset(osb, 0, sizeof(struct ocfs2_super));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb)\n{\n\t/* This function assumes that the caller has the main osb resource */\n\n\tocfs2_free_slot_info(osb);\n\n\tkfree(osb->osb_orphan_wipes);\n\tkfree(osb->slot_recovery_generations);\n\t/* FIXME\n\t * This belongs in journal shutdown, but because we have to\n\t * allocate osb->journal at the start of ocfs2_initialize_osb(),\n\t * we free it here.\n\t */\n\tkfree(osb->journal);\n\tkfree(osb->local_alloc_copy);\n\tkfree(osb->uuid_str);\n\tkfree(osb->vol_label);\n\tocfs2_put_dlm_debug(osb->osb_dlm_debug);\n\tmemset(osb, 0, sizeof(struct ocfs2_super));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\"",
            "osb->dev_str",
            "nodestr"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nodestr",
            "sizeof(nodestr)",
            "\"%u\"",
            "osb->node_num"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nodestr",
            "sizeof(nodestr)",
            "\"local\""
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->vol_state",
            "VOLUME_DISMOUNTED"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_hangup",
          "args": [
            "osb->uuid_str",
            "strlen(osb->uuid_str)"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_hangup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "458-467",
          "snippet": "void ocfs2_cluster_hangup(const char *group, int grouplen)\n{\n\tBUG_ON(group == NULL);\n\tBUG_ON(group[grouplen] != '\\0');\n\n\tocfs2_leave_group(group);\n\n\t/* cluster_disconnect() was called with hangup_pending==1 */\n\tocfs2_stack_driver_put();\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nvoid ocfs2_cluster_hangup(const char *group, int grouplen)\n{\n\tBUG_ON(group == NULL);\n\tBUG_ON(group[grouplen] != '\\0');\n\n\tocfs2_leave_group(group);\n\n\t/* cluster_disconnect() was called with hangup_pending==1 */\n\tocfs2_stack_driver_put();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "osb->uuid_str"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "osb->osb_debug_root"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_shutdown",
          "args": [
            "osb",
            "hangup_needed"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3045-3070",
          "snippet": "void ocfs2_dlm_shutdown(struct ocfs2_super *osb,\n\t\t\tint hangup_pending)\n{\n\tocfs2_drop_osb_locks(osb);\n\n\t/*\n\t * Now that we have dropped all locks and ocfs2_dismount_volume()\n\t * has disabled recovery, the DLM won't be talking to us.  It's\n\t * safe to tear things down before disconnecting the cluster.\n\t */\n\n\tif (osb->dc_task) {\n\t\tkthread_stop(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t}\n\n\tocfs2_lock_res_free(&osb->osb_super_lockres);\n\tocfs2_lock_res_free(&osb->osb_rename_lockres);\n\tocfs2_lock_res_free(&osb->osb_nfs_sync_lockres);\n\tocfs2_lock_res_free(&osb->osb_orphan_scan.os_lockres);\n\n\tocfs2_cluster_disconnect(osb->cconn, hangup_pending);\n\tosb->cconn = NULL;\n\n\tocfs2_dlm_shutdown_debug(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nvoid ocfs2_dlm_shutdown(struct ocfs2_super *osb,\n\t\t\tint hangup_pending)\n{\n\tocfs2_drop_osb_locks(osb);\n\n\t/*\n\t * Now that we have dropped all locks and ocfs2_dismount_volume()\n\t * has disabled recovery, the DLM won't be talking to us.  It's\n\t * safe to tear things down before disconnecting the cluster.\n\t */\n\n\tif (osb->dc_task) {\n\t\tkthread_stop(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t}\n\n\tocfs2_lock_res_free(&osb->osb_super_lockres);\n\tocfs2_lock_res_free(&osb->osb_rename_lockres);\n\tocfs2_lock_res_free(&osb->osb_nfs_sync_lockres);\n\tocfs2_lock_res_free(&osb->osb_orphan_scan.os_lockres);\n\n\tocfs2_cluster_disconnect(osb->cconn, hangup_pending);\n\tosb->cconn = NULL;\n\n\tocfs2_dlm_shutdown_debug(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_release_system_inodes",
          "args": [
            "osb"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_release_system_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "524-561",
          "snippet": "static void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_super_unlock",
          "args": [
            "osb",
            "1"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_super_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2587-2595",
          "snippet": "void ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_put_slot",
          "args": [
            "osb"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_put_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "513-537",
          "snippet": "void ocfs2_put_slot(struct ocfs2_super *osb)\n{\n\tint status, slot_num;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (!si)\n\t\treturn;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\tslot_num = osb->slot_num;\n\tocfs2_invalidate_slot(si, osb->slot_num);\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, slot_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\tocfs2_free_slot_info(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_put_slot(struct ocfs2_super *osb)\n{\n\tint status, slot_num;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (!si)\n\t\treturn;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\tslot_num = osb->slot_num;\n\tocfs2_invalidate_slot(si, osb->slot_num);\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, slot_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\tocfs2_free_slot_info(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "tmp"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_super_lock",
          "args": [
            "osb",
            "1"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_super_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2548-2585",
          "snippet": "int ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* The super block lock path is really in the best position to\n\t * know when resources covered by the lock need to be\n\t * refreshed, so we do it here. Of course, making sense of\n\t * everything is up to the caller :) */\n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* The super block lock path is really in the best position to\n\t * know when resources covered by the lock need to be\n\t * refreshed, so we do it here. Of course, making sense of\n\t * everything is up to the caller :) */\n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_purge_refcount_trees",
          "args": [
            "osb"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_purge_refcount_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "538-553",
          "snippet": "void ocfs2_purge_refcount_trees(struct ocfs2_super *osb)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_refcount_tree *tree;\n\tstruct rb_root *root = &osb->osb_rf_lock_tree;\n\n\twhile ((node = rb_last(root)) != NULL) {\n\t\ttree = rb_entry(node, struct ocfs2_refcount_tree, rf_node);\n\n\t\ttrace_ocfs2_purge_refcount_trees(\n\t\t\t\t(unsigned long long) tree->rf_blkno);\n\n\t\trb_erase(&tree->rf_node, root);\n\t\tocfs2_free_refcount_tree(tree);\n\t}\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_purge_refcount_trees(struct ocfs2_super *osb)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_refcount_tree *tree;\n\tstruct rb_root *root = &osb->osb_rf_lock_tree;\n\n\twhile ((node = rb_last(root)) != NULL) {\n\t\ttree = rb_entry(node, struct ocfs2_refcount_tree, rf_node);\n\n\t\ttrace_ocfs2_purge_refcount_trees(\n\t\t\t\t(unsigned long long) tree->rf_blkno);\n\n\t\trb_erase(&tree->rf_node, root);\n\t\tocfs2_free_refcount_tree(tree);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sync_blockdev",
          "args": [
            "sb"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "548-551",
          "snippet": "void ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_shutdown",
          "args": [
            "osb"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "941-1020",
          "snippet": "void ocfs2_journal_shutdown(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = NULL;\n\tint status = 0;\n\tstruct inode *inode = NULL;\n\tint num_running_trans = 0;\n\n\tBUG_ON(!osb);\n\n\tjournal = osb->journal;\n\tif (!journal)\n\t\tgoto done;\n\n\tinode = journal->j_inode;\n\n\tif (journal->j_state != OCFS2_JOURNAL_LOADED)\n\t\tgoto done;\n\n\t/* need to inc inode use count - jbd2_journal_destroy will iput. */\n\tif (!igrab(inode))\n\t\tBUG();\n\n\tnum_running_trans = atomic_read(&(osb->journal->j_num_trans));\n\ttrace_ocfs2_journal_shutdown(num_running_trans);\n\n\t/* Do a commit_cache here. It will flush our journal, *and*\n\t * release any locks that are still held.\n\t * set the SHUTDOWN flag and release the trans lock.\n\t * the commit thread will take the trans lock for us below. */\n\tjournal->j_state = OCFS2_JOURNAL_IN_SHUTDOWN;\n\n\t/* The OCFS2_JOURNAL_IN_SHUTDOWN will signal to commit_cache to not\n\t * drop the trans_lock (which we want to hold until we\n\t * completely destroy the journal. */\n\tif (osb->commit_task) {\n\t\t/* Wait for the commit thread */\n\t\ttrace_ocfs2_journal_shutdown_wait(osb->commit_task);\n\t\tkthread_stop(osb->commit_task);\n\t\tosb->commit_task = NULL;\n\t}\n\n\tBUG_ON(atomic_read(&(osb->journal->j_num_trans)) != 0);\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tjbd2_journal_lock_updates(journal->j_journal);\n\t\tstatus = jbd2_journal_flush(journal->j_journal);\n\t\tjbd2_journal_unlock_updates(journal->j_journal);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\tif (status == 0) {\n\t\t/*\n\t\t * Do not toggle if flush was unsuccessful otherwise\n\t\t * will leave dirty metadata in a \"clean\" journal\n\t\t */\n\t\tstatus = ocfs2_journal_toggle_dirty(osb, 0, 0);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\t/* Shutdown the kernel journal system */\n\tjbd2_journal_destroy(journal->j_journal);\n\tjournal->j_journal = NULL;\n\n\tOCFS2_I(inode)->ip_open_count--;\n\n\t/* unlock our journal */\n\tocfs2_inode_unlock(inode, 1);\n\n\tbrelse(journal->j_bh);\n\tjournal->j_bh = NULL;\n\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n//\tup_write(&journal->j_trans_barrier);\ndone:\n\tif (inode)\n\t\tiput(inode);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_journal_shutdown(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = NULL;\n\tint status = 0;\n\tstruct inode *inode = NULL;\n\tint num_running_trans = 0;\n\n\tBUG_ON(!osb);\n\n\tjournal = osb->journal;\n\tif (!journal)\n\t\tgoto done;\n\n\tinode = journal->j_inode;\n\n\tif (journal->j_state != OCFS2_JOURNAL_LOADED)\n\t\tgoto done;\n\n\t/* need to inc inode use count - jbd2_journal_destroy will iput. */\n\tif (!igrab(inode))\n\t\tBUG();\n\n\tnum_running_trans = atomic_read(&(osb->journal->j_num_trans));\n\ttrace_ocfs2_journal_shutdown(num_running_trans);\n\n\t/* Do a commit_cache here. It will flush our journal, *and*\n\t * release any locks that are still held.\n\t * set the SHUTDOWN flag and release the trans lock.\n\t * the commit thread will take the trans lock for us below. */\n\tjournal->j_state = OCFS2_JOURNAL_IN_SHUTDOWN;\n\n\t/* The OCFS2_JOURNAL_IN_SHUTDOWN will signal to commit_cache to not\n\t * drop the trans_lock (which we want to hold until we\n\t * completely destroy the journal. */\n\tif (osb->commit_task) {\n\t\t/* Wait for the commit thread */\n\t\ttrace_ocfs2_journal_shutdown_wait(osb->commit_task);\n\t\tkthread_stop(osb->commit_task);\n\t\tosb->commit_task = NULL;\n\t}\n\n\tBUG_ON(atomic_read(&(osb->journal->j_num_trans)) != 0);\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tjbd2_journal_lock_updates(journal->j_journal);\n\t\tstatus = jbd2_journal_flush(journal->j_journal);\n\t\tjbd2_journal_unlock_updates(journal->j_journal);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\tif (status == 0) {\n\t\t/*\n\t\t * Do not toggle if flush was unsuccessful otherwise\n\t\t * will leave dirty metadata in a \"clean\" journal\n\t\t */\n\t\tstatus = ocfs2_journal_toggle_dirty(osb, 0, 0);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\t/* Shutdown the kernel journal system */\n\tjbd2_journal_destroy(journal->j_journal);\n\tjournal->j_journal = NULL;\n\n\tOCFS2_I(inode)->ip_open_count--;\n\n\t/* unlock our journal */\n\tocfs2_inode_unlock(inode, 1);\n\n\tbrelse(journal->j_bh);\n\tjournal->j_bh = NULL;\n\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n//\tup_write(&journal->j_trans_barrier);\ndone:\n\tif (inode)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_exit",
          "args": [
            "osb"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "220-244",
          "snippet": "void ocfs2_recovery_exit(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\t/* disable any new recovery threads and wait for any currently\n\t * running ones to exit. Do this before setting the vol_state. */\n\tmutex_lock(&osb->recovery_lock);\n\tosb->disable_recovery = 1;\n\tmutex_unlock(&osb->recovery_lock);\n\twait_event(osb->recovery_event, !ocfs2_recovery_thread_running(osb));\n\n\t/* At this point, we know that no more recovery threads can be\n\t * launched, so wait for any recovery completion work to\n\t * complete. */\n\tflush_workqueue(ocfs2_wq);\n\n\t/*\n\t * Now that recovery is shut down, and the osb is about to be\n\t * freed,  the osb_lock is not taken here.\n\t */\n\trm = osb->recovery_map;\n\t/* XXX: Should we bug if there are dirty entries? */\n\n\tkfree(rm);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_recovery_exit(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\t/* disable any new recovery threads and wait for any currently\n\t * running ones to exit. Do this before setting the vol_state. */\n\tmutex_lock(&osb->recovery_lock);\n\tosb->disable_recovery = 1;\n\tmutex_unlock(&osb->recovery_lock);\n\twait_event(osb->recovery_event, !ocfs2_recovery_thread_running(osb));\n\n\t/* At this point, we know that no more recovery threads can be\n\t * launched, so wait for any recovery completion work to\n\t * complete. */\n\tflush_workqueue(ocfs2_wq);\n\n\t/*\n\t * Now that recovery is shut down, and the osb is about to be\n\t * freed,  the osb_lock is not taken here.\n\t */\n\trm = osb->recovery_map;\n\t/* XXX: Should we bug if there are dirty entries? */\n\n\tkfree(rm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_shutdown",
          "args": [
            "osb"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6233-6251",
          "snippet": "void ocfs2_truncate_log_shutdown(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tatomic_set(&osb->osb_tl_disable, 1);\n\n\tif (tl_inode) {\n\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\t\tflush_workqueue(ocfs2_wq);\n\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\tbrelse(osb->osb_tl_bh);\n\t\tiput(osb->osb_tl_inode);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_truncate_log_shutdown(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tatomic_set(&osb->osb_tl_disable, 1);\n\n\tif (tl_inode) {\n\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\t\tflush_workqueue(ocfs2_wq);\n\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\n\t\tbrelse(osb->osb_tl_bh);\n\t\tiput(osb->osb_tl_inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_shutdown_local_alloc",
          "args": [
            "osb"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_shutdown_local_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "378-480",
          "snippet": "void ocfs2_shutdown_local_alloc(struct ocfs2_super *osb)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *local_alloc_inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_dinode *alloc = NULL;\n\n\tcancel_delayed_work(&osb->la_enable_wq);\n\tflush_workqueue(ocfs2_wq);\n\n\tif (osb->local_alloc_state == OCFS2_LA_UNUSED)\n\t\tgoto out;\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\n\tocfs2_resmap_uninit(&osb->osb_la_resmap);\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\t/* WINDOW_MOVE_CREDITS is a bit heavy... */\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\thandle = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tbh = osb->local_alloc_bh;\n\talloc = (struct ocfs2_dinode *) bh->b_data;\n\n\talloc_copy = kmalloc(bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_commit;\n\t}\n\tmemcpy(alloc_copy, alloc, bh->b_size);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, bh);\n\n\tbrelse(bh);\n\tosb->local_alloc_bh = NULL;\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\n\nout:\n\tif (local_alloc_inode)\n\t\tiput(local_alloc_inode);\n\n\tkfree(alloc_copy);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);",
            "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nvoid ocfs2_shutdown_local_alloc(struct ocfs2_super *osb)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *local_alloc_inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_dinode *alloc = NULL;\n\n\tcancel_delayed_work(&osb->la_enable_wq);\n\tflush_workqueue(ocfs2_wq);\n\n\tif (osb->local_alloc_state == OCFS2_LA_UNUSED)\n\t\tgoto out;\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\n\tocfs2_resmap_uninit(&osb->osb_la_resmap);\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\t/* WINDOW_MOVE_CREDITS is a bit heavy... */\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\thandle = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tbh = osb->local_alloc_bh;\n\talloc = (struct ocfs2_dinode *) bh->b_data;\n\n\talloc_copy = kmalloc(bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_commit;\n\t}\n\tmemcpy(alloc_copy, alloc, bh->b_size);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, bh);\n\n\tbrelse(bh);\n\tosb->local_alloc_bh = NULL;\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\n\nout:\n\tif (local_alloc_inode)\n\t\tiput(local_alloc_inode);\n\n\tkfree(alloc_copy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&osb->dquot_drop_work"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!llist_empty(&osb->dquot_drop_list)"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "&osb->dquot_drop_list"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_disable_quotas",
          "args": [
            "osb"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_disable_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "978-1003",
          "snippet": "static void ocfs2_disable_quotas(struct ocfs2_super *osb)\n{\n\tint type;\n\tstruct inode *inode;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t/* We mostly ignore errors in this function because there's not much\n\t * we can do when we see them */\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!sb_has_quota_loaded(sb, type))\n\t\t\tcontinue;\n\t\t/* Cancel periodic syncing before we grab dqonoff_mutex */\n\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\tinode = igrab(sb->s_dquot.files[type]);\n\t\t/* Turn off quotas. This will remove all dquot structures from\n\t\t * memory and so they will be automatically synced to global\n\t\t * quota files */\n\t\tdquot_disable(sb, type, DQUOT_USAGE_ENABLED |\n\t\t\t\t\tDQUOT_LIMITS_ENABLED);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb)\n{\n\tint type;\n\tstruct inode *inode;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t/* We mostly ignore errors in this function because there's not much\n\t * we can do when we see them */\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!sb_has_quota_loaded(sb, type))\n\t\t\tcontinue;\n\t\t/* Cancel periodic syncing before we grab dqonoff_mutex */\n\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\tinode = igrab(sb->s_dquot.files[type]);\n\t\t/* Turn off quotas. This will remove all dquot structures from\n\t\t * memory and so they will be automatically synced to global\n\t\t * quota files */\n\t\tdquot_disable(sb, type, DQUOT_USAGE_ENABLED |\n\t\t\t\t\tDQUOT_LIMITS_ENABLED);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_scan_stop",
          "args": [
            "osb"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_scan_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1953-1964",
          "snippet": "void ocfs2_orphan_scan_stop(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE) {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\t\tmutex_lock(&os->os_lock);\n\t\tcancel_delayed_work(&os->os_orphan_scan_work);\n\t\tmutex_unlock(&os->os_lock);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_orphan_scan_stop(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE) {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\t\tmutex_lock(&os->os_lock);\n\t\tcancel_delayed_work(&os->os_orphan_scan_work);\n\t\tmutex_unlock(&os->os_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!osb"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sb"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_dismount_volume",
          "args": [
            "sb"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "ocfs2_mount_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1841-1892",
    "snippet": "static int ocfs2_mount_volume(struct super_block *sb)\n{\n\tint status = 0;\n\tint unlock_super = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\tgoto leave;\n\n\tstatus = ocfs2_dlm_init(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_super_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tunlock_super = 1;\n\n\t/* This will load up the node map and add ourselves to it. */\n\tstatus = ocfs2_find_slot(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* load all node-local system inodes */\n\tstatus = ocfs2_init_local_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_volume(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_truncate_log_init(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nleave:\n\tif (unlock_super)\n\t\tocfs2_super_unlock(osb, 1);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_super_unlock",
          "args": [
            "osb",
            "1"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_super_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2587-2595",
          "snippet": "void ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_log_init",
          "args": [
            "osb"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_log_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6253-6276",
          "snippet": "int ocfs2_truncate_log_init(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\n\tstatus = ocfs2_get_truncate_log_info(osb,\n\t\t\t\t\t     osb->slot_num,\n\t\t\t\t\t     &tl_inode,\n\t\t\t\t\t     &tl_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* ocfs2_truncate_log_shutdown keys on the existence of\n\t * osb->osb_tl_inode so we don't set any of the osb variables\n\t * until we're sure all is well. */\n\tINIT_DELAYED_WORK(&osb->osb_truncate_log_wq,\n\t\t\t  ocfs2_truncate_log_worker);\n\tatomic_set(&osb->osb_tl_disable, 0);\n\tosb->osb_tl_bh    = tl_bh;\n\tosb->osb_tl_inode = tl_inode;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_log_init(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\n\tstatus = ocfs2_get_truncate_log_info(osb,\n\t\t\t\t\t     osb->slot_num,\n\t\t\t\t\t     &tl_inode,\n\t\t\t\t\t     &tl_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* ocfs2_truncate_log_shutdown keys on the existence of\n\t * osb->osb_tl_inode so we don't set any of the osb variables\n\t * until we're sure all is well. */\n\tINIT_DELAYED_WORK(&osb->osb_truncate_log_wq,\n\t\t\t  ocfs2_truncate_log_worker);\n\tatomic_set(&osb->osb_tl_disable, 0);\n\tosb->osb_tl_bh    = tl_bh;\n\tosb->osb_tl_inode = tl_inode;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_volume",
          "args": [
            "osb"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2413-2513",
          "snippet": "static int ocfs2_check_volume(struct ocfs2_super *osb)\n{\n\tint status;\n\tint dirty;\n\tint local;\n\tstruct ocfs2_dinode *local_alloc = NULL; /* only used if we\n\t\t\t\t\t\t  * recover\n\t\t\t\t\t\t  * ourselves. */\n\n\t/* Init our journal object. */\n\tstatus = ocfs2_journal_init(osb->journal, &dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Could not initialize journal!\\n\");\n\t\tgoto finally;\n\t}\n\n\t/* Now that journal has been initialized, check to make sure\n\t   entire volume is addressable. */\n\tstatus = ocfs2_journal_addressable(osb);\n\tif (status)\n\t\tgoto finally;\n\n\t/* If the journal was unmounted cleanly then we don't want to\n\t * recover anything. Otherwise, journal_load will do that\n\t * dirty work for us :) */\n\tif (!dirty) {\n\t\tstatus = ocfs2_journal_wipe(osb->journal, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t} else {\n\t\tprintk(KERN_NOTICE \"ocfs2: File system on device (%s) was not \"\n\t\t       \"unmounted cleanly, recovering it.\\n\", osb->dev_str);\n\t}\n\n\tlocal = ocfs2_mount_local(osb);\n\n\t/* will play back anything left in the journal. */\n\tstatus = ocfs2_journal_load(osb->journal, local, dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"ocfs2 journal load failed! %d\\n\", status);\n\t\tgoto finally;\n\t}\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT)\n\t\tjbd2_journal_set_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\telse\n\t\tjbd2_journal_clear_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\n\tif (dirty) {\n\t\t/* recover my local alloc if we didn't unmount cleanly. */\n\t\tstatus = ocfs2_begin_local_alloc_recovery(osb,\n\t\t\t\t\t\t\t  osb->slot_num,\n\t\t\t\t\t\t\t  &local_alloc);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t\t/* we complete the recovery process after we've marked\n\t\t * ourselves as mounted. */\n\t}\n\n\tstatus = ocfs2_load_local_alloc(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tif (dirty) {\n\t\t/* Recovery will be completed after we've mounted the\n\t\t * rest of the volume. */\n\t\tosb->dirty = 1;\n\t\tosb->local_alloc_copy = local_alloc;\n\t\tlocal_alloc = NULL;\n\t}\n\n\t/* go through each journal, trylock it and if you get the\n\t * lock, and it's marked as dirty, set the bit in the recover\n\t * map and launch a recovery thread for it. */\n\tstatus = ocfs2_mark_dead_nodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tstatus = ocfs2_compute_replay_slots(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nfinally:\n\tkfree(local_alloc);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_check_volume(struct ocfs2_super *osb)\n{\n\tint status;\n\tint dirty;\n\tint local;\n\tstruct ocfs2_dinode *local_alloc = NULL; /* only used if we\n\t\t\t\t\t\t  * recover\n\t\t\t\t\t\t  * ourselves. */\n\n\t/* Init our journal object. */\n\tstatus = ocfs2_journal_init(osb->journal, &dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Could not initialize journal!\\n\");\n\t\tgoto finally;\n\t}\n\n\t/* Now that journal has been initialized, check to make sure\n\t   entire volume is addressable. */\n\tstatus = ocfs2_journal_addressable(osb);\n\tif (status)\n\t\tgoto finally;\n\n\t/* If the journal was unmounted cleanly then we don't want to\n\t * recover anything. Otherwise, journal_load will do that\n\t * dirty work for us :) */\n\tif (!dirty) {\n\t\tstatus = ocfs2_journal_wipe(osb->journal, 0);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t} else {\n\t\tprintk(KERN_NOTICE \"ocfs2: File system on device (%s) was not \"\n\t\t       \"unmounted cleanly, recovering it.\\n\", osb->dev_str);\n\t}\n\n\tlocal = ocfs2_mount_local(osb);\n\n\t/* will play back anything left in the journal. */\n\tstatus = ocfs2_journal_load(osb->journal, local, dirty);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"ocfs2 journal load failed! %d\\n\", status);\n\t\tgoto finally;\n\t}\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT)\n\t\tjbd2_journal_set_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\telse\n\t\tjbd2_journal_clear_features(osb->journal->j_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\n\tif (dirty) {\n\t\t/* recover my local alloc if we didn't unmount cleanly. */\n\t\tstatus = ocfs2_begin_local_alloc_recovery(osb,\n\t\t\t\t\t\t\t  osb->slot_num,\n\t\t\t\t\t\t\t  &local_alloc);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto finally;\n\t\t}\n\t\t/* we complete the recovery process after we've marked\n\t\t * ourselves as mounted. */\n\t}\n\n\tstatus = ocfs2_load_local_alloc(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tif (dirty) {\n\t\t/* Recovery will be completed after we've mounted the\n\t\t * rest of the volume. */\n\t\tosb->dirty = 1;\n\t\tosb->local_alloc_copy = local_alloc;\n\t\tlocal_alloc = NULL;\n\t}\n\n\t/* go through each journal, trylock it and if you get the\n\t * lock, and it's marked as dirty, set the bit in the recover\n\t * map and launch a recovery thread for it. */\n\tstatus = ocfs2_mark_dead_nodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tstatus = ocfs2_compute_replay_slots(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nfinally:\n\tkfree(local_alloc);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_local_system_inodes",
          "args": [
            "osb"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_local_system_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "495-522",
          "snippet": "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tfor (i = OCFS2_LAST_GLOBAL_SYSTEM_INODE + 1;\n\t     i < NUM_SYSTEM_INODES;\n\t     i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"status=%d, sysfile=%d, slot=%d\\n\",\n\t\t\t     status, i, osb->slot_num);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* the array now has one ref, so drop this one */\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tfor (i = OCFS2_LAST_GLOBAL_SYSTEM_INODE + 1;\n\t     i < NUM_SYSTEM_INODES;\n\t     i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"status=%d, sysfile=%d, slot=%d\\n\",\n\t\t\t     status, i, osb->slot_num);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* the array now has one ref, so drop this one */\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_slot",
          "args": [
            "osb"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "469-511",
          "snippet": "int ocfs2_find_slot(struct ocfs2_super *osb)\n{\n\tint status;\n\tint slot;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\t/* search for ourselves first and take the slot if it already\n\t * exists. Perhaps we need to mark this in a variable for our\n\t * own journal recovery? Possibly not, though we certainly\n\t * need to warn to the user */\n\tslot = __ocfs2_node_num_to_slot(si, osb->node_num);\n\tif (slot < 0) {\n\t\t/* if no slot yet, then just take 1st available\n\t\t * one. */\n\t\tslot = __ocfs2_find_empty_slot(si, osb->preferred_slot);\n\t\tif (slot < 0) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tmlog(ML_ERROR, \"no free slots available!\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t} else\n\t\tprintk(KERN_INFO \"ocfs2: Slot %d on device (%s) was already \"\n\t\t       \"allocated to this node!\\n\", slot, osb->dev_str);\n\n\tocfs2_set_slot(si, slot, osb->node_num);\n\tosb->slot_num = slot;\n\tspin_unlock(&osb->osb_lock);\n\n\ttrace_ocfs2_find_slot(osb->slot_num);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, osb->slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nint ocfs2_find_slot(struct ocfs2_super *osb)\n{\n\tint status;\n\tint slot;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\t/* search for ourselves first and take the slot if it already\n\t * exists. Perhaps we need to mark this in a variable for our\n\t * own journal recovery? Possibly not, though we certainly\n\t * need to warn to the user */\n\tslot = __ocfs2_node_num_to_slot(si, osb->node_num);\n\tif (slot < 0) {\n\t\t/* if no slot yet, then just take 1st available\n\t\t * one. */\n\t\tslot = __ocfs2_find_empty_slot(si, osb->preferred_slot);\n\t\tif (slot < 0) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tmlog(ML_ERROR, \"no free slots available!\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t} else\n\t\tprintk(KERN_INFO \"ocfs2: Slot %d on device (%s) was already \"\n\t\t       \"allocated to this node!\\n\", slot, osb->dev_str);\n\n\tocfs2_set_slot(si, slot, osb->node_num);\n\tosb->slot_num = slot;\n\tspin_unlock(&osb->osb_lock);\n\n\ttrace_ocfs2_find_slot(osb->slot_num);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, osb->slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_super_lock",
          "args": [
            "osb",
            "1"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_super_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2548-2585",
          "snippet": "int ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* The super block lock path is really in the best position to\n\t * know when resources covered by the lock need to be\n\t * refreshed, so we do it here. Of course, making sense of\n\t * everything is up to the caller :) */\n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* The super block lock path is really in the best position to\n\t * know when resources covered by the lock need to be\n\t * refreshed, so we do it here. Of course, making sense of\n\t * everything is up to the caller :) */\n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_init",
          "args": [
            "osb"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2979-3043",
          "snippet": "int ocfs2_dlm_init(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_cluster_connection *conn = NULL;\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tosb->node_num = 0;\n\t\tgoto local;\n\t}\n\n\tstatus = ocfs2_dlm_init_debug(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* launch downconvert thread */\n\tosb->dc_task = kthread_run(ocfs2_downconvert_thread, osb, \"ocfs2dc\");\n\tif (IS_ERR(osb->dc_task)) {\n\t\tstatus = PTR_ERR(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* for now, uuid == domain */\n\tstatus = ocfs2_cluster_connect(osb->osb_cluster_stack,\n\t\t\t\t       osb->osb_cluster_name,\n\t\t\t\t       strlen(osb->osb_cluster_name),\n\t\t\t\t       osb->uuid_str,\n\t\t\t\t       strlen(osb->uuid_str),\n\t\t\t\t       &lproto, ocfs2_do_node_down, osb,\n\t\t\t\t       &conn);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_cluster_this_node(conn, &osb->node_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR,\n\t\t     \"could not find this host's node number\\n\");\n\t\tocfs2_cluster_disconnect(conn, 0);\n\t\tgoto bail;\n\t}\n\nlocal:\n\tocfs2_super_lock_res_init(&osb->osb_super_lockres, osb);\n\tocfs2_rename_lock_res_init(&osb->osb_rename_lockres, osb);\n\tocfs2_nfs_sync_lock_res_init(&osb->osb_nfs_sync_lockres, osb);\n\tocfs2_orphan_scan_lock_res_init(&osb->osb_orphan_scan.os_lockres, osb);\n\n\tosb->cconn = conn;\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tocfs2_dlm_shutdown_debug(osb);\n\t\tif (osb->dc_task)\n\t\t\tkthread_stop(osb->dc_task);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};\n\nint ocfs2_dlm_init(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_cluster_connection *conn = NULL;\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tosb->node_num = 0;\n\t\tgoto local;\n\t}\n\n\tstatus = ocfs2_dlm_init_debug(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* launch downconvert thread */\n\tosb->dc_task = kthread_run(ocfs2_downconvert_thread, osb, \"ocfs2dc\");\n\tif (IS_ERR(osb->dc_task)) {\n\t\tstatus = PTR_ERR(osb->dc_task);\n\t\tosb->dc_task = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* for now, uuid == domain */\n\tstatus = ocfs2_cluster_connect(osb->osb_cluster_stack,\n\t\t\t\t       osb->osb_cluster_name,\n\t\t\t\t       strlen(osb->osb_cluster_name),\n\t\t\t\t       osb->uuid_str,\n\t\t\t\t       strlen(osb->uuid_str),\n\t\t\t\t       &lproto, ocfs2_do_node_down, osb,\n\t\t\t\t       &conn);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_cluster_this_node(conn, &osb->node_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR,\n\t\t     \"could not find this host's node number\\n\");\n\t\tocfs2_cluster_disconnect(conn, 0);\n\t\tgoto bail;\n\t}\n\nlocal:\n\tocfs2_super_lock_res_init(&osb->osb_super_lockres, osb);\n\tocfs2_rename_lock_res_init(&osb->osb_rename_lockres, osb);\n\tocfs2_nfs_sync_lock_res_init(&osb->osb_nfs_sync_lockres, osb);\n\tocfs2_orphan_scan_lock_res_init(&osb->osb_orphan_scan.os_lockres, osb);\n\n\tosb->cconn = conn;\n\n\tstatus = 0;\nbail:\n\tif (status < 0) {\n\t\tocfs2_dlm_shutdown_debug(osb);\n\t\tif (osb->dc_task)\n\t\t\tkthread_stop(osb->dc_task);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_mount_volume(struct super_block *sb)\n{\n\tint status = 0;\n\tint unlock_super = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\tgoto leave;\n\n\tstatus = ocfs2_dlm_init(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_super_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tunlock_super = 1;\n\n\t/* This will load up the node map and add ourselves to it. */\n\tstatus = ocfs2_find_slot(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* load all node-local system inodes */\n\tstatus = ocfs2_init_local_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_volume(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_truncate_log_init(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nleave:\n\tif (unlock_super)\n\t\tocfs2_super_unlock(osb, 1);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_get_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1810-1839",
    "snippet": "static int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size)\n{\n\tif (!sb_set_blocksize(sb, sect_size)) {\n\t\tmlog(ML_ERROR, \"unable to set blocksize\\n\");\n\t\treturn -EIO;\n\t}\n\n\t*bh = sb_getblk(sb, block);\n\tif (!*bh) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\tlock_buffer(*bh);\n\tif (!buffer_dirty(*bh))\n\t\tclear_buffer_uptodate(*bh);\n\tunlock_buffer(*bh);\n\tll_rw_block(READ, 1, bh);\n\twait_on_buffer(*bh);\n\tif (!buffer_uptodate(*bh)) {\n\t\tmlog_errno(-EIO);\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bh"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-EIO"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "*bh"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "*bh"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "bh"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "*bh"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "*bh"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "*bh"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"unable to set blocksize\\n\""
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "sect_size"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size)\n{\n\tif (!sb_set_blocksize(sb, sect_size)) {\n\t\tmlog(ML_ERROR, \"unable to set blocksize\\n\");\n\t\treturn -EIO;\n\t}\n\n\t*bh = sb_getblk(sb, block);\n\tif (!*bh) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\tlock_buffer(*bh);\n\tif (!buffer_dirty(*bh))\n\t\tclear_buffer_uptodate(*bh);\n\tunlock_buffer(*bh);\n\tll_rw_block(READ, 1, bh);\n\twait_on_buffer(*bh);\n\tif (!buffer_uptodate(*bh)) {\n\t\tmlog_errno(-EIO);\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_free_mem_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1790-1808",
    "snippet": "static void ocfs2_free_mem_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tif (ocfs2_inode_cachep)\n\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\tocfs2_inode_cachep = NULL;\n\n\tif (ocfs2_dquot_cachep)\n\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\tocfs2_dquot_cachep = NULL;\n\n\tif (ocfs2_qf_chunk_cachep)\n\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\tocfs2_qf_chunk_cachep = NULL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ocfs2_inode_cachep;",
      "struct kmem_cache *ocfs2_dquot_cachep;",
      "struct kmem_cache *ocfs2_qf_chunk_cachep;",
      "static void ocfs2_free_mem_caches(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ocfs2_qf_chunk_cachep"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ocfs2_dquot_cachep"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ocfs2_inode_cachep"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ocfs2_inode_cachep;\nstruct kmem_cache *ocfs2_dquot_cachep;\nstruct kmem_cache *ocfs2_qf_chunk_cachep;\nstatic void ocfs2_free_mem_caches(void);\n\nstatic void ocfs2_free_mem_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tif (ocfs2_inode_cachep)\n\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\tocfs2_inode_cachep = NULL;\n\n\tif (ocfs2_dquot_cachep)\n\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\tocfs2_dquot_cachep = NULL;\n\n\tif (ocfs2_qf_chunk_cachep)\n\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\tocfs2_qf_chunk_cachep = NULL;\n}"
  },
  {
    "function_name": "ocfs2_initialize_mem_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1757-1788",
    "snippet": "static int ocfs2_initialize_mem_caches(void)\n{\n\tocfs2_inode_cachep = kmem_cache_create(\"ocfs2_inode_cache\",\n\t\t\t\t       sizeof(struct ocfs2_inode_info),\n\t\t\t\t       0,\n\t\t\t\t       (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t       ocfs2_inode_init_once);\n\tocfs2_dquot_cachep = kmem_cache_create(\"ocfs2_dquot_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_dquot),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tocfs2_qf_chunk_cachep = kmem_cache_create(\"ocfs2_qf_chunk_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_quota_chunk),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tif (!ocfs2_inode_cachep || !ocfs2_dquot_cachep ||\n\t    !ocfs2_qf_chunk_cachep) {\n\t\tif (ocfs2_inode_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\t\tif (ocfs2_dquot_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\t\tif (ocfs2_qf_chunk_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ocfs2_inode_cachep;",
      "struct kmem_cache *ocfs2_dquot_cachep;",
      "struct kmem_cache *ocfs2_qf_chunk_cachep;",
      "static int ocfs2_initialize_mem_caches(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ocfs2_qf_chunk_cachep"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ocfs2_dquot_cachep"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ocfs2_inode_cachep"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ocfs2_qf_chunk_cache\"",
            "sizeof(struct ocfs2_quota_chunk)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD)",
            "NULL"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ocfs2_dquot_cache\"",
            "sizeof(struct ocfs2_dquot)",
            "0",
            "(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "NULL"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ocfs2_inode_cache\"",
            "sizeof(struct ocfs2_inode_info)",
            "0",
            "(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "ocfs2_inode_init_once"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ocfs2_inode_cachep;\nstruct kmem_cache *ocfs2_dquot_cachep;\nstruct kmem_cache *ocfs2_qf_chunk_cachep;\nstatic int ocfs2_initialize_mem_caches(void);\n\nstatic int ocfs2_initialize_mem_caches(void)\n{\n\tocfs2_inode_cachep = kmem_cache_create(\"ocfs2_inode_cache\",\n\t\t\t\t       sizeof(struct ocfs2_inode_info),\n\t\t\t\t       0,\n\t\t\t\t       (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t       ocfs2_inode_init_once);\n\tocfs2_dquot_cachep = kmem_cache_create(\"ocfs2_dquot_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_dquot),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tocfs2_qf_chunk_cachep = kmem_cache_create(\"ocfs2_qf_chunk_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_quota_chunk),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tif (!ocfs2_inode_cachep || !ocfs2_dquot_cachep ||\n\t    !ocfs2_qf_chunk_cachep) {\n\t\tif (ocfs2_inode_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\t\tif (ocfs2_dquot_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\t\tif (ocfs2_qf_chunk_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1725-1755",
    "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&oi->vfs_inode"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_init",
          "args": [
            "INODE_CACHE(&oi->vfs_inode)",
            "&ocfs2_inode_caching_ops"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "127-134",
          "snippet": "void ocfs2_metadata_cache_init(struct ocfs2_caching_info *ci,\n\t\t\t       const struct ocfs2_caching_operations *ops)\n{\n\tBUG_ON(!ops);\n\n\tci->ci_ops = ops;\n\tocfs2_metadata_cache_reset(ci, 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_init(struct ocfs2_caching_info *ci,\n\t\t\t       const struct ocfs2_caching_operations *ops)\n{\n\tBUG_ON(!ops);\n\n\tci->ci_ops = ops;\n\tocfs2_metadata_cache_reset(ci, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "&oi->vfs_inode"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&oi->append_dio_wq"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_init_once",
          "args": [
            "&oi->ip_open_lockres"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "526-534",
          "snippet": "void ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\n{\n\t/* This also clears out the lock status block */\n\tmemset(res, 0, sizeof(struct ocfs2_lock_res));\n\tspin_lock_init(&res->l_lock);\n\tinit_waitqueue_head(&res->l_event);\n\tINIT_LIST_HEAD(&res->l_blocked_list);\n\tINIT_LIST_HEAD(&res->l_mask_waiters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_init_once",
          "args": [
            "&oi->ip_la_data_resv"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "200-204",
          "snippet": "void ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&oi->ip_io_mutex"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&oi->ip_xattr_sem"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&oi->ip_unaligned_aio"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&oi->ip_io_markers"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_init",
          "args": [
            "&oi->vfs_inode"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "54-60",
          "snippet": "void ocfs2_extent_map_init(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->ip_extent_map.em_num_items = 0;\n\tINIT_LIST_HEAD(&oi->ip_extent_map.em_list);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_init(struct inode *inode)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->ip_extent_map.em_num_items = 0;\n\tINIT_LIST_HEAD(&oi->ip_extent_map.em_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
  },
  {
    "function_name": "ocfs2_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1663-1723",
    "snippet": "static int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ocfs2_super *osb;\n\tu32 numbits, freebits;\n\tint status;\n\tstruct ocfs2_dinode *bm_lock;\n\tstruct buffer_head *bh = NULL;\n\tstruct inode *inode = NULL;\n\n\ttrace_ocfs2_statfs(dentry->d_sb, buf);\n\n\tosb = OCFS2_SB(dentry->d_sb);\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"failed to get bitmap inode\\n\");\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbm_lock = (struct ocfs2_dinode *) bh->b_data;\n\n\tnumbits = le32_to_cpu(bm_lock->id1.bitmap1.i_total);\n\tfreebits = numbits - le32_to_cpu(bm_lock->id1.bitmap1.i_used);\n\n\tbuf->f_type = OCFS2_SUPER_MAGIC;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\tbuf->f_namelen = OCFS2_MAX_FILENAME_LEN;\n\tbuf->f_blocks = ((sector_t) numbits) *\n\t\t\t(osb->s_clustersize >> osb->sb->s_blocksize_bits);\n\tbuf->f_bfree = ((sector_t) freebits) *\n\t\t       (osb->s_clustersize >> osb->sb->s_blocksize_bits);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = numbits;\n\tbuf->f_ffree = freebits;\n\tbuf->f_fsid.val[0] = crc32_le(0, osb->uuid_str, OCFS2_VOL_UUID_LEN)\n\t\t\t\t& 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = crc32_le(0, osb->uuid_str + OCFS2_VOL_UUID_LEN,\n\t\t\t\tOCFS2_VOL_UUID_LEN) & 0xFFFFFFFFUL;\n\n\tbrelse(bh);\n\n\tocfs2_inode_unlock(inode, 0);\n\tstatus = 0;\nbail:\n\tif (inode)\n\t\tiput(inode);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "0",
            "osb->uuid_str + OCFS2_VOL_UUID_LEN",
            "OCFS2_VOL_UUID_LEN"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "0",
            "osb->uuid_str",
            "OCFS2_VOL_UUID_LEN"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bm_lock->id1.bitmap1.i_used"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&bh",
            "0"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"failed to get bitmap inode\\n\""
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_statfs",
          "args": [
            "dentry->d_sb",
            "buf"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ocfs2_super *osb;\n\tu32 numbits, freebits;\n\tint status;\n\tstruct ocfs2_dinode *bm_lock;\n\tstruct buffer_head *bh = NULL;\n\tstruct inode *inode = NULL;\n\n\ttrace_ocfs2_statfs(dentry->d_sb, buf);\n\n\tosb = OCFS2_SB(dentry->d_sb);\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tmlog(ML_ERROR, \"failed to get bitmap inode\\n\");\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbm_lock = (struct ocfs2_dinode *) bh->b_data;\n\n\tnumbits = le32_to_cpu(bm_lock->id1.bitmap1.i_total);\n\tfreebits = numbits - le32_to_cpu(bm_lock->id1.bitmap1.i_used);\n\n\tbuf->f_type = OCFS2_SUPER_MAGIC;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\tbuf->f_namelen = OCFS2_MAX_FILENAME_LEN;\n\tbuf->f_blocks = ((sector_t) numbits) *\n\t\t\t(osb->s_clustersize >> osb->sb->s_blocksize_bits);\n\tbuf->f_bfree = ((sector_t) freebits) *\n\t\t       (osb->s_clustersize >> osb->sb->s_blocksize_bits);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = numbits;\n\tbuf->f_ffree = freebits;\n\tbuf->f_fsid.val[0] = crc32_le(0, osb->uuid_str, OCFS2_VOL_UUID_LEN)\n\t\t\t\t& 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = crc32_le(0, osb->uuid_str + OCFS2_VOL_UUID_LEN,\n\t\t\t\tOCFS2_VOL_UUID_LEN) & 0xFFFFFFFFUL;\n\n\tbrelse(bh);\n\n\tocfs2_inode_unlock(inode, 0);\n\tstatus = 0;\nbail:\n\tif (inode)\n\t\tiput(inode);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1655-1661",
    "snippet": "static void ocfs2_put_super(struct super_block *sb)\n{\n\ttrace_ocfs2_put_super(sb);\n\n\tocfs2_sync_blockdev(sb);\n\tocfs2_dismount_volume(sb, 0);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_dismount_volume",
          "args": [
            "sb",
            "0"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dismount_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1894-1982",
          "snippet": "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sync_blockdev",
          "args": [
            "sb"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "548-551",
          "snippet": "void ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_sync_blockdev(struct super_block *sb)\n{\n\tsync_blockdev(sb->s_bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_put_super",
          "args": [
            "sb"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic void ocfs2_put_super(struct super_block *sb)\n{\n\ttrace_ocfs2_put_super(sb);\n\n\tocfs2_sync_blockdev(sb);\n\tocfs2_dismount_volume(sb, 0);\n}"
  },
  {
    "function_name": "ocfs2_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1637-1653",
    "snippet": "static void __exit ocfs2_exit(void)\n{\n\tif (ocfs2_wq) {\n\t\tflush_workqueue(ocfs2_wq);\n\t\tdestroy_workqueue(ocfs2_wq);\n\t}\n\n\tunregister_quota_format(&ocfs2_quota_format);\n\n\tdebugfs_remove(ocfs2_debugfs_root);\n\n\tocfs2_free_mem_caches();\n\n\tunregister_filesystem(&ocfs2_fs_type);\n\n\texit_ocfs2_uptodate_cache();\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *ocfs2_wq = NULL;",
      "static struct dentry *ocfs2_debugfs_root;",
      "static void ocfs2_free_mem_caches(void);",
      "static struct file_system_type ocfs2_fs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"ocfs2\",\n\t.mount          = ocfs2_mount,\n\t.kill_sb        = kill_block_super,\n\t.fs_flags       = FS_REQUIRES_DEV|FS_RENAME_DOES_D_MOVE,\n\t.next           = NULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_ocfs2_uptodate_cache",
          "args": [],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "exit_ocfs2_uptodate_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "634-638",
          "snippet": "void exit_ocfs2_uptodate_cache(void)\n{\n\tif (ocfs2_uptodate_cachep)\n\t\tkmem_cache_destroy(ocfs2_uptodate_cachep);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ocfs2_uptodate_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ocfs2_uptodate_cachep;\n\nvoid exit_ocfs2_uptodate_cache(void)\n{\n\tif (ocfs2_uptodate_cachep)\n\t\tkmem_cache_destroy(ocfs2_uptodate_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ocfs2_fs_type"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_mem_caches",
          "args": [],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_mem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1790-1808",
          "snippet": "static void ocfs2_free_mem_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tif (ocfs2_inode_cachep)\n\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\tocfs2_inode_cachep = NULL;\n\n\tif (ocfs2_dquot_cachep)\n\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\tocfs2_dquot_cachep = NULL;\n\n\tif (ocfs2_qf_chunk_cachep)\n\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\tocfs2_qf_chunk_cachep = NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ocfs2_inode_cachep;",
            "struct kmem_cache *ocfs2_dquot_cachep;",
            "struct kmem_cache *ocfs2_qf_chunk_cachep;",
            "static void ocfs2_free_mem_caches(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ocfs2_inode_cachep;\nstruct kmem_cache *ocfs2_dquot_cachep;\nstruct kmem_cache *ocfs2_qf_chunk_cachep;\nstatic void ocfs2_free_mem_caches(void);\n\nstatic void ocfs2_free_mem_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tif (ocfs2_inode_cachep)\n\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\tocfs2_inode_cachep = NULL;\n\n\tif (ocfs2_dquot_cachep)\n\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\tocfs2_dquot_cachep = NULL;\n\n\tif (ocfs2_qf_chunk_cachep)\n\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\tocfs2_qf_chunk_cachep = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "ocfs2_debugfs_root"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_quota_format",
          "args": [
            "&ocfs2_quota_format"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_quota_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "171-182",
          "snippet": "void unregister_quota_format(struct quota_format_type *fmt)\n{\n\tstruct quota_format_type **actqf;\n\n\tspin_lock(&dq_list_lock);\n\tfor (actqf = &quota_formats; *actqf && *actqf != fmt;\n\t     actqf = &(*actqf)->qf_next)\n\t\t;\n\tif (*actqf)\n\t\t*actqf = (*actqf)->qf_next;\n\tspin_unlock(&dq_list_lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static struct quota_format_type *quota_formats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic struct quota_format_type *quota_formats;\n\nvoid unregister_quota_format(struct quota_format_type *fmt)\n{\n\tstruct quota_format_type **actqf;\n\n\tspin_lock(&dq_list_lock);\n\tfor (actqf = &quota_formats; *actqf && *actqf != fmt;\n\t     actqf = &(*actqf)->qf_next)\n\t\t;\n\tif (*actqf)\n\t\t*actqf = (*actqf)->qf_next;\n\tspin_unlock(&dq_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "ocfs2_wq"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "ocfs2_wq"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct workqueue_struct *ocfs2_wq = NULL;\nstatic struct dentry *ocfs2_debugfs_root;\nstatic void ocfs2_free_mem_caches(void);\nstatic struct file_system_type ocfs2_fs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"ocfs2\",\n\t.mount          = ocfs2_mount,\n\t.kill_sb        = kill_block_super,\n\t.fs_flags       = FS_REQUIRES_DEV|FS_RENAME_DOES_D_MOVE,\n\t.next           = NULL\n};\n\nstatic void __exit ocfs2_exit(void)\n{\n\tif (ocfs2_wq) {\n\t\tflush_workqueue(ocfs2_wq);\n\t\tdestroy_workqueue(ocfs2_wq);\n\t}\n\n\tunregister_quota_format(&ocfs2_quota_format);\n\n\tdebugfs_remove(ocfs2_debugfs_root);\n\n\tocfs2_free_mem_caches();\n\n\tunregister_filesystem(&ocfs2_fs_type);\n\n\texit_ocfs2_uptodate_cache();\n}"
  },
  {
    "function_name": "ocfs2_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1590-1635",
    "snippet": "static int __init ocfs2_init(void)\n{\n\tint status;\n\n\tstatus = init_ocfs2_uptodate_cache();\n\tif (status < 0)\n\t\tgoto out1;\n\n\tstatus = ocfs2_initialize_mem_caches();\n\tif (status < 0)\n\t\tgoto out2;\n\n\tocfs2_wq = create_singlethread_workqueue(\"ocfs2_wq\");\n\tif (!ocfs2_wq) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out3;\n\t}\n\n\tocfs2_debugfs_root = debugfs_create_dir(\"ocfs2\", NULL);\n\tif (!ocfs2_debugfs_root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create ocfs2 debugfs root.\\n\");\n\t\tgoto out4;\n\t}\n\n\tocfs2_set_locking_protocol();\n\n\tstatus = register_quota_format(&ocfs2_quota_format);\n\tif (status < 0)\n\t\tgoto out4;\n\tstatus = register_filesystem(&ocfs2_fs_type);\n\tif (!status)\n\t\treturn 0;\n\n\tunregister_quota_format(&ocfs2_quota_format);\nout4:\n\tdestroy_workqueue(ocfs2_wq);\n\tdebugfs_remove(ocfs2_debugfs_root);\nout3:\n\tocfs2_free_mem_caches();\nout2:\n\texit_ocfs2_uptodate_cache();\nout1:\n\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *ocfs2_wq = NULL;",
      "static struct dentry *ocfs2_debugfs_root;",
      "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
      "static int ocfs2_initialize_mem_caches(void);",
      "static void ocfs2_free_mem_caches(void);",
      "static struct file_system_type ocfs2_fs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"ocfs2\",\n\t.mount          = ocfs2_mount,\n\t.kill_sb        = kill_block_super,\n\t.fs_flags       = FS_REQUIRES_DEV|FS_RENAME_DOES_D_MOVE,\n\t.next           = NULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_ocfs2_uptodate_cache",
          "args": [],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "exit_ocfs2_uptodate_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "634-638",
          "snippet": "void exit_ocfs2_uptodate_cache(void)\n{\n\tif (ocfs2_uptodate_cachep)\n\t\tkmem_cache_destroy(ocfs2_uptodate_cachep);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ocfs2_uptodate_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ocfs2_uptodate_cachep;\n\nvoid exit_ocfs2_uptodate_cache(void)\n{\n\tif (ocfs2_uptodate_cachep)\n\t\tkmem_cache_destroy(ocfs2_uptodate_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_mem_caches",
          "args": [],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_mem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1790-1808",
          "snippet": "static void ocfs2_free_mem_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tif (ocfs2_inode_cachep)\n\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\tocfs2_inode_cachep = NULL;\n\n\tif (ocfs2_dquot_cachep)\n\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\tocfs2_dquot_cachep = NULL;\n\n\tif (ocfs2_qf_chunk_cachep)\n\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\tocfs2_qf_chunk_cachep = NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ocfs2_inode_cachep;",
            "struct kmem_cache *ocfs2_dquot_cachep;",
            "struct kmem_cache *ocfs2_qf_chunk_cachep;",
            "static void ocfs2_free_mem_caches(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ocfs2_inode_cachep;\nstruct kmem_cache *ocfs2_dquot_cachep;\nstruct kmem_cache *ocfs2_qf_chunk_cachep;\nstatic void ocfs2_free_mem_caches(void);\n\nstatic void ocfs2_free_mem_caches(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tif (ocfs2_inode_cachep)\n\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\tocfs2_inode_cachep = NULL;\n\n\tif (ocfs2_dquot_cachep)\n\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\tocfs2_dquot_cachep = NULL;\n\n\tif (ocfs2_qf_chunk_cachep)\n\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\tocfs2_qf_chunk_cachep = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "ocfs2_debugfs_root"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "ocfs2_wq"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_quota_format",
          "args": [
            "&ocfs2_quota_format"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_quota_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "171-182",
          "snippet": "void unregister_quota_format(struct quota_format_type *fmt)\n{\n\tstruct quota_format_type **actqf;\n\n\tspin_lock(&dq_list_lock);\n\tfor (actqf = &quota_formats; *actqf && *actqf != fmt;\n\t     actqf = &(*actqf)->qf_next)\n\t\t;\n\tif (*actqf)\n\t\t*actqf = (*actqf)->qf_next;\n\tspin_unlock(&dq_list_lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static struct quota_format_type *quota_formats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic struct quota_format_type *quota_formats;\n\nvoid unregister_quota_format(struct quota_format_type *fmt)\n{\n\tstruct quota_format_type **actqf;\n\n\tspin_lock(&dq_list_lock);\n\tfor (actqf = &quota_formats; *actqf && *actqf != fmt;\n\t     actqf = &(*actqf)->qf_next)\n\t\t;\n\tif (*actqf)\n\t\t*actqf = (*actqf)->qf_next;\n\tspin_unlock(&dq_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ocfs2_fs_type"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_locking_protocol",
          "args": [],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_locking_protocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1194-1197",
          "snippet": "void ocfs2_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&lproto.lp_max_version);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_locking_protocol lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= ocfs2_locking_ast,\n\t.lp_blocking_ast\t= ocfs2_blocking_ast,\n\t.lp_unlock_ast\t\t= ocfs2_unlock_ast,\n};\n\nvoid ocfs2_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&lproto.lp_max_version);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unable to create ocfs2 debugfs root.\\n\""
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"ocfs2\"",
            "NULL"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "407-429",
          "snippet": "struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"ocfs2_wq\""
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_initialize_mem_caches",
          "args": [],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_initialize_mem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1757-1788",
          "snippet": "static int ocfs2_initialize_mem_caches(void)\n{\n\tocfs2_inode_cachep = kmem_cache_create(\"ocfs2_inode_cache\",\n\t\t\t\t       sizeof(struct ocfs2_inode_info),\n\t\t\t\t       0,\n\t\t\t\t       (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t       ocfs2_inode_init_once);\n\tocfs2_dquot_cachep = kmem_cache_create(\"ocfs2_dquot_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_dquot),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tocfs2_qf_chunk_cachep = kmem_cache_create(\"ocfs2_qf_chunk_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_quota_chunk),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tif (!ocfs2_inode_cachep || !ocfs2_dquot_cachep ||\n\t    !ocfs2_qf_chunk_cachep) {\n\t\tif (ocfs2_inode_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\t\tif (ocfs2_dquot_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\t\tif (ocfs2_qf_chunk_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ocfs2_inode_cachep;",
            "struct kmem_cache *ocfs2_dquot_cachep;",
            "struct kmem_cache *ocfs2_qf_chunk_cachep;",
            "static int ocfs2_initialize_mem_caches(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ocfs2_inode_cachep;\nstruct kmem_cache *ocfs2_dquot_cachep;\nstruct kmem_cache *ocfs2_qf_chunk_cachep;\nstatic int ocfs2_initialize_mem_caches(void);\n\nstatic int ocfs2_initialize_mem_caches(void)\n{\n\tocfs2_inode_cachep = kmem_cache_create(\"ocfs2_inode_cache\",\n\t\t\t\t       sizeof(struct ocfs2_inode_info),\n\t\t\t\t       0,\n\t\t\t\t       (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t       ocfs2_inode_init_once);\n\tocfs2_dquot_cachep = kmem_cache_create(\"ocfs2_dquot_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_dquot),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tocfs2_qf_chunk_cachep = kmem_cache_create(\"ocfs2_qf_chunk_cache\",\n\t\t\t\t\tsizeof(struct ocfs2_quota_chunk),\n\t\t\t\t\t0,\n\t\t\t\t\t(SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD),\n\t\t\t\t\tNULL);\n\tif (!ocfs2_inode_cachep || !ocfs2_dquot_cachep ||\n\t    !ocfs2_qf_chunk_cachep) {\n\t\tif (ocfs2_inode_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_inode_cachep);\n\t\tif (ocfs2_dquot_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_dquot_cachep);\n\t\tif (ocfs2_qf_chunk_cachep)\n\t\t\tkmem_cache_destroy(ocfs2_qf_chunk_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_ocfs2_uptodate_cache",
          "args": [],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "init_ocfs2_uptodate_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "623-632",
          "snippet": "int __init init_ocfs2_uptodate_cache(void)\n{\n\tocfs2_uptodate_cachep = kmem_cache_create(\"ocfs2_uptodate\",\n\t\t\t\t  sizeof(struct ocfs2_meta_cache_item),\n\t\t\t\t  0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!ocfs2_uptodate_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ocfs2_uptodate_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *ocfs2_uptodate_cachep;\n\nint __init init_ocfs2_uptodate_cache(void)\n{\n\tocfs2_uptodate_cachep = kmem_cache_create(\"ocfs2_uptodate\",\n\t\t\t\t  sizeof(struct ocfs2_meta_cache_item),\n\t\t\t\t  0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!ocfs2_uptodate_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct workqueue_struct *ocfs2_wq = NULL;\nstatic struct dentry *ocfs2_debugfs_root;\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic int ocfs2_initialize_mem_caches(void);\nstatic void ocfs2_free_mem_caches(void);\nstatic struct file_system_type ocfs2_fs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"ocfs2\",\n\t.mount          = ocfs2_mount,\n\t.kill_sb        = kill_block_super,\n\t.fs_flags       = FS_REQUIRES_DEV|FS_RENAME_DOES_D_MOVE,\n\t.next           = NULL\n};\n\nstatic int __init ocfs2_init(void)\n{\n\tint status;\n\n\tstatus = init_ocfs2_uptodate_cache();\n\tif (status < 0)\n\t\tgoto out1;\n\n\tstatus = ocfs2_initialize_mem_caches();\n\tif (status < 0)\n\t\tgoto out2;\n\n\tocfs2_wq = create_singlethread_workqueue(\"ocfs2_wq\");\n\tif (!ocfs2_wq) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out3;\n\t}\n\n\tocfs2_debugfs_root = debugfs_create_dir(\"ocfs2\", NULL);\n\tif (!ocfs2_debugfs_root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create ocfs2 debugfs root.\\n\");\n\t\tgoto out4;\n\t}\n\n\tocfs2_set_locking_protocol();\n\n\tstatus = register_quota_format(&ocfs2_quota_format);\n\tif (status < 0)\n\t\tgoto out4;\n\tstatus = register_filesystem(&ocfs2_fs_type);\n\tif (!status)\n\t\treturn 0;\n\n\tunregister_quota_format(&ocfs2_quota_format);\nout4:\n\tdestroy_workqueue(ocfs2_wq);\n\tdebugfs_remove(ocfs2_debugfs_root);\nout3:\n\tocfs2_free_mem_caches();\nout2:\n\texit_ocfs2_uptodate_cache();\nout1:\n\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1505-1588",
    "snippet": "static int ocfs2_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(root->d_sb);\n\tunsigned long opts = osb->s_mount_opt;\n\tunsigned int local_alloc_megs;\n\n\tif (opts & (OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL)) {\n\t\tseq_printf(s, \",_netdev\");\n\t\tif (opts & OCFS2_MOUNT_HB_LOCAL)\n\t\t\tseq_printf(s, \",%s\", OCFS2_HB_LOCAL);\n\t\telse\n\t\t\tseq_printf(s, \",%s\", OCFS2_HB_GLOBAL);\n\t} else\n\t\tseq_printf(s, \",%s\", OCFS2_HB_NONE);\n\n\tif (opts & OCFS2_MOUNT_NOINTR)\n\t\tseq_printf(s, \",nointr\");\n\n\tif (opts & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\tseq_printf(s, \",data=writeback\");\n\telse\n\t\tseq_printf(s, \",data=ordered\");\n\n\tif (opts & OCFS2_MOUNT_BARRIER)\n\t\tseq_printf(s, \",barrier=1\");\n\n\tif (opts & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tseq_printf(s, \",errors=panic\");\n\telse\n\t\tseq_printf(s, \",errors=remount-ro\");\n\n\tif (osb->preferred_slot != OCFS2_INVALID_SLOT)\n\t\tseq_printf(s, \",preferred_slot=%d\", osb->preferred_slot);\n\n\tseq_printf(s, \",atime_quantum=%u\", osb->s_atime_quantum);\n\n\tif (osb->osb_commit_interval)\n\t\tseq_printf(s, \",commit=%u\",\n\t\t\t   (unsigned) (osb->osb_commit_interval / HZ));\n\n\tlocal_alloc_megs = osb->local_alloc_bits >> (20 - osb->s_clustersize_bits);\n\tif (local_alloc_megs != ocfs2_la_default_mb(osb))\n\t\tseq_printf(s, \",localalloc=%d\", local_alloc_megs);\n\n\tif (opts & OCFS2_MOUNT_LOCALFLOCKS)\n\t\tseq_printf(s, \",localflocks,\");\n\n\tif (osb->osb_cluster_stack[0])\n\t\tseq_printf(s, \",cluster_stack=%.*s\", OCFS2_STACK_LABEL_LEN,\n\t\t\t   osb->osb_cluster_stack);\n\tif (opts & OCFS2_MOUNT_USRQUOTA)\n\t\tseq_printf(s, \",usrquota\");\n\tif (opts & OCFS2_MOUNT_GRPQUOTA)\n\t\tseq_printf(s, \",grpquota\");\n\n\tif (opts & OCFS2_MOUNT_COHERENCY_BUFFERED)\n\t\tseq_printf(s, \",coherency=buffered\");\n\telse\n\t\tseq_printf(s, \",coherency=full\");\n\n\tif (opts & OCFS2_MOUNT_NOUSERXATTR)\n\t\tseq_printf(s, \",nouser_xattr\");\n\telse\n\t\tseq_printf(s, \",user_xattr\");\n\n\tif (opts & OCFS2_MOUNT_INODE64)\n\t\tseq_printf(s, \",inode64\");\n\n\tif (opts & OCFS2_MOUNT_POSIX_ACL)\n\t\tseq_printf(s, \",acl\");\n\telse\n\t\tseq_printf(s, \",noacl\");\n\n\tif (osb->osb_resv_level != OCFS2_DEFAULT_RESV_LEVEL)\n\t\tseq_printf(s, \",resv_level=%d\", osb->osb_resv_level);\n\n\tif (osb->osb_dir_resv_level != osb->osb_resv_level)\n\t\tseq_printf(s, \",dir_resv_level=%d\", osb->osb_resv_level);\n\n\tif (opts & OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT)\n\t\tseq_printf(s, \",journal_async_commit\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
      "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\",journal_async_commit\""
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_la_default_mb",
          "args": [
            "osb"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_la_default_mb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "117-193",
          "snippet": "unsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t/*\n\t * This takes care of files systems with very small group\n\t * descriptors - 512 byte blocksize at cluster sizes lower\n\t * than 16K and also 1k blocksize with 4k cluster size.\n\t */\n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t/*\n\t * Leave enough room for some block groups and make the final\n\t * value we work from a multiple of 4.\n\t */\n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t/*\n\t * Keep window sizes down to a reasonable default\n\t */\n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t/*\n\t\t * Some clustersize / blocksize combinations will have\n\t\t * given us a larger than OCFS2_LA_MAX_DEFAULT_MB\n\t\t * default size, but get poor distribution when\n\t\t * limited to exactly 256 megabytes.\n\t\t *\n\t\t * As an example, 16K clustersize at 4K blocksize\n\t\t * gives us a cluster group size of 504M. Paring the\n\t\t * local alloc size down to 256 however, would give us\n\t\t * only one window and around 200MB left in the\n\t\t * cluster group. Instead, find the first size below\n\t\t * 256 which would give us an even distribution.\n\t\t *\n\t\t * Larger cluster group sizes actually work out pretty\n\t\t * well when pared to 256, so we don't have to do this\n\t\t * for any group that fits more than two\n\t\t * OCFS2_LA_MAX_DEFAULT_MB windows.\n\t\t */\n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t/* Too many nodes, too few disk clusters. */\n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t/* We can't store more bits than we can in a block. */\n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tOCFS2_LA_OLD_DEFAULT\t8",
            "#define\tOCFS2_LA_MAX_DEFAULT_MB\t256"
          ],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define\tOCFS2_LA_OLD_DEFAULT\t8\n#define\tOCFS2_LA_MAX_DEFAULT_MB\t256\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nunsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t/*\n\t * This takes care of files systems with very small group\n\t * descriptors - 512 byte blocksize at cluster sizes lower\n\t * than 16K and also 1k blocksize with 4k cluster size.\n\t */\n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t/*\n\t * Leave enough room for some block groups and make the final\n\t * value we work from a multiple of 4.\n\t */\n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t/*\n\t * Keep window sizes down to a reasonable default\n\t */\n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t/*\n\t\t * Some clustersize / blocksize combinations will have\n\t\t * given us a larger than OCFS2_LA_MAX_DEFAULT_MB\n\t\t * default size, but get poor distribution when\n\t\t * limited to exactly 256 megabytes.\n\t\t *\n\t\t * As an example, 16K clustersize at 4K blocksize\n\t\t * gives us a cluster group size of 504M. Paring the\n\t\t * local alloc size down to 256 however, would give us\n\t\t * only one window and around 200MB left in the\n\t\t * cluster group. Instead, find the first size below\n\t\t * 256 which would give us an even distribution.\n\t\t *\n\t\t * Larger cluster group sizes actually work out pretty\n\t\t * well when pared to 256, so we don't have to do this\n\t\t * for any group that fits more than two\n\t\t * OCFS2_LA_MAX_DEFAULT_MB windows.\n\t\t */\n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t/* Too many nodes, too few disk clusters. */\n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t/* We can't store more bits than we can in a block. */\n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "root->d_sb"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(root->d_sb);\n\tunsigned long opts = osb->s_mount_opt;\n\tunsigned int local_alloc_megs;\n\n\tif (opts & (OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL)) {\n\t\tseq_printf(s, \",_netdev\");\n\t\tif (opts & OCFS2_MOUNT_HB_LOCAL)\n\t\t\tseq_printf(s, \",%s\", OCFS2_HB_LOCAL);\n\t\telse\n\t\t\tseq_printf(s, \",%s\", OCFS2_HB_GLOBAL);\n\t} else\n\t\tseq_printf(s, \",%s\", OCFS2_HB_NONE);\n\n\tif (opts & OCFS2_MOUNT_NOINTR)\n\t\tseq_printf(s, \",nointr\");\n\n\tif (opts & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\tseq_printf(s, \",data=writeback\");\n\telse\n\t\tseq_printf(s, \",data=ordered\");\n\n\tif (opts & OCFS2_MOUNT_BARRIER)\n\t\tseq_printf(s, \",barrier=1\");\n\n\tif (opts & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tseq_printf(s, \",errors=panic\");\n\telse\n\t\tseq_printf(s, \",errors=remount-ro\");\n\n\tif (osb->preferred_slot != OCFS2_INVALID_SLOT)\n\t\tseq_printf(s, \",preferred_slot=%d\", osb->preferred_slot);\n\n\tseq_printf(s, \",atime_quantum=%u\", osb->s_atime_quantum);\n\n\tif (osb->osb_commit_interval)\n\t\tseq_printf(s, \",commit=%u\",\n\t\t\t   (unsigned) (osb->osb_commit_interval / HZ));\n\n\tlocal_alloc_megs = osb->local_alloc_bits >> (20 - osb->s_clustersize_bits);\n\tif (local_alloc_megs != ocfs2_la_default_mb(osb))\n\t\tseq_printf(s, \",localalloc=%d\", local_alloc_megs);\n\n\tif (opts & OCFS2_MOUNT_LOCALFLOCKS)\n\t\tseq_printf(s, \",localflocks,\");\n\n\tif (osb->osb_cluster_stack[0])\n\t\tseq_printf(s, \",cluster_stack=%.*s\", OCFS2_STACK_LABEL_LEN,\n\t\t\t   osb->osb_cluster_stack);\n\tif (opts & OCFS2_MOUNT_USRQUOTA)\n\t\tseq_printf(s, \",usrquota\");\n\tif (opts & OCFS2_MOUNT_GRPQUOTA)\n\t\tseq_printf(s, \",grpquota\");\n\n\tif (opts & OCFS2_MOUNT_COHERENCY_BUFFERED)\n\t\tseq_printf(s, \",coherency=buffered\");\n\telse\n\t\tseq_printf(s, \",coherency=full\");\n\n\tif (opts & OCFS2_MOUNT_NOUSERXATTR)\n\t\tseq_printf(s, \",nouser_xattr\");\n\telse\n\t\tseq_printf(s, \",user_xattr\");\n\n\tif (opts & OCFS2_MOUNT_INODE64)\n\t\tseq_printf(s, \",inode64\");\n\n\tif (opts & OCFS2_MOUNT_POSIX_ACL)\n\t\tseq_printf(s, \",acl\");\n\telse\n\t\tseq_printf(s, \",noacl\");\n\n\tif (osb->osb_resv_level != OCFS2_DEFAULT_RESV_LEVEL)\n\t\tseq_printf(s, \",resv_level=%d\", osb->osb_resv_level);\n\n\tif (osb->osb_dir_resv_level != osb->osb_resv_level)\n\t\tseq_printf(s, \",dir_resv_level=%d\", osb->osb_resv_level);\n\n\tif (opts & OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT)\n\t\tseq_printf(s, \",journal_async_commit\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1273-1503",
    "snippet": "static int ocfs2_parse_options(struct super_block *sb,\n\t\t\t       char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount)\n{\n\tint status, user_stack = 0;\n\tchar *p;\n\tu32 tmp;\n\n\ttrace_ocfs2_parse_options(is_remount, options ? options : \"(none)\");\n\n\tmopt->commit_interval = 0;\n\tmopt->mount_opt = OCFS2_MOUNT_NOINTR;\n\tmopt->atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\tmopt->slot = OCFS2_INVALID_SLOT;\n\tmopt->localalloc_opt = -1;\n\tmopt->cluster_stack[0] = '\\0';\n\tmopt->resv_level = OCFS2_DEFAULT_RESV_LEVEL;\n\tmopt->dir_resv_level = -1;\n\n\tif (!options) {\n\t\tstatus = 1;\n\t\tgoto bail;\n\t}\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, option;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_hb_local:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_LOCAL;\n\t\t\tbreak;\n\t\tcase Opt_hb_none:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_NONE;\n\t\t\tbreak;\n\t\tcase Opt_hb_global:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_GLOBAL;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_BARRIER;\n\t\t\telse\n\t\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_user_xattr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_atime_quantum:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->atime_quantum = option;\n\t\t\tbreak;\n\t\tcase Opt_slot:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->slot = (s16)option;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tmopt->commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_localalloc:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->localalloc_opt = option;\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\t/*\n\t\t\t * Changing this during remount could race\n\t\t\t * flock() requests, or \"unbalance\" existing\n\t\t\t * ones (e.g., a lock is taken in one mode but\n\t\t\t * dropped in the other). If users care enough\n\t\t\t * to flip locking modes during remount, we\n\t\t\t * could add a \"local\" flag to individual\n\t\t\t * flock structures for proper tracking of\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (!is_remount)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_LOCALFLOCKS;\n\t\t\tbreak;\n\t\tcase Opt_stack:\n\t\t\t/* Check both that the option we were passed\n\t\t\t * is of the right length and that it is a proper\n\t\t\t * string of the right length.\n\t\t\t */\n\t\t\tif (((args[0].to - args[0].from) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN) ||\n\t\t\t    (strnlen(args[0].from,\n\t\t\t\t     OCFS2_STACK_LABEL_LEN) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN)) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Invalid cluster_stack option\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(mopt->cluster_stack, args[0].from,\n\t\t\t       OCFS2_STACK_LABEL_LEN);\n\t\t\tmopt->cluster_stack[OCFS2_STACK_LABEL_LEN] = '\\0';\n\t\t\t/*\n\t\t\t * Open code the memcmp here as we don't have\n\t\t\t * an osb to pass to\n\t\t\t * ocfs2_userspace_stack().\n\t\t\t */\n\t\t\tif (memcmp(mopt->cluster_stack,\n\t\t\t\t   OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t\t\t   OCFS2_STACK_LABEL_LEN))\n\t\t\t\tuser_stack = 1;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_INODE64;\n\t\t\tbreak;\n\t\tcase Opt_usrquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_GRPQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_coherency_buffered:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_coherency_full:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_dir_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->dir_resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_async_commit:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t     \"or missing value\\n\", p);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (user_stack == 0) {\n\t\t/* Ensure only one heartbeat mode */\n\t\ttmp = mopt->mount_opt & (OCFS2_MOUNT_HB_LOCAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_GLOBAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_NONE);\n\t\tif (hweight32(tmp) != 1) {\n\t\t\tmlog(ML_ERROR, \"Invalid heartbeat mount options\\n\");\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 1;\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_parse_options(struct super_block *sb, char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount);",
      "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
      "static const match_table_t tokens = {\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_intr, \"intr\"},\n\t{Opt_nointr, \"nointr\"},\n\t{Opt_hb_none, OCFS2_HB_NONE},\n\t{Opt_hb_local, OCFS2_HB_LOCAL},\n\t{Opt_hb_global, OCFS2_HB_GLOBAL},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_atime_quantum, \"atime_quantum=%u\"},\n\t{Opt_slot, \"preferred_slot=%u\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_localalloc, \"localalloc=%d\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_stack, \"cluster_stack=%s\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_coherency_buffered, \"coherency=buffered\"},\n\t{Opt_coherency_full, \"coherency=full\"},\n\t{Opt_resv_level, \"resv_level=%u\"},\n\t{Opt_dir_resv_level, \"dir_resv_level=%u\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Invalid heartbeat mount options\\n\""
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "tmp"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t     \"or missing value\\n\"",
            "p"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mopt->cluster_stack",
            "OCFS2_CLASSIC_CLUSTER_STACK",
            "OCFS2_STACK_LABEL_LEN"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mopt->cluster_stack",
            "args[0].from",
            "OCFS2_STACK_LABEL_LEN"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "args[0].from",
            "OCFS2_STACK_LABEL_LEN"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_parse_options",
          "args": [
            "is_remount",
            "options ? options : \"(none)\""
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_parse_options(struct super_block *sb, char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount);\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const match_table_t tokens = {\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_intr, \"intr\"},\n\t{Opt_nointr, \"nointr\"},\n\t{Opt_hb_none, OCFS2_HB_NONE},\n\t{Opt_hb_local, OCFS2_HB_LOCAL},\n\t{Opt_hb_global, OCFS2_HB_GLOBAL},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_atime_quantum, \"atime_quantum=%u\"},\n\t{Opt_slot, \"preferred_slot=%u\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_localalloc, \"localalloc=%d\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_stack, \"cluster_stack=%s\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_coherency_buffered, \"coherency=buffered\"},\n\t{Opt_coherency_full, \"coherency=full\"},\n\t{Opt_resv_level, \"resv_level=%u\"},\n\t{Opt_dir_resv_level, \"dir_resv_level=%u\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ocfs2_parse_options(struct super_block *sb,\n\t\t\t       char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount)\n{\n\tint status, user_stack = 0;\n\tchar *p;\n\tu32 tmp;\n\n\ttrace_ocfs2_parse_options(is_remount, options ? options : \"(none)\");\n\n\tmopt->commit_interval = 0;\n\tmopt->mount_opt = OCFS2_MOUNT_NOINTR;\n\tmopt->atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\tmopt->slot = OCFS2_INVALID_SLOT;\n\tmopt->localalloc_opt = -1;\n\tmopt->cluster_stack[0] = '\\0';\n\tmopt->resv_level = OCFS2_DEFAULT_RESV_LEVEL;\n\tmopt->dir_resv_level = -1;\n\n\tif (!options) {\n\t\tstatus = 1;\n\t\tgoto bail;\n\t}\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, option;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_hb_local:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_LOCAL;\n\t\t\tbreak;\n\t\tcase Opt_hb_none:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_NONE;\n\t\t\tbreak;\n\t\tcase Opt_hb_global:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_GLOBAL;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_BARRIER;\n\t\t\telse\n\t\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_user_xattr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_atime_quantum:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->atime_quantum = option;\n\t\t\tbreak;\n\t\tcase Opt_slot:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->slot = (s16)option;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tmopt->commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_localalloc:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->localalloc_opt = option;\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\t/*\n\t\t\t * Changing this during remount could race\n\t\t\t * flock() requests, or \"unbalance\" existing\n\t\t\t * ones (e.g., a lock is taken in one mode but\n\t\t\t * dropped in the other). If users care enough\n\t\t\t * to flip locking modes during remount, we\n\t\t\t * could add a \"local\" flag to individual\n\t\t\t * flock structures for proper tracking of\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (!is_remount)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_LOCALFLOCKS;\n\t\t\tbreak;\n\t\tcase Opt_stack:\n\t\t\t/* Check both that the option we were passed\n\t\t\t * is of the right length and that it is a proper\n\t\t\t * string of the right length.\n\t\t\t */\n\t\t\tif (((args[0].to - args[0].from) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN) ||\n\t\t\t    (strnlen(args[0].from,\n\t\t\t\t     OCFS2_STACK_LABEL_LEN) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN)) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Invalid cluster_stack option\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(mopt->cluster_stack, args[0].from,\n\t\t\t       OCFS2_STACK_LABEL_LEN);\n\t\t\tmopt->cluster_stack[OCFS2_STACK_LABEL_LEN] = '\\0';\n\t\t\t/*\n\t\t\t * Open code the memcmp here as we don't have\n\t\t\t * an osb to pass to\n\t\t\t * ocfs2_userspace_stack().\n\t\t\t */\n\t\t\tif (memcmp(mopt->cluster_stack,\n\t\t\t\t   OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t\t\t   OCFS2_STACK_LABEL_LEN))\n\t\t\t\tuser_stack = 1;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_INODE64;\n\t\t\tbreak;\n\t\tcase Opt_usrquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_GRPQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_coherency_buffered:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_coherency_full:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_dir_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->dir_resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_async_commit:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t     \"or missing value\\n\", p);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (user_stack == 0) {\n\t\t/* Ensure only one heartbeat mode */\n\t\ttmp = mopt->mount_opt & (OCFS2_MOUNT_HB_LOCAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_GLOBAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_NONE);\n\t\tif (hweight32(tmp) != 1) {\n\t\t\tmlog(ML_ERROR, \"Invalid heartbeat mount options\\n\");\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 1;\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_check_set_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1239-1271",
    "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "OCFS2_FEATURE_INCOMPAT_XATTR"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\""
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "OCFS2_FEATURE_INCOMPAT_XATTR"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "OCFS2_FEATURE_RO_COMPAT_GRPQUOTA"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "OCFS2_FEATURE_RO_COMPAT_USRQUOTA"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ocfs2_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1221-1227",
    "snippet": "static struct dentry *ocfs2_mount(struct file_system_type *fs_type,\n\t\t\tint flags,\n\t\t\tconst char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ocfs2_fill_super);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "ocfs2_fill_super"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic struct dentry *ocfs2_mount(struct file_system_type *fs_type,\n\t\t\tint flags,\n\t\t\tconst char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ocfs2_fill_super);\n}"
  },
  {
    "function_name": "ocfs2_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "1005-1219",
    "snippet": "static int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(MS_POSIXACL | MS_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, MS_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb->s_flags & MS_RDONLY)\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ocfs2_debugfs_root;",
      "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_sync_fs(struct super_block *sb, int wait);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
      "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
      "static const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dismount_volume",
          "args": [
            "sb",
            "1"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dismount_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1894-1982",
          "snippet": "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&osb->osb_mount_event"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->vol_state",
            "VOLUME_DISABLED"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_scan_start",
          "args": [
            "osb"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_scan_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1978-1991",
          "snippet": "void ocfs2_orphan_scan_start(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_scantime = CURRENT_TIME;\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\telse {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_ACTIVE);\n\t\tqueue_delayed_work(ocfs2_wq, &os->os_orphan_scan_work,\n\t\t\t\t   ocfs2_orphan_scan_timeout());\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_orphan_scan_start(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_scantime = CURRENT_TIME;\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\telse {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_ACTIVE);\n\t\tqueue_delayed_work(ocfs2_wq, &os->os_orphan_scan_work,\n\t\t\t\t   ocfs2_orphan_scan_timeout());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->vol_state",
            "VOLUME_MOUNTED_QUOTAS"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_quota_recovery",
          "args": [
            "osb"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1332-1343",
          "snippet": "void ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nvoid ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->vol_state",
            "VOLUME_DISABLED"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_enable_quotas",
          "args": [
            "osb"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_enable_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "938-976",
          "snippet": "static int ocfs2_enable_quotas(struct ocfs2_super *osb)\n{\n\tstruct inode *inode[OCFS2_MAXQUOTAS] = { NULL, NULL };\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tLOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\tLOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tint status;\n\tint type;\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NEGATIVE_USAGE;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tinode[type] = ocfs2_get_system_file_inode(osb, ino[type],\n\t\t\t\t\t\t\tosb->slot_num);\n\t\tif (!inode[type]) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out_quota_off;\n\t\t}\n\t\tstatus = dquot_enable(inode[type], type, QFMT_OCFS2,\n\t\t\t\t      DQUOT_USAGE_ENABLED);\n\t\tif (status < 0)\n\t\t\tgoto out_quota_off;\n\t}\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\treturn 0;\nout_quota_off:\n\tocfs2_disable_quotas(osb);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb)\n{\n\tstruct inode *inode[OCFS2_MAXQUOTAS] = { NULL, NULL };\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tLOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\tLOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tint status;\n\tint type;\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NEGATIVE_USAGE;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tinode[type] = ocfs2_get_system_file_inode(osb, ino[type],\n\t\t\t\t\t\t\tosb->slot_num);\n\t\tif (!inode[type]) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out_quota_off;\n\t\t}\n\t\tstatus = dquot_enable(inode[type], type, QFMT_OCFS2,\n\t\t\t\t      DQUOT_USAGE_ENABLED);\n\t\tif (status < 0)\n\t\t\tgoto out_quota_off;\n\t}\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\treturn 0;\nout_quota_off:\n\tocfs2_disable_quotas(osb);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&osb->vol_state",
            "VOLUME_MOUNTED"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\"",
            "osb->dev_str",
            "nodestr",
            "osb->slot_num",
            "osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\""
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nodestr",
            "sizeof(nodestr)",
            "\"%u\"",
            "osb->node_num"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nodestr",
            "sizeof(nodestr)",
            "\"local\""
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_mount_recovery",
          "args": [
            "osb"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_mount_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1309-1330",
          "snippet": "void ocfs2_complete_mount_recovery(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn;\n\n\t/* No need to queue up our truncate_log as regular cleanup will catch\n\t * that */\n\tocfs2_queue_recovery_completion(journal, osb->slot_num,\n\t\t\t\t\tosb->local_alloc_copy, NULL, NULL,\n\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\tocfs2_schedule_truncate_log_flush(osb, 0);\n\n\tosb->local_alloc_copy = NULL;\n\tosb->dirty = 0;\n\n\t/* queue to recover orphan slots for all offline slots */\n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\tocfs2_queue_replay_slots(osb, ORPHAN_NEED_TRUNCATE);\n\tocfs2_free_replay_slots(osb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nvoid ocfs2_complete_mount_recovery(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn;\n\n\t/* No need to queue up our truncate_log as regular cleanup will catch\n\t * that */\n\tocfs2_queue_recovery_completion(journal, osb->slot_num,\n\t\t\t\t\tosb->local_alloc_copy, NULL, NULL,\n\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\tocfs2_schedule_truncate_log_flush(osb, 0);\n\n\tosb->local_alloc_copy = NULL;\n\tosb->dirty = 0;\n\n\t/* queue to recover orphan slots for all offline slots */\n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\tocfs2_queue_replay_slots(osb, ORPHAN_NEED_TRUNCATE);\n\tocfs2_free_replay_slots(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "osb->root_inode"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_volume",
          "args": [
            "sb"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1841-1892",
          "snippet": "static int ocfs2_mount_volume(struct super_block *sb)\n{\n\tint status = 0;\n\tint unlock_super = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\tgoto leave;\n\n\tstatus = ocfs2_dlm_init(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_super_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tunlock_super = 1;\n\n\t/* This will load up the node map and add ourselves to it. */\n\tstatus = ocfs2_find_slot(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* load all node-local system inodes */\n\tstatus = ocfs2_init_local_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_volume(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_truncate_log_init(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nleave:\n\tif (unlock_super)\n\t\tocfs2_super_unlock(osb, 1);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_mount_volume(struct super_block *sb)\n{\n\tint status = 0;\n\tint unlock_super = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\tgoto leave;\n\n\tstatus = ocfs2_dlm_init(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_super_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tunlock_super = 1;\n\n\t/* This will load up the node map and add ourselves to it. */\n\tstatus = ocfs2_find_slot(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* load all node-local system inodes */\n\tstatus = ocfs2_init_local_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_volume(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_truncate_log_init(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nleave:\n\tif (unlock_super)\n\t\tocfs2_super_unlock(osb, 1);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\""
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_stats_debugfs_install",
          "args": [
            "&osb->osb_ecc_stats",
            "osb->osb_debug_root"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "312-316",
          "snippet": "int ocfs2_blockcheck_stats_debugfs_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t   struct dentry *parent)\n{\n\treturn ocfs2_blockcheck_debug_install(stats, parent);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_blockcheck_stats_debugfs_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t   struct dentry *parent)\n{\n\treturn ocfs2_blockcheck_debug_install(stats, parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "osb"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"fs_state\"",
            "S_IFREG|S_IRUSR",
            "osb->osb_debug_root",
            "osb",
            "&ocfs2_osb_debug_fops"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "321-346",
          "snippet": "struct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "osb->uuid_str",
            "ocfs2_debugfs_root"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "407-429",
          "snippet": "struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_verify_heartbeat",
          "args": [
            "osb"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_verify_heartbeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "842-876",
          "snippet": "static int ocfs2_verify_heartbeat(struct ocfs2_super *osb)\n{\n\tu32 hb_enabled = OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL;\n\n\tif (osb->s_mount_opt & hb_enabled) {\n\t\tif (ocfs2_mount_local(osb)) {\n\t\t\tmlog(ML_ERROR, \"Cannot heartbeat on a locally \"\n\t\t\t     \"mounted device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Userspace stack expected, but \"\n\t\t\t     \"o2cb heartbeat arguments passed to mount\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (((osb->s_mount_opt & OCFS2_MOUNT_HB_GLOBAL) &&\n\t\t     !ocfs2_cluster_o2cb_global_heartbeat(osb)) ||\n\t\t    ((osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) &&\n\t\t     ocfs2_cluster_o2cb_global_heartbeat(osb))) {\n\t\t\tmlog(ML_ERROR, \"Mismatching o2cb heartbeat modes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!(osb->s_mount_opt & hb_enabled)) {\n\t\tif (!ocfs2_mount_local(osb) && !ocfs2_is_hard_readonly(osb) &&\n\t\t    !ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Heartbeat has to be started to mount \"\n\t\t\t     \"a read-write clustered device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_verify_heartbeat(struct ocfs2_super *osb)\n{\n\tu32 hb_enabled = OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL;\n\n\tif (osb->s_mount_opt & hb_enabled) {\n\t\tif (ocfs2_mount_local(osb)) {\n\t\t\tmlog(ML_ERROR, \"Cannot heartbeat on a locally \"\n\t\t\t     \"mounted device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Userspace stack expected, but \"\n\t\t\t     \"o2cb heartbeat arguments passed to mount\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (((osb->s_mount_opt & OCFS2_MOUNT_HB_GLOBAL) &&\n\t\t     !ocfs2_cluster_o2cb_global_heartbeat(osb)) ||\n\t\t    ((osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) &&\n\t\t     ocfs2_cluster_o2cb_global_heartbeat(osb))) {\n\t\t\tmlog(ML_ERROR, \"Mismatching o2cb heartbeat modes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!(osb->s_mount_opt & hb_enabled)) {\n\t\tif (!ocfs2_mount_local(osb) && !ocfs2_is_hard_readonly(osb) &&\n\t\t    !ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Heartbeat has to be started to mount \"\n\t\t\t     \"a read-write clustered device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_ro_flag",
          "args": [
            "osb",
            "0"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_ro_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "603-613",
          "snippet": "static inline void ocfs2_set_ro_flag(struct ocfs2_super *osb,\n\t\t\t\t     int hard)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_flags &= ~(OCFS2_OSB_SOFT_RO|OCFS2_OSB_HARD_RO);\n\tif (hard)\n\t\tosb->osb_flags |= OCFS2_OSB_HARD_RO;\n\telse\n\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002",
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline void ocfs2_set_ro_flag(struct ocfs2_super *osb,\n\t\t\t\t     int hard)\n{\n\tspin_lock(&osb->osb_lock);\n\tosb->osb_flags &= ~(OCFS2_OSB_SOFT_RO|OCFS2_OSB_HARD_RO);\n\tif (hard)\n\t\tosb->osb_flags |= OCFS2_OSB_HARD_RO;\n\telse\n\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_journals_nolocks",
          "args": [
            "osb"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_journals_nolocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2291-2323",
          "snippet": "int ocfs2_check_journals_nolocks(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tunsigned int slot;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint journal_dirty = 0;\n\n\tfor(slot = 0; slot < osb->max_slots; slot++) {\n\t\tret = ocfs2_read_journal_inode(osb, slot, &di_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\t\tosb->slot_recovery_generations[slot] =\n\t\t\t\t\tocfs2_get_recovery_generation(di);\n\n\t\tif (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t    OCFS2_JOURNAL_DIRTY_FL)\n\t\t\tjournal_dirty = 1;\n\n\t\tbrelse(di_bh);\n\t\tdi_bh = NULL;\n\t}\n\nout:\n\tif (journal_dirty)\n\t\tret = -EROFS;\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_check_journals_nolocks(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tunsigned int slot;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint journal_dirty = 0;\n\n\tfor(slot = 0; slot < osb->max_slots; slot++) {\n\t\tret = ocfs2_read_journal_inode(osb, slot, &di_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\t\tosb->slot_recovery_generations[slot] =\n\t\t\t\t\tocfs2_get_recovery_generation(di);\n\n\t\tif (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t    OCFS2_JOURNAL_DIRTY_FL)\n\t\t\tjournal_dirty = 1;\n\n\t\tbrelse(di_bh);\n\t\tdi_bh = NULL;\n\t}\n\nout:\n\tif (journal_dirty)\n\t\tret = -EROFS;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_verify_userspace_stack",
          "args": [
            "osb",
            "&parsed_options"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_verify_userspace_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "883-905",
          "snippet": "static int ocfs2_verify_userspace_stack(struct ocfs2_super *osb,\n\t\t\t\t\tstruct mount_options *mopt)\n{\n\tif (!ocfs2_userspace_stack(osb) && mopt->cluster_stack[0]) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount, but this filesystem \"\n\t\t     \"does not support it\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ocfs2_userspace_stack(osb) &&\n\t    strncmp(osb->osb_cluster_stack, mopt->cluster_stack,\n\t\t    OCFS2_STACK_LABEL_LEN)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount (\\\"%s\\\") does not \"\n\t\t     \"match the filesystem (\\\"%s\\\")\\n\",\n\t\t     mopt->cluster_stack,\n\t\t     osb->osb_cluster_stack);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_verify_userspace_stack(struct ocfs2_super *osb,\n\t\t\t\t\tstruct mount_options *mopt)\n{\n\tif (!ocfs2_userspace_stack(osb) && mopt->cluster_stack[0]) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount, but this filesystem \"\n\t\t     \"does not support it\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ocfs2_userspace_stack(osb) &&\n\t    strncmp(osb->osb_cluster_stack, mopt->cluster_stack,\n\t\t    OCFS2_STACK_LABEL_LEN)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount (\\\"%s\\\") does not \"\n\t\t     \"match the filesystem (\\\"%s\\\")\\n\",\n\t\t     mopt->cluster_stack,\n\t\t     osb->osb_cluster_stack);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_la_set_sizes",
          "args": [
            "osb",
            "parsed_options.localalloc_opt"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_la_set_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "195-220",
          "snippet": "void ocfs2_la_set_sizes(struct ocfs2_super *osb, int requested_mb)\n{\n\tstruct super_block *sb = osb->sb;\n\tunsigned int la_default_mb = ocfs2_la_default_mb(osb);\n\tunsigned int la_max_mb;\n\n\tla_max_mb = ocfs2_clusters_to_megabytes(sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\n\ttrace_ocfs2_la_set_sizes(requested_mb, la_max_mb, la_default_mb);\n\n\tif (requested_mb == -1) {\n\t\t/* No user request - use defaults */\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_default_mb);\n\t} else if (requested_mb > la_max_mb) {\n\t\t/* Request is too big, we give the maximum available */\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_max_mb);\n\t} else {\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, requested_mb);\n\t}\n\n\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_la_set_sizes(struct ocfs2_super *osb, int requested_mb)\n{\n\tstruct super_block *sb = osb->sb;\n\tunsigned int la_default_mb = ocfs2_la_default_mb(osb);\n\tunsigned int la_max_mb;\n\n\tla_max_mb = ocfs2_clusters_to_megabytes(sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\n\ttrace_ocfs2_la_set_sizes(requested_mb, la_max_mb, la_default_mb);\n\n\tif (requested_mb == -1) {\n\t\t/* No user request - use defaults */\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_default_mb);\n\t} else if (requested_mb > la_max_mb) {\n\t\t/* Request is too big, we give the maximum available */\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_max_mb);\n\t} else {\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, requested_mb);\n\t}\n\n\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_set_options",
          "args": [
            "sb",
            "&parsed_options"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_initialize_super",
          "args": [
            "sb",
            "bh",
            "sector_size",
            "&stats"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_initialize_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2038-2340",
          "snippet": "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status;\n\tint i, cbits, bbits;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_journal *journal;\n\tstruct ocfs2_super *osb;\n\tu64 total_blocks;\n\n\tosb = kzalloc(sizeof(struct ocfs2_super), GFP_KERNEL);\n\tif (!osb) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsb->s_fs_info = osb;\n\tsb->s_op = &ocfs2_sops;\n\tsb->s_d_op = &ocfs2_dentry_ops;\n\tsb->s_export_op = &ocfs2_export_ops;\n\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\tsb->dq_op = &ocfs2_quota_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb->s_xattr = ocfs2_xattr_handlers;\n\tsb->s_time_gran = 1;\n\tsb->s_flags |= MS_NOATIME;\n\t/* this is needed to support O_LARGEFILE */\n\tcbits = le32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tbbits = le32_to_cpu(di->id2.i_super.s_blocksize_bits);\n\tsb->s_maxbytes = ocfs2_max_file_offset(bbits, cbits);\n\n\tosb->osb_dx_mask = (1 << (cbits - bbits)) - 1;\n\n\tfor (i = 0; i < 3; i++)\n\t\tosb->osb_dx_seed[i] = le32_to_cpu(di->id2.i_super.s_dx_seed[i]);\n\tosb->osb_dx_seed[3] = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\n\tosb->sb = sb;\n\t/* Save off for ocfs2_rw_direct */\n\tosb->s_sectsize_bits = blksize_bits(sector_size);\n\tBUG_ON(!osb->s_sectsize_bits);\n\n\tspin_lock_init(&osb->dc_task_lock);\n\tinit_waitqueue_head(&osb->dc_event);\n\tosb->dc_work_sequence = 0;\n\tosb->dc_wake_sequence = 0;\n\tINIT_LIST_HEAD(&osb->blocked_lock_list);\n\tosb->blocked_lock_count = 0;\n\tspin_lock_init(&osb->osb_lock);\n\tspin_lock_init(&osb->osb_xattr_lock);\n\tocfs2_init_steal_slots(osb);\n\n\tmutex_init(&osb->system_file_mutex);\n\n\tatomic_set(&osb->alloc_stats.moves, 0);\n\tatomic_set(&osb->alloc_stats.local_data, 0);\n\tatomic_set(&osb->alloc_stats.bitmap_data, 0);\n\tatomic_set(&osb->alloc_stats.bg_allocs, 0);\n\tatomic_set(&osb->alloc_stats.bg_extends, 0);\n\n\t/* Copy the blockcheck stats from the superblock probe */\n\tosb->osb_ecc_stats = *stats;\n\n\tocfs2_init_node_maps(osb);\n\n\tsnprintf(osb->dev_str, sizeof(osb->dev_str), \"%u,%u\",\n\t\t MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\n\tosb->max_slots = le16_to_cpu(di->id2.i_super.s_max_slots);\n\tif (osb->max_slots > OCFS2_MAX_SLOTS || osb->max_slots == 0) {\n\t\tmlog(ML_ERROR, \"Invalid number of node slots (%u)\\n\",\n\t\t     osb->max_slots);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tocfs2_orphan_scan_init(osb);\n\n\tstatus = ocfs2_recovery_init(osb);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Unable to initialize recovery state\\n\");\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->checkpoint_event);\n\n\tosb->s_atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\n\tosb->s_xattr_inline_size = le16_to_cpu(\n\t\t\t\t\tdi->id2.i_super.s_xattr_inline_size);\n\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\tosb->local_alloc_bh = NULL;\n\tINIT_DELAYED_WORK(&osb->la_enable_wq, ocfs2_la_enable_worker);\n\n\tinit_waitqueue_head(&osb->osb_mount_event);\n\n\tstatus = ocfs2_resmap_init(osb, &osb->osb_la_resmap);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->vol_label = kmalloc(OCFS2_MAX_VOL_LABEL_LEN, GFP_KERNEL);\n\tif (!osb->vol_label) {\n\t\tmlog(ML_ERROR, \"unable to alloc vol label\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tosb->slot_recovery_generations =\n\t\tkcalloc(osb->max_slots, sizeof(*osb->slot_recovery_generations),\n\t\t\tGFP_KERNEL);\n\tif (!osb->slot_recovery_generations) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->osb_wipe_event);\n\tosb->osb_orphan_wipes = kcalloc(osb->max_slots,\n\t\t\t\t\tsizeof(*osb->osb_orphan_wipes),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!osb->osb_orphan_wipes) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->osb_rf_lock_tree = RB_ROOT;\n\n\tosb->s_feature_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_compat);\n\tosb->s_feature_ro_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_ro_compat);\n\tosb->s_feature_incompat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_incompat);\n\n\tif ((i = OCFS2_HAS_INCOMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_INCOMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount because of unsupported \"\n\t\t     \"optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (!(osb->sb->s_flags & MS_RDONLY) &&\n\t    (i = OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount RDWR because of \"\n\t\t     \"unsupported optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_clusterinfo_valid(osb)) {\n\t\tosb->osb_stackflags =\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_stackflags;\n\t\tstrlcpy(osb->osb_cluster_stack,\n\t\t       OCFS2_RAW_SB(di)->s_cluster_info.ci_stack,\n\t\t       OCFS2_STACK_LABEL_LEN + 1);\n\t\tif (strlen(osb->osb_cluster_stack) != OCFS2_STACK_LABEL_LEN) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"couldn't mount because of an invalid \"\n\t\t\t     \"cluster stack label (%s) \\n\",\n\t\t\t     osb->osb_cluster_stack);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\tstrlcpy(osb->osb_cluster_name,\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_cluster,\n\t\t\tOCFS2_CLUSTER_NAME_LEN + 1);\n\t} else {\n\t\t/* The empty string is identical with classic tools that\n\t\t * don't know about s_cluster_info. */\n\t\tosb->osb_cluster_stack[0] = '\\0';\n\t}\n\n\tget_random_bytes(&osb->s_next_generation, sizeof(u32));\n\n\t/* FIXME\n\t * This should be done in ocfs2_journal_init(), but unknown\n\t * ordering issues will cause the filesystem to crash.\n\t * If anyone wants to figure out what part of the code\n\t * refers to osb->journal before ocfs2_journal_init() is run,\n\t * be my guest.\n\t */\n\t/* initialize our journal structure */\n\n\tjournal = kzalloc(sizeof(struct ocfs2_journal), GFP_KERNEL);\n\tif (!journal) {\n\t\tmlog(ML_ERROR, \"unable to alloc journal\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tosb->journal = journal;\n\tjournal->j_osb = osb;\n\n\tatomic_set(&journal->j_num_trans, 0);\n\tinit_rwsem(&journal->j_trans_barrier);\n\tinit_waitqueue_head(&journal->j_checkpointed);\n\tspin_lock_init(&journal->j_lock);\n\tjournal->j_trans_id = (unsigned long) 1;\n\tINIT_LIST_HEAD(&journal->j_la_cleanups);\n\tINIT_WORK(&journal->j_recovery_work, ocfs2_complete_recovery);\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n\tINIT_WORK(&osb->dquot_drop_work, ocfs2_drop_dquot_refs);\n\tinit_llist_head(&osb->dquot_drop_list);\n\n\t/* get some pseudo constants for clustersize bits */\n\tosb->s_clustersize_bits =\n\t\tle32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tosb->s_clustersize = 1 << osb->s_clustersize_bits;\n\n\tif (osb->s_clustersize < OCFS2_MIN_CLUSTERSIZE ||\n\t    osb->s_clustersize > OCFS2_MAX_CLUSTERSIZE) {\n\t\tmlog(ML_ERROR, \"Volume has invalid cluster size (%d)\\n\",\n\t\t     osb->s_clustersize);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\ttotal_blocks = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(di->i_clusters));\n\n\tstatus = generic_check_addressable(osb->sb->s_blocksize_bits,\n\t\t\t\t\t   total_blocks);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Volume too large \"\n\t\t     \"to mount safely on this system\");\n\t\tstatus = -EFBIG;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_setup_osb_uuid(osb, di->id2.i_super.s_uuid,\n\t\t\t\t sizeof(di->id2.i_super.s_uuid))) {\n\t\tmlog(ML_ERROR, \"Out of memory trying to setup our uuid.\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tstrlcpy(osb->vol_label, di->id2.i_super.s_label,\n\t\tOCFS2_MAX_VOL_LABEL_LEN);\n\tosb->root_blkno = le64_to_cpu(di->id2.i_super.s_root_blkno);\n\tosb->system_dir_blkno = le64_to_cpu(di->id2.i_super.s_system_dir_blkno);\n\tosb->first_cluster_group_blkno =\n\t\tle64_to_cpu(di->id2.i_super.s_first_cluster_group);\n\tosb->fs_generation = le32_to_cpu(di->i_fs_generation);\n\tosb->uuid_hash = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\ttrace_ocfs2_initialize_super(osb->vol_label, osb->uuid_str,\n\t\t\t\t     (unsigned long long)osb->root_blkno,\n\t\t\t\t     (unsigned long long)osb->system_dir_blkno,\n\t\t\t\t     osb->s_clustersize_bits);\n\n\tosb->osb_dlm_debug = ocfs2_new_dlm_debug();\n\tif (!osb->osb_dlm_debug) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_set(&osb->vol_state, VOLUME_INIT);\n\n\t/* load root, system_dir, and all global system inodes */\n\tstatus = ocfs2_init_global_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * global bitmap\n\t */\n\tinode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->bitmap_blkno = OCFS2_I(inode)->ip_blkno;\n\tosb->osb_clusters_at_boot = OCFS2_I(inode)->ip_clusters;\n\tiput(inode);\n\n\tosb->bitmap_cpg = ocfs2_group_bitmap_size(sb, 0,\n\t\t\t\t osb->s_feature_incompat) * 8;\n\n\tstatus = ocfs2_init_slot_info(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tcleancache_init_shared_fs((char *)&di->id2.i_super.s_uuid, sb);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
            "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
            "static const struct super_operations ocfs2_sops = {\n\t.statfs\t\t= ocfs2_statfs,\n\t.alloc_inode\t= ocfs2_alloc_inode,\n\t.destroy_inode\t= ocfs2_destroy_inode,\n\t.drop_inode\t= ocfs2_drop_inode,\n\t.evict_inode\t= ocfs2_evict_inode,\n\t.sync_fs\t= ocfs2_sync_fs,\n\t.put_super\t= ocfs2_put_super,\n\t.remount_fs\t= ocfs2_remount,\n\t.show_options   = ocfs2_show_options,\n\t.quota_read\t= ocfs2_quota_read,\n\t.quota_write\t= ocfs2_quota_write,\n\t.get_dquots\t= ocfs2_get_dquots,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const struct super_operations ocfs2_sops = {\n\t.statfs\t\t= ocfs2_statfs,\n\t.alloc_inode\t= ocfs2_alloc_inode,\n\t.destroy_inode\t= ocfs2_destroy_inode,\n\t.drop_inode\t= ocfs2_drop_inode,\n\t.evict_inode\t= ocfs2_evict_inode,\n\t.sync_fs\t= ocfs2_sync_fs,\n\t.put_super\t= ocfs2_put_super,\n\t.remount_fs\t= ocfs2_remount,\n\t.show_options   = ocfs2_show_options,\n\t.quota_read\t= ocfs2_quota_read,\n\t.quota_write\t= ocfs2_quota_write,\n\t.get_dquots\t= ocfs2_get_dquots,\n};\n\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status;\n\tint i, cbits, bbits;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_journal *journal;\n\tstruct ocfs2_super *osb;\n\tu64 total_blocks;\n\n\tosb = kzalloc(sizeof(struct ocfs2_super), GFP_KERNEL);\n\tif (!osb) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsb->s_fs_info = osb;\n\tsb->s_op = &ocfs2_sops;\n\tsb->s_d_op = &ocfs2_dentry_ops;\n\tsb->s_export_op = &ocfs2_export_ops;\n\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\tsb->dq_op = &ocfs2_quota_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n\tsb->s_xattr = ocfs2_xattr_handlers;\n\tsb->s_time_gran = 1;\n\tsb->s_flags |= MS_NOATIME;\n\t/* this is needed to support O_LARGEFILE */\n\tcbits = le32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tbbits = le32_to_cpu(di->id2.i_super.s_blocksize_bits);\n\tsb->s_maxbytes = ocfs2_max_file_offset(bbits, cbits);\n\n\tosb->osb_dx_mask = (1 << (cbits - bbits)) - 1;\n\n\tfor (i = 0; i < 3; i++)\n\t\tosb->osb_dx_seed[i] = le32_to_cpu(di->id2.i_super.s_dx_seed[i]);\n\tosb->osb_dx_seed[3] = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\n\tosb->sb = sb;\n\t/* Save off for ocfs2_rw_direct */\n\tosb->s_sectsize_bits = blksize_bits(sector_size);\n\tBUG_ON(!osb->s_sectsize_bits);\n\n\tspin_lock_init(&osb->dc_task_lock);\n\tinit_waitqueue_head(&osb->dc_event);\n\tosb->dc_work_sequence = 0;\n\tosb->dc_wake_sequence = 0;\n\tINIT_LIST_HEAD(&osb->blocked_lock_list);\n\tosb->blocked_lock_count = 0;\n\tspin_lock_init(&osb->osb_lock);\n\tspin_lock_init(&osb->osb_xattr_lock);\n\tocfs2_init_steal_slots(osb);\n\n\tmutex_init(&osb->system_file_mutex);\n\n\tatomic_set(&osb->alloc_stats.moves, 0);\n\tatomic_set(&osb->alloc_stats.local_data, 0);\n\tatomic_set(&osb->alloc_stats.bitmap_data, 0);\n\tatomic_set(&osb->alloc_stats.bg_allocs, 0);\n\tatomic_set(&osb->alloc_stats.bg_extends, 0);\n\n\t/* Copy the blockcheck stats from the superblock probe */\n\tosb->osb_ecc_stats = *stats;\n\n\tocfs2_init_node_maps(osb);\n\n\tsnprintf(osb->dev_str, sizeof(osb->dev_str), \"%u,%u\",\n\t\t MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\n\tosb->max_slots = le16_to_cpu(di->id2.i_super.s_max_slots);\n\tif (osb->max_slots > OCFS2_MAX_SLOTS || osb->max_slots == 0) {\n\t\tmlog(ML_ERROR, \"Invalid number of node slots (%u)\\n\",\n\t\t     osb->max_slots);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tocfs2_orphan_scan_init(osb);\n\n\tstatus = ocfs2_recovery_init(osb);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Unable to initialize recovery state\\n\");\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->checkpoint_event);\n\n\tosb->s_atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\n\tosb->s_xattr_inline_size = le16_to_cpu(\n\t\t\t\t\tdi->id2.i_super.s_xattr_inline_size);\n\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\tosb->local_alloc_bh = NULL;\n\tINIT_DELAYED_WORK(&osb->la_enable_wq, ocfs2_la_enable_worker);\n\n\tinit_waitqueue_head(&osb->osb_mount_event);\n\n\tstatus = ocfs2_resmap_init(osb, &osb->osb_la_resmap);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->vol_label = kmalloc(OCFS2_MAX_VOL_LABEL_LEN, GFP_KERNEL);\n\tif (!osb->vol_label) {\n\t\tmlog(ML_ERROR, \"unable to alloc vol label\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tosb->slot_recovery_generations =\n\t\tkcalloc(osb->max_slots, sizeof(*osb->slot_recovery_generations),\n\t\t\tGFP_KERNEL);\n\tif (!osb->slot_recovery_generations) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tinit_waitqueue_head(&osb->osb_wipe_event);\n\tosb->osb_orphan_wipes = kcalloc(osb->max_slots,\n\t\t\t\t\tsizeof(*osb->osb_orphan_wipes),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!osb->osb_orphan_wipes) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->osb_rf_lock_tree = RB_ROOT;\n\n\tosb->s_feature_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_compat);\n\tosb->s_feature_ro_compat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_ro_compat);\n\tosb->s_feature_incompat =\n\t\tle32_to_cpu(OCFS2_RAW_SB(di)->s_feature_incompat);\n\n\tif ((i = OCFS2_HAS_INCOMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_INCOMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount because of unsupported \"\n\t\t     \"optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (!(osb->sb->s_flags & MS_RDONLY) &&\n\t    (i = OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP))) {\n\t\tmlog(ML_ERROR, \"couldn't mount RDWR because of \"\n\t\t     \"unsupported optional features (%x).\\n\", i);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_clusterinfo_valid(osb)) {\n\t\tosb->osb_stackflags =\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_stackflags;\n\t\tstrlcpy(osb->osb_cluster_stack,\n\t\t       OCFS2_RAW_SB(di)->s_cluster_info.ci_stack,\n\t\t       OCFS2_STACK_LABEL_LEN + 1);\n\t\tif (strlen(osb->osb_cluster_stack) != OCFS2_STACK_LABEL_LEN) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"couldn't mount because of an invalid \"\n\t\t\t     \"cluster stack label (%s) \\n\",\n\t\t\t     osb->osb_cluster_stack);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\tstrlcpy(osb->osb_cluster_name,\n\t\t\tOCFS2_RAW_SB(di)->s_cluster_info.ci_cluster,\n\t\t\tOCFS2_CLUSTER_NAME_LEN + 1);\n\t} else {\n\t\t/* The empty string is identical with classic tools that\n\t\t * don't know about s_cluster_info. */\n\t\tosb->osb_cluster_stack[0] = '\\0';\n\t}\n\n\tget_random_bytes(&osb->s_next_generation, sizeof(u32));\n\n\t/* FIXME\n\t * This should be done in ocfs2_journal_init(), but unknown\n\t * ordering issues will cause the filesystem to crash.\n\t * If anyone wants to figure out what part of the code\n\t * refers to osb->journal before ocfs2_journal_init() is run,\n\t * be my guest.\n\t */\n\t/* initialize our journal structure */\n\n\tjournal = kzalloc(sizeof(struct ocfs2_journal), GFP_KERNEL);\n\tif (!journal) {\n\t\tmlog(ML_ERROR, \"unable to alloc journal\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tosb->journal = journal;\n\tjournal->j_osb = osb;\n\n\tatomic_set(&journal->j_num_trans, 0);\n\tinit_rwsem(&journal->j_trans_barrier);\n\tinit_waitqueue_head(&journal->j_checkpointed);\n\tspin_lock_init(&journal->j_lock);\n\tjournal->j_trans_id = (unsigned long) 1;\n\tINIT_LIST_HEAD(&journal->j_la_cleanups);\n\tINIT_WORK(&journal->j_recovery_work, ocfs2_complete_recovery);\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n\tINIT_WORK(&osb->dquot_drop_work, ocfs2_drop_dquot_refs);\n\tinit_llist_head(&osb->dquot_drop_list);\n\n\t/* get some pseudo constants for clustersize bits */\n\tosb->s_clustersize_bits =\n\t\tle32_to_cpu(di->id2.i_super.s_clustersize_bits);\n\tosb->s_clustersize = 1 << osb->s_clustersize_bits;\n\n\tif (osb->s_clustersize < OCFS2_MIN_CLUSTERSIZE ||\n\t    osb->s_clustersize > OCFS2_MAX_CLUSTERSIZE) {\n\t\tmlog(ML_ERROR, \"Volume has invalid cluster size (%d)\\n\",\n\t\t     osb->s_clustersize);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\ttotal_blocks = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(di->i_clusters));\n\n\tstatus = generic_check_addressable(osb->sb->s_blocksize_bits,\n\t\t\t\t\t   total_blocks);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"Volume too large \"\n\t\t     \"to mount safely on this system\");\n\t\tstatus = -EFBIG;\n\t\tgoto bail;\n\t}\n\n\tif (ocfs2_setup_osb_uuid(osb, di->id2.i_super.s_uuid,\n\t\t\t\t sizeof(di->id2.i_super.s_uuid))) {\n\t\tmlog(ML_ERROR, \"Out of memory trying to setup our uuid.\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tstrlcpy(osb->vol_label, di->id2.i_super.s_label,\n\t\tOCFS2_MAX_VOL_LABEL_LEN);\n\tosb->root_blkno = le64_to_cpu(di->id2.i_super.s_root_blkno);\n\tosb->system_dir_blkno = le64_to_cpu(di->id2.i_super.s_system_dir_blkno);\n\tosb->first_cluster_group_blkno =\n\t\tle64_to_cpu(di->id2.i_super.s_first_cluster_group);\n\tosb->fs_generation = le32_to_cpu(di->i_fs_generation);\n\tosb->uuid_hash = le32_to_cpu(di->id2.i_super.s_uuid_hash);\n\ttrace_ocfs2_initialize_super(osb->vol_label, osb->uuid_str,\n\t\t\t\t     (unsigned long long)osb->root_blkno,\n\t\t\t\t     (unsigned long long)osb->system_dir_blkno,\n\t\t\t\t     osb->s_clustersize_bits);\n\n\tosb->osb_dlm_debug = ocfs2_new_dlm_debug();\n\tif (!osb->osb_dlm_debug) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_set(&osb->vol_state, VOLUME_INIT);\n\n\t/* load root, system_dir, and all global system inodes */\n\tstatus = ocfs2_init_global_system_inodes(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * global bitmap\n\t */\n\tinode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->bitmap_blkno = OCFS2_I(inode)->ip_blkno;\n\tosb->osb_clusters_at_boot = OCFS2_I(inode)->ip_clusters;\n\tiput(inode);\n\n\tosb->bitmap_cpg = ocfs2_group_bitmap_size(sb, 0,\n\t\t\t\t osb->s_feature_incompat) * 8;\n\n\tstatus = ocfs2_init_slot_info(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tcleancache_init_shared_fs((char *)&di->id2.i_super.s_uuid, sb);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sb_probe",
          "args": [
            "sb",
            "&bh",
            "&sector_size",
            "&stats"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sb_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "756-840",
          "snippet": "static int ocfs2_sb_probe(struct super_block *sb,\n\t\t\t  struct buffer_head **bh,\n\t\t\t  int *sector_size,\n\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status, tmpstat;\n\tstruct ocfs1_vol_disk_hdr *hdr;\n\tstruct ocfs2_dinode *di;\n\tint blksize;\n\n\t*bh = NULL;\n\n\t/* may be > 512 */\n\t*sector_size = bdev_logical_block_size(sb->s_bdev);\n\tif (*sector_size > OCFS2_MAX_BLOCKSIZE) {\n\t\tmlog(ML_ERROR, \"Hardware sector size too large: %d (max=%d)\\n\",\n\t\t     *sector_size, OCFS2_MAX_BLOCKSIZE);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t/* Can this really happen? */\n\tif (*sector_size < OCFS2_MIN_BLOCKSIZE)\n\t\t*sector_size = OCFS2_MIN_BLOCKSIZE;\n\n\t/* check block zero for old format */\n\tstatus = ocfs2_get_sector(sb, bh, 0, *sector_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\thdr = (struct ocfs1_vol_disk_hdr *) (*bh)->b_data;\n\tif (hdr->major_version == OCFS1_MAJOR_VERSION) {\n\t\tmlog(ML_ERROR, \"incompatible version: %u.%u\\n\",\n\t\t     hdr->major_version, hdr->minor_version);\n\t\tstatus = -EINVAL;\n\t}\n\tif (memcmp(hdr->signature, OCFS1_VOLUME_SIGNATURE,\n\t\t   strlen(OCFS1_VOLUME_SIGNATURE)) == 0) {\n\t\tmlog(ML_ERROR, \"incompatible volume signature: %8s\\n\",\n\t\t     hdr->signature);\n\t\tstatus = -EINVAL;\n\t}\n\tbrelse(*bh);\n\t*bh = NULL;\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"This is an ocfs v1 filesystem which must be \"\n\t\t     \"upgraded before mounting with ocfs v2\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Now check at magic offset for 512, 1024, 2048, 4096\n\t * blocksizes.  4096 is the maximum blocksize because it is\n\t * the minimum clustersize.\n\t */\n\tstatus = -EINVAL;\n\tfor (blksize = *sector_size;\n\t     blksize <= OCFS2_MAX_BLOCKSIZE;\n\t     blksize <<= 1) {\n\t\ttmpstat = ocfs2_get_sector(sb, bh,\n\t\t\t\t\t   OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t\t\t   blksize);\n\t\tif (tmpstat < 0) {\n\t\t\tstatus = tmpstat;\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *) (*bh)->b_data;\n\t\tmemset(stats, 0, sizeof(struct ocfs2_blockcheck_stats));\n\t\tspin_lock_init(&stats->b_lock);\n\t\ttmpstat = ocfs2_verify_volume(di, *bh, blksize, stats);\n\t\tif (tmpstat < 0) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t\tif (tmpstat != -EAGAIN) {\n\t\t\tstatus = tmpstat;\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
            "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_sb_probe(struct super_block *sb,\n\t\t\t  struct buffer_head **bh,\n\t\t\t  int *sector_size,\n\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status, tmpstat;\n\tstruct ocfs1_vol_disk_hdr *hdr;\n\tstruct ocfs2_dinode *di;\n\tint blksize;\n\n\t*bh = NULL;\n\n\t/* may be > 512 */\n\t*sector_size = bdev_logical_block_size(sb->s_bdev);\n\tif (*sector_size > OCFS2_MAX_BLOCKSIZE) {\n\t\tmlog(ML_ERROR, \"Hardware sector size too large: %d (max=%d)\\n\",\n\t\t     *sector_size, OCFS2_MAX_BLOCKSIZE);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t/* Can this really happen? */\n\tif (*sector_size < OCFS2_MIN_BLOCKSIZE)\n\t\t*sector_size = OCFS2_MIN_BLOCKSIZE;\n\n\t/* check block zero for old format */\n\tstatus = ocfs2_get_sector(sb, bh, 0, *sector_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\thdr = (struct ocfs1_vol_disk_hdr *) (*bh)->b_data;\n\tif (hdr->major_version == OCFS1_MAJOR_VERSION) {\n\t\tmlog(ML_ERROR, \"incompatible version: %u.%u\\n\",\n\t\t     hdr->major_version, hdr->minor_version);\n\t\tstatus = -EINVAL;\n\t}\n\tif (memcmp(hdr->signature, OCFS1_VOLUME_SIGNATURE,\n\t\t   strlen(OCFS1_VOLUME_SIGNATURE)) == 0) {\n\t\tmlog(ML_ERROR, \"incompatible volume signature: %8s\\n\",\n\t\t     hdr->signature);\n\t\tstatus = -EINVAL;\n\t}\n\tbrelse(*bh);\n\t*bh = NULL;\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"This is an ocfs v1 filesystem which must be \"\n\t\t     \"upgraded before mounting with ocfs v2\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Now check at magic offset for 512, 1024, 2048, 4096\n\t * blocksizes.  4096 is the maximum blocksize because it is\n\t * the minimum clustersize.\n\t */\n\tstatus = -EINVAL;\n\tfor (blksize = *sector_size;\n\t     blksize <= OCFS2_MAX_BLOCKSIZE;\n\t     blksize <<= 1) {\n\t\ttmpstat = ocfs2_get_sector(sb, bh,\n\t\t\t\t\t   OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t\t\t   blksize);\n\t\tif (tmpstat < 0) {\n\t\t\tstatus = tmpstat;\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *) (*bh)->b_data;\n\t\tmemset(stats, 0, sizeof(struct ocfs2_blockcheck_stats));\n\t\tspin_lock_init(&stats->b_lock);\n\t\ttmpstat = ocfs2_verify_volume(di, *bh, blksize, stats);\n\t\tif (tmpstat < 0) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t\tif (tmpstat != -EAGAIN) {\n\t\t\tstatus = tmpstat;\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_parse_options",
          "args": [
            "sb",
            "data",
            "&parsed_options",
            "0"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1273-1503",
          "snippet": "static int ocfs2_parse_options(struct super_block *sb,\n\t\t\t       char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount)\n{\n\tint status, user_stack = 0;\n\tchar *p;\n\tu32 tmp;\n\n\ttrace_ocfs2_parse_options(is_remount, options ? options : \"(none)\");\n\n\tmopt->commit_interval = 0;\n\tmopt->mount_opt = OCFS2_MOUNT_NOINTR;\n\tmopt->atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\tmopt->slot = OCFS2_INVALID_SLOT;\n\tmopt->localalloc_opt = -1;\n\tmopt->cluster_stack[0] = '\\0';\n\tmopt->resv_level = OCFS2_DEFAULT_RESV_LEVEL;\n\tmopt->dir_resv_level = -1;\n\n\tif (!options) {\n\t\tstatus = 1;\n\t\tgoto bail;\n\t}\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, option;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_hb_local:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_LOCAL;\n\t\t\tbreak;\n\t\tcase Opt_hb_none:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_NONE;\n\t\t\tbreak;\n\t\tcase Opt_hb_global:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_GLOBAL;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_BARRIER;\n\t\t\telse\n\t\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_user_xattr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_atime_quantum:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->atime_quantum = option;\n\t\t\tbreak;\n\t\tcase Opt_slot:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->slot = (s16)option;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tmopt->commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_localalloc:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->localalloc_opt = option;\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\t/*\n\t\t\t * Changing this during remount could race\n\t\t\t * flock() requests, or \"unbalance\" existing\n\t\t\t * ones (e.g., a lock is taken in one mode but\n\t\t\t * dropped in the other). If users care enough\n\t\t\t * to flip locking modes during remount, we\n\t\t\t * could add a \"local\" flag to individual\n\t\t\t * flock structures for proper tracking of\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (!is_remount)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_LOCALFLOCKS;\n\t\t\tbreak;\n\t\tcase Opt_stack:\n\t\t\t/* Check both that the option we were passed\n\t\t\t * is of the right length and that it is a proper\n\t\t\t * string of the right length.\n\t\t\t */\n\t\t\tif (((args[0].to - args[0].from) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN) ||\n\t\t\t    (strnlen(args[0].from,\n\t\t\t\t     OCFS2_STACK_LABEL_LEN) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN)) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Invalid cluster_stack option\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(mopt->cluster_stack, args[0].from,\n\t\t\t       OCFS2_STACK_LABEL_LEN);\n\t\t\tmopt->cluster_stack[OCFS2_STACK_LABEL_LEN] = '\\0';\n\t\t\t/*\n\t\t\t * Open code the memcmp here as we don't have\n\t\t\t * an osb to pass to\n\t\t\t * ocfs2_userspace_stack().\n\t\t\t */\n\t\t\tif (memcmp(mopt->cluster_stack,\n\t\t\t\t   OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t\t\t   OCFS2_STACK_LABEL_LEN))\n\t\t\t\tuser_stack = 1;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_INODE64;\n\t\t\tbreak;\n\t\tcase Opt_usrquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_GRPQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_coherency_buffered:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_coherency_full:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_dir_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->dir_resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_async_commit:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t     \"or missing value\\n\", p);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (user_stack == 0) {\n\t\t/* Ensure only one heartbeat mode */\n\t\ttmp = mopt->mount_opt & (OCFS2_MOUNT_HB_LOCAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_GLOBAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_NONE);\n\t\tif (hweight32(tmp) != 1) {\n\t\t\tmlog(ML_ERROR, \"Invalid heartbeat mount options\\n\");\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 1;\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_parse_options(struct super_block *sb, char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount);",
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
            "static const match_table_t tokens = {\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_intr, \"intr\"},\n\t{Opt_nointr, \"nointr\"},\n\t{Opt_hb_none, OCFS2_HB_NONE},\n\t{Opt_hb_local, OCFS2_HB_LOCAL},\n\t{Opt_hb_global, OCFS2_HB_GLOBAL},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_atime_quantum, \"atime_quantum=%u\"},\n\t{Opt_slot, \"preferred_slot=%u\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_localalloc, \"localalloc=%d\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_stack, \"cluster_stack=%s\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_coherency_buffered, \"coherency=buffered\"},\n\t{Opt_coherency_full, \"coherency=full\"},\n\t{Opt_resv_level, \"resv_level=%u\"},\n\t{Opt_dir_resv_level, \"dir_resv_level=%u\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_parse_options(struct super_block *sb, char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount);\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const match_table_t tokens = {\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_intr, \"intr\"},\n\t{Opt_nointr, \"nointr\"},\n\t{Opt_hb_none, OCFS2_HB_NONE},\n\t{Opt_hb_local, OCFS2_HB_LOCAL},\n\t{Opt_hb_global, OCFS2_HB_GLOBAL},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_atime_quantum, \"atime_quantum=%u\"},\n\t{Opt_slot, \"preferred_slot=%u\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_localalloc, \"localalloc=%d\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_stack, \"cluster_stack=%s\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_coherency_buffered, \"coherency=buffered\"},\n\t{Opt_coherency_full, \"coherency=full\"},\n\t{Opt_resv_level, \"resv_level=%u\"},\n\t{Opt_dir_resv_level, \"dir_resv_level=%u\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ocfs2_parse_options(struct super_block *sb,\n\t\t\t       char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount)\n{\n\tint status, user_stack = 0;\n\tchar *p;\n\tu32 tmp;\n\n\ttrace_ocfs2_parse_options(is_remount, options ? options : \"(none)\");\n\n\tmopt->commit_interval = 0;\n\tmopt->mount_opt = OCFS2_MOUNT_NOINTR;\n\tmopt->atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\tmopt->slot = OCFS2_INVALID_SLOT;\n\tmopt->localalloc_opt = -1;\n\tmopt->cluster_stack[0] = '\\0';\n\tmopt->resv_level = OCFS2_DEFAULT_RESV_LEVEL;\n\tmopt->dir_resv_level = -1;\n\n\tif (!options) {\n\t\tstatus = 1;\n\t\tgoto bail;\n\t}\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, option;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_hb_local:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_LOCAL;\n\t\t\tbreak;\n\t\tcase Opt_hb_none:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_NONE;\n\t\t\tbreak;\n\t\tcase Opt_hb_global:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_GLOBAL;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_BARRIER;\n\t\t\telse\n\t\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_user_xattr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_atime_quantum:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->atime_quantum = option;\n\t\t\tbreak;\n\t\tcase Opt_slot:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->slot = (s16)option;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tmopt->commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_localalloc:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->localalloc_opt = option;\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\t/*\n\t\t\t * Changing this during remount could race\n\t\t\t * flock() requests, or \"unbalance\" existing\n\t\t\t * ones (e.g., a lock is taken in one mode but\n\t\t\t * dropped in the other). If users care enough\n\t\t\t * to flip locking modes during remount, we\n\t\t\t * could add a \"local\" flag to individual\n\t\t\t * flock structures for proper tracking of\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (!is_remount)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_LOCALFLOCKS;\n\t\t\tbreak;\n\t\tcase Opt_stack:\n\t\t\t/* Check both that the option we were passed\n\t\t\t * is of the right length and that it is a proper\n\t\t\t * string of the right length.\n\t\t\t */\n\t\t\tif (((args[0].to - args[0].from) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN) ||\n\t\t\t    (strnlen(args[0].from,\n\t\t\t\t     OCFS2_STACK_LABEL_LEN) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN)) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Invalid cluster_stack option\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(mopt->cluster_stack, args[0].from,\n\t\t\t       OCFS2_STACK_LABEL_LEN);\n\t\t\tmopt->cluster_stack[OCFS2_STACK_LABEL_LEN] = '\\0';\n\t\t\t/*\n\t\t\t * Open code the memcmp here as we don't have\n\t\t\t * an osb to pass to\n\t\t\t * ocfs2_userspace_stack().\n\t\t\t */\n\t\t\tif (memcmp(mopt->cluster_stack,\n\t\t\t\t   OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t\t\t   OCFS2_STACK_LABEL_LEN))\n\t\t\t\tuser_stack = 1;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_INODE64;\n\t\t\tbreak;\n\t\tcase Opt_usrquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_GRPQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_coherency_buffered:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_coherency_full:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_dir_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->dir_resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_async_commit:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t     \"or missing value\\n\", p);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (user_stack == 0) {\n\t\t/* Ensure only one heartbeat mode */\n\t\ttmp = mopt->mount_opt & (OCFS2_MOUNT_HB_LOCAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_GLOBAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_NONE);\n\t\tif (hweight32(tmp) != 1) {\n\t\t\tmlog(ML_ERROR, \"Invalid heartbeat mount options\\n\");\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 1;\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_fill_super",
          "args": [
            "sb",
            "data",
            "silent"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *ocfs2_debugfs_root;\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(MS_POSIXACL | MS_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, MS_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb->s_flags & MS_RDONLY)\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_disable_quotas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "978-1003",
    "snippet": "static void ocfs2_disable_quotas(struct ocfs2_super *osb)\n{\n\tint type;\n\tstruct inode *inode;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t/* We mostly ignore errors in this function because there's not much\n\t * we can do when we see them */\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!sb_has_quota_loaded(sb, type))\n\t\t\tcontinue;\n\t\t/* Cancel periodic syncing before we grab dqonoff_mutex */\n\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\tinode = igrab(sb->s_dquot.files[type]);\n\t\t/* Turn off quotas. This will remove all dquot structures from\n\t\t * memory and so they will be automatically synced to global\n\t\t * quota files */\n\t\tdquot_disable(sb, type, DQUOT_USAGE_ENABLED |\n\t\t\t\t\tDQUOT_LIMITS_ENABLED);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tiput(inode);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_disable",
          "args": [
            "sb",
            "type",
            "DQUOT_USAGE_ENABLED |\n\t\t\t\t\tDQUOT_LIMITS_ENABLED"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1999-2127",
          "snippet": "int dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "sb->s_dquot.files[type]"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&oinfo->dqi_sync_work"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_has_quota_loaded",
          "args": [
            "sb",
            "type"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb)\n{\n\tint type;\n\tstruct inode *inode;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t/* We mostly ignore errors in this function because there's not much\n\t * we can do when we see them */\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!sb_has_quota_loaded(sb, type))\n\t\t\tcontinue;\n\t\t/* Cancel periodic syncing before we grab dqonoff_mutex */\n\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\tinode = igrab(sb->s_dquot.files[type]);\n\t\t/* Turn off quotas. This will remove all dquot structures from\n\t\t * memory and so they will be automatically synced to global\n\t\t * quota files */\n\t\tdquot_disable(sb, type, DQUOT_USAGE_ENABLED |\n\t\t\t\t\tDQUOT_LIMITS_ENABLED);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tiput(inode);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_enable_quotas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "938-976",
    "snippet": "static int ocfs2_enable_quotas(struct ocfs2_super *osb)\n{\n\tstruct inode *inode[OCFS2_MAXQUOTAS] = { NULL, NULL };\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tLOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\tLOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tint status;\n\tint type;\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NEGATIVE_USAGE;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tinode[type] = ocfs2_get_system_file_inode(osb, ino[type],\n\t\t\t\t\t\t\tosb->slot_num);\n\t\tif (!inode[type]) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out_quota_off;\n\t\t}\n\t\tstatus = dquot_enable(inode[type], type, QFMT_OCFS2,\n\t\t\t\t      DQUOT_USAGE_ENABLED);\n\t\tif (status < 0)\n\t\t\tgoto out_quota_off;\n\t}\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\treturn 0;\nout_quota_off:\n\tocfs2_disable_quotas(osb);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode[type]"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_disable_quotas",
          "args": [
            "osb"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_disable_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "978-1003",
          "snippet": "static void ocfs2_disable_quotas(struct ocfs2_super *osb)\n{\n\tint type;\n\tstruct inode *inode;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t/* We mostly ignore errors in this function because there's not much\n\t * we can do when we see them */\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!sb_has_quota_loaded(sb, type))\n\t\t\tcontinue;\n\t\t/* Cancel periodic syncing before we grab dqonoff_mutex */\n\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\tinode = igrab(sb->s_dquot.files[type]);\n\t\t/* Turn off quotas. This will remove all dquot structures from\n\t\t * memory and so they will be automatically synced to global\n\t\t * quota files */\n\t\tdquot_disable(sb, type, DQUOT_USAGE_ENABLED |\n\t\t\t\t\tDQUOT_LIMITS_ENABLED);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb)\n{\n\tint type;\n\tstruct inode *inode;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t/* We mostly ignore errors in this function because there's not much\n\t * we can do when we see them */\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!sb_has_quota_loaded(sb, type))\n\t\t\tcontinue;\n\t\t/* Cancel periodic syncing before we grab dqonoff_mutex */\n\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\tinode = igrab(sb->s_dquot.files[type]);\n\t\t/* Turn off quotas. This will remove all dquot structures from\n\t\t * memory and so they will be automatically synced to global\n\t\t * quota files */\n\t\tdquot_disable(sb, type, DQUOT_USAGE_ENABLED |\n\t\t\t\t\tDQUOT_LIMITS_ENABLED);\n\t\tif (!inode)\n\t\t\tcontinue;\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_enable",
          "args": [
            "inode[type]",
            "type",
            "QFMT_OCFS2",
            "DQUOT_USAGE_ENABLED"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2313-2353",
          "snippet": "int dquot_enable(struct inode *inode, int type, int format_id,\n\t\t unsigned int flags)\n{\n\tint ret = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\t/* Just unsuspend quotas? */\n\tBUG_ON(flags & DQUOT_SUSPENDED);\n\n\tif (!flags)\n\t\treturn 0;\n\t/* Just updating flags needed? */\n\tif (sb_has_quota_loaded(sb, type)) {\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t/* Now do a reliable test... */\n\t\tif (!sb_has_quota_loaded(sb, type)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tgoto load_quota;\n\t\t}\n\t\tif (flags & DQUOT_USAGE_ENABLED &&\n\t\t    sb_has_quota_usage_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_lock;\n\t\t}\n\t\tif (flags & DQUOT_LIMITS_ENABLED &&\n\t\t    sb_has_quota_limits_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_lock;\n\t\t}\n\t\tspin_lock(&dq_state_lock);\n\t\tsb_dqopt(sb)->flags |= dquot_state_flag(flags, type);\n\t\tspin_unlock(&dq_state_lock);\nout_lock:\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn ret;\n\t}\n\nload_quota:\n\treturn vfs_load_quota_inode(inode, type, format_id, flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_enable(struct inode *inode, int type, int format_id,\n\t\t unsigned int flags)\n{\n\tint ret = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\n\t/* Just unsuspend quotas? */\n\tBUG_ON(flags & DQUOT_SUSPENDED);\n\n\tif (!flags)\n\t\treturn 0;\n\t/* Just updating flags needed? */\n\tif (sb_has_quota_loaded(sb, type)) {\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t/* Now do a reliable test... */\n\t\tif (!sb_has_quota_loaded(sb, type)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tgoto load_quota;\n\t\t}\n\t\tif (flags & DQUOT_USAGE_ENABLED &&\n\t\t    sb_has_quota_usage_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_lock;\n\t\t}\n\t\tif (flags & DQUOT_LIMITS_ENABLED &&\n\t\t    sb_has_quota_limits_enabled(sb, type)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_lock;\n\t\t}\n\t\tspin_lock(&dq_state_lock);\n\t\tsb_dqopt(sb)->flags |= dquot_state_flag(flags, type);\n\t\tspin_unlock(&dq_state_lock);\nout_lock:\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn ret;\n\t}\n\nload_quota:\n\treturn vfs_load_quota_inode(inode, type, format_id, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "ino[type]",
            "osb->slot_num"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "feature[type]"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb)\n{\n\tstruct inode *inode[OCFS2_MAXQUOTAS] = { NULL, NULL };\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tLOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\tLOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tint status;\n\tint type;\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NEGATIVE_USAGE;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tinode[type] = ocfs2_get_system_file_inode(osb, ino[type],\n\t\t\t\t\t\t\tosb->slot_num);\n\t\tif (!inode[type]) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out_quota_off;\n\t\t}\n\t\tstatus = dquot_enable(inode[type], type, QFMT_OCFS2,\n\t\t\t\t      DQUOT_USAGE_ENABLED);\n\t\tif (status < 0)\n\t\t\tgoto out_quota_off;\n\t}\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\treturn 0;\nout_quota_off:\n\tocfs2_disable_quotas(osb);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_susp_quotas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "907-936",
    "snippet": "static int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend)\n{\n\tint type;\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tint status = 0;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tif (unsuspend)\n\t\t\tstatus = dquot_resume(sb, type);\n\t\telse {\n\t\t\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t\t\t/* Cancel periodic syncing before suspending */\n\t\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\t\tstatus = dquot_suspend(sb, type);\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Failed to suspend/unsuspend quotas on \"\n\t\t     \"remount (error = %d).\\n\", status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Failed to suspend/unsuspend quotas on \"\n\t\t     \"remount (error = %d).\\n\"",
            "status"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_suspend",
          "args": [
            "sb",
            "type"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&oinfo->dqi_sync_work"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_resume",
          "args": [
            "sb",
            "type"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2256-2289",
          "snippet": "int dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "feature[type]"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend)\n{\n\tint type;\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tint status = 0;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tif (unsuspend)\n\t\t\tstatus = dquot_resume(sb, type);\n\t\telse {\n\t\t\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t\t\t/* Cancel periodic syncing before suspending */\n\t\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\t\tstatus = dquot_suspend(sb, type);\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Failed to suspend/unsuspend quotas on \"\n\t\t     \"remount (error = %d).\\n\", status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_verify_userspace_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "883-905",
    "snippet": "static int ocfs2_verify_userspace_stack(struct ocfs2_super *osb,\n\t\t\t\t\tstruct mount_options *mopt)\n{\n\tif (!ocfs2_userspace_stack(osb) && mopt->cluster_stack[0]) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount, but this filesystem \"\n\t\t     \"does not support it\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ocfs2_userspace_stack(osb) &&\n\t    strncmp(osb->osb_cluster_stack, mopt->cluster_stack,\n\t\t    OCFS2_STACK_LABEL_LEN)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount (\\\"%s\\\") does not \"\n\t\t     \"match the filesystem (\\\"%s\\\")\\n\",\n\t\t     mopt->cluster_stack,\n\t\t     osb->osb_cluster_stack);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"cluster stack passed to mount (\\\"%s\\\") does not \"\n\t\t     \"match the filesystem (\\\"%s\\\")\\n\"",
            "mopt->cluster_stack",
            "osb->osb_cluster_stack"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "osb->osb_cluster_stack",
            "mopt->cluster_stack",
            "OCFS2_STACK_LABEL_LEN"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_userspace_stack",
          "args": [
            "osb"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_userspace_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "644-651",
          "snippet": "static inline int ocfs2_userspace_stack(struct ocfs2_super *osb)\n{\n\tif (ocfs2_clusterinfo_valid(osb) &&\n\t    memcmp(osb->osb_cluster_stack, OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t   OCFS2_STACK_LABEL_LEN))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_userspace_stack(struct ocfs2_super *osb)\n{\n\tif (ocfs2_clusterinfo_valid(osb) &&\n\t    memcmp(osb->osb_cluster_stack, OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t   OCFS2_STACK_LABEL_LEN))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"cluster stack passed to mount, but this filesystem \"\n\t\t     \"does not support it\\n\""
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_verify_userspace_stack(struct ocfs2_super *osb,\n\t\t\t\t\tstruct mount_options *mopt)\n{\n\tif (!ocfs2_userspace_stack(osb) && mopt->cluster_stack[0]) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount, but this filesystem \"\n\t\t     \"does not support it\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ocfs2_userspace_stack(osb) &&\n\t    strncmp(osb->osb_cluster_stack, mopt->cluster_stack,\n\t\t    OCFS2_STACK_LABEL_LEN)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"cluster stack passed to mount (\\\"%s\\\") does not \"\n\t\t     \"match the filesystem (\\\"%s\\\")\\n\",\n\t\t     mopt->cluster_stack,\n\t\t     osb->osb_cluster_stack);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_verify_heartbeat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "842-876",
    "snippet": "static int ocfs2_verify_heartbeat(struct ocfs2_super *osb)\n{\n\tu32 hb_enabled = OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL;\n\n\tif (osb->s_mount_opt & hb_enabled) {\n\t\tif (ocfs2_mount_local(osb)) {\n\t\t\tmlog(ML_ERROR, \"Cannot heartbeat on a locally \"\n\t\t\t     \"mounted device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Userspace stack expected, but \"\n\t\t\t     \"o2cb heartbeat arguments passed to mount\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (((osb->s_mount_opt & OCFS2_MOUNT_HB_GLOBAL) &&\n\t\t     !ocfs2_cluster_o2cb_global_heartbeat(osb)) ||\n\t\t    ((osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) &&\n\t\t     ocfs2_cluster_o2cb_global_heartbeat(osb))) {\n\t\t\tmlog(ML_ERROR, \"Mismatching o2cb heartbeat modes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!(osb->s_mount_opt & hb_enabled)) {\n\t\tif (!ocfs2_mount_local(osb) && !ocfs2_is_hard_readonly(osb) &&\n\t\t    !ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Heartbeat has to be started to mount \"\n\t\t\t     \"a read-write clustered device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Heartbeat has to be started to mount \"\n\t\t\t     \"a read-write clustered device.\\n\""
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_userspace_stack",
          "args": [
            "osb"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_userspace_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "644-651",
          "snippet": "static inline int ocfs2_userspace_stack(struct ocfs2_super *osb)\n{\n\tif (ocfs2_clusterinfo_valid(osb) &&\n\t    memcmp(osb->osb_cluster_stack, OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t   OCFS2_STACK_LABEL_LEN))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_userspace_stack(struct ocfs2_super *osb)\n{\n\tif (ocfs2_clusterinfo_valid(osb) &&\n\t    memcmp(osb->osb_cluster_stack, OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t   OCFS2_STACK_LABEL_LEN))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_o2cb_global_heartbeat",
          "args": [
            "osb"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_o2cb_global_heartbeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "662-666",
          "snippet": "static inline int ocfs2_cluster_o2cb_global_heartbeat(struct ocfs2_super *osb)\n{\n\treturn ocfs2_o2cb_stack(osb) &&\n\t\t(osb->osb_stackflags & OCFS2_CLUSTER_O2CB_GLOBAL_HEARTBEAT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_cluster_o2cb_global_heartbeat(struct ocfs2_super *osb)\n{\n\treturn ocfs2_o2cb_stack(osb) &&\n\t\t(osb->osb_stackflags & OCFS2_CLUSTER_O2CB_GLOBAL_HEARTBEAT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_verify_heartbeat(struct ocfs2_super *osb)\n{\n\tu32 hb_enabled = OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL;\n\n\tif (osb->s_mount_opt & hb_enabled) {\n\t\tif (ocfs2_mount_local(osb)) {\n\t\t\tmlog(ML_ERROR, \"Cannot heartbeat on a locally \"\n\t\t\t     \"mounted device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Userspace stack expected, but \"\n\t\t\t     \"o2cb heartbeat arguments passed to mount\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (((osb->s_mount_opt & OCFS2_MOUNT_HB_GLOBAL) &&\n\t\t     !ocfs2_cluster_o2cb_global_heartbeat(osb)) ||\n\t\t    ((osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) &&\n\t\t     ocfs2_cluster_o2cb_global_heartbeat(osb))) {\n\t\t\tmlog(ML_ERROR, \"Mismatching o2cb heartbeat modes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!(osb->s_mount_opt & hb_enabled)) {\n\t\tif (!ocfs2_mount_local(osb) && !ocfs2_is_hard_readonly(osb) &&\n\t\t    !ocfs2_userspace_stack(osb)) {\n\t\t\tmlog(ML_ERROR, \"Heartbeat has to be started to mount \"\n\t\t\t     \"a read-write clustered device.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_sb_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "756-840",
    "snippet": "static int ocfs2_sb_probe(struct super_block *sb,\n\t\t\t  struct buffer_head **bh,\n\t\t\t  int *sector_size,\n\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status, tmpstat;\n\tstruct ocfs1_vol_disk_hdr *hdr;\n\tstruct ocfs2_dinode *di;\n\tint blksize;\n\n\t*bh = NULL;\n\n\t/* may be > 512 */\n\t*sector_size = bdev_logical_block_size(sb->s_bdev);\n\tif (*sector_size > OCFS2_MAX_BLOCKSIZE) {\n\t\tmlog(ML_ERROR, \"Hardware sector size too large: %d (max=%d)\\n\",\n\t\t     *sector_size, OCFS2_MAX_BLOCKSIZE);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t/* Can this really happen? */\n\tif (*sector_size < OCFS2_MIN_BLOCKSIZE)\n\t\t*sector_size = OCFS2_MIN_BLOCKSIZE;\n\n\t/* check block zero for old format */\n\tstatus = ocfs2_get_sector(sb, bh, 0, *sector_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\thdr = (struct ocfs1_vol_disk_hdr *) (*bh)->b_data;\n\tif (hdr->major_version == OCFS1_MAJOR_VERSION) {\n\t\tmlog(ML_ERROR, \"incompatible version: %u.%u\\n\",\n\t\t     hdr->major_version, hdr->minor_version);\n\t\tstatus = -EINVAL;\n\t}\n\tif (memcmp(hdr->signature, OCFS1_VOLUME_SIGNATURE,\n\t\t   strlen(OCFS1_VOLUME_SIGNATURE)) == 0) {\n\t\tmlog(ML_ERROR, \"incompatible volume signature: %8s\\n\",\n\t\t     hdr->signature);\n\t\tstatus = -EINVAL;\n\t}\n\tbrelse(*bh);\n\t*bh = NULL;\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"This is an ocfs v1 filesystem which must be \"\n\t\t     \"upgraded before mounting with ocfs v2\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Now check at magic offset for 512, 1024, 2048, 4096\n\t * blocksizes.  4096 is the maximum blocksize because it is\n\t * the minimum clustersize.\n\t */\n\tstatus = -EINVAL;\n\tfor (blksize = *sector_size;\n\t     blksize <= OCFS2_MAX_BLOCKSIZE;\n\t     blksize <<= 1) {\n\t\ttmpstat = ocfs2_get_sector(sb, bh,\n\t\t\t\t\t   OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t\t\t   blksize);\n\t\tif (tmpstat < 0) {\n\t\t\tstatus = tmpstat;\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *) (*bh)->b_data;\n\t\tmemset(stats, 0, sizeof(struct ocfs2_blockcheck_stats));\n\t\tspin_lock_init(&stats->b_lock);\n\t\ttmpstat = ocfs2_verify_volume(di, *bh, blksize, stats);\n\t\tif (tmpstat < 0) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t\tif (tmpstat != -EAGAIN) {\n\t\t\tstatus = tmpstat;\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
      "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bh"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_verify_volume",
          "args": [
            "di",
            "*bh",
            "blksize",
            "stats"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_verify_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2347-2411",
          "snippet": "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 blksz,\n\t\t\t       struct ocfs2_blockcheck_stats *stats)\n{\n\tint status = -EAGAIN;\n\n\tif (memcmp(di->i_signature, OCFS2_SUPER_BLOCK_SIGNATURE,\n\t\t   strlen(OCFS2_SUPER_BLOCK_SIGNATURE)) == 0) {\n\t\t/* We have to do a raw check of the feature here */\n\t\tif (le32_to_cpu(di->id2.i_super.s_feature_incompat) &\n\t\t    OCFS2_FEATURE_INCOMPAT_META_ECC) {\n\t\t\tstatus = ocfs2_block_check_validate(bh->b_data,\n\t\t\t\t\t\t\t    bh->b_size,\n\t\t\t\t\t\t\t    &di->i_check,\n\t\t\t\t\t\t\t    stats);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tstatus = -EINVAL;\n\t\tif ((1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits)) != blksz) {\n\t\t\tmlog(ML_ERROR, \"found superblock with incorrect block \"\n\t\t\t     \"size: found %u, should be %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits),\n\t\t\t       blksz);\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_major_rev_level) !=\n\t\t\t   OCFS2_MAJOR_REV_LEVEL ||\n\t\t\t   le16_to_cpu(di->id2.i_super.s_minor_rev_level) !=\n\t\t\t   OCFS2_MINOR_REV_LEVEL) {\n\t\t\tmlog(ML_ERROR, \"found superblock with bad version: \"\n\t\t\t     \"found %u.%u, should be %u.%u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_major_rev_level),\n\t\t\t     le16_to_cpu(di->id2.i_super.s_minor_rev_level),\n\t\t\t     OCFS2_MAJOR_REV_LEVEL,\n\t\t\t     OCFS2_MINOR_REV_LEVEL);\n\t\t} else if (bh->b_blocknr != le64_to_cpu(di->i_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad block number on superblock: \"\n\t\t\t     \"found %llu, should be %llu\\n\",\n\t\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t} else if (le32_to_cpu(di->id2.i_super.s_clustersize_bits) < 12 ||\n\t\t\t    le32_to_cpu(di->id2.i_super.s_clustersize_bits) > 20) {\n\t\t\tmlog(ML_ERROR, \"bad cluster size found: %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_clustersize_bits));\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_root_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad root_blkno: 0\\n\");\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_system_dir_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad system_dir_blkno: 0\\n\");\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_max_slots) > OCFS2_MAX_SLOTS) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Superblock slots found greater than file system \"\n\t\t\t     \"maximum: found %u, max %u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_max_slots),\n\t\t\t     OCFS2_MAX_SLOTS);\n\t\t} else {\n\t\t\t/* found it! */\n\t\t\tstatus = 0;\n\t\t}\n\t}\n\nout:\n\tif (status && status != -EAGAIN)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
            "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\n\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 blksz,\n\t\t\t       struct ocfs2_blockcheck_stats *stats)\n{\n\tint status = -EAGAIN;\n\n\tif (memcmp(di->i_signature, OCFS2_SUPER_BLOCK_SIGNATURE,\n\t\t   strlen(OCFS2_SUPER_BLOCK_SIGNATURE)) == 0) {\n\t\t/* We have to do a raw check of the feature here */\n\t\tif (le32_to_cpu(di->id2.i_super.s_feature_incompat) &\n\t\t    OCFS2_FEATURE_INCOMPAT_META_ECC) {\n\t\t\tstatus = ocfs2_block_check_validate(bh->b_data,\n\t\t\t\t\t\t\t    bh->b_size,\n\t\t\t\t\t\t\t    &di->i_check,\n\t\t\t\t\t\t\t    stats);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tstatus = -EINVAL;\n\t\tif ((1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits)) != blksz) {\n\t\t\tmlog(ML_ERROR, \"found superblock with incorrect block \"\n\t\t\t     \"size: found %u, should be %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_blocksize_bits),\n\t\t\t       blksz);\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_major_rev_level) !=\n\t\t\t   OCFS2_MAJOR_REV_LEVEL ||\n\t\t\t   le16_to_cpu(di->id2.i_super.s_minor_rev_level) !=\n\t\t\t   OCFS2_MINOR_REV_LEVEL) {\n\t\t\tmlog(ML_ERROR, \"found superblock with bad version: \"\n\t\t\t     \"found %u.%u, should be %u.%u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_major_rev_level),\n\t\t\t     le16_to_cpu(di->id2.i_super.s_minor_rev_level),\n\t\t\t     OCFS2_MAJOR_REV_LEVEL,\n\t\t\t     OCFS2_MINOR_REV_LEVEL);\n\t\t} else if (bh->b_blocknr != le64_to_cpu(di->i_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad block number on superblock: \"\n\t\t\t     \"found %llu, should be %llu\\n\",\n\t\t\t     (unsigned long long)le64_to_cpu(di->i_blkno),\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t} else if (le32_to_cpu(di->id2.i_super.s_clustersize_bits) < 12 ||\n\t\t\t    le32_to_cpu(di->id2.i_super.s_clustersize_bits) > 20) {\n\t\t\tmlog(ML_ERROR, \"bad cluster size found: %u\\n\",\n\t\t\t     1 << le32_to_cpu(di->id2.i_super.s_clustersize_bits));\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_root_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad root_blkno: 0\\n\");\n\t\t} else if (!le64_to_cpu(di->id2.i_super.s_system_dir_blkno)) {\n\t\t\tmlog(ML_ERROR, \"bad system_dir_blkno: 0\\n\");\n\t\t} else if (le16_to_cpu(di->id2.i_super.s_max_slots) > OCFS2_MAX_SLOTS) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Superblock slots found greater than file system \"\n\t\t\t     \"maximum: found %u, max %u\\n\",\n\t\t\t     le16_to_cpu(di->id2.i_super.s_max_slots),\n\t\t\t     OCFS2_MAX_SLOTS);\n\t\t} else {\n\t\t\t/* found it! */\n\t\t\tstatus = 0;\n\t\t}\n\t}\n\nout:\n\tif (status && status != -EAGAIN)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&stats->b_lock"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stats",
            "0",
            "sizeof(struct ocfs2_blockcheck_stats)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_sector",
          "args": [
            "sb",
            "bh",
            "OCFS2_SUPER_BLOCK_BLKNO",
            "blksize"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1810-1839",
          "snippet": "static int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size)\n{\n\tif (!sb_set_blocksize(sb, sect_size)) {\n\t\tmlog(ML_ERROR, \"unable to set blocksize\\n\");\n\t\treturn -EIO;\n\t}\n\n\t*bh = sb_getblk(sb, block);\n\tif (!*bh) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\tlock_buffer(*bh);\n\tif (!buffer_dirty(*bh))\n\t\tclear_buffer_uptodate(*bh);\n\tunlock_buffer(*bh);\n\tll_rw_block(READ, 1, bh);\n\twait_on_buffer(*bh);\n\tif (!buffer_uptodate(*bh)) {\n\t\tmlog_errno(-EIO);\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_get_sector(struct super_block *sb,\n\t\t\t    struct buffer_head **bh,\n\t\t\t    int block,\n\t\t\t    int sect_size)\n{\n\tif (!sb_set_blocksize(sb, sect_size)) {\n\t\tmlog(ML_ERROR, \"unable to set blocksize\\n\");\n\t\treturn -EIO;\n\t}\n\n\t*bh = sb_getblk(sb, block);\n\tif (!*bh) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\tlock_buffer(*bh);\n\tif (!buffer_dirty(*bh))\n\t\tclear_buffer_uptodate(*bh);\n\tunlock_buffer(*bh);\n\tll_rw_block(READ, 1, bh);\n\twait_on_buffer(*bh);\n\tif (!buffer_uptodate(*bh)) {\n\t\tmlog_errno(-EIO);\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"This is an ocfs v1 filesystem which must be \"\n\t\t     \"upgraded before mounting with ocfs v2\\n\""
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"incompatible volume signature: %8s\\n\"",
            "hdr->signature"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "hdr->signature",
            "OCFS1_VOLUME_SIGNATURE",
            "strlen(OCFS1_VOLUME_SIGNATURE)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "OCFS1_VOLUME_SIGNATURE"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"incompatible version: %u.%u\\n\"",
            "hdr->major_version",
            "hdr->minor_version"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_sb_probe(struct super_block *sb,\n\t\t\t  struct buffer_head **bh,\n\t\t\t  int *sector_size,\n\t\t\t  struct ocfs2_blockcheck_stats *stats)\n{\n\tint status, tmpstat;\n\tstruct ocfs1_vol_disk_hdr *hdr;\n\tstruct ocfs2_dinode *di;\n\tint blksize;\n\n\t*bh = NULL;\n\n\t/* may be > 512 */\n\t*sector_size = bdev_logical_block_size(sb->s_bdev);\n\tif (*sector_size > OCFS2_MAX_BLOCKSIZE) {\n\t\tmlog(ML_ERROR, \"Hardware sector size too large: %d (max=%d)\\n\",\n\t\t     *sector_size, OCFS2_MAX_BLOCKSIZE);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t/* Can this really happen? */\n\tif (*sector_size < OCFS2_MIN_BLOCKSIZE)\n\t\t*sector_size = OCFS2_MIN_BLOCKSIZE;\n\n\t/* check block zero for old format */\n\tstatus = ocfs2_get_sector(sb, bh, 0, *sector_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\thdr = (struct ocfs1_vol_disk_hdr *) (*bh)->b_data;\n\tif (hdr->major_version == OCFS1_MAJOR_VERSION) {\n\t\tmlog(ML_ERROR, \"incompatible version: %u.%u\\n\",\n\t\t     hdr->major_version, hdr->minor_version);\n\t\tstatus = -EINVAL;\n\t}\n\tif (memcmp(hdr->signature, OCFS1_VOLUME_SIGNATURE,\n\t\t   strlen(OCFS1_VOLUME_SIGNATURE)) == 0) {\n\t\tmlog(ML_ERROR, \"incompatible volume signature: %8s\\n\",\n\t\t     hdr->signature);\n\t\tstatus = -EINVAL;\n\t}\n\tbrelse(*bh);\n\t*bh = NULL;\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"This is an ocfs v1 filesystem which must be \"\n\t\t     \"upgraded before mounting with ocfs v2\\n\");\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Now check at magic offset for 512, 1024, 2048, 4096\n\t * blocksizes.  4096 is the maximum blocksize because it is\n\t * the minimum clustersize.\n\t */\n\tstatus = -EINVAL;\n\tfor (blksize = *sector_size;\n\t     blksize <= OCFS2_MAX_BLOCKSIZE;\n\t     blksize <<= 1) {\n\t\ttmpstat = ocfs2_get_sector(sb, bh,\n\t\t\t\t\t   OCFS2_SUPER_BLOCK_BLKNO,\n\t\t\t\t\t   blksize);\n\t\tif (tmpstat < 0) {\n\t\t\tstatus = tmpstat;\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *) (*bh)->b_data;\n\t\tmemset(stats, 0, sizeof(struct ocfs2_blockcheck_stats));\n\t\tspin_lock_init(&stats->b_lock);\n\t\ttmpstat = ocfs2_verify_volume(di, *bh, blksize, stats);\n\t\tif (tmpstat < 0) {\n\t\t\tbrelse(*bh);\n\t\t\t*bh = NULL;\n\t\t}\n\t\tif (tmpstat != -EAGAIN) {\n\t\t\tstatus = tmpstat;\n\t\t\tbreak;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "638-754",
    "snippet": "static int ocfs2_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint incompat_features;\n\tint ret = 0;\n\tstruct mount_options parsed_options;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu32 tmp;\n\n\tsync_filesystem(sb);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 1) ||\n\t    !ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttmp = OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL |\n\t\tOCFS2_MOUNT_HB_NONE;\n\tif ((osb->s_mount_opt & tmp) != (parsed_options.mount_opt & tmp)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot change heartbeat mode on remount\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK) !=\n\t    (parsed_options.mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot change data mode on remount\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Probably don't want this on remount; it might\n\t * mess with other nodes */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64) &&\n\t    (parsed_options.mount_opt & OCFS2_MOUNT_INODE64)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot enable inode64 on remount\\n\");\n\t\tgoto out;\n\t}\n\n\t/* We're going to/from readonly mode. */\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {\n\t\t/* Disable quota accounting before remounting RO */\n\t\tif (*flags & MS_RDONLY) {\n\t\t\tret = ocfs2_susp_quotas(osb, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/* Lock here so the check of HARD_RO and the potential\n\t\t * setting of SOFT_RO is atomic. */\n\t\tspin_lock(&osb->osb_lock);\n\t\tif (osb->osb_flags & OCFS2_OSB_HARD_RO) {\n\t\t\tmlog(ML_ERROR, \"Remount on readonly device is forbidden.\\n\");\n\t\t\tret = -EROFS;\n\t\t\tgoto unlock_osb;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\t\t} else {\n\t\t\tif (osb->osb_flags & OCFS2_OSB_ERROR_FS) {\n\t\t\t\tmlog(ML_ERROR, \"Cannot remount RDWR \"\n\t\t\t\t     \"filesystem due to previous errors.\\n\");\n\t\t\t\tret = -EROFS;\n\t\t\t\tgoto unlock_osb;\n\t\t\t}\n\t\t\tincompat_features = OCFS2_HAS_RO_COMPAT_FEATURE(sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP);\n\t\t\tif (incompat_features) {\n\t\t\t\tmlog(ML_ERROR, \"Cannot remount RDWR because \"\n\t\t\t\t     \"of unsupported optional features \"\n\t\t\t\t     \"(%x).\\n\", incompat_features);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto unlock_osb;\n\t\t\t}\n\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tosb->osb_flags &= ~OCFS2_OSB_SOFT_RO;\n\t\t}\n\t\ttrace_ocfs2_remount(sb->s_flags, osb->osb_flags, *flags);\nunlock_osb:\n\t\tspin_unlock(&osb->osb_lock);\n\t\t/* Enable quota accounting after remounting RW */\n\t\tif (!ret && !(*flags & MS_RDONLY)) {\n\t\t\tif (sb_any_quota_suspended(sb))\n\t\t\t\tret = ocfs2_susp_quotas(osb, 1);\n\t\t\telse\n\t\t\t\tret = ocfs2_enable_quotas(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\t/* Return back changes... */\n\t\t\t\tspin_lock(&osb->osb_lock);\n\t\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\t\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t/* Only save off the new mount options in case of a successful\n\t\t * remount. */\n\t\tosb->s_mount_opt = parsed_options.mount_opt;\n\t\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\t\tosb->preferred_slot = parsed_options.slot;\n\t\tif (parsed_options.commit_interval)\n\t\t\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\t\tif (!ocfs2_is_hard_readonly(osb))\n\t\t\tocfs2_set_journal_params(osb);\n\n\t\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ?\n\t\t\t\t\t\t\tMS_POSIXACL : 0);\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_set_journal_params",
          "args": [
            "osb"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_journal_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "783-798",
          "snippet": "void ocfs2_set_journal_params(struct ocfs2_super *osb)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\tunsigned long commit_interval = OCFS2_DEFAULT_COMMIT_INTERVAL;\n\n\tif (osb->osb_commit_interval)\n\t\tcommit_interval = osb->osb_commit_interval;\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_commit_interval = commit_interval;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_BARRIER)\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DEFAULT_COMMIT_INTERVAL\t(HZ * JBD2_DEFAULT_MAX_COMMIT_AGE)"
          ],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DEFAULT_COMMIT_INTERVAL\t(HZ * JBD2_DEFAULT_MAX_COMMIT_AGE)\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_set_journal_params(struct ocfs2_super *osb)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\tunsigned long commit_interval = OCFS2_DEFAULT_COMMIT_INTERVAL;\n\n\tif (osb->osb_commit_interval)\n\t\tcommit_interval = osb->osb_commit_interval;\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_commit_interval = commit_interval;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_BARRIER)\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_enable_quotas",
          "args": [
            "osb"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_enable_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "938-976",
          "snippet": "static int ocfs2_enable_quotas(struct ocfs2_super *osb)\n{\n\tstruct inode *inode[OCFS2_MAXQUOTAS] = { NULL, NULL };\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tLOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\tLOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tint status;\n\tint type;\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NEGATIVE_USAGE;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tinode[type] = ocfs2_get_system_file_inode(osb, ino[type],\n\t\t\t\t\t\t\tosb->slot_num);\n\t\tif (!inode[type]) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out_quota_off;\n\t\t}\n\t\tstatus = dquot_enable(inode[type], type, QFMT_OCFS2,\n\t\t\t\t      DQUOT_USAGE_ENABLED);\n\t\tif (status < 0)\n\t\t\tgoto out_quota_off;\n\t}\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\treturn 0;\nout_quota_off:\n\tocfs2_disable_quotas(osb);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb)\n{\n\tstruct inode *inode[OCFS2_MAXQUOTAS] = { NULL, NULL };\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tLOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\tLOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tint status;\n\tint type;\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NEGATIVE_USAGE;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tinode[type] = ocfs2_get_system_file_inode(osb, ino[type],\n\t\t\t\t\t\t\tosb->slot_num);\n\t\tif (!inode[type]) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out_quota_off;\n\t\t}\n\t\tstatus = dquot_enable(inode[type], type, QFMT_OCFS2,\n\t\t\t\t      DQUOT_USAGE_ENABLED);\n\t\tif (status < 0)\n\t\t\tgoto out_quota_off;\n\t}\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\treturn 0;\nout_quota_off:\n\tocfs2_disable_quotas(osb);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tiput(inode[type]);\n\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_susp_quotas",
          "args": [
            "osb",
            "1"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_susp_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "907-936",
          "snippet": "static int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend)\n{\n\tint type;\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tint status = 0;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tif (unsuspend)\n\t\t\tstatus = dquot_resume(sb, type);\n\t\telse {\n\t\t\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t\t\t/* Cancel periodic syncing before suspending */\n\t\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\t\tstatus = dquot_suspend(sb, type);\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Failed to suspend/unsuspend quotas on \"\n\t\t     \"remount (error = %d).\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_susp_quotas(struct ocfs2_super *osb, int unsuspend)\n{\n\tint type;\n\tstruct super_block *sb = osb->sb;\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tint status = 0;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\tif (unsuspend)\n\t\t\tstatus = dquot_resume(sb, type);\n\t\telse {\n\t\t\tstruct ocfs2_mem_dqinfo *oinfo;\n\n\t\t\t/* Cancel periodic syncing before suspending */\n\t\t\toinfo = sb_dqinfo(sb, type)->dqi_priv;\n\t\t\tcancel_delayed_work_sync(&oinfo->dqi_sync_work);\n\t\t\tstatus = dquot_suspend(sb, type);\n\t\t}\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Failed to suspend/unsuspend quotas on \"\n\t\t     \"remount (error = %d).\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_any_quota_suspended",
          "args": [
            "sb"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_remount",
          "args": [
            "sb->s_flags",
            "osb->osb_flags",
            "*flags"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Cannot remount RDWR because \"\n\t\t\t\t     \"of unsupported optional features \"\n\t\t\t\t     \"(%x).\\n\"",
            "incompat_features"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~OCFS2_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Cannot remount RDWR \"\n\t\t\t\t     \"filesystem due to previous errors.\\n\""
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_set_options",
          "args": [
            "sb",
            "&parsed_options"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_parse_options",
          "args": [
            "sb",
            "data",
            "&parsed_options",
            "1"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1273-1503",
          "snippet": "static int ocfs2_parse_options(struct super_block *sb,\n\t\t\t       char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount)\n{\n\tint status, user_stack = 0;\n\tchar *p;\n\tu32 tmp;\n\n\ttrace_ocfs2_parse_options(is_remount, options ? options : \"(none)\");\n\n\tmopt->commit_interval = 0;\n\tmopt->mount_opt = OCFS2_MOUNT_NOINTR;\n\tmopt->atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\tmopt->slot = OCFS2_INVALID_SLOT;\n\tmopt->localalloc_opt = -1;\n\tmopt->cluster_stack[0] = '\\0';\n\tmopt->resv_level = OCFS2_DEFAULT_RESV_LEVEL;\n\tmopt->dir_resv_level = -1;\n\n\tif (!options) {\n\t\tstatus = 1;\n\t\tgoto bail;\n\t}\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, option;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_hb_local:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_LOCAL;\n\t\t\tbreak;\n\t\tcase Opt_hb_none:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_NONE;\n\t\t\tbreak;\n\t\tcase Opt_hb_global:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_GLOBAL;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_BARRIER;\n\t\t\telse\n\t\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_user_xattr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_atime_quantum:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->atime_quantum = option;\n\t\t\tbreak;\n\t\tcase Opt_slot:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->slot = (s16)option;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tmopt->commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_localalloc:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->localalloc_opt = option;\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\t/*\n\t\t\t * Changing this during remount could race\n\t\t\t * flock() requests, or \"unbalance\" existing\n\t\t\t * ones (e.g., a lock is taken in one mode but\n\t\t\t * dropped in the other). If users care enough\n\t\t\t * to flip locking modes during remount, we\n\t\t\t * could add a \"local\" flag to individual\n\t\t\t * flock structures for proper tracking of\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (!is_remount)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_LOCALFLOCKS;\n\t\t\tbreak;\n\t\tcase Opt_stack:\n\t\t\t/* Check both that the option we were passed\n\t\t\t * is of the right length and that it is a proper\n\t\t\t * string of the right length.\n\t\t\t */\n\t\t\tif (((args[0].to - args[0].from) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN) ||\n\t\t\t    (strnlen(args[0].from,\n\t\t\t\t     OCFS2_STACK_LABEL_LEN) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN)) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Invalid cluster_stack option\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(mopt->cluster_stack, args[0].from,\n\t\t\t       OCFS2_STACK_LABEL_LEN);\n\t\t\tmopt->cluster_stack[OCFS2_STACK_LABEL_LEN] = '\\0';\n\t\t\t/*\n\t\t\t * Open code the memcmp here as we don't have\n\t\t\t * an osb to pass to\n\t\t\t * ocfs2_userspace_stack().\n\t\t\t */\n\t\t\tif (memcmp(mopt->cluster_stack,\n\t\t\t\t   OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t\t\t   OCFS2_STACK_LABEL_LEN))\n\t\t\t\tuser_stack = 1;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_INODE64;\n\t\t\tbreak;\n\t\tcase Opt_usrquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_GRPQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_coherency_buffered:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_coherency_full:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_dir_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->dir_resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_async_commit:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t     \"or missing value\\n\", p);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (user_stack == 0) {\n\t\t/* Ensure only one heartbeat mode */\n\t\ttmp = mopt->mount_opt & (OCFS2_MOUNT_HB_LOCAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_GLOBAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_NONE);\n\t\tif (hweight32(tmp) != 1) {\n\t\t\tmlog(ML_ERROR, \"Invalid heartbeat mount options\\n\");\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 1;\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_parse_options(struct super_block *sb, char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount);",
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
            "static const match_table_t tokens = {\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_intr, \"intr\"},\n\t{Opt_nointr, \"nointr\"},\n\t{Opt_hb_none, OCFS2_HB_NONE},\n\t{Opt_hb_local, OCFS2_HB_LOCAL},\n\t{Opt_hb_global, OCFS2_HB_GLOBAL},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_atime_quantum, \"atime_quantum=%u\"},\n\t{Opt_slot, \"preferred_slot=%u\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_localalloc, \"localalloc=%d\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_stack, \"cluster_stack=%s\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_coherency_buffered, \"coherency=buffered\"},\n\t{Opt_coherency_full, \"coherency=full\"},\n\t{Opt_resv_level, \"resv_level=%u\"},\n\t{Opt_dir_resv_level, \"dir_resv_level=%u\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_parse_options(struct super_block *sb, char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount);\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const match_table_t tokens = {\n\t{Opt_barrier, \"barrier=%u\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_intr, \"intr\"},\n\t{Opt_nointr, \"nointr\"},\n\t{Opt_hb_none, OCFS2_HB_NONE},\n\t{Opt_hb_local, OCFS2_HB_LOCAL},\n\t{Opt_hb_global, OCFS2_HB_GLOBAL},\n\t{Opt_data_ordered, \"data=ordered\"},\n\t{Opt_data_writeback, \"data=writeback\"},\n\t{Opt_atime_quantum, \"atime_quantum=%u\"},\n\t{Opt_slot, \"preferred_slot=%u\"},\n\t{Opt_commit, \"commit=%u\"},\n\t{Opt_localalloc, \"localalloc=%d\"},\n\t{Opt_localflocks, \"localflocks\"},\n\t{Opt_stack, \"cluster_stack=%s\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_inode64, \"inode64\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_coherency_buffered, \"coherency=buffered\"},\n\t{Opt_coherency_full, \"coherency=full\"},\n\t{Opt_resv_level, \"resv_level=%u\"},\n\t{Opt_dir_resv_level, \"dir_resv_level=%u\"},\n\t{Opt_journal_async_commit, \"journal_async_commit\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ocfs2_parse_options(struct super_block *sb,\n\t\t\t       char *options,\n\t\t\t       struct mount_options *mopt,\n\t\t\t       int is_remount)\n{\n\tint status, user_stack = 0;\n\tchar *p;\n\tu32 tmp;\n\n\ttrace_ocfs2_parse_options(is_remount, options ? options : \"(none)\");\n\n\tmopt->commit_interval = 0;\n\tmopt->mount_opt = OCFS2_MOUNT_NOINTR;\n\tmopt->atime_quantum = OCFS2_DEFAULT_ATIME_QUANTUM;\n\tmopt->slot = OCFS2_INVALID_SLOT;\n\tmopt->localalloc_opt = -1;\n\tmopt->cluster_stack[0] = '\\0';\n\tmopt->resv_level = OCFS2_DEFAULT_RESV_LEVEL;\n\tmopt->dir_resv_level = -1;\n\n\tif (!options) {\n\t\tstatus = 1;\n\t\tgoto bail;\n\t}\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, option;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_hb_local:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_LOCAL;\n\t\t\tbreak;\n\t\tcase Opt_hb_none:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_NONE;\n\t\t\tbreak;\n\t\tcase Opt_hb_global:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_HB_GLOBAL;\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_BARRIER;\n\t\t\telse\n\t\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_BARRIER;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOINTR;\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_ERRORS_PANIC;\n\t\t\tbreak;\n\t\tcase Opt_data_ordered:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_data_writeback:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_DATA_WRITEBACK;\n\t\t\tbreak;\n\t\tcase Opt_user_xattr:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NOUSERXATTR;\n\t\t\tbreak;\n\t\tcase Opt_atime_quantum:\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->atime_quantum = option;\n\t\t\tbreak;\n\t\tcase Opt_slot:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option)\n\t\t\t\tmopt->slot = (s16)option;\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tmopt->commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_localalloc:\n\t\t\toption = 0;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= 0)\n\t\t\t\tmopt->localalloc_opt = option;\n\t\t\tbreak;\n\t\tcase Opt_localflocks:\n\t\t\t/*\n\t\t\t * Changing this during remount could race\n\t\t\t * flock() requests, or \"unbalance\" existing\n\t\t\t * ones (e.g., a lock is taken in one mode but\n\t\t\t * dropped in the other). If users care enough\n\t\t\t * to flip locking modes during remount, we\n\t\t\t * could add a \"local\" flag to individual\n\t\t\t * flock structures for proper tracking of\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (!is_remount)\n\t\t\t\tmopt->mount_opt |= OCFS2_MOUNT_LOCALFLOCKS;\n\t\t\tbreak;\n\t\tcase Opt_stack:\n\t\t\t/* Check both that the option we were passed\n\t\t\t * is of the right length and that it is a proper\n\t\t\t * string of the right length.\n\t\t\t */\n\t\t\tif (((args[0].to - args[0].from) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN) ||\n\t\t\t    (strnlen(args[0].from,\n\t\t\t\t     OCFS2_STACK_LABEL_LEN) !=\n\t\t\t     OCFS2_STACK_LABEL_LEN)) {\n\t\t\t\tmlog(ML_ERROR,\n\t\t\t\t     \"Invalid cluster_stack option\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tmemcpy(mopt->cluster_stack, args[0].from,\n\t\t\t       OCFS2_STACK_LABEL_LEN);\n\t\t\tmopt->cluster_stack[OCFS2_STACK_LABEL_LEN] = '\\0';\n\t\t\t/*\n\t\t\t * Open code the memcmp here as we don't have\n\t\t\t * an osb to pass to\n\t\t\t * ocfs2_userspace_stack().\n\t\t\t */\n\t\t\tif (memcmp(mopt->cluster_stack,\n\t\t\t\t   OCFS2_CLASSIC_CLUSTER_STACK,\n\t\t\t\t   OCFS2_STACK_LABEL_LEN))\n\t\t\t\tuser_stack = 1;\n\t\t\tbreak;\n\t\tcase Opt_inode64:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_INODE64;\n\t\t\tbreak;\n\t\tcase Opt_usrquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_USRQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_GRPQUOTA;\n\t\t\tbreak;\n\t\tcase Opt_coherency_buffered:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_coherency_full:\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_COHERENCY_BUFFERED;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t\t\tmopt->mount_opt &= ~OCFS2_MOUNT_POSIX_ACL;\n\t\t\tbreak;\n\t\tcase Opt_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_dir_resv_level:\n\t\t\tif (is_remount)\n\t\t\t\tbreak;\n\t\t\tif (match_int(&args[0], &option)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (option >= OCFS2_MIN_RESV_LEVEL &&\n\t\t\t    option < OCFS2_MAX_RESV_LEVEL)\n\t\t\t\tmopt->dir_resv_level = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_async_commit:\n\t\t\tmopt->mount_opt |= OCFS2_MOUNT_JOURNAL_ASYNC_COMMIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t     \"or missing value\\n\", p);\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (user_stack == 0) {\n\t\t/* Ensure only one heartbeat mode */\n\t\ttmp = mopt->mount_opt & (OCFS2_MOUNT_HB_LOCAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_GLOBAL |\n\t\t\t\t\t OCFS2_MOUNT_HB_NONE);\n\t\tif (hweight32(tmp) != 1) {\n\t\t\tmlog(ML_ERROR, \"Invalid heartbeat mount options\\n\");\n\t\t\tstatus = 0;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 1;\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint incompat_features;\n\tint ret = 0;\n\tstruct mount_options parsed_options;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tu32 tmp;\n\n\tsync_filesystem(sb);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 1) ||\n\t    !ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttmp = OCFS2_MOUNT_HB_LOCAL | OCFS2_MOUNT_HB_GLOBAL |\n\t\tOCFS2_MOUNT_HB_NONE;\n\tif ((osb->s_mount_opt & tmp) != (parsed_options.mount_opt & tmp)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot change heartbeat mode on remount\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK) !=\n\t    (parsed_options.mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot change data mode on remount\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Probably don't want this on remount; it might\n\t * mess with other nodes */\n\tif (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64) &&\n\t    (parsed_options.mount_opt & OCFS2_MOUNT_INODE64)) {\n\t\tret = -EINVAL;\n\t\tmlog(ML_ERROR, \"Cannot enable inode64 on remount\\n\");\n\t\tgoto out;\n\t}\n\n\t/* We're going to/from readonly mode. */\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {\n\t\t/* Disable quota accounting before remounting RO */\n\t\tif (*flags & MS_RDONLY) {\n\t\t\tret = ocfs2_susp_quotas(osb, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/* Lock here so the check of HARD_RO and the potential\n\t\t * setting of SOFT_RO is atomic. */\n\t\tspin_lock(&osb->osb_lock);\n\t\tif (osb->osb_flags & OCFS2_OSB_HARD_RO) {\n\t\t\tmlog(ML_ERROR, \"Remount on readonly device is forbidden.\\n\");\n\t\t\tret = -EROFS;\n\t\t\tgoto unlock_osb;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\t\t} else {\n\t\t\tif (osb->osb_flags & OCFS2_OSB_ERROR_FS) {\n\t\t\t\tmlog(ML_ERROR, \"Cannot remount RDWR \"\n\t\t\t\t     \"filesystem due to previous errors.\\n\");\n\t\t\t\tret = -EROFS;\n\t\t\t\tgoto unlock_osb;\n\t\t\t}\n\t\t\tincompat_features = OCFS2_HAS_RO_COMPAT_FEATURE(sb, ~OCFS2_FEATURE_RO_COMPAT_SUPP);\n\t\t\tif (incompat_features) {\n\t\t\t\tmlog(ML_ERROR, \"Cannot remount RDWR because \"\n\t\t\t\t     \"of unsupported optional features \"\n\t\t\t\t     \"(%x).\\n\", incompat_features);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto unlock_osb;\n\t\t\t}\n\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tosb->osb_flags &= ~OCFS2_OSB_SOFT_RO;\n\t\t}\n\t\ttrace_ocfs2_remount(sb->s_flags, osb->osb_flags, *flags);\nunlock_osb:\n\t\tspin_unlock(&osb->osb_lock);\n\t\t/* Enable quota accounting after remounting RW */\n\t\tif (!ret && !(*flags & MS_RDONLY)) {\n\t\t\tif (sb_any_quota_suspended(sb))\n\t\t\t\tret = ocfs2_susp_quotas(osb, 1);\n\t\t\telse\n\t\t\t\tret = ocfs2_enable_quotas(osb);\n\t\t\tif (ret < 0) {\n\t\t\t\t/* Return back changes... */\n\t\t\t\tspin_lock(&osb->osb_lock);\n\t\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t\t\tosb->osb_flags |= OCFS2_OSB_SOFT_RO;\n\t\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret) {\n\t\t/* Only save off the new mount options in case of a successful\n\t\t * remount. */\n\t\tosb->s_mount_opt = parsed_options.mount_opt;\n\t\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\t\tosb->preferred_slot = parsed_options.slot;\n\t\tif (parsed_options.commit_interval)\n\t\t\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\t\tif (!ocfs2_is_hard_readonly(osb))\n\t\t\tocfs2_set_journal_params(osb);\n\n\t\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ?\n\t\t\t\t\t\t\tMS_POSIXACL : 0);\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_max_file_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "591-636",
    "snippet": "static unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(sector_t) != 8"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}"
  },
  {
    "function_name": "ocfs2_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "586-589",
    "snippet": "static void ocfs2_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ocfs2_i_callback);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "ocfs2_i_callback"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic void ocfs2_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ocfs2_i_callback);\n}"
  },
  {
    "function_name": "ocfs2_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "580-584",
    "snippet": "static void ocfs2_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ocfs2_inode_cachep, OCFS2_I(inode));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ocfs2_inode_cachep;",
      "static void ocfs2_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ocfs2_inode_cachep",
            "OCFS2_I(inode)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ocfs2_inode_cachep;\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic void ocfs2_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ocfs2_inode_cachep, OCFS2_I(inode));\n}"
  },
  {
    "function_name": "ocfs2_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "564-578",
    "snippet": "static struct inode *ocfs2_alloc_inode(struct super_block *sb)\n{\n\tstruct ocfs2_inode_info *oi;\n\n\toi = kmem_cache_alloc(ocfs2_inode_cachep, GFP_NOFS);\n\tif (!oi)\n\t\treturn NULL;\n\n\toi->i_sync_tid = 0;\n\toi->i_datasync_tid = 0;\n\tmemset(&oi->i_dquot, 0, sizeof(oi->i_dquot));\n\n\tjbd2_journal_init_jbd_inode(&oi->ip_jinode, &oi->vfs_inode);\n\treturn &oi->vfs_inode;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ocfs2_inode_cachep;",
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static void ocfs2_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_init_jbd_inode",
          "args": [
            "&oi->ip_jinode",
            "&oi->vfs_inode"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_jbd_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2525-2532",
          "snippet": "void jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode)\n{\n\tjinode->i_transaction = NULL;\n\tjinode->i_next_transaction = NULL;\n\tjinode->i_vfs_inode = inode;\n\tjinode->i_flags = 0;\n\tINIT_LIST_HEAD(&jinode->i_list);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode)\n{\n\tjinode->i_transaction = NULL;\n\tjinode->i_next_transaction = NULL;\n\tjinode->i_vfs_inode = inode;\n\tjinode->i_flags = 0;\n\tINIT_LIST_HEAD(&jinode->i_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&oi->i_dquot",
            "0",
            "sizeof(oi->i_dquot)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ocfs2_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *ocfs2_inode_cachep;\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb)\n{\n\tstruct ocfs2_inode_info *oi;\n\n\toi = kmem_cache_alloc(ocfs2_inode_cachep, GFP_NOFS);\n\tif (!oi)\n\t\treturn NULL;\n\n\toi->i_sync_tid = 0;\n\toi->i_datasync_tid = 0;\n\tmemset(&oi->i_dquot, 0, sizeof(oi->i_dquot));\n\n\tjbd2_journal_init_jbd_inode(&oi->ip_jinode, &oi->vfs_inode);\n\treturn &oi->vfs_inode;\n}"
  },
  {
    "function_name": "ocfs2_release_system_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "524-561",
    "snippet": "static void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osb->local_system_inodes"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "osb->local_system_inodes[i]"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}"
  },
  {
    "function_name": "ocfs2_init_local_system_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "495-522",
    "snippet": "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tfor (i = OCFS2_LAST_GLOBAL_SYSTEM_INODE + 1;\n\t     i < NUM_SYSTEM_INODES;\n\t     i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"status=%d, sysfile=%d, slot=%d\\n\",\n\t\t\t     status, i, osb->slot_num);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* the array now has one ref, so drop this one */\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "new"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"status=%d, sysfile=%d, slot=%d\\n\"",
            "status",
            "i",
            "osb->slot_num"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_release_system_inodes",
          "args": [
            "osb"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_release_system_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "524-561",
          "snippet": "static void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "i",
            "osb->slot_num"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_need_system_inode",
          "args": [
            "osb",
            "i"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_need_system_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "436-447",
          "snippet": "static int ocfs2_need_system_inode(struct ocfs2_super *osb, int ino)\n{\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)\n\t    && (ino == USER_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_USER_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)\n\t    && (ino == GROUP_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_GROUP_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_need_system_inode(struct ocfs2_super *osb, int ino)\n{\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)\n\t    && (ino == USER_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_USER_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)\n\t    && (ino == GROUP_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_GROUP_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tfor (i = OCFS2_LAST_GLOBAL_SYSTEM_INODE + 1;\n\t     i < NUM_SYSTEM_INODES;\n\t     i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog(ML_ERROR, \"status=%d, sysfile=%d, slot=%d\\n\",\n\t\t\t     status, i, osb->slot_num);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* the array now has one ref, so drop this one */\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_init_global_system_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "449-493",
    "snippet": "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tnew = ocfs2_iget(osb, osb->root_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->root_inode = new;\n\n\tnew = ocfs2_iget(osb, osb->system_dir_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->sys_root_inode = new;\n\n\tfor (i = OCFS2_FIRST_ONLINE_SYSTEM_INODE;\n\t     i <= OCFS2_LAST_GLOBAL_SYSTEM_INODE; i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\t/* FIXME: Should ERROR_RO_FS */\n\t\t\tmlog(ML_ERROR, \"Unable to load system inode %d, \"\n\t\t\t     \"possibly corrupt fs?\", i);\n\t\t\tgoto bail;\n\t\t}\n\t\t// the array now has one ref, so drop this one\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "new"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unable to load system inode %d, \"\n\t\t\t     \"possibly corrupt fs?\"",
            "i"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_release_system_inodes",
          "args": [
            "osb"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_release_system_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "524-561",
          "snippet": "static void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb)\n{\n\tint i;\n\tstruct inode *inode;\n\n\tfor (i = 0; i < NUM_GLOBAL_SYSTEM_INODES; i++) {\n\t\tinode = osb->global_system_inodes[i];\n\t\tif (inode) {\n\t\t\tiput(inode);\n\t\t\tosb->global_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tinode = osb->sys_root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->sys_root_inode = NULL;\n\t}\n\n\tinode = osb->root_inode;\n\tif (inode) {\n\t\tiput(inode);\n\t\tosb->root_inode = NULL;\n\t}\n\n\tif (!osb->local_system_inodes)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_LOCAL_SYSTEM_INODES * osb->max_slots; i++) {\n\t\tif (osb->local_system_inodes[i]) {\n\t\t\tiput(osb->local_system_inodes[i]);\n\t\t\tosb->local_system_inodes[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(osb->local_system_inodes);\n\tosb->local_system_inodes = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "i",
            "osb->slot_num"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_need_system_inode",
          "args": [
            "osb",
            "i"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_need_system_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "436-447",
          "snippet": "static int ocfs2_need_system_inode(struct ocfs2_super *osb, int ino)\n{\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)\n\t    && (ino == USER_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_USER_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)\n\t    && (ino == GROUP_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_GROUP_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_need_system_inode(struct ocfs2_super *osb, int ino)\n{\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)\n\t    && (ino == USER_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_USER_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)\n\t    && (ino == GROUP_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_GROUP_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iget",
          "args": [
            "osb",
            "osb->system_dir_blkno",
            "OCFS2_FI_FLAG_SYSFILE",
            "0"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "127-206",
          "snippet": "struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb)\n{\n\tstruct inode *new = NULL;\n\tint status = 0;\n\tint i;\n\n\tnew = ocfs2_iget(osb, osb->root_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->root_inode = new;\n\n\tnew = ocfs2_iget(osb, osb->system_dir_blkno, OCFS2_FI_FLAG_SYSFILE, 0);\n\tif (IS_ERR(new)) {\n\t\tstatus = PTR_ERR(new);\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tosb->sys_root_inode = new;\n\n\tfor (i = OCFS2_FIRST_ONLINE_SYSTEM_INODE;\n\t     i <= OCFS2_LAST_GLOBAL_SYSTEM_INODE; i++) {\n\t\tif (!ocfs2_need_system_inode(osb, i))\n\t\t\tcontinue;\n\t\tnew = ocfs2_get_system_file_inode(osb, i, osb->slot_num);\n\t\tif (!new) {\n\t\t\tocfs2_release_system_inodes(osb);\n\t\t\tstatus = -EINVAL;\n\t\t\tmlog_errno(status);\n\t\t\t/* FIXME: Should ERROR_RO_FS */\n\t\t\tmlog(ML_ERROR, \"Unable to load system inode %d, \"\n\t\t\t     \"possibly corrupt fs?\", i);\n\t\t\tgoto bail;\n\t\t}\n\t\t// the array now has one ref, so drop this one\n\t\tiput(new);\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_need_system_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "436-447",
    "snippet": "static int ocfs2_need_system_inode(struct ocfs2_super *osb, int ino)\n{\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)\n\t    && (ino == USER_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_USER_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)\n\t    && (ino == GROUP_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_GROUP_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "osb->sb",
            "OCFS2_FEATURE_RO_COMPAT_GRPQUOTA"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "osb->sb",
            "OCFS2_FEATURE_RO_COMPAT_USRQUOTA"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_need_system_inode(struct ocfs2_super *osb, int ino)\n{\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)\n\t    && (ino == USER_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_USER_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)\n\t    && (ino == GROUP_QUOTA_SYSTEM_INODE\n\t\t|| ino == LOCAL_GROUP_QUOTA_SYSTEM_INODE))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ocfs2_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "410-434",
    "snippet": "static int ocfs2_sync_fs(struct super_block *sb, int wait)\n{\n\tint status;\n\ttid_t target;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (wait) {\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t} else {\n\t\tocfs2_schedule_truncate_log_flush(osb, 0);\n\t}\n\n\tif (jbd2_journal_start_commit(OCFS2_SB(sb)->journal->j_journal,\n\t\t\t\t      &target)) {\n\t\tif (wait)\n\t\t\tjbd2_log_wait_commit(OCFS2_SB(sb)->journal->j_journal,\n\t\t\t\t\t     target);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_sync_fs(struct super_block *sb, int wait);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "OCFS2_SB(sb)->journal->j_journal",
            "target"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "698-724",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_start_commit",
          "args": [
            "OCFS2_SB(sb)->journal->j_journal",
            "&target"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "626-651",
          "snippet": "int jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "0"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_flush_truncate_log",
          "args": [
            "osb"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_flush_truncate_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6030-6040",
          "snippet": "int ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_flush_truncate_log(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tstatus = __ocfs2_flush_truncate_log(osb);\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait)\n{\n\tint status;\n\ttid_t target;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (wait) {\n\t\tstatus = ocfs2_flush_truncate_log(osb);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t} else {\n\t\tocfs2_schedule_truncate_log_flush(osb, 0);\n\t}\n\n\tif (jbd2_journal_start_commit(OCFS2_SB(sb)->journal->j_journal,\n\t\t\t\t      &target)) {\n\t\tif (wait)\n\t\t\tjbd2_log_wait_commit(OCFS2_SB(sb)->journal->j_journal,\n\t\t\t\t\t     target);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_debug_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "396-400",
    "snippet": "static ssize_t ocfs2_debug_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t ocfs2_debug_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_debug_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "392-395",
    "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_osb_debug_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "388-391",
    "snippet": "static int ocfs2_osb_debug_open(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_osb_debug_open(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_debug_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "381-386",
    "snippet": "static ssize_t ocfs2_debug_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, nbytes, ppos, file->private_data,\n\t\t\t\t       i_size_read(file->f_mapping->host));\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "nbytes",
            "ppos",
            "file->private_data",
            "i_size_read(file->f_mapping->host)"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic ssize_t ocfs2_debug_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, nbytes, ppos, file->private_data,\n\t\t\t\t       i_size_read(file->f_mapping->host));\n}"
  },
  {
    "function_name": "ocfs2_debug_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "375-379",
    "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "file->private_data"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_osb_debug_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "357-373",
    "snippet": "static int ocfs2_osb_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_super *osb = inode->i_private;\n\tchar *buf = NULL;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto bail;\n\n\ti_size_write(inode, ocfs2_osb_dump(osb, buf, PAGE_SIZE));\n\n\tfile->private_data = buf;\n\n\treturn 0;\nbail:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static void ocfs2_destroy_inode(struct inode *inode);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "ocfs2_osb_dump(osb, buf, PAGE_SIZE)"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_osb_dump",
          "args": [
            "osb",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_osb_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "231-355",
          "snippet": "static int ocfs2_osb_dump(struct ocfs2_super *osb, char *buf, int len)\n{\n\tstruct ocfs2_cluster_connection *cconn = osb->cconn;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\tstruct ocfs2_orphan_scan *os = &osb->osb_orphan_scan;\n\tint i, out = 0;\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Id: %-s  Uuid: %-s  Gen: 0x%X  Label: %-s\\n\",\n\t\t\t\"Device\", osb->dev_str, osb->uuid_str,\n\t\t\tosb->fs_generation, osb->vol_label);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  Flags: 0x%lX\\n\", \"Volume\",\n\t\t\tatomic_read(&osb->vol_state), osb->osb_flags);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Block: %lu  Cluster: %d\\n\", \"Sizes\",\n\t\t\tosb->sb->s_blocksize, osb->s_clustersize);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Compat: 0x%X  Incompat: 0x%X  \"\n\t\t\t\"ROcompat: 0x%X\\n\",\n\t\t\t\"Features\", osb->s_feature_compat,\n\t\t\tosb->s_feature_incompat, osb->s_feature_ro_compat);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Opts: 0x%lX  AtimeQuanta: %u\\n\", \"Mount\",\n\t\t\tosb->s_mount_opt, osb->s_atime_quantum);\n\n\tif (cconn) {\n\t\tout += snprintf(buf + out, len - out,\n\t\t\t\t\"%10s => Stack: %s  Name: %*s  \"\n\t\t\t\t\"Version: %d.%d\\n\", \"Cluster\",\n\t\t\t\t(*osb->osb_cluster_stack == '\\0' ?\n\t\t\t\t \"o2cb\" : osb->osb_cluster_stack),\n\t\t\t\tcconn->cc_namelen, cconn->cc_name,\n\t\t\t\tcconn->cc_version.pv_major,\n\t\t\t\tcconn->cc_version.pv_minor);\n\t}\n\n\tspin_lock(&osb->dc_task_lock);\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Count: %lu  WakeSeq: %lu  \"\n\t\t\t\"WorkSeq: %lu\\n\", \"DownCnvt\",\n\t\t\t(osb->dc_task ?  task_pid_nr(osb->dc_task) : -1),\n\t\t\tosb->blocked_lock_count, osb->dc_wake_sequence,\n\t\t\tosb->dc_work_sequence);\n\tspin_unlock(&osb->dc_task_lock);\n\n\tspin_lock(&osb->osb_lock);\n\tout += snprintf(buf + out, len - out, \"%10s => Pid: %d  Nodes:\",\n\t\t\t\"Recovery\",\n\t\t\t(osb->recovery_thread_task ?\n\t\t\t task_pid_nr(osb->recovery_thread_task) : -1));\n\tif (rm->rm_used == 0)\n\t\tout += snprintf(buf + out, len - out, \" None\\n\");\n\telse {\n\t\tfor (i = 0; i < rm->rm_used; i++)\n\t\t\tout += snprintf(buf + out, len - out, \" %d\",\n\t\t\t\t\trm->rm_entries[i]);\n\t\tout += snprintf(buf + out, len - out, \"\\n\");\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Interval: %lu\\n\", \"Commit\",\n\t\t\t(osb->commit_task ? task_pid_nr(osb->commit_task) : -1),\n\t\t\tosb->osb_commit_interval);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  TxnId: %lu  NumTxns: %d\\n\",\n\t\t\t\"Journal\", osb->journal->j_state,\n\t\t\tosb->journal->j_trans_id,\n\t\t\tatomic_read(&osb->journal->j_num_trans));\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => GlobalAllocs: %d  LocalAllocs: %d  \"\n\t\t\t\"SubAllocs: %d  LAWinMoves: %d  SAExtends: %d\\n\",\n\t\t\t\"Stats\",\n\t\t\tatomic_read(&osb->alloc_stats.bitmap_data),\n\t\t\tatomic_read(&osb->alloc_stats.local_data),\n\t\t\tatomic_read(&osb->alloc_stats.bg_allocs),\n\t\t\tatomic_read(&osb->alloc_stats.moves),\n\t\t\tatomic_read(&osb->alloc_stats.bg_extends));\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %u  Descriptor: %llu  Size: %u bits  \"\n\t\t\t\"Default: %u bits\\n\",\n\t\t\t\"LocalAlloc\", osb->local_alloc_state,\n\t\t\t(unsigned long long)osb->la_last_gd,\n\t\t\tosb->local_alloc_bits, osb->local_alloc_default_bits);\n\n\tspin_lock(&osb->osb_lock);\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => InodeSlot: %d  StolenInodes: %d, \"\n\t\t\t\"MetaSlot: %d  StolenMeta: %d\\n\", \"Steal\",\n\t\t\tosb->s_inode_steal_slot,\n\t\t\tatomic_read(&osb->s_num_inodes_stolen),\n\t\t\tosb->s_meta_steal_slot,\n\t\t\tatomic_read(&osb->s_num_meta_stolen));\n\tspin_unlock(&osb->osb_lock);\n\n\tout += snprintf(buf + out, len - out, \"OrphanScan => \");\n\tout += snprintf(buf + out, len - out, \"Local: %u  Global: %u \",\n\t\t\tos->os_count, os->os_seqno);\n\tout += snprintf(buf + out, len - out, \" Last Scan: \");\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tout += snprintf(buf + out, len - out, \"Disabled\\n\");\n\telse\n\t\tout += snprintf(buf + out, len - out, \"%lu seconds ago\\n\",\n\t\t\t\t(get_seconds() - os->os_scantime.tv_sec));\n\n\tout += snprintf(buf + out, len - out, \"%10s => %3s  %10s\\n\",\n\t\t\t\"Slots\", \"Num\", \"RecoGen\");\n\tfor (i = 0; i < osb->max_slots; ++i) {\n\t\tout += snprintf(buf + out, len - out,\n\t\t\t\t\"%10s  %c %3d  %10d\\n\",\n\t\t\t\t\" \",\n\t\t\t\t(i == osb->slot_num ? '*' : ' '),\n\t\t\t\ti, osb->slot_recovery_generations[i]);\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_osb_dump(struct ocfs2_super *osb, char *buf, int len)\n{\n\tstruct ocfs2_cluster_connection *cconn = osb->cconn;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\tstruct ocfs2_orphan_scan *os = &osb->osb_orphan_scan;\n\tint i, out = 0;\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Id: %-s  Uuid: %-s  Gen: 0x%X  Label: %-s\\n\",\n\t\t\t\"Device\", osb->dev_str, osb->uuid_str,\n\t\t\tosb->fs_generation, osb->vol_label);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  Flags: 0x%lX\\n\", \"Volume\",\n\t\t\tatomic_read(&osb->vol_state), osb->osb_flags);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Block: %lu  Cluster: %d\\n\", \"Sizes\",\n\t\t\tosb->sb->s_blocksize, osb->s_clustersize);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Compat: 0x%X  Incompat: 0x%X  \"\n\t\t\t\"ROcompat: 0x%X\\n\",\n\t\t\t\"Features\", osb->s_feature_compat,\n\t\t\tosb->s_feature_incompat, osb->s_feature_ro_compat);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Opts: 0x%lX  AtimeQuanta: %u\\n\", \"Mount\",\n\t\t\tosb->s_mount_opt, osb->s_atime_quantum);\n\n\tif (cconn) {\n\t\tout += snprintf(buf + out, len - out,\n\t\t\t\t\"%10s => Stack: %s  Name: %*s  \"\n\t\t\t\t\"Version: %d.%d\\n\", \"Cluster\",\n\t\t\t\t(*osb->osb_cluster_stack == '\\0' ?\n\t\t\t\t \"o2cb\" : osb->osb_cluster_stack),\n\t\t\t\tcconn->cc_namelen, cconn->cc_name,\n\t\t\t\tcconn->cc_version.pv_major,\n\t\t\t\tcconn->cc_version.pv_minor);\n\t}\n\n\tspin_lock(&osb->dc_task_lock);\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Count: %lu  WakeSeq: %lu  \"\n\t\t\t\"WorkSeq: %lu\\n\", \"DownCnvt\",\n\t\t\t(osb->dc_task ?  task_pid_nr(osb->dc_task) : -1),\n\t\t\tosb->blocked_lock_count, osb->dc_wake_sequence,\n\t\t\tosb->dc_work_sequence);\n\tspin_unlock(&osb->dc_task_lock);\n\n\tspin_lock(&osb->osb_lock);\n\tout += snprintf(buf + out, len - out, \"%10s => Pid: %d  Nodes:\",\n\t\t\t\"Recovery\",\n\t\t\t(osb->recovery_thread_task ?\n\t\t\t task_pid_nr(osb->recovery_thread_task) : -1));\n\tif (rm->rm_used == 0)\n\t\tout += snprintf(buf + out, len - out, \" None\\n\");\n\telse {\n\t\tfor (i = 0; i < rm->rm_used; i++)\n\t\t\tout += snprintf(buf + out, len - out, \" %d\",\n\t\t\t\t\trm->rm_entries[i]);\n\t\tout += snprintf(buf + out, len - out, \"\\n\");\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Interval: %lu\\n\", \"Commit\",\n\t\t\t(osb->commit_task ? task_pid_nr(osb->commit_task) : -1),\n\t\t\tosb->osb_commit_interval);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  TxnId: %lu  NumTxns: %d\\n\",\n\t\t\t\"Journal\", osb->journal->j_state,\n\t\t\tosb->journal->j_trans_id,\n\t\t\tatomic_read(&osb->journal->j_num_trans));\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => GlobalAllocs: %d  LocalAllocs: %d  \"\n\t\t\t\"SubAllocs: %d  LAWinMoves: %d  SAExtends: %d\\n\",\n\t\t\t\"Stats\",\n\t\t\tatomic_read(&osb->alloc_stats.bitmap_data),\n\t\t\tatomic_read(&osb->alloc_stats.local_data),\n\t\t\tatomic_read(&osb->alloc_stats.bg_allocs),\n\t\t\tatomic_read(&osb->alloc_stats.moves),\n\t\t\tatomic_read(&osb->alloc_stats.bg_extends));\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %u  Descriptor: %llu  Size: %u bits  \"\n\t\t\t\"Default: %u bits\\n\",\n\t\t\t\"LocalAlloc\", osb->local_alloc_state,\n\t\t\t(unsigned long long)osb->la_last_gd,\n\t\t\tosb->local_alloc_bits, osb->local_alloc_default_bits);\n\n\tspin_lock(&osb->osb_lock);\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => InodeSlot: %d  StolenInodes: %d, \"\n\t\t\t\"MetaSlot: %d  StolenMeta: %d\\n\", \"Steal\",\n\t\t\tosb->s_inode_steal_slot,\n\t\t\tatomic_read(&osb->s_num_inodes_stolen),\n\t\t\tosb->s_meta_steal_slot,\n\t\t\tatomic_read(&osb->s_num_meta_stolen));\n\tspin_unlock(&osb->osb_lock);\n\n\tout += snprintf(buf + out, len - out, \"OrphanScan => \");\n\tout += snprintf(buf + out, len - out, \"Local: %u  Global: %u \",\n\t\t\tos->os_count, os->os_seqno);\n\tout += snprintf(buf + out, len - out, \" Last Scan: \");\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tout += snprintf(buf + out, len - out, \"Disabled\\n\");\n\telse\n\t\tout += snprintf(buf + out, len - out, \"%lu seconds ago\\n\",\n\t\t\t\t(get_seconds() - os->os_scantime.tv_sec));\n\n\tout += snprintf(buf + out, len - out, \"%10s => %3s  %10s\\n\",\n\t\t\t\"Slots\", \"Num\", \"RecoGen\");\n\tfor (i = 0; i < osb->max_slots; ++i) {\n\t\tout += snprintf(buf + out, len - out,\n\t\t\t\t\"%10s  %c %3d  %10d\\n\",\n\t\t\t\t\" \",\n\t\t\t\t(i == osb->slot_num ? '*' : ' '),\n\t\t\t\ti, osb->slot_recovery_generations[i]);\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_osb_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_super *osb = inode->i_private;\n\tchar *buf = NULL;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto bail;\n\n\ti_size_write(inode, ocfs2_osb_dump(osb, buf, PAGE_SIZE));\n\n\tfile->private_data = buf;\n\n\treturn 0;\nbail:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ocfs2_osb_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "231-355",
    "snippet": "static int ocfs2_osb_dump(struct ocfs2_super *osb, char *buf, int len)\n{\n\tstruct ocfs2_cluster_connection *cconn = osb->cconn;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\tstruct ocfs2_orphan_scan *os = &osb->osb_orphan_scan;\n\tint i, out = 0;\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Id: %-s  Uuid: %-s  Gen: 0x%X  Label: %-s\\n\",\n\t\t\t\"Device\", osb->dev_str, osb->uuid_str,\n\t\t\tosb->fs_generation, osb->vol_label);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  Flags: 0x%lX\\n\", \"Volume\",\n\t\t\tatomic_read(&osb->vol_state), osb->osb_flags);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Block: %lu  Cluster: %d\\n\", \"Sizes\",\n\t\t\tosb->sb->s_blocksize, osb->s_clustersize);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Compat: 0x%X  Incompat: 0x%X  \"\n\t\t\t\"ROcompat: 0x%X\\n\",\n\t\t\t\"Features\", osb->s_feature_compat,\n\t\t\tosb->s_feature_incompat, osb->s_feature_ro_compat);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Opts: 0x%lX  AtimeQuanta: %u\\n\", \"Mount\",\n\t\t\tosb->s_mount_opt, osb->s_atime_quantum);\n\n\tif (cconn) {\n\t\tout += snprintf(buf + out, len - out,\n\t\t\t\t\"%10s => Stack: %s  Name: %*s  \"\n\t\t\t\t\"Version: %d.%d\\n\", \"Cluster\",\n\t\t\t\t(*osb->osb_cluster_stack == '\\0' ?\n\t\t\t\t \"o2cb\" : osb->osb_cluster_stack),\n\t\t\t\tcconn->cc_namelen, cconn->cc_name,\n\t\t\t\tcconn->cc_version.pv_major,\n\t\t\t\tcconn->cc_version.pv_minor);\n\t}\n\n\tspin_lock(&osb->dc_task_lock);\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Count: %lu  WakeSeq: %lu  \"\n\t\t\t\"WorkSeq: %lu\\n\", \"DownCnvt\",\n\t\t\t(osb->dc_task ?  task_pid_nr(osb->dc_task) : -1),\n\t\t\tosb->blocked_lock_count, osb->dc_wake_sequence,\n\t\t\tosb->dc_work_sequence);\n\tspin_unlock(&osb->dc_task_lock);\n\n\tspin_lock(&osb->osb_lock);\n\tout += snprintf(buf + out, len - out, \"%10s => Pid: %d  Nodes:\",\n\t\t\t\"Recovery\",\n\t\t\t(osb->recovery_thread_task ?\n\t\t\t task_pid_nr(osb->recovery_thread_task) : -1));\n\tif (rm->rm_used == 0)\n\t\tout += snprintf(buf + out, len - out, \" None\\n\");\n\telse {\n\t\tfor (i = 0; i < rm->rm_used; i++)\n\t\t\tout += snprintf(buf + out, len - out, \" %d\",\n\t\t\t\t\trm->rm_entries[i]);\n\t\tout += snprintf(buf + out, len - out, \"\\n\");\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Interval: %lu\\n\", \"Commit\",\n\t\t\t(osb->commit_task ? task_pid_nr(osb->commit_task) : -1),\n\t\t\tosb->osb_commit_interval);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  TxnId: %lu  NumTxns: %d\\n\",\n\t\t\t\"Journal\", osb->journal->j_state,\n\t\t\tosb->journal->j_trans_id,\n\t\t\tatomic_read(&osb->journal->j_num_trans));\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => GlobalAllocs: %d  LocalAllocs: %d  \"\n\t\t\t\"SubAllocs: %d  LAWinMoves: %d  SAExtends: %d\\n\",\n\t\t\t\"Stats\",\n\t\t\tatomic_read(&osb->alloc_stats.bitmap_data),\n\t\t\tatomic_read(&osb->alloc_stats.local_data),\n\t\t\tatomic_read(&osb->alloc_stats.bg_allocs),\n\t\t\tatomic_read(&osb->alloc_stats.moves),\n\t\t\tatomic_read(&osb->alloc_stats.bg_extends));\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %u  Descriptor: %llu  Size: %u bits  \"\n\t\t\t\"Default: %u bits\\n\",\n\t\t\t\"LocalAlloc\", osb->local_alloc_state,\n\t\t\t(unsigned long long)osb->la_last_gd,\n\t\t\tosb->local_alloc_bits, osb->local_alloc_default_bits);\n\n\tspin_lock(&osb->osb_lock);\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => InodeSlot: %d  StolenInodes: %d, \"\n\t\t\t\"MetaSlot: %d  StolenMeta: %d\\n\", \"Steal\",\n\t\t\tosb->s_inode_steal_slot,\n\t\t\tatomic_read(&osb->s_num_inodes_stolen),\n\t\t\tosb->s_meta_steal_slot,\n\t\t\tatomic_read(&osb->s_num_meta_stolen));\n\tspin_unlock(&osb->osb_lock);\n\n\tout += snprintf(buf + out, len - out, \"OrphanScan => \");\n\tout += snprintf(buf + out, len - out, \"Local: %u  Global: %u \",\n\t\t\tos->os_count, os->os_seqno);\n\tout += snprintf(buf + out, len - out, \" Last Scan: \");\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tout += snprintf(buf + out, len - out, \"Disabled\\n\");\n\telse\n\t\tout += snprintf(buf + out, len - out, \"%lu seconds ago\\n\",\n\t\t\t\t(get_seconds() - os->os_scantime.tv_sec));\n\n\tout += snprintf(buf + out, len - out, \"%10s => %3s  %10s\\n\",\n\t\t\t\"Slots\", \"Num\", \"RecoGen\");\n\tfor (i = 0; i < osb->max_slots; ++i) {\n\t\tout += snprintf(buf + out, len - out,\n\t\t\t\t\"%10s  %c %3d  %10d\\n\",\n\t\t\t\t\" \",\n\t\t\t\t(i == osb->slot_num ? '*' : ' '),\n\t\t\t\ti, osb->slot_recovery_generations[i]);\n\t}\n\n\treturn out;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_put_super(struct super_block *sb);",
      "static int ocfs2_mount_volume(struct super_block *sb);",
      "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
      "static int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);",
      "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
      "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
      "static int ocfs2_check_volume(struct ocfs2_super *osb);",
      "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
      "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
      "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s  %c %3d  %10d\\n\"",
            "\" \"",
            "(i == osb->slot_num ? '*' : ' ')",
            "i",
            "osb->slot_recovery_generations[i]"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => %3s  %10s\\n\"",
            "\"Slots\"",
            "\"Num\"",
            "\"RecoGen\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%lu seconds ago\\n\"",
            "(get_seconds() - os->os_scantime.tv_sec)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"Disabled\\n\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&os->os_state"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\" Last Scan: \""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"Local: %u  Global: %u \"",
            "os->os_count",
            "os->os_seqno"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"OrphanScan => \""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => InodeSlot: %d  StolenInodes: %d, \"\n\t\t\t\"MetaSlot: %d  StolenMeta: %d\\n\"",
            "\"Steal\"",
            "osb->s_inode_steal_slot",
            "atomic_read(&osb->s_num_inodes_stolen)",
            "osb->s_meta_steal_slot",
            "atomic_read(&osb->s_num_meta_stolen)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->s_num_meta_stolen"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->s_num_inodes_stolen"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => State: %u  Descriptor: %llu  Size: %u bits  \"\n\t\t\t\"Default: %u bits\\n\"",
            "\"LocalAlloc\"",
            "osb->local_alloc_state",
            "(unsigned long long)osb->la_last_gd",
            "osb->local_alloc_bits",
            "osb->local_alloc_default_bits"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => GlobalAllocs: %d  LocalAllocs: %d  \"\n\t\t\t\"SubAllocs: %d  LAWinMoves: %d  SAExtends: %d\\n\"",
            "\"Stats\"",
            "atomic_read(&osb->alloc_stats.bitmap_data)",
            "atomic_read(&osb->alloc_stats.local_data)",
            "atomic_read(&osb->alloc_stats.bg_allocs)",
            "atomic_read(&osb->alloc_stats.moves)",
            "atomic_read(&osb->alloc_stats.bg_extends)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->alloc_stats.bg_extends"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->alloc_stats.moves"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->alloc_stats.bg_allocs"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->alloc_stats.local_data"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->alloc_stats.bitmap_data"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => State: %d  TxnId: %lu  NumTxns: %d\\n\"",
            "\"Journal\"",
            "osb->journal->j_state",
            "osb->journal->j_trans_id",
            "atomic_read(&osb->journal->j_num_trans)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->journal->j_num_trans"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => Pid: %d  Interval: %lu\\n\"",
            "\"Commit\"",
            "(osb->commit_task ? task_pid_nr(osb->commit_task) : -1)",
            "osb->osb_commit_interval"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "osb->commit_task"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"\\n\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\" %d\"",
            "rm->rm_entries[i]"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\" None\\n\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => Pid: %d  Nodes:\"",
            "\"Recovery\"",
            "(osb->recovery_thread_task ?\n\t\t\t task_pid_nr(osb->recovery_thread_task) : -1)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "osb->recovery_thread_task"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => Pid: %d  Count: %lu  WakeSeq: %lu  \"\n\t\t\t\"WorkSeq: %lu\\n\"",
            "\"DownCnvt\"",
            "(osb->dc_task ?  task_pid_nr(osb->dc_task) : -1)",
            "osb->blocked_lock_count",
            "osb->dc_wake_sequence",
            "osb->dc_work_sequence"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "osb->dc_task"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => Stack: %s  Name: %*s  \"\n\t\t\t\t\"Version: %d.%d\\n\"",
            "\"Cluster\"",
            "(*osb->osb_cluster_stack == '\\0' ?\n\t\t\t\t \"o2cb\" : osb->osb_cluster_stack)",
            "cconn->cc_namelen",
            "cconn->cc_name",
            "cconn->cc_version.pv_major",
            "cconn->cc_version.pv_minor"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => Opts: 0x%lX  AtimeQuanta: %u\\n\"",
            "\"Mount\"",
            "osb->s_mount_opt",
            "osb->s_atime_quantum"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => Compat: 0x%X  Incompat: 0x%X  \"\n\t\t\t\"ROcompat: 0x%X\\n\"",
            "\"Features\"",
            "osb->s_feature_compat",
            "osb->s_feature_incompat",
            "osb->s_feature_ro_compat"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => Block: %lu  Cluster: %d\\n\"",
            "\"Sizes\"",
            "osb->sb->s_blocksize",
            "osb->s_clustersize"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => State: %d  Flags: 0x%lX\\n\"",
            "\"Volume\"",
            "atomic_read(&osb->vol_state)",
            "osb->osb_flags"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->vol_state"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + out",
            "len - out",
            "\"%10s => Id: %-s  Uuid: %-s  Gen: 0x%X  Label: %-s\\n\"",
            "\"Device\"",
            "osb->dev_str",
            "osb->uuid_str",
            "osb->fs_generation",
            "osb->vol_label"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_statfs(struct dentry *dentry, struct kstatfs *buf);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic int ocfs2_osb_dump(struct ocfs2_super *osb, char *buf, int len)\n{\n\tstruct ocfs2_cluster_connection *cconn = osb->cconn;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\tstruct ocfs2_orphan_scan *os = &osb->osb_orphan_scan;\n\tint i, out = 0;\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Id: %-s  Uuid: %-s  Gen: 0x%X  Label: %-s\\n\",\n\t\t\t\"Device\", osb->dev_str, osb->uuid_str,\n\t\t\tosb->fs_generation, osb->vol_label);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  Flags: 0x%lX\\n\", \"Volume\",\n\t\t\tatomic_read(&osb->vol_state), osb->osb_flags);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Block: %lu  Cluster: %d\\n\", \"Sizes\",\n\t\t\tosb->sb->s_blocksize, osb->s_clustersize);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Compat: 0x%X  Incompat: 0x%X  \"\n\t\t\t\"ROcompat: 0x%X\\n\",\n\t\t\t\"Features\", osb->s_feature_compat,\n\t\t\tosb->s_feature_incompat, osb->s_feature_ro_compat);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Opts: 0x%lX  AtimeQuanta: %u\\n\", \"Mount\",\n\t\t\tosb->s_mount_opt, osb->s_atime_quantum);\n\n\tif (cconn) {\n\t\tout += snprintf(buf + out, len - out,\n\t\t\t\t\"%10s => Stack: %s  Name: %*s  \"\n\t\t\t\t\"Version: %d.%d\\n\", \"Cluster\",\n\t\t\t\t(*osb->osb_cluster_stack == '\\0' ?\n\t\t\t\t \"o2cb\" : osb->osb_cluster_stack),\n\t\t\t\tcconn->cc_namelen, cconn->cc_name,\n\t\t\t\tcconn->cc_version.pv_major,\n\t\t\t\tcconn->cc_version.pv_minor);\n\t}\n\n\tspin_lock(&osb->dc_task_lock);\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Count: %lu  WakeSeq: %lu  \"\n\t\t\t\"WorkSeq: %lu\\n\", \"DownCnvt\",\n\t\t\t(osb->dc_task ?  task_pid_nr(osb->dc_task) : -1),\n\t\t\tosb->blocked_lock_count, osb->dc_wake_sequence,\n\t\t\tosb->dc_work_sequence);\n\tspin_unlock(&osb->dc_task_lock);\n\n\tspin_lock(&osb->osb_lock);\n\tout += snprintf(buf + out, len - out, \"%10s => Pid: %d  Nodes:\",\n\t\t\t\"Recovery\",\n\t\t\t(osb->recovery_thread_task ?\n\t\t\t task_pid_nr(osb->recovery_thread_task) : -1));\n\tif (rm->rm_used == 0)\n\t\tout += snprintf(buf + out, len - out, \" None\\n\");\n\telse {\n\t\tfor (i = 0; i < rm->rm_used; i++)\n\t\t\tout += snprintf(buf + out, len - out, \" %d\",\n\t\t\t\t\trm->rm_entries[i]);\n\t\tout += snprintf(buf + out, len - out, \"\\n\");\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => Pid: %d  Interval: %lu\\n\", \"Commit\",\n\t\t\t(osb->commit_task ? task_pid_nr(osb->commit_task) : -1),\n\t\t\tosb->osb_commit_interval);\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %d  TxnId: %lu  NumTxns: %d\\n\",\n\t\t\t\"Journal\", osb->journal->j_state,\n\t\t\tosb->journal->j_trans_id,\n\t\t\tatomic_read(&osb->journal->j_num_trans));\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => GlobalAllocs: %d  LocalAllocs: %d  \"\n\t\t\t\"SubAllocs: %d  LAWinMoves: %d  SAExtends: %d\\n\",\n\t\t\t\"Stats\",\n\t\t\tatomic_read(&osb->alloc_stats.bitmap_data),\n\t\t\tatomic_read(&osb->alloc_stats.local_data),\n\t\t\tatomic_read(&osb->alloc_stats.bg_allocs),\n\t\t\tatomic_read(&osb->alloc_stats.moves),\n\t\t\tatomic_read(&osb->alloc_stats.bg_extends));\n\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => State: %u  Descriptor: %llu  Size: %u bits  \"\n\t\t\t\"Default: %u bits\\n\",\n\t\t\t\"LocalAlloc\", osb->local_alloc_state,\n\t\t\t(unsigned long long)osb->la_last_gd,\n\t\t\tosb->local_alloc_bits, osb->local_alloc_default_bits);\n\n\tspin_lock(&osb->osb_lock);\n\tout += snprintf(buf + out, len - out,\n\t\t\t\"%10s => InodeSlot: %d  StolenInodes: %d, \"\n\t\t\t\"MetaSlot: %d  StolenMeta: %d\\n\", \"Steal\",\n\t\t\tosb->s_inode_steal_slot,\n\t\t\tatomic_read(&osb->s_num_inodes_stolen),\n\t\t\tosb->s_meta_steal_slot,\n\t\t\tatomic_read(&osb->s_num_meta_stolen));\n\tspin_unlock(&osb->osb_lock);\n\n\tout += snprintf(buf + out, len - out, \"OrphanScan => \");\n\tout += snprintf(buf + out, len - out, \"Local: %u  Global: %u \",\n\t\t\tos->os_count, os->os_seqno);\n\tout += snprintf(buf + out, len - out, \" Last Scan: \");\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tout += snprintf(buf + out, len - out, \"Disabled\\n\");\n\telse\n\t\tout += snprintf(buf + out, len - out, \"%lu seconds ago\\n\",\n\t\t\t\t(get_seconds() - os->os_scantime.tv_sec));\n\n\tout += snprintf(buf + out, len - out, \"%10s => %3s  %10s\\n\",\n\t\t\t\"Slots\", \"Num\", \"RecoGen\");\n\tfor (i = 0; i < osb->max_slots; ++i) {\n\t\tout += snprintf(buf + out, len - out,\n\t\t\t\t\"%10s  %c %3d  %10d\\n\",\n\t\t\t\t\" \",\n\t\t\t\t(i == osb->slot_num ? '*' : ' '),\n\t\t\t\ti, osb->slot_recovery_generations[i]);\n\t}\n\n\treturn out;\n}"
  },
  {
    "function_name": "ocfs2_get_dquots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
    "lines": "146-149",
    "snippet": "static struct dquot **ocfs2_get_dquots(struct inode *inode)\n{\n\treturn OCFS2_I(inode)->i_dquot;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"suballoc.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"xattr.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"namei.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"export.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs1_fs_compat.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include \"ocfs2_trace.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/crc32.h>",
      "#include <linux/parser.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/statfs.h>",
      "#include <linux/random.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ocfs2_destroy_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic struct dquot **ocfs2_get_dquots(struct inode *inode)\n{\n\treturn OCFS2_I(inode)->i_dquot;\n}"
  }
]