[
  {
    "function_name": "udf_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/ialloc.c",
    "lines": "48-133",
    "snippet": "struct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "insert_inode_locked(inode) < 0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_inode_locked",
          "args": [
            "inode"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1323-1362",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_USE_SHORT_AD"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "&iinfo->i_location",
            "0"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_updated_lvid",
          "args": [
            "sb"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "udf_updated_lvid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "119-128",
          "snippet": "static inline void udf_updated_lvid(struct super_block *sb)\n{\n\tstruct buffer_head *bh = UDF_SB(sb)->s_lvid_bh;\n\n\tBUG_ON(!bh);\n\tWARN_ON_ONCE(((struct logicalVolIntegrityDesc *)\n\t\t     bh->b_data)->integrityType !=\n\t\t     cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN));\n\tUDF_SB(sb)->s_lvid_dirty = 1;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline void udf_updated_lvid(struct super_block *sb)\n{\n\tstruct buffer_head *bh = UDF_SB(sb)->s_lvid_bh;\n\n\tBUG_ON(!bh);\n\tWARN_ON_ONCE(((struct logicalVolIntegrityDesc *)\n\t\t     bh->b_data)->integrityType !=\n\t\t     cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN));\n\tUDF_SB(sb)->s_lvid_dirty = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&lvidiu->numFiles",
            "1"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&lvidiu->numDirs",
            "1"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lvid_get_unique_id",
          "args": [
            "sb"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "lvid_get_unique_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2034-2059",
          "snippet": "u64 lvid_get_unique_id(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolHeaderDesc *lvhd;\n\tu64 uniqueID;\n\tu64 ret;\n\n\tbh = sbi->s_lvid_bh;\n\tif (!bh)\n\t\treturn 0;\n\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvhd = (struct logicalVolHeaderDesc *)lvid->logicalVolContentsUse;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tret = uniqueID = le64_to_cpu(lvhd->uniqueID);\n\tif (!(++uniqueID & 0xFFFFFFFF))\n\t\tuniqueID += 16;\n\tlvhd->uniqueID = cpu_to_le64(uniqueID);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\tmark_buffer_dirty(bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nu64 lvid_get_unique_id(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolHeaderDesc *lvhd;\n\tu64 uniqueID;\n\tu64 ret;\n\n\tbh = sbi->s_lvid_bh;\n\tif (!bh)\n\t\treturn 0;\n\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvhd = (struct logicalVolHeaderDesc *)lvid->logicalVolContentsUse;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tret = uniqueID = le64_to_cpu(lvhd->uniqueID);\n\tif (!(++uniqueID & 0xFFFFFFFF))\n\t\tuniqueID += 16;\n\tlvhd->uniqueID = cpu_to_le64(uniqueID);\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\tmark_buffer_dirty(bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_sb_lvidiu",
          "args": [
            "sb"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_lvidiu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "100-120",
          "snippet": "struct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_block",
          "args": [
            "dir->i_sb",
            "NULL",
            "dinfo->i_location.partitionReferenceNum",
            "start",
            "&err"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "795-825",
          "snippet": "inline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\ninline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry)",
            "GFP_KERNEL"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry)",
            "GFP_KERNEL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct inode *udf_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct inode *inode;\n\tint block;\n\tuint32_t start = UDF_I(dir)->i_location.logicalBlockNum;\n\tstruct udf_inode_info *iinfo;\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tint err;\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiinfo = UDF_I(inode);\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_EXTENDED_FE)) {\n\t\tiinfo->i_efe = 1;\n\t\tif (UDF_VERS_USE_EXTENDED_FE > sbi->s_udfrev)\n\t\t\tsbi->s_udfrev = UDF_VERS_USE_EXTENDED_FE;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct extendedFileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t} else {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_ext.i_data = kzalloc(inode->i_sb->s_blocksize -\n\t\t\t\t\t    sizeof(struct fileEntry),\n\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tif (!iinfo->i_ext.i_data) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = -ENOSPC;\n\tblock = udf_new_block(dir->i_sb, NULL,\n\t\t\t      dinfo->i_location.partitionReferenceNum,\n\t\t\t      start, &err);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlvidiu = udf_sb_lvidiu(sb);\n\tif (lvidiu) {\n\t\tiinfo->i_unique = lvid_get_unique_id(sb);\n\t\tinode->i_generation = iinfo->i_unique;\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, 1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, 1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tinode_init_owner(inode, dir, mode);\n\n\tiinfo->i_location.logicalBlockNum = block;\n\tiinfo->i_location.partitionReferenceNum =\n\t\t\t\tdinfo->i_location.partitionReferenceNum;\n\tinode->i_ino = udf_get_lb_pblock(sb, &iinfo->i_location, 0);\n\tinode->i_blocks = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_use = 0;\n\tiinfo->i_checkpoint = 1;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_AD_IN_ICB))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\telse if (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime =\n\t\tiinfo->i_crtime = current_fs_time(inode->i_sb);\n\tif (unlikely(insert_inode_locked(inode) < 0)) {\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tmark_inode_dirty(inode);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "udf_free_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/ialloc.c",
    "lines": "29-46",
    "snippet": "void udf_free_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu = udf_sb_lvidiu(sb);\n\n\tif (lvidiu) {\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, -1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, -1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tudf_free_blocks(sb, NULL, &UDF_I(inode)->i_location, 0, 1);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_free_blocks",
          "args": [
            "sb",
            "NULL",
            "&UDF_I(inode)->i_location",
            "0",
            "1"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "udf_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "732-757",
          "snippet": "void udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_updated_lvid",
          "args": [
            "sb"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "udf_updated_lvid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "119-128",
          "snippet": "static inline void udf_updated_lvid(struct super_block *sb)\n{\n\tstruct buffer_head *bh = UDF_SB(sb)->s_lvid_bh;\n\n\tBUG_ON(!bh);\n\tWARN_ON_ONCE(((struct logicalVolIntegrityDesc *)\n\t\t     bh->b_data)->integrityType !=\n\t\t     cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN));\n\tUDF_SB(sb)->s_lvid_dirty = 1;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline void udf_updated_lvid(struct super_block *sb)\n{\n\tstruct buffer_head *bh = UDF_SB(sb)->s_lvid_bh;\n\n\tBUG_ON(!bh);\n\tWARN_ON_ONCE(((struct logicalVolIntegrityDesc *)\n\t\t     bh->b_data)->integrityType !=\n\t\t     cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN));\n\tUDF_SB(sb)->s_lvid_dirty = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&lvidiu->numFiles",
            "-1"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&lvidiu->numDirs",
            "-1"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_sb_lvidiu",
          "args": [
            "sb"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sb_lvidiu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "100-120",
          "snippet": "struct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct logicalVolIntegrityDescImpUse *udf_sb_lvidiu(struct super_block *sb)\n{\n\tstruct logicalVolIntegrityDesc *lvid;\n\tunsigned int partnum;\n\tunsigned int offset;\n\n\tif (!UDF_SB(sb)->s_lvid_bh)\n\t\treturn NULL;\n\tlvid = (struct logicalVolIntegrityDesc *)UDF_SB(sb)->s_lvid_bh->b_data;\n\tpartnum = le32_to_cpu(lvid->numOfPartitions);\n\tif ((sb->s_blocksize - sizeof(struct logicalVolIntegrityDescImpUse) -\n\t     offsetof(struct logicalVolIntegrityDesc, impUse)) /\n\t     (2 * sizeof(uint32_t)) < partnum) {\n\t\tudf_err(sb, \"Logical volume integrity descriptor corrupted \"\n\t\t\t\"(numOfPartitions = %u)!\\n\", partnum);\n\t\treturn NULL;\n\t}\n\t/* The offset is to skip freeSpaceTable and sizeTable arrays */\n\toffset = partnum * 2 * sizeof(uint32_t);\n\treturn (struct logicalVolIntegrityDescImpUse *)&(lvid->impUse[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu = udf_sb_lvidiu(sb);\n\n\tif (lvidiu) {\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, -1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, -1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tudf_free_blocks(sb, NULL, &UDF_I(inode)->i_location, 0, 1);\n}"
  }
]