[
  {
    "function_name": "hpfs_remove_fnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "480-496",
    "snippet": "void hpfs_remove_fnode(struct super_block *s, fnode_secno fno)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end;\n\tif (!(fnode = hpfs_map_fnode(s, fno, &bh))) return;\n\tif (!fnode_is_dir(fnode)) hpfs_remove_btree(s, &fnode->btree);\n\telse hpfs_remove_dtree(s, le32_to_cpu(fnode->u.external[0].disk_secno));\n\tea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (ea_indirect(ea))\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\thpfs_ea_ext_remove(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l));\n\tbrelse(bh);\n\thpfs_free_sectors(s, fno, 1);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "fno",
            "1"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_ea_ext_remove",
          "args": [
            "s",
            "le32_to_cpu(fnode->ea_secno)",
            "fnode_in_anode(fnode)",
            "le32_to_cpu(fnode->ea_size_l)"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_ext_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
          "lines": "14-48",
          "snippet": "void hpfs_ea_ext_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tunsigned pos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tstruct extended_attribute *ea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (ea_indirect(ea)) {\n\t\t\tif (ea_valuelen(ea) != 8) {\n\t\t\t\thpfs_error(s, \"ea_indirect(ea) set while ea->valuelen!=8, %s %08x, pos %08x\",\n\t\t\t\t\tano ? \"anode\" : \"sectors\", a, pos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 9, ex+4))\n\t\t\t\treturn;\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!ano) hpfs_free_sectors(s, a, (len+511) >> 9);\n\telse {\n\t\tstruct buffer_head *bh;\n\t\tstruct anode *anode;\n\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\thpfs_remove_btree(s, &anode->btree);\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, a, 1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_ea_ext_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tunsigned pos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tstruct extended_attribute *ea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (ea_indirect(ea)) {\n\t\t\tif (ea_valuelen(ea) != 8) {\n\t\t\t\thpfs_error(s, \"ea_indirect(ea) set while ea->valuelen!=8, %s %08x, pos %08x\",\n\t\t\t\t\tano ? \"anode\" : \"sectors\", a, pos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 9, ex+4))\n\t\t\t\treturn;\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!ano) hpfs_free_sectors(s, a, (len+511) >> 9);\n\telse {\n\t\tstruct buffer_head *bh;\n\t\tstruct anode *anode;\n\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\thpfs_remove_btree(s, &anode->btree);\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, a, 1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fnode->ea_size_l"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_in_anode",
          "args": [
            "fnode"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "475-478",
          "snippet": "static inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_in_anode(struct fnode *p)\n{\n\treturn (p->flags & FNODE_anode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_ea_remove",
          "args": [
            "s",
            "ea_sec(ea)",
            "ea_in_anode(ea)",
            "ea_len(ea)"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "384-394",
          "snippet": "void hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_len",
          "args": [
            "ea"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ea_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "154-157",
          "snippet": "static inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_len(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 5 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_in_anode",
          "args": [
            "ea"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ea_in_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "550-553",
          "snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_in_anode(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_anode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_sec",
          "args": [
            "ea"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ea_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "149-152",
          "snippet": "static inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline secno ea_sec(struct extended_attribute *ea)\n{\n\treturn le32_to_cpu(get_unaligned((__le32 *)((char *)ea + 9 + ea->namelen)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_indirect",
          "args": [
            "ea"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ea_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "545-548",
          "snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool ea_indirect(struct extended_attribute *ea)\n{\n\treturn ea->flags & EA_indirect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_ea",
          "args": [
            "ea"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "next_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "144-147",
          "snippet": "static inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_ea",
          "args": [
            "fnode"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "129-132",
          "snippet": "static inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_end_ea",
          "args": [
            "fnode"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_end_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "134-137",
          "snippet": "static inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_remove_dtree",
          "args": [
            "s",
            "le32_to_cpu(fnode->u.external[0].disk_secno)"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_dtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "948-989",
          "snippet": "void hpfs_remove_dtree(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tdnode_secno d1, d2, rdno = dno;\n\twhile (1) {\n\t\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\t\tde = dnode_first_de(dnode);\n\t\tif (de->last) {\n\t\t\tif (de->down) d1 = de_down_pointer(de);\n\t\t\telse goto error;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t\tdno = d1;\n\t\t} else break;\n\t}\n\tif (!de->first) goto error;\n\td1 = de->down ? de_down_pointer(de) : 0;\n\tde = de_next_de(de);\n\tif (!de->last) goto error;\n\td2 = de->down ? de_down_pointer(de) : 0;\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\tdo {\n\t\twhile (d1) {\n\t\t\tif (!(dnode = hpfs_map_dnode(s, dno = d1, &qbh))) return;\n\t\t\tde = dnode_first_de(dnode);\n\t\t\tif (!de->last) goto error;\n\t\t\td1 = de->down ? de_down_pointer(de) : 0;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t}\n\t\td1 = d2;\n\t\td2 = 0;\n\t} while (d1);\n\treturn;\n\terror:\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\thpfs_error(s, \"directory %08x is corrupted or not empty\", rdno);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_dtree(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tdnode_secno d1, d2, rdno = dno;\n\twhile (1) {\n\t\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\t\tde = dnode_first_de(dnode);\n\t\tif (de->last) {\n\t\t\tif (de->down) d1 = de_down_pointer(de);\n\t\t\telse goto error;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t\tdno = d1;\n\t\t} else break;\n\t}\n\tif (!de->first) goto error;\n\td1 = de->down ? de_down_pointer(de) : 0;\n\tde = de_next_de(de);\n\tif (!de->last) goto error;\n\td2 = de->down ? de_down_pointer(de) : 0;\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\tdo {\n\t\twhile (d1) {\n\t\t\tif (!(dnode = hpfs_map_dnode(s, dno = d1, &qbh))) return;\n\t\t\tde = dnode_first_de(dnode);\n\t\t\tif (!de->last) goto error;\n\t\t\td1 = de->down ? de_down_pointer(de) : 0;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t}\n\t\td1 = d2;\n\t\td2 = 0;\n\t} while (d1);\n\treturn;\n\terror:\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\thpfs_error(s, \"directory %08x is corrupted or not empty\", rdno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_remove_btree",
          "args": [
            "s",
            "&fnode->btree"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "273-325",
          "snippet": "void hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_is_dir",
          "args": [
            "fnode"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "480-483",
          "snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "s",
            "fno",
            "&bh"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_fnode(struct super_block *s, fnode_secno fno)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end;\n\tif (!(fnode = hpfs_map_fnode(s, fno, &bh))) return;\n\tif (!fnode_is_dir(fnode)) hpfs_remove_btree(s, &fnode->btree);\n\telse hpfs_remove_dtree(s, le32_to_cpu(fnode->u.external[0].disk_secno));\n\tea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (ea_indirect(ea))\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\thpfs_ea_ext_remove(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l));\n\tbrelse(bh);\n\thpfs_free_sectors(s, fno, 1);\n}"
  },
  {
    "function_name": "hpfs_truncate_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "398-475",
    "snippet": "void hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno)); /* I hope gcc optimizes this :-) */\n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "8 + 12 * btree->n_used_nodes"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "le32_to_cpu(btree->u.external[j].disk_secno)",
            "le32_to_cpu(btree->u.external[j].length)"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "btree->u.external[j].length"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "secs - le32_to_cpu(btree->u.external[i].file_secno)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"there is an allocation error in file %08x, sector %08x\"",
            "f",
            "secs"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_anode",
          "args": [
            "s",
            "node",
            "&bh"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "194-223",
          "snippet": "struct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "s",
            "node",
            "&c1",
            "&c2",
            "\"hpfs_truncate_btree\""
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "secs"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "8 + 8 * btree->n_used_nodes"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_ea_remove",
          "args": [
            "s",
            "le32_to_cpu(btree->u.internal[j].down)",
            "1",
            "0"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_ea_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "384-394",
          "snippet": "void hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bp_internal",
          "args": [
            "btree"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "bp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "417-420",
          "snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "8"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_remove_btree",
          "args": [
            "s",
            "btree"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "273-325",
          "snippet": "void hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "s",
            "f",
            "&bh"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\n{\n\tstruct fnode *fnode;\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tstruct bplus_header *btree;\n\tanode_secno node = f;\n\tint i, j, nodes;\n\tint c1, c2 = 0;\n\tif (fno) {\n\t\tif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, f, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\n\tif (!secs) {\n\t\thpfs_remove_btree(s, btree);\n\t\tif (fno) {\n\t\t\tbtree->n_free_nodes = 8;\n\t\t\tbtree->n_used_nodes = 0;\n\t\t\tbtree->first_free = cpu_to_le16(8);\n\t\t\tbtree->flags &= ~BP_internal;\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else hpfs_free_sectors(s, f, 1);\n\t\tbrelse(bh);\n\t\treturn;\n\t}\n\twhile (bp_internal(btree)) {\n\t\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"internal btree %08x doesn't end with -1\", node);\n\t\treturn;\n\t\tf:\n\t\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\t\thpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\n\t\tbtree->n_used_nodes = i + 1;\n\t\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\t\tbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\n\t\tmark_buffer_dirty(bh);\n\t\tif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tnode = le32_to_cpu(btree->u.internal[i].down);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, node, &c1, &c2, \"hpfs_truncate_btree\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return;\n\t\tbtree = &anode->btree;\n\t}\t\n\tnodes = btree->n_used_nodes + btree->n_free_nodes;\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\n\tbrelse(bh);\n\treturn;\n\tff:\n\tif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\n\t\thpfs_error(s, \"there is an allocation error in file %08x, sector %08x\", f, secs);\n\t\tif (i) i--;\n\t}\n\telse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\n\t\t\tle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\n\t\t\t- secs + le32_to_cpu(btree->u.external[i].file_secno)); /* I hope gcc optimizes this :-) */\n\t\tbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\n\t}\n\tfor (j = i + 1; j < btree->n_used_nodes; j++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\n\tbtree->n_used_nodes = i + 1;\n\tbtree->n_free_nodes = nodes - btree->n_used_nodes;\n\tbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "hpfs_ea_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "384-394",
    "snippet": "void hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "a",
            "(len + 511) >> 9"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_remove_btree",
          "args": [
            "s",
            "&anode->btree"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "273-325",
          "snippet": "void hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_anode",
          "args": [
            "s",
            "a",
            "&bh"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "194-223",
          "snippet": "struct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (ano) {\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return;\n\t\thpfs_remove_btree(s, &anode->btree);\n\t\tbrelse(bh);\n\t\thpfs_free_sectors(s, a, 1);\n\t} else hpfs_free_sectors(s, a, (len + 511) >> 9);\n}"
  },
  {
    "function_name": "hpfs_ea_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "360-382",
    "snippet": "int hpfs_ea_write(struct super_block *s, secno a, int ano, unsigned pos,\n\t     unsigned len, const char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #2\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(data + (pos & 0x1ff), buf, l);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + (pos & 0x1ff)",
            "buf",
            "l"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "sec",
            "&bh",
            "(len - 1) >> 9"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "s",
            "sec",
            "1",
            "\"ea #2\""
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anode_lookup",
          "args": [
            "s",
            "a",
            "pos >> 9"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "anode_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "329-335",
          "snippet": "static secno anode_lookup(struct super_block *s, anode_secno a, unsigned sec)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\treturn hpfs_bplus_lookup(s, NULL, &anode->btree, sec, bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno anode_lookup(struct super_block *s, anode_secno a, unsigned sec)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\treturn hpfs_bplus_lookup(s, NULL, &anode->btree, sec, bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_write(struct super_block *s, secno a, int ano, unsigned pos,\n\t     unsigned len, const char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #2\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(data + (pos & 0x1ff), buf, l);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hpfs_ea_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "337-358",
    "snippet": "int hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "data + (pos & 0x1ff)",
            "l"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "sec",
            "&bh",
            "(len - 1) >> 9"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "s",
            "sec",
            "1",
            "\"ea #1\""
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anode_lookup",
          "args": [
            "s",
            "a",
            "pos >> 9"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "anode_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "329-335",
          "snippet": "static secno anode_lookup(struct super_block *s, anode_secno a, unsigned sec)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\treturn hpfs_bplus_lookup(s, NULL, &anode->btree, sec, bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno anode_lookup(struct super_block *s, anode_secno a, unsigned sec)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\treturn hpfs_bplus_lookup(s, NULL, &anode->btree, sec, bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\n\t    unsigned len, char *buf)\n{\n\tstruct buffer_head *bh;\n\tchar *data;\n\tsecno sec;\n\tunsigned l;\n\twhile (len) {\n\t\tif (ano) {\n\t\t\tif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\n\t\t\t\treturn -1;\n\t\t} else sec = a + (pos >> 9);\n\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, \"ea #1\")) return -1;\n\t\tif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\n\t\t\treturn -1;\n\t\tl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\n\t\tmemcpy(buf, data + (pos & 0x1ff), l);\n\t\tbrelse(bh);\n\t\tbuf += l; pos += l; len -= l;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "anode_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "329-335",
    "snippet": "static secno anode_lookup(struct super_block *s, anode_secno a, unsigned sec)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\treturn hpfs_bplus_lookup(s, NULL, &anode->btree, sec, bh);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_bplus_lookup",
          "args": [
            "s",
            "NULL",
            "&anode->btree",
            "sec",
            "bh"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_bplus_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "13-56",
          "snippet": "secno hpfs_bplus_lookup(struct super_block *s, struct inode *inode,\n\t\t   struct bplus_header *btree, unsigned sec,\n\t\t   struct buffer_head *bh)\n{\n\tanode_secno a = -1;\n\tstruct anode *anode;\n\tint i;\n\tint c1, c2 = 0;\n\tgo_down:\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_bplus_lookup\")) return -1;\n\tif (bp_internal(btree)) {\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) > sec) {\n\t\t\t\ta = le32_to_cpu(btree->u.internal[i].down);\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\t\t\tbtree = &anode->btree;\n\t\t\t\tgoto go_down;\n\t\t\t}\n\t\thpfs_error(s, \"sector %08x not found in internal anode %08x\", sec, a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) <= sec &&\n\t\t    le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > sec) {\n\t\t\ta = le32_to_cpu(btree->u.external[i].disk_secno) + sec - le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, a, 1, \"data\")) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (inode) {\n\t\t\t\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\t\t\t\thpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\t\thpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);\n\t\t\t\thpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn a;\n\t\t}\n\thpfs_error(s, \"sector %08x not found in external anode %08x\", sec, a);\n\tbrelse(bh);\n\treturn -1;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_bplus_lookup(struct super_block *s, struct inode *inode,\n\t\t   struct bplus_header *btree, unsigned sec,\n\t\t   struct buffer_head *bh)\n{\n\tanode_secno a = -1;\n\tstruct anode *anode;\n\tint i;\n\tint c1, c2 = 0;\n\tgo_down:\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_bplus_lookup\")) return -1;\n\tif (bp_internal(btree)) {\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) > sec) {\n\t\t\t\ta = le32_to_cpu(btree->u.internal[i].down);\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\t\t\tbtree = &anode->btree;\n\t\t\t\tgoto go_down;\n\t\t\t}\n\t\thpfs_error(s, \"sector %08x not found in internal anode %08x\", sec, a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) <= sec &&\n\t\t    le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > sec) {\n\t\t\ta = le32_to_cpu(btree->u.external[i].disk_secno) + sec - le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, a, 1, \"data\")) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (inode) {\n\t\t\t\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\t\t\t\thpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\t\thpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);\n\t\t\t\thpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn a;\n\t\t}\n\thpfs_error(s, \"sector %08x not found in external anode %08x\", sec, a);\n\tbrelse(bh);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_anode",
          "args": [
            "s",
            "a",
            "&bh"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "194-223",
          "snippet": "struct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno anode_lookup(struct super_block *s, anode_secno a, unsigned sec)\n{\n\tstruct anode *anode;\n\tstruct buffer_head *bh;\n\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\treturn hpfs_bplus_lookup(s, NULL, &anode->btree, sec, bh);\n}"
  },
  {
    "function_name": "hpfs_remove_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "273-325",
    "snippet": "void hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\"",
            "oano",
            "level ? ano : -1"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "btree1->u.internal[i].down"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_anode",
          "args": [
            "s",
            "ano",
            "&bh"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "194-223",
          "snippet": "struct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "ano",
            "1"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "s",
            "ano",
            "&c1",
            "&c2",
            "\"hpfs_remove_btree #2\""
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bp_internal",
          "args": [
            "btree1"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "bp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "417-420",
          "snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\n{\n\tstruct bplus_header *btree1 = btree;\n\tstruct anode *anode = NULL;\n\tanode_secno ano = 0, oano;\n\tstruct buffer_head *bh;\n\tint level = 0;\n\tint pos = 0;\n\tint i;\n\tint c1, c2 = 0;\n\tint d1, d2;\n\tgo_down:\n\td2 = 0;\n\twhile (bp_internal(btree1)) {\n\t\tano = le32_to_cpu(btree1->u.internal[pos].down);\n\t\tif (level) brelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, ano, &d1, &d2, \"hpfs_remove_btree #1\"))\n\t\t\t\treturn;\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t\tlevel++;\n\t\tpos = 0;\n\t}\n\tfor (i = 0; i < btree1->n_used_nodes; i++)\n\t\thpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\n\tgo_up:\n\tif (!level) return;\n\tbrelse(bh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ano, &c1, &c2, \"hpfs_remove_btree #2\")) return;\n\thpfs_free_sectors(s, ano, 1);\n\toano = ano;\n\tano = le32_to_cpu(anode->up);\n\tif (--level) {\n\t\tif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\n\t\tbtree1 = &anode->btree;\n\t} else btree1 = btree;\n\tfor (i = 0; i < btree1->n_used_nodes; i++) {\n\t\tif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\n\t\t\tif ((pos = i + 1) < btree1->n_used_nodes)\n\t\t\t\tgoto go_down;\n\t\t\telse\n\t\t\t\tgoto go_up;\n\t\t}\n\t}\n\thpfs_error(s,\n\t\t   \"reference to anode %08x not found in anode %08x \"\n\t\t   \"(probably bad up pointer)\",\n\t\t   oano, level ? ano : -1);\n\tif (level)\n\t\tbrelse(bh);\n}"
  },
  {
    "function_name": "hpfs_add_sector_to_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "60-266",
    "snippet": "secno hpfs_add_sector_to_btree(struct super_block *s, secno node, int fnod, unsigned fsecno)\n{\n\tstruct bplus_header *btree;\n\tstruct anode *anode = NULL, *ranode = NULL;\n\tstruct fnode *fnode;\n\tanode_secno a, na = -1, ra, up = -1;\n\tsecno se;\n\tstruct buffer_head *bh, *bh1, *bh2;\n\tint n;\n\tunsigned fs;\n\tint c1, c2 = 0;\n\tif (fnod) {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) return -1;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t}\n\ta = node;\n\tgo_down:\n\tif ((n = btree->n_used_nodes - 1) < -!!fnod) {\n\t\thpfs_error(s, \"anode %08x has no entries\", a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tif (bp_internal(btree)) {\n\t\ta = le32_to_cpu(btree->u.internal[n].down);\n\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_add_sector_to_btree #1\")) return -1;\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t\tgoto go_down;\n\t}\n\tif (n >= 0) {\n\t\tif (le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length) != fsecno) {\n\t\t\thpfs_error(s, \"allocated size %08x, trying to add sector %08x, %cnode %08x\",\n\t\t\t\tle32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length), fsecno,\n\t\t\t\tfnod?'f':'a', node);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tif (hpfs_alloc_if_possible(s, se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length))) {\n\t\t\tle32_add_cpu(&btree->u.external[n].length, 1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\treturn se;\n\t\t}\n\t} else {\n\t\tif (fsecno) {\n\t\t\thpfs_error(s, \"empty file %08x, trying to add sector %08x\", node, fsecno);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tse = !fnod ? node : (node + 16384) & ~16383;\n\t}\t\n\tif (!(se = hpfs_alloc_sector(s, se, 1, fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M))) {\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfs = n < 0 ? 0 : le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length);\n\tif (!btree->n_free_nodes) {\n\t\tup = a != node ? le32_to_cpu(anode->up) : -1;\n\t\tif (!(anode = hpfs_alloc_anode(s, a, &na, &bh1))) {\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (a == node && fnod) {\n\t\t\tanode->up = cpu_to_le32(node);\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\tanode->btree.n_used_nodes = btree->n_used_nodes;\n\t\t\tanode->btree.first_free = btree->first_free;\n\t\t\tanode->btree.n_free_nodes = 40 - anode->btree.n_used_nodes;\n\t\t\tmemcpy(&anode->u, &btree->u, btree->n_used_nodes * 12);\n\t\t\tbtree->flags |= BP_internal;\n\t\t\tbtree->n_free_nodes = 11;\n\t\t\tbtree->n_used_nodes = 1;\n\t\t\tbtree->first_free = cpu_to_le16((char *)&(btree->u.internal[1]) - (char *)btree);\n\t\t\tbtree->u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[0].down = cpu_to_le32(na);\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else if (!(ranode = hpfs_alloc_anode(s, /*a*/0, &ra, &bh2))) {\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh1);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\thpfs_free_sectors(s, na, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(bh);\n\t\tbh = bh1;\n\t\tbtree = &anode->btree;\n\t}\n\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\tle16_add_cpu(&btree->first_free, 12);\n\tbtree->u.external[n].disk_secno = cpu_to_le32(se);\n\tbtree->u.external[n].file_secno = cpu_to_le32(fs);\n\tbtree->u.external[n].length = cpu_to_le32(1);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tif ((a == node && fnod) || na == -1) return se;\n\tc2 = 0;\n\twhile (up != (anode_secno)-1) {\n\t\tstruct anode *new_anode;\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, up, &c1, &c2, \"hpfs_add_sector_to_btree #2\")) return -1;\n\t\tif (up != node || !fnod) {\n\t\t\tif (!(anode = hpfs_map_anode(s, up, &bh))) return -1;\n\t\t\tbtree = &anode->btree;\n\t\t} else {\n\t\t\tif (!(fnode = hpfs_map_fnode(s, up, &bh))) return -1;\n\t\t\tbtree = &fnode->btree;\n\t\t}\n\t\tif (btree->n_free_nodes) {\n\t\t\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\t\t\tle16_add_cpu(&btree->first_free, 8);\n\t\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[n].down = cpu_to_le32(na);\n\t\t\tbtree->u.internal[n-1].file_secno = cpu_to_le32(fs);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh2);\n\t\t\thpfs_free_sectors(s, ra, 1);\n\t\t\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(up);\n\t\t\t\tif (up == node && fnod)\n\t\t\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\t\telse\n\t\t\t\t\tanode->btree.flags &= ~BP_fnode_parent;\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\treturn se;\n\t\t}\n\t\tup = up != node ? le32_to_cpu(anode->up) : -1;\n\t\tbtree->u.internal[btree->n_used_nodes - 1].file_secno = cpu_to_le32(/*fs*/-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\ta = na;\n\t\tif ((new_anode = hpfs_alloc_anode(s, a, &na, &bh))) {\n\t\t\tanode = new_anode;\n\t\t\t/*anode->up = cpu_to_le32(up != -1 ? up : ra);*/\n\t\t\tanode->btree.flags |= BP_internal;\n\t\t\tanode->btree.n_used_nodes = 1;\n\t\t\tanode->btree.n_free_nodes = 59;\n\t\t\tanode->btree.first_free = cpu_to_le16(16);\n\t\t\tanode->btree.u.internal[0].down = cpu_to_le32(a);\n\t\t\tanode->btree.u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(na);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t} else na = a;\n\t}\n\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\tanode->up = cpu_to_le32(node);\n\t\tif (fnod)\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tif (!fnod) {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &anode->btree;\n\t} else {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &fnode->btree;\n\t}\n\tranode->up = cpu_to_le32(node);\n\tmemcpy(&ranode->btree, btree, le16_to_cpu(btree->first_free));\n\tif (fnod)\n\t\tranode->btree.flags |= BP_fnode_parent;\n\tranode->btree.n_free_nodes = (bp_internal(&ranode->btree) ? 60 : 40) - ranode->btree.n_used_nodes;\n\tif (bp_internal(&ranode->btree)) for (n = 0; n < ranode->btree.n_used_nodes; n++) {\n\t\tstruct anode *unode;\n\t\tif ((unode = hpfs_map_anode(s, le32_to_cpu(ranode->u.internal[n].down), &bh1))) {\n\t\t\tunode->up = cpu_to_le32(ra);\n\t\t\tunode->btree.flags &= ~BP_fnode_parent;\n\t\t\tmark_buffer_dirty(bh1);\n\t\t\tbrelse(bh1);\n\t\t}\n\t}\n\tbtree->flags |= BP_internal;\n\tbtree->n_free_nodes = fnod ? 10 : 58;\n\tbtree->n_used_nodes = 2;\n\tbtree->first_free = cpu_to_le16((char *)&btree->u.internal[2] - (char *)btree);\n\tbtree->u.internal[0].file_secno = cpu_to_le32(fs);\n\tbtree->u.internal[0].down = cpu_to_le32(ra);\n\tbtree->u.internal[1].file_secno = cpu_to_le32(-1);\n\tbtree->u.internal[1].down = cpu_to_le32(na);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tmark_buffer_dirty(bh2);\n\tbrelse(bh2);\n\treturn se;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh2"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh2"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "na"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ra"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fs"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(char *)&btree->u.internal[2] - (char *)btree"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ra"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_anode",
          "args": [
            "s",
            "le32_to_cpu(ranode->u.internal[n].down)",
            "&bh1"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "194-223",
          "snippet": "struct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ranode->u.internal[n].down"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bp_internal",
          "args": [
            "&ranode->btree"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "bp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "417-420",
          "snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ranode->btree",
            "btree",
            "le16_to_cpu(btree->first_free)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "btree->first_free"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "node"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "s",
            "node",
            "&bh"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "node"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "na"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "a"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "16"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_anode",
          "args": [
            "s",
            "a",
            "&na",
            "&bh"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "470-486",
          "snippet": "struct anode *hpfs_alloc_anode(struct super_block *s, secno near, anode_secno *ano,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct anode *a;\n\tif (!(*ano = hpfs_alloc_sector(s, near, 1, ANODE_ALLOC_FWD))) return NULL;\n\tif (!(a = hpfs_get_sector(s, *ano, bh))) {\n\t\thpfs_free_sectors(s, *ano, 1);\n\t\treturn NULL;\n\t}\n\tmemset(a, 0, 512);\n\ta->magic = cpu_to_le32(ANODE_MAGIC);\n\ta->self = cpu_to_le32(*ano);\n\ta->btree.n_free_nodes = 40;\n\ta->btree.n_used_nodes = 0;\n\ta->btree.first_free = cpu_to_le16(8);\n\treturn a;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_alloc_anode(struct super_block *s, secno near, anode_secno *ano,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct anode *a;\n\tif (!(*ano = hpfs_alloc_sector(s, near, 1, ANODE_ALLOC_FWD))) return NULL;\n\tif (!(a = hpfs_get_sector(s, *ano, bh))) {\n\t\thpfs_free_sectors(s, *ano, 1);\n\t\treturn NULL;\n\t}\n\tmemset(a, 0, 512);\n\ta->magic = cpu_to_le32(ANODE_MAGIC);\n\ta->self = cpu_to_le32(*ano);\n\ta->btree.n_free_nodes = 40;\n\ta->btree.n_used_nodes = 0;\n\ta->btree.first_free = cpu_to_le16(8);\n\treturn a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "/*fs*/-1"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "up"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "s",
            "ra",
            "1"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fs"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "na"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&btree->first_free",
            "8"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "s",
            "up",
            "&c1",
            "&c2",
            "\"hpfs_add_sector_to_btree #2\""
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fs"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "se"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&btree->first_free",
            "12"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "na"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(char *)&(btree->u.internal[1]) - (char *)btree"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&anode->u",
            "&btree->u",
            "btree->n_used_nodes * 12"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "node"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_sector",
          "args": [
            "s",
            "se",
            "1",
            "fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "202-274",
          "snippet": "secno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_alloc_sector(struct super_block *s, secno near, unsigned n, int forward)\n{\n\tsecno sec;\n\tint i;\n\tunsigned n_bmps;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tint f_p = 0;\n\tint near_bmp;\n\tif (forward < 0) {\n\t\tforward = -forward;\n\t\tf_p = 1;\n\t}\n\tn_bmps = (sbi->sb_fs_size + 0x4000 - 1) >> 14;\n\tif (near && near < sbi->sb_fs_size) {\n\t\tif ((sec = alloc_in_bmp(s, near, n, f_p ? forward : forward/4))) goto ret;\n\t\tnear_bmp = near >> 14;\n\t} else near_bmp = n_bmps / 2;\n\t/*\n\tif (b != -1) {\n\t\tif ((sec = alloc_in_bmp(s, b<<14, n, f_p ? forward : forward/2))) {\n\t\t\tb &= 0x0fffffff;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (b > 0x10000000) if ((sec = alloc_in_bmp(s, (b&0xfffffff)<<14, n, f_p ? forward : 0))) goto ret;\n\t*/\n\tif (!f_p) if (forward > sbi->sb_max_fwd_alloc) forward = sbi->sb_max_fwd_alloc;\n\tless_fwd:\n\tfor (i = 0; i < n_bmps; i++) {\n\t\tif (near_bmp+i < n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i) << 14, n, forward)))) {\n\t\t\tsbi->sb_c_bitmap = near_bmp+i;\n\t\t\tgoto ret;\n\t\t}\t\n\t\tif (!forward) {\n\t\t\tif (near_bmp-i-1 >= 0 && ((sec = alloc_in_bmp(s, (near_bmp-i-1) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp-i-1;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t} else {\n\t\t\tif (near_bmp+i >= n_bmps && ((sec = alloc_in_bmp(s, (near_bmp+i-n_bmps) << 14, n, forward)))) {\n\t\t\t\tsbi->sb_c_bitmap = near_bmp+i-n_bmps;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\tif (i == 1 && sbi->sb_c_bitmap != -1 && ((sec = alloc_in_bmp(s, (sbi->sb_c_bitmap) << 14, n, forward)))) {\n\t\t\tgoto ret;\n\t\t}\n\t}\n\tif (!f_p) {\n\t\tif (forward) {\n\t\t\tsbi->sb_max_fwd_alloc = forward * 3 / 4;\n\t\t\tforward /= 2;\n\t\t\tgoto less_fwd;\n\t\t}\n\t}\n\tsec = 0;\n\tret:\n\tif (sec) {\n\t\ti = 0;\n\t\tdo\n\t\t\thpfs_claim_alloc(s, sec + i);\n\t\twhile (unlikely(++i < n));\n\t}\n\tif (sec && f_p) {\n\t\tfor (i = 0; i < forward; i++) {\n\t\t\tif (!hpfs_alloc_if_possible(s, sec + n + i)) {\n\t\t\t\thpfs_error(s, \"Prealloc doesn't work! Wanted %d, allocated at %08x, can't allocate %d\", forward, sec, i);\n\t\t\t\tsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"empty file %08x, trying to add sector %08x\"",
            "node",
            "fsecno"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&btree->u.external[n].length",
            "1"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_if_possible",
          "args": [
            "s",
            "se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length)"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_if_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "295-310",
          "snippet": "int hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_alloc_if_possible(struct super_block *s, secno sec)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"aip\"))) goto end;\n\tif (le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) & (1 << (sec & 0x1f))) {\n\t\tbmp[(sec & 0x3fff) >> 5] &= cpu_to_le32(~(1 << (sec & 0x1f)));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_alloc(s, sec);\n\t\treturn 1;\n\t}\n\thpfs_brelse4(&qbh);\n\tend:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_add_sector_to_btree(struct super_block *s, secno node, int fnod, unsigned fsecno)\n{\n\tstruct bplus_header *btree;\n\tstruct anode *anode = NULL, *ranode = NULL;\n\tstruct fnode *fnode;\n\tanode_secno a, na = -1, ra, up = -1;\n\tsecno se;\n\tstruct buffer_head *bh, *bh1, *bh2;\n\tint n;\n\tunsigned fs;\n\tint c1, c2 = 0;\n\tif (fnod) {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) return -1;\n\t\tbtree = &fnode->btree;\n\t} else {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t}\n\ta = node;\n\tgo_down:\n\tif ((n = btree->n_used_nodes - 1) < -!!fnod) {\n\t\thpfs_error(s, \"anode %08x has no entries\", a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tif (bp_internal(btree)) {\n\t\ta = le32_to_cpu(btree->u.internal[n].down);\n\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_add_sector_to_btree #1\")) return -1;\n\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\tbtree = &anode->btree;\n\t\tgoto go_down;\n\t}\n\tif (n >= 0) {\n\t\tif (le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length) != fsecno) {\n\t\t\thpfs_error(s, \"allocated size %08x, trying to add sector %08x, %cnode %08x\",\n\t\t\t\tle32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length), fsecno,\n\t\t\t\tfnod?'f':'a', node);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tif (hpfs_alloc_if_possible(s, se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length))) {\n\t\t\tle32_add_cpu(&btree->u.external[n].length, 1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\treturn se;\n\t\t}\n\t} else {\n\t\tif (fsecno) {\n\t\t\thpfs_error(s, \"empty file %08x, trying to add sector %08x\", node, fsecno);\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\tse = !fnod ? node : (node + 16384) & ~16383;\n\t}\t\n\tif (!(se = hpfs_alloc_sector(s, se, 1, fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M))) {\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfs = n < 0 ? 0 : le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length);\n\tif (!btree->n_free_nodes) {\n\t\tup = a != node ? le32_to_cpu(anode->up) : -1;\n\t\tif (!(anode = hpfs_alloc_anode(s, a, &na, &bh1))) {\n\t\t\tbrelse(bh);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (a == node && fnod) {\n\t\t\tanode->up = cpu_to_le32(node);\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\tanode->btree.n_used_nodes = btree->n_used_nodes;\n\t\t\tanode->btree.first_free = btree->first_free;\n\t\t\tanode->btree.n_free_nodes = 40 - anode->btree.n_used_nodes;\n\t\t\tmemcpy(&anode->u, &btree->u, btree->n_used_nodes * 12);\n\t\t\tbtree->flags |= BP_internal;\n\t\t\tbtree->n_free_nodes = 11;\n\t\t\tbtree->n_used_nodes = 1;\n\t\t\tbtree->first_free = cpu_to_le16((char *)&(btree->u.internal[1]) - (char *)btree);\n\t\t\tbtree->u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[0].down = cpu_to_le32(na);\n\t\t\tmark_buffer_dirty(bh);\n\t\t} else if (!(ranode = hpfs_alloc_anode(s, /*a*/0, &ra, &bh2))) {\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh1);\n\t\t\thpfs_free_sectors(s, se, 1);\n\t\t\thpfs_free_sectors(s, na, 1);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(bh);\n\t\tbh = bh1;\n\t\tbtree = &anode->btree;\n\t}\n\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\tle16_add_cpu(&btree->first_free, 12);\n\tbtree->u.external[n].disk_secno = cpu_to_le32(se);\n\tbtree->u.external[n].file_secno = cpu_to_le32(fs);\n\tbtree->u.external[n].length = cpu_to_le32(1);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tif ((a == node && fnod) || na == -1) return se;\n\tc2 = 0;\n\twhile (up != (anode_secno)-1) {\n\t\tstruct anode *new_anode;\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, up, &c1, &c2, \"hpfs_add_sector_to_btree #2\")) return -1;\n\t\tif (up != node || !fnod) {\n\t\t\tif (!(anode = hpfs_map_anode(s, up, &bh))) return -1;\n\t\t\tbtree = &anode->btree;\n\t\t} else {\n\t\t\tif (!(fnode = hpfs_map_fnode(s, up, &bh))) return -1;\n\t\t\tbtree = &fnode->btree;\n\t\t}\n\t\tif (btree->n_free_nodes) {\n\t\t\tbtree->n_free_nodes--; n = btree->n_used_nodes++;\n\t\t\tle16_add_cpu(&btree->first_free, 8);\n\t\t\tbtree->u.internal[n].file_secno = cpu_to_le32(-1);\n\t\t\tbtree->u.internal[n].down = cpu_to_le32(na);\n\t\t\tbtree->u.internal[n-1].file_secno = cpu_to_le32(fs);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tbrelse(bh2);\n\t\t\thpfs_free_sectors(s, ra, 1);\n\t\t\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(up);\n\t\t\t\tif (up == node && fnod)\n\t\t\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\t\t\telse\n\t\t\t\t\tanode->btree.flags &= ~BP_fnode_parent;\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\treturn se;\n\t\t}\n\t\tup = up != node ? le32_to_cpu(anode->up) : -1;\n\t\tbtree->u.internal[btree->n_used_nodes - 1].file_secno = cpu_to_le32(/*fs*/-1);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t\ta = na;\n\t\tif ((new_anode = hpfs_alloc_anode(s, a, &na, &bh))) {\n\t\t\tanode = new_anode;\n\t\t\t/*anode->up = cpu_to_le32(up != -1 ? up : ra);*/\n\t\t\tanode->btree.flags |= BP_internal;\n\t\t\tanode->btree.n_used_nodes = 1;\n\t\t\tanode->btree.n_free_nodes = 59;\n\t\t\tanode->btree.first_free = cpu_to_le16(16);\n\t\t\tanode->btree.u.internal[0].down = cpu_to_le32(a);\n\t\t\tanode->btree.u.internal[0].file_secno = cpu_to_le32(-1);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tif ((anode = hpfs_map_anode(s, a, &bh))) {\n\t\t\t\tanode->up = cpu_to_le32(na);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t} else na = a;\n\t}\n\tif ((anode = hpfs_map_anode(s, na, &bh))) {\n\t\tanode->up = cpu_to_le32(node);\n\t\tif (fnod)\n\t\t\tanode->btree.flags |= BP_fnode_parent;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tif (!fnod) {\n\t\tif (!(anode = hpfs_map_anode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &anode->btree;\n\t} else {\n\t\tif (!(fnode = hpfs_map_fnode(s, node, &bh))) {\n\t\t\tbrelse(bh2);\n\t\t\treturn -1;\n\t\t}\n\t\tbtree = &fnode->btree;\n\t}\n\tranode->up = cpu_to_le32(node);\n\tmemcpy(&ranode->btree, btree, le16_to_cpu(btree->first_free));\n\tif (fnod)\n\t\tranode->btree.flags |= BP_fnode_parent;\n\tranode->btree.n_free_nodes = (bp_internal(&ranode->btree) ? 60 : 40) - ranode->btree.n_used_nodes;\n\tif (bp_internal(&ranode->btree)) for (n = 0; n < ranode->btree.n_used_nodes; n++) {\n\t\tstruct anode *unode;\n\t\tif ((unode = hpfs_map_anode(s, le32_to_cpu(ranode->u.internal[n].down), &bh1))) {\n\t\t\tunode->up = cpu_to_le32(ra);\n\t\t\tunode->btree.flags &= ~BP_fnode_parent;\n\t\t\tmark_buffer_dirty(bh1);\n\t\t\tbrelse(bh1);\n\t\t}\n\t}\n\tbtree->flags |= BP_internal;\n\tbtree->n_free_nodes = fnod ? 10 : 58;\n\tbtree->n_used_nodes = 2;\n\tbtree->first_free = cpu_to_le16((char *)&btree->u.internal[2] - (char *)btree);\n\tbtree->u.internal[0].file_secno = cpu_to_le32(fs);\n\tbtree->u.internal[0].down = cpu_to_le32(ra);\n\tbtree->u.internal[1].file_secno = cpu_to_le32(-1);\n\tbtree->u.internal[1].down = cpu_to_le32(na);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\tmark_buffer_dirty(bh2);\n\tbrelse(bh2);\n\treturn se;\n}"
  },
  {
    "function_name": "hpfs_bplus_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
    "lines": "13-56",
    "snippet": "secno hpfs_bplus_lookup(struct super_block *s, struct inode *inode,\n\t\t   struct bplus_header *btree, unsigned sec,\n\t\t   struct buffer_head *bh)\n{\n\tanode_secno a = -1;\n\tstruct anode *anode;\n\tint i;\n\tint c1, c2 = 0;\n\tgo_down:\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_bplus_lookup\")) return -1;\n\tif (bp_internal(btree)) {\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) > sec) {\n\t\t\t\ta = le32_to_cpu(btree->u.internal[i].down);\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\t\t\tbtree = &anode->btree;\n\t\t\t\tgoto go_down;\n\t\t\t}\n\t\thpfs_error(s, \"sector %08x not found in internal anode %08x\", sec, a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) <= sec &&\n\t\t    le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > sec) {\n\t\t\ta = le32_to_cpu(btree->u.external[i].disk_secno) + sec - le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, a, 1, \"data\")) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (inode) {\n\t\t\t\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\t\t\t\thpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\t\thpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);\n\t\t\t\thpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn a;\n\t\t}\n\thpfs_error(s, \"sector %08x not found in external anode %08x\", sec, a);\n\tbrelse(bh);\n\treturn -1;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"sector %08x not found in external anode %08x\"",
            "sec",
            "a"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "btree->u.external[i].length"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "s",
            "a",
            "1",
            "\"data\""
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_anode",
          "args": [
            "s",
            "a",
            "&bh"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_anode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "194-223",
          "snippet": "struct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bp_internal",
          "args": [
            "btree"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "bp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "417-420",
          "snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "s",
            "a",
            "&c1",
            "&c2",
            "\"hpfs_bplus_lookup\""
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nsecno hpfs_bplus_lookup(struct super_block *s, struct inode *inode,\n\t\t   struct bplus_header *btree, unsigned sec,\n\t\t   struct buffer_head *bh)\n{\n\tanode_secno a = -1;\n\tstruct anode *anode;\n\tint i;\n\tint c1, c2 = 0;\n\tgo_down:\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_stop_cycles(s, a, &c1, &c2, \"hpfs_bplus_lookup\")) return -1;\n\tif (bp_internal(btree)) {\n\t\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\t\tif (le32_to_cpu(btree->u.internal[i].file_secno) > sec) {\n\t\t\t\ta = le32_to_cpu(btree->u.internal[i].down);\n\t\t\t\tbrelse(bh);\n\t\t\t\tif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\n\t\t\t\tbtree = &anode->btree;\n\t\t\t\tgoto go_down;\n\t\t\t}\n\t\thpfs_error(s, \"sector %08x not found in internal anode %08x\", sec, a);\n\t\tbrelse(bh);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < btree->n_used_nodes; i++)\n\t\tif (le32_to_cpu(btree->u.external[i].file_secno) <= sec &&\n\t\t    le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > sec) {\n\t\t\ta = le32_to_cpu(btree->u.external[i].disk_secno) + sec - le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, a, 1, \"data\")) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (inode) {\n\t\t\t\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\t\t\t\thpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);\n\t\t\t\thpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);\n\t\t\t\thpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn a;\n\t\t}\n\thpfs_error(s, \"sector %08x not found in external anode %08x\", sec, a);\n\tbrelse(bh);\n\treturn -1;\n}"
  }
]