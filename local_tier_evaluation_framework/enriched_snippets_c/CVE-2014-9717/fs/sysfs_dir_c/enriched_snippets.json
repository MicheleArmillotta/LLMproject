[
  {
    "function_name": "sysfs_move_dir_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
    "lines": "113-123",
    "snippet": "int sysfs_move_dir_ns(struct kobject *kobj, struct kobject *new_parent_kobj,\n\t\t      const void *new_ns)\n{\n\tstruct kernfs_node *kn = kobj->sd;\n\tstruct kernfs_node *new_parent;\n\n\tnew_parent = new_parent_kobj && new_parent_kobj->sd ?\n\t\tnew_parent_kobj->sd : sysfs_root_kn;\n\n\treturn kernfs_rename_ns(kn, new_parent, kn->name, new_ns);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kobject.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_rename_ns",
          "args": [
            "kn",
            "new_parent",
            "kn->name",
            "new_ns"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_rename_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1236-1302",
          "snippet": "int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t/* can't move or rename root */\n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t/* nothing to rename */\n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t/* rename kernfs_node */\n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t/*\n\t * Move to the appropriate place in the appropriate directories rbtree.\n\t */\n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t/* rename_lock protects ->parent and ->name accessors */\n\tspin_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\tspin_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nint kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t/* can't move or rename root */\n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t/* nothing to rename */\n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t/* rename kernfs_node */\n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t/*\n\t * Move to the appropriate place in the appropriate directories rbtree.\n\t */\n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t/* rename_lock protects ->parent and ->name accessors */\n\tspin_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\tspin_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nint sysfs_move_dir_ns(struct kobject *kobj, struct kobject *new_parent_kobj,\n\t\t      const void *new_ns)\n{\n\tstruct kernfs_node *kn = kobj->sd;\n\tstruct kernfs_node *new_parent;\n\n\tnew_parent = new_parent_kobj && new_parent_kobj->sd ?\n\t\tnew_parent_kobj->sd : sysfs_root_kn;\n\n\treturn kernfs_rename_ns(kn, new_parent, kn->name, new_ns);\n}"
  },
  {
    "function_name": "sysfs_rename_dir_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
    "lines": "101-111",
    "snippet": "int sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,\n\t\t\tconst void *new_ns)\n{\n\tstruct kernfs_node *parent;\n\tint ret;\n\n\tparent = kernfs_get_parent(kobj->sd);\n\tret = kernfs_rename_ns(kobj->sd, parent, new_name, new_ns);\n\tkernfs_put(parent);\n\treturn ret;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kobject.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "parent"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_rename_ns",
          "args": [
            "kobj->sd",
            "parent",
            "new_name",
            "new_ns"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_rename_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1236-1302",
          "snippet": "int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t/* can't move or rename root */\n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t/* nothing to rename */\n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t/* rename kernfs_node */\n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t/*\n\t * Move to the appropriate place in the appropriate directories rbtree.\n\t */\n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t/* rename_lock protects ->parent and ->name accessors */\n\tspin_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\tspin_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nint kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t     const char *new_name, const void *new_ns)\n{\n\tstruct kernfs_node *old_parent;\n\tconst char *old_name = NULL;\n\tint error;\n\n\t/* can't move or rename root */\n\tif (!kn->parent)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kernfs_mutex);\n\n\terror = -ENOENT;\n\tif (!kernfs_active(kn) || !kernfs_active(new_parent))\n\t\tgoto out;\n\n\terror = 0;\n\tif ((kn->parent == new_parent) && (kn->ns == new_ns) &&\n\t    (strcmp(kn->name, new_name) == 0))\n\t\tgoto out;\t/* nothing to rename */\n\n\terror = -EEXIST;\n\tif (kernfs_find_ns(new_parent, new_name, new_ns))\n\t\tgoto out;\n\n\t/* rename kernfs_node */\n\tif (strcmp(kn->name, new_name) != 0) {\n\t\terror = -ENOMEM;\n\t\tnew_name = kstrdup_const(new_name, GFP_KERNEL);\n\t\tif (!new_name)\n\t\t\tgoto out;\n\t} else {\n\t\tnew_name = NULL;\n\t}\n\n\t/*\n\t * Move to the appropriate place in the appropriate directories rbtree.\n\t */\n\tkernfs_unlink_sibling(kn);\n\tkernfs_get(new_parent);\n\n\t/* rename_lock protects ->parent and ->name accessors */\n\tspin_lock_irq(&kernfs_rename_lock);\n\n\told_parent = kn->parent;\n\tkn->parent = new_parent;\n\n\tkn->ns = new_ns;\n\tif (new_name) {\n\t\told_name = kn->name;\n\t\tkn->name = new_name;\n\t}\n\n\tspin_unlock_irq(&kernfs_rename_lock);\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\tkernfs_link_sibling(kn);\n\n\tkernfs_put(old_parent);\n\tkfree_const(old_name);\n\n\terror = 0;\n out:\n\tmutex_unlock(&kernfs_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get_parent",
          "args": [
            "kobj->sd"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "165-176",
          "snippet": "struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tparent = kn->parent;\n\tkernfs_get(parent);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\n\treturn parent;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nstruct kernfs_node *kernfs_get_parent(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tparent = kn->parent;\n\tkernfs_get(parent);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\n\treturn parent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nint sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,\n\t\t\tconst void *new_ns)\n{\n\tstruct kernfs_node *parent;\n\tint ret;\n\n\tparent = kernfs_get_parent(kobj->sd);\n\tret = kernfs_rename_ns(kobj->sd, parent, new_name, new_ns);\n\tkernfs_put(parent);\n\treturn ret;\n}"
  },
  {
    "function_name": "sysfs_remove_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
    "lines": "75-99",
    "snippet": "void sysfs_remove_dir(struct kobject *kobj)\n{\n\tstruct kernfs_node *kn = kobj->sd;\n\n\t/*\n\t * In general, kboject owner is responsible for ensuring removal\n\t * doesn't race with other operations and sysfs doesn't provide any\n\t * protection; however, when @kobj is used as a symlink target, the\n\t * symlinking entity usually doesn't own @kobj and thus has no\n\t * control over removal.  @kobj->sd may be removed anytime\n\t * and symlink code may end up dereferencing an already freed node.\n\t *\n\t * sysfs_symlink_target_lock synchronizes @kobj->sd\n\t * disassociation against symlink operations so that symlink code\n\t * can safely dereference @kobj->sd.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tkobj->sd = NULL;\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (kn) {\n\t\tWARN_ON_ONCE(kernfs_type(kn) != KERNFS_DIR);\n\t\tkernfs_remove(kn);\n\t}\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kobject.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "kn"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_remove_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "1144-1193",
          "snippet": "bool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nbool kernfs_remove_self(struct kernfs_node *kn)\n{\n\tbool ret;\n\n\tmutex_lock(&kernfs_mutex);\n\tkernfs_break_active_protection(kn);\n\n\t/*\n\t * SUICIDAL is used to arbitrate among competing invocations.  Only\n\t * the first one will actually perform removal.  When the removal\n\t * is complete, SUICIDED is set and the active ref is restored\n\t * while holding kernfs_mutex.  The ones which lost arbitration\n\t * waits for SUICDED && drained which can happen only after the\n\t * enclosing kernfs operation which executed the winning instance\n\t * of kernfs_remove_self() finished.\n\t */\n\tif (!(kn->flags & KERNFS_SUICIDAL)) {\n\t\tkn->flags |= KERNFS_SUICIDAL;\n\t\t__kernfs_remove(kn);\n\t\tkn->flags |= KERNFS_SUICIDED;\n\t\tret = true;\n\t} else {\n\t\twait_queue_head_t *waitq = &kernfs_root(kn)->deactivate_waitq;\n\t\tDEFINE_WAIT(wait);\n\n\t\twhile (true) {\n\t\t\tprepare_to_wait(waitq, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\t\tif ((kn->flags & KERNFS_SUICIDED) &&\n\t\t\t    atomic_read(&kn->active) == KN_DEACTIVATED_BIAS)\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&kernfs_mutex);\n\t\t\tschedule();\n\t\t\tmutex_lock(&kernfs_mutex);\n\t\t}\n\t\tfinish_wait(waitq, &wait);\n\t\tWARN_ON_ONCE(!RB_EMPTY_NODE(&kn->rb));\n\t\tret = false;\n\t}\n\n\t/*\n\t * This must be done while holding kernfs_mutex; otherwise, waiting\n\t * for SUICIDED && deactivated could finish prematurely.\n\t */\n\tkernfs_unbreak_active_protection(kn);\n\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "kernfs_type(kn) != KERNFS_DIR"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysfs_symlink_target_lock"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysfs_symlink_target_lock"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nvoid sysfs_remove_dir(struct kobject *kobj)\n{\n\tstruct kernfs_node *kn = kobj->sd;\n\n\t/*\n\t * In general, kboject owner is responsible for ensuring removal\n\t * doesn't race with other operations and sysfs doesn't provide any\n\t * protection; however, when @kobj is used as a symlink target, the\n\t * symlinking entity usually doesn't own @kobj and thus has no\n\t * control over removal.  @kobj->sd may be removed anytime\n\t * and symlink code may end up dereferencing an already freed node.\n\t *\n\t * sysfs_symlink_target_lock synchronizes @kobj->sd\n\t * disassociation against symlink operations so that symlink code\n\t * can safely dereference @kobj->sd.\n\t */\n\tspin_lock(&sysfs_symlink_target_lock);\n\tkobj->sd = NULL;\n\tspin_unlock(&sysfs_symlink_target_lock);\n\n\tif (kn) {\n\t\tWARN_ON_ONCE(kernfs_type(kn) != KERNFS_DIR);\n\t\tkernfs_remove(kn);\n\t}\n}"
  },
  {
    "function_name": "sysfs_create_dir_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
    "lines": "41-65",
    "snippet": "int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)\n{\n\tstruct kernfs_node *parent, *kn;\n\n\tBUG_ON(!kobj);\n\n\tif (kobj->parent)\n\t\tparent = kobj->parent->sd;\n\telse\n\t\tparent = sysfs_root_kn;\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_dir_ns(parent, kobject_name(kobj),\n\t\t\t\t  S_IRWXU | S_IRUGO | S_IXUGO, kobj, ns);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, kobject_name(kobj));\n\t\treturn PTR_ERR(kn);\n\t}\n\n\tkobj->sd = kn;\n\treturn 0;\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kobject.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_warn_dup",
          "args": [
            "parent",
            "kobject_name(kobj)"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_warn_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
          "lines": "22-34",
          "snippet": "void sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nvoid sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "kobj"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kn"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_create_dir_ns",
          "args": [
            "parent",
            "kobject_name(kobj)",
            "S_IRWXU | S_IRUGO | S_IXUGO",
            "kobj",
            "ns"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_create_dir_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "754-777",
          "snippet": "struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,\n\t\t\t\t\t const char *name, umode_t mode,\n\t\t\t\t\t void *priv, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\tint rc;\n\n\t/* allocate */\n\tkn = kernfs_new_node(parent, name, mode | S_IFDIR, KERNFS_DIR);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->dir.root = parent->dir.root;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n\t/* link in */\n\trc = kernfs_add_one(kn);\n\tif (!rc)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,\n\t\t\t\t\t const char *name, umode_t mode,\n\t\t\t\t\t void *priv, const void *ns)\n{\n\tstruct kernfs_node *kn;\n\tint rc;\n\n\t/* allocate */\n\tkn = kernfs_new_node(parent, name, mode | S_IFDIR, KERNFS_DIR);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->dir.root = parent->dir.root;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n\t/* link in */\n\trc = kernfs_add_one(kn);\n\tif (!rc)\n\t\treturn kn;\n\n\tkernfs_put(kn);\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "kobj"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kobj"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nint sysfs_create_dir_ns(struct kobject *kobj, const void *ns)\n{\n\tstruct kernfs_node *parent, *kn;\n\n\tBUG_ON(!kobj);\n\n\tif (kobj->parent)\n\t\tparent = kobj->parent->sd;\n\telse\n\t\tparent = sysfs_root_kn;\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tkn = kernfs_create_dir_ns(parent, kobject_name(kobj),\n\t\t\t\t  S_IRWXU | S_IRUGO | S_IXUGO, kobj, ns);\n\tif (IS_ERR(kn)) {\n\t\tif (PTR_ERR(kn) == -EEXIST)\n\t\t\tsysfs_warn_dup(parent, kobject_name(kobj));\n\t\treturn PTR_ERR(kn);\n\t}\n\n\tkobj->sd = kn;\n\treturn 0;\n}"
  },
  {
    "function_name": "sysfs_warn_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/dir.c",
    "lines": "22-34",
    "snippet": "void sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}",
    "includes": [
      "#include \"sysfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kobject.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\"",
            "path",
            "name"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_path",
          "args": [
            "parent",
            "buf",
            "PATH_MAX"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "105-114",
          "snippet": "char *kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tp = kernfs_path_locked(kn, buf, buflen);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\treturn p;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(kernfs_rename_lock);\n\nchar *kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen)\n{\n\tunsigned long flags;\n\tchar *p;\n\n\tspin_lock_irqsave(&kernfs_rename_lock, flags);\n\tp = kernfs_path_locked(kn, buf, buflen);\n\tspin_unlock_irqrestore(&kernfs_rename_lock, flags);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nvoid sysfs_warn_dup(struct kernfs_node *parent, const char *name)\n{\n\tchar *buf, *path = NULL;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (buf)\n\t\tpath = kernfs_path(parent, buf, PATH_MAX);\n\n\tWARN(1, KERN_WARNING \"sysfs: cannot create duplicate filename '%s/%s'\\n\",\n\t     path, name);\n\n\tkfree(buf);\n}"
  }
]