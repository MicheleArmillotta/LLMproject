[
  {
    "function_name": "hfs_clear_vbm_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bitmap.c",
    "lines": "193-243",
    "snippet": "int hfs_clear_vbm_bits(struct super_block *sb, u16 start, u16 count)\n{\n\t__be32 *curr;\n\tu32 mask;\n\tint i, len;\n\n\t/* is there any actual work to be done? */\n\tif (!count)\n\t\treturn 0;\n\n\thfs_dbg(BITMAP, \"clear_bits: %u,%u\\n\", start, count);\n\t/* are all of the bits in range? */\n\tif ((start + count) > HFS_SB(sb)->fs_ablocks)\n\t\treturn -2;\n\n\tmutex_lock(&HFS_SB(sb)->bitmap_lock);\n\t/* bitmap is always on a 32-bit boundary */\n\tcurr = HFS_SB(sb)->bitmap + (start / 32);\n\tlen = count;\n\n\t/* do any partial u32 at the start */\n\ti = start % 32;\n\tif (i) {\n\t\tint j = 32 - i;\n\t\tmask = 0xffffffffU << j;\n\t\tif (j > count) {\n\t\t\tmask |= 0xffffffffU >> (i + count);\n\t\t\t*curr &= cpu_to_be32(mask);\n\t\t\tgoto out;\n\t\t}\n\t\t*curr++ &= cpu_to_be32(mask);\n\t\tcount -= j;\n\t}\n\n\t/* do full u32s */\n\twhile (count >= 32) {\n\t\t*curr++ = 0;\n\t\tcount -= 32;\n\t}\n\t/* do any partial u32 at end */\n\tif (count) {\n\t\tmask = 0xffffffffU >> count;\n\t\t*curr &= cpu_to_be32(mask);\n\t}\nout:\n\tHFS_SB(sb)->free_ablocks += len;\n\tmutex_unlock(&HFS_SB(sb)->bitmap_lock);\n\thfs_bitmap_dirty(sb);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bitmap_dirty",
          "args": [
            "sb"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bitmap_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/hfs_fs.h",
          "lines": "267-271",
          "snippet": "static inline void hfs_bitmap_dirty(struct super_block *sb)\n{\n\tset_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"hfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define HFS_FLG_BITMAP_DIRTY\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfs.h\"\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/workqueue.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n#define HFS_FLG_BITMAP_DIRTY\t0\n\nstatic inline void hfs_bitmap_dirty(struct super_block *sb)\n{\n\tset_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&HFS_SB(sb)->bitmap_lock"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "mask"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "mask"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "mask"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&HFS_SB(sb)->bitmap_lock"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BITMAP",
            "\"clear_bits: %u,%u\\n\"",
            "start",
            "count"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfs_fs.h\"\n\nint hfs_clear_vbm_bits(struct super_block *sb, u16 start, u16 count)\n{\n\t__be32 *curr;\n\tu32 mask;\n\tint i, len;\n\n\t/* is there any actual work to be done? */\n\tif (!count)\n\t\treturn 0;\n\n\thfs_dbg(BITMAP, \"clear_bits: %u,%u\\n\", start, count);\n\t/* are all of the bits in range? */\n\tif ((start + count) > HFS_SB(sb)->fs_ablocks)\n\t\treturn -2;\n\n\tmutex_lock(&HFS_SB(sb)->bitmap_lock);\n\t/* bitmap is always on a 32-bit boundary */\n\tcurr = HFS_SB(sb)->bitmap + (start / 32);\n\tlen = count;\n\n\t/* do any partial u32 at the start */\n\ti = start % 32;\n\tif (i) {\n\t\tint j = 32 - i;\n\t\tmask = 0xffffffffU << j;\n\t\tif (j > count) {\n\t\t\tmask |= 0xffffffffU >> (i + count);\n\t\t\t*curr &= cpu_to_be32(mask);\n\t\t\tgoto out;\n\t\t}\n\t\t*curr++ &= cpu_to_be32(mask);\n\t\tcount -= j;\n\t}\n\n\t/* do full u32s */\n\twhile (count >= 32) {\n\t\t*curr++ = 0;\n\t\tcount -= 32;\n\t}\n\t/* do any partial u32 at end */\n\tif (count) {\n\t\tmask = 0xffffffffU >> count;\n\t\t*curr &= cpu_to_be32(mask);\n\t}\nout:\n\tHFS_SB(sb)->free_ablocks += len;\n\tmutex_unlock(&HFS_SB(sb)->bitmap_lock);\n\thfs_bitmap_dirty(sb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_vbm_search_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bitmap.c",
    "lines": "139-167",
    "snippet": "u32 hfs_vbm_search_free(struct super_block *sb, u32 goal, u32 *num_bits)\n{\n\tvoid *bitmap;\n\tu32 pos;\n\n\t/* make sure we have actual work to perform */\n\tif (!*num_bits)\n\t\treturn 0;\n\n\tmutex_lock(&HFS_SB(sb)->bitmap_lock);\n\tbitmap = HFS_SB(sb)->bitmap;\n\n\tpos = hfs_find_set_zero_bits(bitmap, HFS_SB(sb)->fs_ablocks, goal, num_bits);\n\tif (pos >= HFS_SB(sb)->fs_ablocks) {\n\t\tif (goal)\n\t\t\tpos = hfs_find_set_zero_bits(bitmap, goal, 0, num_bits);\n\t\tif (pos >= HFS_SB(sb)->fs_ablocks) {\n\t\t\t*num_bits = pos = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thfs_dbg(BITMAP, \"alloc_bits: %u,%u\\n\", pos, *num_bits);\n\tHFS_SB(sb)->free_ablocks -= *num_bits;\n\thfs_bitmap_dirty(sb);\nout:\n\tmutex_unlock(&HFS_SB(sb)->bitmap_lock);\n\treturn pos;\n}",
    "includes": [
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&HFS_SB(sb)->bitmap_lock"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bitmap_dirty",
          "args": [
            "sb"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bitmap_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/hfs_fs.h",
          "lines": "267-271",
          "snippet": "static inline void hfs_bitmap_dirty(struct super_block *sb)\n{\n\tset_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"hfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define HFS_FLG_BITMAP_DIRTY\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfs.h\"\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/workqueue.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n#define HFS_FLG_BITMAP_DIRTY\t0\n\nstatic inline void hfs_bitmap_dirty(struct super_block *sb)\n{\n\tset_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BITMAP",
            "\"alloc_bits: %u,%u\\n\"",
            "pos",
            "*num_bits"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_set_zero_bits",
          "args": [
            "bitmap",
            "goal",
            "0",
            "num_bits"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_set_zero_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bitmap.c",
          "lines": "29-110",
          "snippet": "static u32 hfs_find_set_zero_bits(__be32 *bitmap, u32 size, u32 offset, u32 *max)\n{\n\t__be32 *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tcurr = bitmap + (offset / 32);\n\tend = bitmap + ((size + 31) / 32);\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\ti = offset % 32;\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (++curr < end) {\n\t\tval = *curr;\n\t\tif (~val) {\n\t\t\tn = be32_to_cpu(val);\n\t\t\tmask = 1 << 31;\n\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\tif (!(n & mask))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n\nfound:\n\tstart = (curr - bitmap) * 32 + i;\n\tif (start >= size)\n\t\treturn start;\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\tn = be32_to_cpu(*curr);\n\t\tif (len < 32)\n\t\t\tbreak;\n\t\tif (n) {\n\t\t\tlen = 32;\n\t\t\tbreak;\n\t\t}\n\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\tlen -= 32;\n\t}\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\t*max = (curr - bitmap) * 32 + i - start;\n\treturn start;\n}",
          "includes": [
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfs_fs.h\"\n\nstatic u32 hfs_find_set_zero_bits(__be32 *bitmap, u32 size, u32 offset, u32 *max)\n{\n\t__be32 *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tcurr = bitmap + (offset / 32);\n\tend = bitmap + ((size + 31) / 32);\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\ti = offset % 32;\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (++curr < end) {\n\t\tval = *curr;\n\t\tif (~val) {\n\t\t\tn = be32_to_cpu(val);\n\t\t\tmask = 1 << 31;\n\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\tif (!(n & mask))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n\nfound:\n\tstart = (curr - bitmap) * 32 + i;\n\tif (start >= size)\n\t\treturn start;\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\tn = be32_to_cpu(*curr);\n\t\tif (len < 32)\n\t\t\tbreak;\n\t\tif (n) {\n\t\t\tlen = 32;\n\t\t\tbreak;\n\t\t}\n\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\tlen -= 32;\n\t}\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\t*max = (curr - bitmap) * 32 + i - start;\n\treturn start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&HFS_SB(sb)->bitmap_lock"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfs_fs.h\"\n\nu32 hfs_vbm_search_free(struct super_block *sb, u32 goal, u32 *num_bits)\n{\n\tvoid *bitmap;\n\tu32 pos;\n\n\t/* make sure we have actual work to perform */\n\tif (!*num_bits)\n\t\treturn 0;\n\n\tmutex_lock(&HFS_SB(sb)->bitmap_lock);\n\tbitmap = HFS_SB(sb)->bitmap;\n\n\tpos = hfs_find_set_zero_bits(bitmap, HFS_SB(sb)->fs_ablocks, goal, num_bits);\n\tif (pos >= HFS_SB(sb)->fs_ablocks) {\n\t\tif (goal)\n\t\t\tpos = hfs_find_set_zero_bits(bitmap, goal, 0, num_bits);\n\t\tif (pos >= HFS_SB(sb)->fs_ablocks) {\n\t\t\t*num_bits = pos = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thfs_dbg(BITMAP, \"alloc_bits: %u,%u\\n\", pos, *num_bits);\n\tHFS_SB(sb)->free_ablocks -= *num_bits;\n\thfs_bitmap_dirty(sb);\nout:\n\tmutex_unlock(&HFS_SB(sb)->bitmap_lock);\n\treturn pos;\n}"
  },
  {
    "function_name": "hfs_find_set_zero_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bitmap.c",
    "lines": "29-110",
    "snippet": "static u32 hfs_find_set_zero_bits(__be32 *bitmap, u32 size, u32 offset, u32 *max)\n{\n\t__be32 *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tcurr = bitmap + (offset / 32);\n\tend = bitmap + ((size + 31) / 32);\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\ti = offset % 32;\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (++curr < end) {\n\t\tval = *curr;\n\t\tif (~val) {\n\t\t\tn = be32_to_cpu(val);\n\t\t\tmask = 1 << 31;\n\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\tif (!(n & mask))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n\nfound:\n\tstart = (curr - bitmap) * 32 + i;\n\tif (start >= size)\n\t\treturn start;\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\tn = be32_to_cpu(*curr);\n\t\tif (len < 32)\n\t\t\tbreak;\n\t\tif (n) {\n\t\t\tlen = 32;\n\t\t\tbreak;\n\t\t}\n\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\tlen -= 32;\n\t}\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\t*max = (curr - bitmap) * 32 + i - start;\n\treturn start;\n}",
    "includes": [
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "n"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0xffffffff"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*curr"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "n"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size - start",
            "len"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "minix_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "41-68",
          "snippet": "void minix_free_block(struct inode *inode, unsigned long block)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct buffer_head *bh;\n\tint k = sb->s_blocksize_bits + 3;\n\tunsigned long bit, zone;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"Trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\tzone = block - sbi->s_firstdatazone + 1;\n\tbit = zone & ((1<<k) - 1);\n\tzone >>= k;\n\tif (zone >= sbi->s_zmap_blocks) {\n\t\tprintk(\"minix_free_block: nonexistent bitmap buffer\\n\");\n\t\treturn;\n\t}\n\tbh = sbi->s_zmap[zone];\n\tspin_lock(&bitmap_lock);\n\tif (!minix_test_and_clear_bit(bit, bh->b_data))\n\t\tprintk(\"minix_free_block (%s:%lu): bit already cleared\\n\",\n\t\t       sb->s_id, block);\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\treturn;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(bitmap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic DEFINE_SPINLOCK(bitmap_lock);\n\nvoid minix_free_block(struct inode *inode, unsigned long block)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct buffer_head *bh;\n\tint k = sb->s_blocksize_bits + 3;\n\tunsigned long bit, zone;\n\n\tif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\n\t\tprintk(\"Trying to free block not in datazone\\n\");\n\t\treturn;\n\t}\n\tzone = block - sbi->s_firstdatazone + 1;\n\tbit = zone & ((1<<k) - 1);\n\tzone >>= k;\n\tif (zone >= sbi->s_zmap_blocks) {\n\t\tprintk(\"minix_free_block: nonexistent bitmap buffer\\n\");\n\t\treturn;\n\t}\n\tbh = sbi->s_zmap[zone];\n\tspin_lock(&bitmap_lock);\n\tif (!minix_test_and_clear_bit(bit, bh->b_data))\n\t\tprintk(\"minix_free_block (%s:%lu): bit already cleared\\n\",\n\t\t       sb->s_id, block);\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "val"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "val"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfs_fs.h\"\n\nstatic u32 hfs_find_set_zero_bits(__be32 *bitmap, u32 size, u32 offset, u32 *max)\n{\n\t__be32 *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tcurr = bitmap + (offset / 32);\n\tend = bitmap + ((size + 31) / 32);\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\ti = offset % 32;\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (++curr < end) {\n\t\tval = *curr;\n\t\tif (~val) {\n\t\t\tn = be32_to_cpu(val);\n\t\t\tmask = 1 << 31;\n\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\tif (!(n & mask))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n\nfound:\n\tstart = (curr - bitmap) * 32 + i;\n\tif (start >= size)\n\t\treturn start;\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\tn = be32_to_cpu(*curr);\n\t\tif (len < 32)\n\t\t\tbreak;\n\t\tif (n) {\n\t\t\tlen = 32;\n\t\t\tbreak;\n\t\t}\n\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\tlen -= 32;\n\t}\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\t*max = (curr - bitmap) * 32 + i - start;\n\treturn start;\n}"
  }
]