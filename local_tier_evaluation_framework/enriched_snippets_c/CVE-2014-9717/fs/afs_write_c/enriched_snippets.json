[
  {
    "function_name": "afs_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "747-762",
    "snippet": "int afs_page_mkwrite(struct vm_area_struct *vma, struct page *page)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(vma->vm_file->f_mapping->host);\n\n\t_enter(\"{{%x:%u}},{%lx}\",\n\t       vnode->fid.vid, vnode->fid.vnode, page->index);\n\n\t/* wait for the page to be written to the cache before we allow it to\n\t * be modified */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_wait_on_page_write(vnode->cache, page);\n#endif\n\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_on_page_write",
          "args": [
            "vnode->cache",
            "page"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "408-414",
          "snippet": "void __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{{%x:%u}},{%lx}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "page->index"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "vma->vm_file->f_mapping->host"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nint afs_page_mkwrite(struct vm_area_struct *vma, struct page *page)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(vma->vm_file->f_mapping->host);\n\n\t_enter(\"{{%x:%u}},{%lx}\",\n\t       vnode->fid.vid, vnode->fid.vnode, page->index);\n\n\t/* wait for the page to be written to the cache before we allow it to\n\t * be modified */\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_wait_on_page_write(vnode->cache, page);\n#endif\n\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "683-741",
    "snippet": "int afs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_writeback *wb, *xwb;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tint ret;\n\n\t_enter(\"{%x:%u},{n=%pD},%d\",\n\t       vnode->fid.vid, vnode->fid.vnode, file,\n\t       datasync);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&inode->i_mutex);\n\n\t/* use a writeback record as a marker in the queue - when this reaches\n\t * the front of the queue, all the outstanding writes are either\n\t * completed or rejected */\n\twb = kzalloc(sizeof(*wb), GFP_KERNEL);\n\tif (!wb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\twb->vnode = vnode;\n\twb->first = 0;\n\twb->last = -1;\n\twb->offset_first = 0;\n\twb->to_last = PAGE_SIZE;\n\twb->usage = 1;\n\twb->state = AFS_WBACK_SYNCING;\n\tinit_waitqueue_head(&wb->waitq);\n\n\tspin_lock(&vnode->writeback_lock);\n\tlist_for_each_entry(xwb, &vnode->writebacks, link) {\n\t\tif (xwb->state == AFS_WBACK_PENDING)\n\t\t\txwb->state = AFS_WBACK_CONFLICTING;\n\t}\n\tlist_add_tail(&wb->link, &vnode->writebacks);\n\tspin_unlock(&vnode->writeback_lock);\n\n\t/* push all the outstanding writebacks to the server */\n\tret = afs_writeback_all(vnode);\n\tif (ret < 0) {\n\t\tafs_put_writeback(wb);\n\t\t_leave(\" = %d [wb]\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait for the preceding writes to actually complete */\n\tret = wait_event_interruptible(wb->waitq,\n\t\t\t\t       wb->state == AFS_WBACK_COMPLETE ||\n\t\t\t\t       vnode->writebacks.next == &wb->link);\n\tafs_put_writeback(wb);\n\t_leave(\" = %d\", ret);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_writeback",
          "args": [
            "wb"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "68-82",
          "snippet": "void afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nvoid afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "wb->waitq",
            "wb->state == AFS_WBACK_COMPLETE ||\n\t\t\t\t       vnode->writebacks.next == &wb->link"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_writeback_all",
          "args": [
            "vnode"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "afs_writeback_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "659-676",
          "snippet": "int afs_writeback_all(struct afs_vnode *vnode)\n{\n\tstruct address_space *mapping = vnode->vfs_inode.i_mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_to_write\t= LONG_MAX,\n\t\t.range_cyclic\t= 1,\n\t};\n\tint ret;\n\n\t_enter(\"\");\n\n\tret = mapping->a_ops->writepages(mapping, &wbc);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nint afs_writeback_all(struct afs_vnode *vnode)\n{\n\tstruct address_space *mapping = vnode->vfs_inode.i_mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_to_write\t= LONG_MAX,\n\t\t.range_cyclic\t= 1,\n\t};\n\tint ret;\n\n\t_enter(\"\");\n\n\tret = mapping->a_ops->writepages(mapping, &wbc);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&wb->link",
            "&vnode->writebacks"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "xwb",
            "&vnode->writebacks",
            "link"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&wb->waitq"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wb)",
            "GFP_KERNEL"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{n=%pD},%d\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "file",
            "datasync"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nint afs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct afs_writeback *wb, *xwb;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tint ret;\n\n\t_enter(\"{%x:%u},{n=%pD},%d\",\n\t       vnode->fid.vid, vnode->fid.vnode, file,\n\t       datasync);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&inode->i_mutex);\n\n\t/* use a writeback record as a marker in the queue - when this reaches\n\t * the front of the queue, all the outstanding writes are either\n\t * completed or rejected */\n\twb = kzalloc(sizeof(*wb), GFP_KERNEL);\n\tif (!wb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\twb->vnode = vnode;\n\twb->first = 0;\n\twb->last = -1;\n\twb->offset_first = 0;\n\twb->to_last = PAGE_SIZE;\n\twb->usage = 1;\n\twb->state = AFS_WBACK_SYNCING;\n\tinit_waitqueue_head(&wb->waitq);\n\n\tspin_lock(&vnode->writeback_lock);\n\tlist_for_each_entry(xwb, &vnode->writebacks, link) {\n\t\tif (xwb->state == AFS_WBACK_PENDING)\n\t\t\txwb->state = AFS_WBACK_CONFLICTING;\n\t}\n\tlist_add_tail(&wb->link, &vnode->writebacks);\n\tspin_unlock(&vnode->writeback_lock);\n\n\t/* push all the outstanding writebacks to the server */\n\tret = afs_writeback_all(vnode);\n\tif (ret < 0) {\n\t\tafs_put_writeback(wb);\n\t\t_leave(\" = %d [wb]\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait for the preceding writes to actually complete */\n\tret = wait_event_interruptible(wb->waitq,\n\t\t\t\t       wb->state == AFS_WBACK_COMPLETE ||\n\t\t\t\t       vnode->writebacks.next == &wb->link);\n\tafs_put_writeback(wb);\n\t_leave(\" = %d\", ret);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_writeback_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "659-676",
    "snippet": "int afs_writeback_all(struct afs_vnode *vnode)\n{\n\tstruct address_space *mapping = vnode->vfs_inode.i_mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_to_write\t= LONG_MAX,\n\t\t.range_cyclic\t= 1,\n\t};\n\tint ret;\n\n\t_enter(\"\");\n\n\tret = mapping->a_ops->writepages(mapping, &wbc);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "mapping->host",
            "I_DIRTY_PAGES"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepages",
          "args": [
            "mapping",
            "&wbc"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nint afs_writeback_all(struct afs_vnode *vnode)\n{\n\tstruct address_space *mapping = vnode->vfs_inode.i_mapping;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_to_write\t= LONG_MAX,\n\t\t.range_cyclic\t= 1,\n\t};\n\tint ret;\n\n\t_enter(\"\");\n\n\tret = mapping->a_ops->writepages(mapping, &wbc);\n\t__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "628-654",
    "snippet": "ssize_t afs_file_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(iocb->ki_filp));\n\tssize_t result;\n\tsize_t count = iov_iter_count(from);\n\n\t_enter(\"{%x.%u},{%zu},\",\n\t       vnode->fid.vid, vnode->fid.vnode, count);\n\n\tif (IS_SWAPFILE(&vnode->vfs_inode)) {\n\t\tprintk(KERN_INFO\n\t\t       \"AFS: Attempt to write to active swap file!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tresult = generic_file_write_iter(iocb, from);\n\tif (IS_ERR_VALUE(result)) {\n\t\t_leave(\" = %zd\", result);\n\t\treturn result;\n\t}\n\n\t_leave(\" = %zd\", result);\n\treturn result;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %zd\"",
            "result"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t       \"AFS: Attempt to write to active swap file!\\n\""
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x.%u},{%zu},\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "count"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "file_inode(iocb->ki_filp)"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "iocb->ki_filp"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nssize_t afs_file_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(iocb->ki_filp));\n\tssize_t result;\n\tsize_t count = iov_iter_count(from);\n\n\t_enter(\"{%x.%u},{%zu},\",\n\t       vnode->fid.vid, vnode->fid.vnode, count);\n\n\tif (IS_SWAPFILE(&vnode->vfs_inode)) {\n\t\tprintk(KERN_INFO\n\t\t       \"AFS: Attempt to write to active swap file!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tresult = generic_file_write_iter(iocb, from);\n\tif (IS_ERR_VALUE(result)) {\n\t\t_leave(\" = %zd\", result);\n\t\treturn result;\n\t}\n\n\t_leave(\" = %zd\", result);\n\treturn result;\n}"
  },
  {
    "function_name": "afs_pages_written_back",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "572-623",
    "snippet": "void afs_pages_written_back(struct afs_vnode *vnode, struct afs_call *call)\n{\n\tstruct afs_writeback *wb = call->wb;\n\tstruct pagevec pv;\n\tunsigned count, loop;\n\tpgoff_t first = call->first, last = call->last;\n\tbool free_wb;\n\n\t_enter(\"{%x:%u},{%lx-%lx}\",\n\t       vnode->fid.vid, vnode->fid.vnode, first, last);\n\n\tASSERT(wb != NULL);\n\n\tpagevec_init(&pv, 0);\n\n\tdo {\n\t\t_debug(\"done %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > PAGEVEC_SIZE)\n\t\t\tcount = PAGEVEC_SIZE;\n\t\tpv.nr = find_get_pages_contig(call->mapping, first, count,\n\t\t\t\t\t      pv.pages);\n\t\tASSERTCMP(pv.nr, ==, count);\n\n\t\tspin_lock(&vnode->writeback_lock);\n\t\tfor (loop = 0; loop < count; loop++) {\n\t\t\tstruct page *page = pv.pages[loop];\n\t\t\tend_page_writeback(page);\n\t\t\tif (page_private(page) == (unsigned long) wb) {\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\twb->usage--;\n\t\t\t}\n\t\t}\n\t\tfree_wb = false;\n\t\tif (wb->usage == 0) {\n\t\t\tafs_unlink_writeback(wb);\n\t\t\tfree_wb = true;\n\t\t}\n\t\tspin_unlock(&vnode->writeback_lock);\n\t\tfirst += count;\n\t\tif (free_wb) {\n\t\t\tafs_free_writeback(wb);\n\t\t\twb = NULL;\n\t\t}\n\n\t\t__pagevec_release(&pv);\n\t} while (first <= last);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pagevec_release",
          "args": [
            "&pv"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_free_writeback",
          "args": [
            "wb"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "58-63",
          "snippet": "static void afs_free_writeback(struct afs_writeback *wb)\n{\n\t_enter(\"\");\n\tkey_put(wb->key);\n\tkfree(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic void afs_free_writeback(struct afs_writeback *wb)\n{\n\t_enter(\"\");\n\tkey_put(wb->key);\n\tkfree(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_unlink_writeback",
          "args": [
            "wb"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "afs_unlink_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "36-53",
          "snippet": "static void afs_unlink_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_writeback *front;\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\tlist_del_init(&wb->link);\n\tif (!list_empty(&vnode->writebacks)) {\n\t\t/* if an fsync rises to the front of the queue then wake it\n\t\t * up */\n\t\tfront = list_entry(vnode->writebacks.next,\n\t\t\t\t   struct afs_writeback, link);\n\t\tif (front->state == AFS_WBACK_SYNCING) {\n\t\t\t_debug(\"wake up sync\");\n\t\t\tfront->state = AFS_WBACK_COMPLETE;\n\t\t\twake_up(&front->waitq);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic void afs_unlink_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_writeback *front;\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\tlist_del_init(&wb->link);\n\tif (!list_empty(&vnode->writebacks)) {\n\t\t/* if an fsync rises to the front of the queue then wake it\n\t\t * up */\n\t\tfront = list_entry(vnode->writebacks.next,\n\t\t\t\t   struct afs_writeback, link);\n\t\tif (front->state == AFS_WBACK_SYNCING) {\n\t\t\t_debug(\"wake up sync\");\n\t\t\tfront->state = AFS_WBACK_COMPLETE;\n\t\t\twake_up(&front->waitq);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "pv.nr",
            "==,count"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "call->mapping",
            "first",
            "count",
            "pv.pages"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"done %lx-%lx\"",
            "first",
            "last"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pv",
            "0"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "wb != NULL"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%lx-%lx}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "first",
            "last"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nvoid afs_pages_written_back(struct afs_vnode *vnode, struct afs_call *call)\n{\n\tstruct afs_writeback *wb = call->wb;\n\tstruct pagevec pv;\n\tunsigned count, loop;\n\tpgoff_t first = call->first, last = call->last;\n\tbool free_wb;\n\n\t_enter(\"{%x:%u},{%lx-%lx}\",\n\t       vnode->fid.vid, vnode->fid.vnode, first, last);\n\n\tASSERT(wb != NULL);\n\n\tpagevec_init(&pv, 0);\n\n\tdo {\n\t\t_debug(\"done %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > PAGEVEC_SIZE)\n\t\t\tcount = PAGEVEC_SIZE;\n\t\tpv.nr = find_get_pages_contig(call->mapping, first, count,\n\t\t\t\t\t      pv.pages);\n\t\tASSERTCMP(pv.nr, ==, count);\n\n\t\tspin_lock(&vnode->writeback_lock);\n\t\tfor (loop = 0; loop < count; loop++) {\n\t\t\tstruct page *page = pv.pages[loop];\n\t\t\tend_page_writeback(page);\n\t\t\tif (page_private(page) == (unsigned long) wb) {\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\twb->usage--;\n\t\t\t}\n\t\t}\n\t\tfree_wb = false;\n\t\tif (wb->usage == 0) {\n\t\t\tafs_unlink_writeback(wb);\n\t\t\tfree_wb = true;\n\t\t}\n\t\tspin_unlock(&vnode->writeback_lock);\n\t\tfirst += count;\n\t\tif (free_wb) {\n\t\t\tafs_free_writeback(wb);\n\t\t\twb = NULL;\n\t\t}\n\n\t\t__pagevec_release(&pv);\n\t} while (first <= last);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "538-567",
    "snippet": "int afs_writepages(struct address_space *mapping,\n\t\t   struct writeback_control *wbc)\n{\n\tpgoff_t start, end, next;\n\tint ret;\n\n\t_enter(\"\");\n\n\tif (wbc->range_cyclic) {\n\t\tstart = mapping->writeback_index;\n\t\tend = -1;\n\t\tret = afs_writepages_region(mapping, wbc, start, end, &next);\n\t\tif (start > 0 && wbc->nr_to_write > 0 && ret == 0)\n\t\t\tret = afs_writepages_region(mapping, wbc, 0, start,\n\t\t\t\t\t\t    &next);\n\t\tmapping->writeback_index = next;\n\t} else if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX) {\n\t\tend = (pgoff_t)(LLONG_MAX >> PAGE_CACHE_SHIFT);\n\t\tret = afs_writepages_region(mapping, wbc, 0, end, &next);\n\t\tif (wbc->nr_to_write > 0)\n\t\t\tmapping->writeback_index = next;\n\t} else {\n\t\tstart = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tret = afs_writepages_region(mapping, wbc, start, end, &next);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_writepages_region",
          "args": [
            "mapping",
            "wbc",
            "start",
            "end",
            "&next"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "afs_writepages_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "464-533",
          "snippet": "static int afs_writepages_region(struct address_space *mapping,\n\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t pgoff_t index, pgoff_t end, pgoff_t *_next)\n{\n\tstruct afs_writeback *wb;\n\tstruct page *page;\n\tint ret, n;\n\n\t_enter(\",,%lx,%lx,\", index, end);\n\n\tdo {\n\t\tn = find_get_pages_tag(mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t       1, &page);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\t_debug(\"wback %lx\", page->index);\n\n\t\tif (page->index > end) {\n\t\t\t*_next = index;\n\t\t\tpage_cache_release(page);\n\t\t\t_leave(\" = 0 [%lx]\", *_next);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* at this point we hold neither mapping->tree_lock nor lock on\n\t\t * the page itself: the page may be truncated or invalidated\n\t\t * (changing page->mapping to NULL), or even swizzled back from\n\t\t * swapper_space to tmpfs file mapping\n\t\t */\n\t\tlock_page(page);\n\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\twait_on_page_writeback(page);\n\n\t\tif (PageWriteback(page) || !PageDirty(page)) {\n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\twb = (struct afs_writeback *) page_private(page);\n\t\tASSERT(wb != NULL);\n\n\t\tspin_lock(&wb->vnode->writeback_lock);\n\t\twb->state = AFS_WBACK_WRITING;\n\t\tspin_unlock(&wb->vnode->writeback_lock);\n\n\t\tret = afs_write_back_from_locked_page(wb, page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret < 0) {\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\twbc->nr_to_write -= ret;\n\n\t\tcond_resched();\n\t} while (index < end && wbc->nr_to_write > 0);\n\n\t*_next = index;\n\t_leave(\" = 0 [%lx]\", *_next);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nstatic int afs_writepages_region(struct address_space *mapping,\n\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t pgoff_t index, pgoff_t end, pgoff_t *_next)\n{\n\tstruct afs_writeback *wb;\n\tstruct page *page;\n\tint ret, n;\n\n\t_enter(\",,%lx,%lx,\", index, end);\n\n\tdo {\n\t\tn = find_get_pages_tag(mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t       1, &page);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\t_debug(\"wback %lx\", page->index);\n\n\t\tif (page->index > end) {\n\t\t\t*_next = index;\n\t\t\tpage_cache_release(page);\n\t\t\t_leave(\" = 0 [%lx]\", *_next);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* at this point we hold neither mapping->tree_lock nor lock on\n\t\t * the page itself: the page may be truncated or invalidated\n\t\t * (changing page->mapping to NULL), or even swizzled back from\n\t\t * swapper_space to tmpfs file mapping\n\t\t */\n\t\tlock_page(page);\n\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\twait_on_page_writeback(page);\n\n\t\tif (PageWriteback(page) || !PageDirty(page)) {\n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\twb = (struct afs_writeback *) page_private(page);\n\t\tASSERT(wb != NULL);\n\n\t\tspin_lock(&wb->vnode->writeback_lock);\n\t\twb->state = AFS_WBACK_WRITING;\n\t\tspin_unlock(&wb->vnode->writeback_lock);\n\n\t\tret = afs_write_back_from_locked_page(wb, page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret < 0) {\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\twbc->nr_to_write -= ret;\n\n\t\tcond_resched();\n\t} while (index < end && wbc->nr_to_write > 0);\n\n\t*_next = index;\n\t_leave(\" = 0 [%lx]\", *_next);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "LLONG_MAX >> PAGE_CACHE_SHIFT"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nint afs_writepages(struct address_space *mapping,\n\t\t   struct writeback_control *wbc)\n{\n\tpgoff_t start, end, next;\n\tint ret;\n\n\t_enter(\"\");\n\n\tif (wbc->range_cyclic) {\n\t\tstart = mapping->writeback_index;\n\t\tend = -1;\n\t\tret = afs_writepages_region(mapping, wbc, start, end, &next);\n\t\tif (start > 0 && wbc->nr_to_write > 0 && ret == 0)\n\t\t\tret = afs_writepages_region(mapping, wbc, 0, start,\n\t\t\t\t\t\t    &next);\n\t\tmapping->writeback_index = next;\n\t} else if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX) {\n\t\tend = (pgoff_t)(LLONG_MAX >> PAGE_CACHE_SHIFT);\n\t\tret = afs_writepages_region(mapping, wbc, 0, end, &next);\n\t\tif (wbc->nr_to_write > 0)\n\t\t\tmapping->writeback_index = next;\n\t} else {\n\t\tstart = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tret = afs_writepages_region(mapping, wbc, start, end, &next);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_writepages_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "464-533",
    "snippet": "static int afs_writepages_region(struct address_space *mapping,\n\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t pgoff_t index, pgoff_t end, pgoff_t *_next)\n{\n\tstruct afs_writeback *wb;\n\tstruct page *page;\n\tint ret, n;\n\n\t_enter(\",,%lx,%lx,\", index, end);\n\n\tdo {\n\t\tn = find_get_pages_tag(mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t       1, &page);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\t_debug(\"wback %lx\", page->index);\n\n\t\tif (page->index > end) {\n\t\t\t*_next = index;\n\t\t\tpage_cache_release(page);\n\t\t\t_leave(\" = 0 [%lx]\", *_next);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* at this point we hold neither mapping->tree_lock nor lock on\n\t\t * the page itself: the page may be truncated or invalidated\n\t\t * (changing page->mapping to NULL), or even swizzled back from\n\t\t * swapper_space to tmpfs file mapping\n\t\t */\n\t\tlock_page(page);\n\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\twait_on_page_writeback(page);\n\n\t\tif (PageWriteback(page) || !PageDirty(page)) {\n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\twb = (struct afs_writeback *) page_private(page);\n\t\tASSERT(wb != NULL);\n\n\t\tspin_lock(&wb->vnode->writeback_lock);\n\t\twb->state = AFS_WBACK_WRITING;\n\t\tspin_unlock(&wb->vnode->writeback_lock);\n\n\t\tret = afs_write_back_from_locked_page(wb, page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret < 0) {\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\twbc->nr_to_write -= ret;\n\n\t\tcond_resched();\n\t} while (index < end && wbc->nr_to_write > 0);\n\n\t*_next = index;\n\t_leave(\" = 0 [%lx]\", *_next);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [%lx]\"",
            "*_next"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_write_back_from_locked_page",
          "args": [
            "wb",
            "page"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "afs_write_back_from_locked_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "316-432",
          "snippet": "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *primary_page)\n{\n\tstruct page *pages[8], *page;\n\tunsigned long count;\n\tunsigned n, offset, to;\n\tpgoff_t start, first, last;\n\tint loop, ret;\n\n\t_enter(\",%lx\", primary_page->index);\n\n\tcount = 1;\n\tif (!clear_page_dirty_for_io(primary_page))\n\t\tBUG();\n\tif (test_set_page_writeback(primary_page))\n\t\tBUG();\n\n\t/* find all consecutive lockable dirty pages, stopping when we find a\n\t * page that is not immediately lockable, is not dirty or is missing,\n\t * or we reach the end of the range */\n\tstart = primary_page->index;\n\tif (start >= wb->last)\n\t\tgoto no_more;\n\tstart++;\n\tdo {\n\t\t_debug(\"more %lx [%lx]\", start, count);\n\t\tn = wb->last - start + 1;\n\t\tif (n > ARRAY_SIZE(pages))\n\t\t\tn = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  start, n, pages);\n\t\t_debug(\"fgpc %u\", n);\n\t\tif (n == 0)\n\t\t\tgoto no_more;\n\t\tif (pages[0]->index != start) {\n\t\t\tdo {\n\t\t\t\tput_page(pages[--n]);\n\t\t\t} while (n > 0);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tfor (loop = 0; loop < n; loop++) {\n\t\t\tpage = pages[loop];\n\t\t\tif (page->index > wb->last)\n\t\t\t\tbreak;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tbreak;\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    page_private(page) != (unsigned long) wb) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tBUG();\n\t\t\tif (test_set_page_writeback(page))\n\t\t\t\tBUG();\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tcount += loop;\n\t\tif (loop < n) {\n\t\t\tfor (; loop < n; loop++)\n\t\t\t\tput_page(pages[loop]);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tstart += loop;\n\t} while (start <= wb->last && count < 65536);\n\nno_more:\n\t/* we now have a contiguous set of dirty pages, each with writeback set\n\t * and the dirty mark cleared; the first page is locked and must remain\n\t * so, all the rest are unlocked */\n\tfirst = primary_page->index;\n\tlast = first + count - 1;\n\n\toffset = (first == wb->first) ? wb->offset_first : 0;\n\tto = (last == wb->last) ? wb->to_last : PAGE_SIZE;\n\n\t_debug(\"write back %lx[%u..] to %lx[..%u]\", first, offset, last, to);\n\n\tret = afs_vnode_store_data(wb, first, last, offset, to);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\t\tset_bit(AS_ENOSPC,\n\t\t\t\t&wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -EREMOTEIO:\n\t\tcase -EFBIG:\n\t\tcase -ENOENT:\n\t\tcase -ENOMEDIUM:\n\t\tcase -ENXIO:\n\t\t\tafs_kill_pages(wb->vnode, true, first, last);\n\t\t\tset_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\tcase -EPERM:\n\t\tcase -ENOKEY:\n\t\tcase -EKEYEXPIRED:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYREVOKED:\n\t\t\tafs_kill_pages(wb->vnode, false, first, last);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = count;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *primary_page)\n{\n\tstruct page *pages[8], *page;\n\tunsigned long count;\n\tunsigned n, offset, to;\n\tpgoff_t start, first, last;\n\tint loop, ret;\n\n\t_enter(\",%lx\", primary_page->index);\n\n\tcount = 1;\n\tif (!clear_page_dirty_for_io(primary_page))\n\t\tBUG();\n\tif (test_set_page_writeback(primary_page))\n\t\tBUG();\n\n\t/* find all consecutive lockable dirty pages, stopping when we find a\n\t * page that is not immediately lockable, is not dirty or is missing,\n\t * or we reach the end of the range */\n\tstart = primary_page->index;\n\tif (start >= wb->last)\n\t\tgoto no_more;\n\tstart++;\n\tdo {\n\t\t_debug(\"more %lx [%lx]\", start, count);\n\t\tn = wb->last - start + 1;\n\t\tif (n > ARRAY_SIZE(pages))\n\t\t\tn = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  start, n, pages);\n\t\t_debug(\"fgpc %u\", n);\n\t\tif (n == 0)\n\t\t\tgoto no_more;\n\t\tif (pages[0]->index != start) {\n\t\t\tdo {\n\t\t\t\tput_page(pages[--n]);\n\t\t\t} while (n > 0);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tfor (loop = 0; loop < n; loop++) {\n\t\t\tpage = pages[loop];\n\t\t\tif (page->index > wb->last)\n\t\t\t\tbreak;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tbreak;\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    page_private(page) != (unsigned long) wb) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tBUG();\n\t\t\tif (test_set_page_writeback(page))\n\t\t\t\tBUG();\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tcount += loop;\n\t\tif (loop < n) {\n\t\t\tfor (; loop < n; loop++)\n\t\t\t\tput_page(pages[loop]);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tstart += loop;\n\t} while (start <= wb->last && count < 65536);\n\nno_more:\n\t/* we now have a contiguous set of dirty pages, each with writeback set\n\t * and the dirty mark cleared; the first page is locked and must remain\n\t * so, all the rest are unlocked */\n\tfirst = primary_page->index;\n\tlast = first + count - 1;\n\n\toffset = (first == wb->first) ? wb->offset_first : 0;\n\tto = (last == wb->last) ? wb->to_last : PAGE_SIZE;\n\n\t_debug(\"write back %lx[%u..] to %lx[..%u]\", first, offset, last, to);\n\n\tret = afs_vnode_store_data(wb, first, last, offset, to);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\t\tset_bit(AS_ENOSPC,\n\t\t\t\t&wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -EREMOTEIO:\n\t\tcase -EFBIG:\n\t\tcase -ENOENT:\n\t\tcase -ENOMEDIUM:\n\t\tcase -ENXIO:\n\t\t\tafs_kill_pages(wb->vnode, true, first, last);\n\t\t\tset_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\tcase -EPERM:\n\t\tcase -ENOKEY:\n\t\tcase -EKEYEXPIRED:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYREVOKED:\n\t\t\tafs_kill_pages(wb->vnode, false, first, last);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = count;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wb->vnode->writeback_lock"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->vnode->writeback_lock"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "wb != NULL"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"wback %lx\"",
            "page->index"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_pages_tag",
          "args": [
            "mapping",
            "&index",
            "PAGECACHE_TAG_DIRTY",
            "1",
            "&page"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",,%lx,%lx,\"",
            "index",
            "end"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nstatic int afs_writepages_region(struct address_space *mapping,\n\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t pgoff_t index, pgoff_t end, pgoff_t *_next)\n{\n\tstruct afs_writeback *wb;\n\tstruct page *page;\n\tint ret, n;\n\n\t_enter(\",,%lx,%lx,\", index, end);\n\n\tdo {\n\t\tn = find_get_pages_tag(mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t       1, &page);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\t_debug(\"wback %lx\", page->index);\n\n\t\tif (page->index > end) {\n\t\t\t*_next = index;\n\t\t\tpage_cache_release(page);\n\t\t\t_leave(\" = 0 [%lx]\", *_next);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* at this point we hold neither mapping->tree_lock nor lock on\n\t\t * the page itself: the page may be truncated or invalidated\n\t\t * (changing page->mapping to NULL), or even swizzled back from\n\t\t * swapper_space to tmpfs file mapping\n\t\t */\n\t\tlock_page(page);\n\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE)\n\t\t\twait_on_page_writeback(page);\n\n\t\tif (PageWriteback(page) || !PageDirty(page)) {\n\t\t\tunlock_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\twb = (struct afs_writeback *) page_private(page);\n\t\tASSERT(wb != NULL);\n\n\t\tspin_lock(&wb->vnode->writeback_lock);\n\t\twb->state = AFS_WBACK_WRITING;\n\t\tspin_unlock(&wb->vnode->writeback_lock);\n\n\t\tret = afs_write_back_from_locked_page(wb, page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret < 0) {\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\twbc->nr_to_write -= ret;\n\n\t\tcond_resched();\n\t} while (index < end && wbc->nr_to_write > 0);\n\n\t*_next = index;\n\t_leave(\" = 0 [%lx]\", *_next);\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "438-459",
    "snippet": "int afs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct afs_writeback *wb;\n\tint ret;\n\n\t_enter(\"{%lx},\", page->index);\n\n\twb = (struct afs_writeback *) page_private(page);\n\tASSERT(wb != NULL);\n\n\tret = afs_write_back_from_locked_page(wb, page);\n\tunlock_page(page);\n\tif (ret < 0) {\n\t\t_leave(\" = %d\", ret);\n\t\treturn 0;\n\t}\n\n\twbc->nr_to_write -= ret;\n\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_write_back_from_locked_page",
          "args": [
            "wb",
            "page"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "afs_write_back_from_locked_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "316-432",
          "snippet": "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *primary_page)\n{\n\tstruct page *pages[8], *page;\n\tunsigned long count;\n\tunsigned n, offset, to;\n\tpgoff_t start, first, last;\n\tint loop, ret;\n\n\t_enter(\",%lx\", primary_page->index);\n\n\tcount = 1;\n\tif (!clear_page_dirty_for_io(primary_page))\n\t\tBUG();\n\tif (test_set_page_writeback(primary_page))\n\t\tBUG();\n\n\t/* find all consecutive lockable dirty pages, stopping when we find a\n\t * page that is not immediately lockable, is not dirty or is missing,\n\t * or we reach the end of the range */\n\tstart = primary_page->index;\n\tif (start >= wb->last)\n\t\tgoto no_more;\n\tstart++;\n\tdo {\n\t\t_debug(\"more %lx [%lx]\", start, count);\n\t\tn = wb->last - start + 1;\n\t\tif (n > ARRAY_SIZE(pages))\n\t\t\tn = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  start, n, pages);\n\t\t_debug(\"fgpc %u\", n);\n\t\tif (n == 0)\n\t\t\tgoto no_more;\n\t\tif (pages[0]->index != start) {\n\t\t\tdo {\n\t\t\t\tput_page(pages[--n]);\n\t\t\t} while (n > 0);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tfor (loop = 0; loop < n; loop++) {\n\t\t\tpage = pages[loop];\n\t\t\tif (page->index > wb->last)\n\t\t\t\tbreak;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tbreak;\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    page_private(page) != (unsigned long) wb) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tBUG();\n\t\t\tif (test_set_page_writeback(page))\n\t\t\t\tBUG();\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tcount += loop;\n\t\tif (loop < n) {\n\t\t\tfor (; loop < n; loop++)\n\t\t\t\tput_page(pages[loop]);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tstart += loop;\n\t} while (start <= wb->last && count < 65536);\n\nno_more:\n\t/* we now have a contiguous set of dirty pages, each with writeback set\n\t * and the dirty mark cleared; the first page is locked and must remain\n\t * so, all the rest are unlocked */\n\tfirst = primary_page->index;\n\tlast = first + count - 1;\n\n\toffset = (first == wb->first) ? wb->offset_first : 0;\n\tto = (last == wb->last) ? wb->to_last : PAGE_SIZE;\n\n\t_debug(\"write back %lx[%u..] to %lx[..%u]\", first, offset, last, to);\n\n\tret = afs_vnode_store_data(wb, first, last, offset, to);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\t\tset_bit(AS_ENOSPC,\n\t\t\t\t&wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -EREMOTEIO:\n\t\tcase -EFBIG:\n\t\tcase -ENOENT:\n\t\tcase -ENOMEDIUM:\n\t\tcase -ENXIO:\n\t\t\tafs_kill_pages(wb->vnode, true, first, last);\n\t\t\tset_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\tcase -EPERM:\n\t\tcase -ENOKEY:\n\t\tcase -EKEYEXPIRED:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYREVOKED:\n\t\t\tafs_kill_pages(wb->vnode, false, first, last);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = count;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *primary_page)\n{\n\tstruct page *pages[8], *page;\n\tunsigned long count;\n\tunsigned n, offset, to;\n\tpgoff_t start, first, last;\n\tint loop, ret;\n\n\t_enter(\",%lx\", primary_page->index);\n\n\tcount = 1;\n\tif (!clear_page_dirty_for_io(primary_page))\n\t\tBUG();\n\tif (test_set_page_writeback(primary_page))\n\t\tBUG();\n\n\t/* find all consecutive lockable dirty pages, stopping when we find a\n\t * page that is not immediately lockable, is not dirty or is missing,\n\t * or we reach the end of the range */\n\tstart = primary_page->index;\n\tif (start >= wb->last)\n\t\tgoto no_more;\n\tstart++;\n\tdo {\n\t\t_debug(\"more %lx [%lx]\", start, count);\n\t\tn = wb->last - start + 1;\n\t\tif (n > ARRAY_SIZE(pages))\n\t\t\tn = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  start, n, pages);\n\t\t_debug(\"fgpc %u\", n);\n\t\tif (n == 0)\n\t\t\tgoto no_more;\n\t\tif (pages[0]->index != start) {\n\t\t\tdo {\n\t\t\t\tput_page(pages[--n]);\n\t\t\t} while (n > 0);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tfor (loop = 0; loop < n; loop++) {\n\t\t\tpage = pages[loop];\n\t\t\tif (page->index > wb->last)\n\t\t\t\tbreak;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tbreak;\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    page_private(page) != (unsigned long) wb) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tBUG();\n\t\t\tif (test_set_page_writeback(page))\n\t\t\t\tBUG();\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tcount += loop;\n\t\tif (loop < n) {\n\t\t\tfor (; loop < n; loop++)\n\t\t\t\tput_page(pages[loop]);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tstart += loop;\n\t} while (start <= wb->last && count < 65536);\n\nno_more:\n\t/* we now have a contiguous set of dirty pages, each with writeback set\n\t * and the dirty mark cleared; the first page is locked and must remain\n\t * so, all the rest are unlocked */\n\tfirst = primary_page->index;\n\tlast = first + count - 1;\n\n\toffset = (first == wb->first) ? wb->offset_first : 0;\n\tto = (last == wb->last) ? wb->to_last : PAGE_SIZE;\n\n\t_debug(\"write back %lx[%u..] to %lx[..%u]\", first, offset, last, to);\n\n\tret = afs_vnode_store_data(wb, first, last, offset, to);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\t\tset_bit(AS_ENOSPC,\n\t\t\t\t&wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -EREMOTEIO:\n\t\tcase -EFBIG:\n\t\tcase -ENOENT:\n\t\tcase -ENOMEDIUM:\n\t\tcase -ENXIO:\n\t\t\tafs_kill_pages(wb->vnode, true, first, last);\n\t\t\tset_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\tcase -EPERM:\n\t\tcase -ENOKEY:\n\t\tcase -EKEYEXPIRED:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYREVOKED:\n\t\t\tafs_kill_pages(wb->vnode, false, first, last);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = count;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "wb != NULL"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%lx},\"",
            "page->index"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nint afs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct afs_writeback *wb;\n\tint ret;\n\n\t_enter(\"{%lx},\", page->index);\n\n\twb = (struct afs_writeback *) page_private(page);\n\tASSERT(wb != NULL);\n\n\tret = afs_write_back_from_locked_page(wb, page);\n\tunlock_page(page);\n\tif (ret < 0) {\n\t\t_leave(\" = %d\", ret);\n\t\treturn 0;\n\t}\n\n\twbc->nr_to_write -= ret;\n\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_write_back_from_locked_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "316-432",
    "snippet": "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *primary_page)\n{\n\tstruct page *pages[8], *page;\n\tunsigned long count;\n\tunsigned n, offset, to;\n\tpgoff_t start, first, last;\n\tint loop, ret;\n\n\t_enter(\",%lx\", primary_page->index);\n\n\tcount = 1;\n\tif (!clear_page_dirty_for_io(primary_page))\n\t\tBUG();\n\tif (test_set_page_writeback(primary_page))\n\t\tBUG();\n\n\t/* find all consecutive lockable dirty pages, stopping when we find a\n\t * page that is not immediately lockable, is not dirty or is missing,\n\t * or we reach the end of the range */\n\tstart = primary_page->index;\n\tif (start >= wb->last)\n\t\tgoto no_more;\n\tstart++;\n\tdo {\n\t\t_debug(\"more %lx [%lx]\", start, count);\n\t\tn = wb->last - start + 1;\n\t\tif (n > ARRAY_SIZE(pages))\n\t\t\tn = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  start, n, pages);\n\t\t_debug(\"fgpc %u\", n);\n\t\tif (n == 0)\n\t\t\tgoto no_more;\n\t\tif (pages[0]->index != start) {\n\t\t\tdo {\n\t\t\t\tput_page(pages[--n]);\n\t\t\t} while (n > 0);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tfor (loop = 0; loop < n; loop++) {\n\t\t\tpage = pages[loop];\n\t\t\tif (page->index > wb->last)\n\t\t\t\tbreak;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tbreak;\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    page_private(page) != (unsigned long) wb) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tBUG();\n\t\t\tif (test_set_page_writeback(page))\n\t\t\t\tBUG();\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tcount += loop;\n\t\tif (loop < n) {\n\t\t\tfor (; loop < n; loop++)\n\t\t\t\tput_page(pages[loop]);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tstart += loop;\n\t} while (start <= wb->last && count < 65536);\n\nno_more:\n\t/* we now have a contiguous set of dirty pages, each with writeback set\n\t * and the dirty mark cleared; the first page is locked and must remain\n\t * so, all the rest are unlocked */\n\tfirst = primary_page->index;\n\tlast = first + count - 1;\n\n\toffset = (first == wb->first) ? wb->offset_first : 0;\n\tto = (last == wb->last) ? wb->to_last : PAGE_SIZE;\n\n\t_debug(\"write back %lx[%u..] to %lx[..%u]\", first, offset, last, to);\n\n\tret = afs_vnode_store_data(wb, first, last, offset, to);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\t\tset_bit(AS_ENOSPC,\n\t\t\t\t&wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -EREMOTEIO:\n\t\tcase -EFBIG:\n\t\tcase -ENOENT:\n\t\tcase -ENOMEDIUM:\n\t\tcase -ENXIO:\n\t\t\tafs_kill_pages(wb->vnode, true, first, last);\n\t\t\tset_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\tcase -EPERM:\n\t\tcase -ENOKEY:\n\t\tcase -EKEYEXPIRED:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYREVOKED:\n\t\t\tafs_kill_pages(wb->vnode, false, first, last);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = count;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_kill_pages",
          "args": [
            "wb->vnode",
            "false",
            "first",
            "last"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "afs_kill_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "278-310",
          "snippet": "static void afs_kill_pages(struct afs_vnode *vnode, bool error,\n\t\t\t   pgoff_t first, pgoff_t last)\n{\n\tstruct pagevec pv;\n\tunsigned count, loop;\n\n\t_enter(\"{%x:%u},%lx-%lx\",\n\t       vnode->fid.vid, vnode->fid.vnode, first, last);\n\n\tpagevec_init(&pv, 0);\n\n\tdo {\n\t\t_debug(\"kill %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > PAGEVEC_SIZE)\n\t\t\tcount = PAGEVEC_SIZE;\n\t\tpv.nr = find_get_pages_contig(vnode->vfs_inode.i_mapping,\n\t\t\t\t\t      first, count, pv.pages);\n\t\tASSERTCMP(pv.nr, ==, count);\n\n\t\tfor (loop = 0; loop < count; loop++) {\n\t\t\tClearPageUptodate(pv.pages[loop]);\n\t\t\tif (error)\n\t\t\t\tSetPageError(pv.pages[loop]);\n\t\t\tend_page_writeback(pv.pages[loop]);\n\t\t}\n\n\t\t__pagevec_release(&pv);\n\t} while (first < last);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic void afs_kill_pages(struct afs_vnode *vnode, bool error,\n\t\t\t   pgoff_t first, pgoff_t last)\n{\n\tstruct pagevec pv;\n\tunsigned count, loop;\n\n\t_enter(\"{%x:%u},%lx-%lx\",\n\t       vnode->fid.vid, vnode->fid.vnode, first, last);\n\n\tpagevec_init(&pv, 0);\n\n\tdo {\n\t\t_debug(\"kill %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > PAGEVEC_SIZE)\n\t\t\tcount = PAGEVEC_SIZE;\n\t\tpv.nr = find_get_pages_contig(vnode->vfs_inode.i_mapping,\n\t\t\t\t\t      first, count, pv.pages);\n\t\tASSERTCMP(pv.nr, ==, count);\n\n\t\tfor (loop = 0; loop < count; loop++) {\n\t\t\tClearPageUptodate(pv.pages[loop]);\n\t\t\tif (error)\n\t\t\t\tSetPageError(pv.pages[loop]);\n\t\t\tend_page_writeback(pv.pages[loop]);\n\t\t}\n\n\t\t__pagevec_release(&pv);\n\t} while (first < last);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AS_EIO",
            "&wb->vnode->vfs_inode.i_mapping->flags"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_store_data",
          "args": [
            "wb",
            "first",
            "last",
            "offset",
            "to"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_store_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "769-819",
          "snippet": "int afs_vnode_store_data(struct afs_writeback *wb, pgoff_t first, pgoff_t last,\n\t\t\t unsigned offset, unsigned to)\n{\n\tstruct afs_server *server;\n\tstruct afs_vnode *vnode = wb->vnode;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%lx,%lx,%x,%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(wb->key),\n\t       first, last, offset, to);\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_store_data(server, wb, first, last, offset, to,\n\t\t\t\t\t&afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_store_data(struct afs_writeback *wb, pgoff_t first, pgoff_t last,\n\t\t\t unsigned offset, unsigned to)\n{\n\tstruct afs_server *server;\n\tstruct afs_vnode *vnode = wb->vnode;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%lx,%lx,%x,%x\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(wb->key),\n\t       first, last, offset, to);\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_store_data(server, wb, first, last, offset, to,\n\t\t\t\t\t&afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"write back %lx[%u..] to %lx[..%u]\"",
            "first",
            "offset",
            "last",
            "to"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[loop]"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_page_writeback",
          "args": [
            "page"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"fgpc %u\"",
            "n"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "wb->vnode->vfs_inode.i_mapping",
            "start",
            "n",
            "pages"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_page_writeback",
          "args": [
            "primary_page"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "primary_page"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%lx\"",
            "primary_page->index"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *primary_page)\n{\n\tstruct page *pages[8], *page;\n\tunsigned long count;\n\tunsigned n, offset, to;\n\tpgoff_t start, first, last;\n\tint loop, ret;\n\n\t_enter(\",%lx\", primary_page->index);\n\n\tcount = 1;\n\tif (!clear_page_dirty_for_io(primary_page))\n\t\tBUG();\n\tif (test_set_page_writeback(primary_page))\n\t\tBUG();\n\n\t/* find all consecutive lockable dirty pages, stopping when we find a\n\t * page that is not immediately lockable, is not dirty or is missing,\n\t * or we reach the end of the range */\n\tstart = primary_page->index;\n\tif (start >= wb->last)\n\t\tgoto no_more;\n\tstart++;\n\tdo {\n\t\t_debug(\"more %lx [%lx]\", start, count);\n\t\tn = wb->last - start + 1;\n\t\tif (n > ARRAY_SIZE(pages))\n\t\t\tn = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  start, n, pages);\n\t\t_debug(\"fgpc %u\", n);\n\t\tif (n == 0)\n\t\t\tgoto no_more;\n\t\tif (pages[0]->index != start) {\n\t\t\tdo {\n\t\t\t\tput_page(pages[--n]);\n\t\t\t} while (n > 0);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tfor (loop = 0; loop < n; loop++) {\n\t\t\tpage = pages[loop];\n\t\t\tif (page->index > wb->last)\n\t\t\t\tbreak;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tbreak;\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    page_private(page) != (unsigned long) wb) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tBUG();\n\t\t\tif (test_set_page_writeback(page))\n\t\t\t\tBUG();\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tcount += loop;\n\t\tif (loop < n) {\n\t\t\tfor (; loop < n; loop++)\n\t\t\t\tput_page(pages[loop]);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tstart += loop;\n\t} while (start <= wb->last && count < 65536);\n\nno_more:\n\t/* we now have a contiguous set of dirty pages, each with writeback set\n\t * and the dirty mark cleared; the first page is locked and must remain\n\t * so, all the rest are unlocked */\n\tfirst = primary_page->index;\n\tlast = first + count - 1;\n\n\toffset = (first == wb->first) ? wb->offset_first : 0;\n\tto = (last == wb->last) ? wb->to_last : PAGE_SIZE;\n\n\t_debug(\"write back %lx[%u..] to %lx[..%u]\", first, offset, last, to);\n\n\tret = afs_vnode_store_data(wb, first, last, offset, to);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\t\tset_bit(AS_ENOSPC,\n\t\t\t\t&wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -EREMOTEIO:\n\t\tcase -EFBIG:\n\t\tcase -ENOENT:\n\t\tcase -ENOMEDIUM:\n\t\tcase -ENXIO:\n\t\t\tafs_kill_pages(wb->vnode, true, first, last);\n\t\t\tset_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\tcase -EPERM:\n\t\tcase -ENOKEY:\n\t\tcase -EKEYEXPIRED:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYREVOKED:\n\t\t\tafs_kill_pages(wb->vnode, false, first, last);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = count;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_kill_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "278-310",
    "snippet": "static void afs_kill_pages(struct afs_vnode *vnode, bool error,\n\t\t\t   pgoff_t first, pgoff_t last)\n{\n\tstruct pagevec pv;\n\tunsigned count, loop;\n\n\t_enter(\"{%x:%u},%lx-%lx\",\n\t       vnode->fid.vid, vnode->fid.vnode, first, last);\n\n\tpagevec_init(&pv, 0);\n\n\tdo {\n\t\t_debug(\"kill %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > PAGEVEC_SIZE)\n\t\t\tcount = PAGEVEC_SIZE;\n\t\tpv.nr = find_get_pages_contig(vnode->vfs_inode.i_mapping,\n\t\t\t\t\t      first, count, pv.pages);\n\t\tASSERTCMP(pv.nr, ==, count);\n\n\t\tfor (loop = 0; loop < count; loop++) {\n\t\t\tClearPageUptodate(pv.pages[loop]);\n\t\t\tif (error)\n\t\t\t\tSetPageError(pv.pages[loop]);\n\t\t\tend_page_writeback(pv.pages[loop]);\n\t\t}\n\n\t\t__pagevec_release(&pv);\n\t} while (first < last);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pagevec_release",
          "args": [
            "&pv"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "pv.pages[loop]"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "pv.pages[loop]"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "pv.pages[loop]"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "pv.nr",
            "==,count"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "vnode->vfs_inode.i_mapping",
            "first",
            "count",
            "pv.pages"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"kill %lx-%lx\"",
            "first",
            "last"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pv",
            "0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%lx-%lx\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "first",
            "last"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic void afs_kill_pages(struct afs_vnode *vnode, bool error,\n\t\t\t   pgoff_t first, pgoff_t last)\n{\n\tstruct pagevec pv;\n\tunsigned count, loop;\n\n\t_enter(\"{%x:%u},%lx-%lx\",\n\t       vnode->fid.vid, vnode->fid.vnode, first, last);\n\n\tpagevec_init(&pv, 0);\n\n\tdo {\n\t\t_debug(\"kill %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > PAGEVEC_SIZE)\n\t\t\tcount = PAGEVEC_SIZE;\n\t\tpv.nr = find_get_pages_contig(vnode->vfs_inode.i_mapping,\n\t\t\t\t\t      first, count, pv.pages);\n\t\tASSERTCMP(pv.nr, ==, count);\n\n\t\tfor (loop = 0; loop < count; loop++) {\n\t\t\tClearPageUptodate(pv.pages[loop]);\n\t\t\tif (error)\n\t\t\t\tSetPageError(pv.pages[loop]);\n\t\t\tend_page_writeback(pv.pages[loop]);\n\t\t}\n\n\t\t__pagevec_release(&pv);\n\t} while (first < last);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "245-273",
    "snippet": "int afs_write_end(struct file *file, struct address_space *mapping,\n\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t  struct page *page, void *fsdata)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tloff_t i_size, maybe_i_size;\n\n\t_enter(\"{%x:%u},{%lx}\",\n\t       vnode->fid.vid, vnode->fid.vnode, page->index);\n\n\tmaybe_i_size = pos + copied;\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (maybe_i_size > i_size) {\n\t\tspin_lock(&vnode->writeback_lock);\n\t\ti_size = i_size_read(&vnode->vfs_inode);\n\t\tif (maybe_i_size > i_size)\n\t\t\ti_size_write(&vnode->vfs_inode, maybe_i_size);\n\t\tspin_unlock(&vnode->writeback_lock);\n\t}\n\n\tset_page_dirty(page);\n\tif (PageDirty(page))\n\t\t_debug(\"dirtied\");\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"dirtied\""
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "afs_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "26-30",
          "snippet": "int afs_set_page_dirty(struct page *page)\n{\n\t_enter(\"\");\n\treturn __set_page_dirty_nobuffers(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nint afs_set_page_dirty(struct page *page)\n{\n\t_enter(\"\");\n\treturn __set_page_dirty_nobuffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "&vnode->vfs_inode",
            "maybe_i_size"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%lx}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "page->index"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nint afs_write_end(struct file *file, struct address_space *mapping,\n\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t  struct page *page, void *fsdata)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tloff_t i_size, maybe_i_size;\n\n\t_enter(\"{%x:%u},{%lx}\",\n\t       vnode->fid.vid, vnode->fid.vnode, page->index);\n\n\tmaybe_i_size = pos + copied;\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (maybe_i_size > i_size) {\n\t\tspin_lock(&vnode->writeback_lock);\n\t\ti_size = i_size_read(&vnode->vfs_inode);\n\t\tif (maybe_i_size > i_size)\n\t\t\ti_size_write(&vnode->vfs_inode, maybe_i_size);\n\t\tspin_unlock(&vnode->writeback_lock);\n\t}\n\n\tset_page_dirty(page);\n\tif (PageDirty(page))\n\t\t_debug(\"dirtied\");\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "afs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "119-240",
    "snippet": "int afs_write_begin(struct file *file, struct address_space *mapping,\n\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct afs_writeback *candidate, *wb;\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tstruct page *page;\n\tstruct key *key = file->private_data;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\t_enter(\"{%x:%u},{%lx},%u,%u\",\n\t       vnode->fid.vid, vnode->fid.vnode, index, from, to);\n\n\tcandidate = kzalloc(sizeof(*candidate), GFP_KERNEL);\n\tif (!candidate)\n\t\treturn -ENOMEM;\n\tcandidate->vnode = vnode;\n\tcandidate->first = candidate->last = index;\n\tcandidate->offset_first = from;\n\tcandidate->to_last = to;\n\tINIT_LIST_HEAD(&candidate->link);\n\tcandidate->usage = 1;\n\tcandidate->state = AFS_WBACK_PENDING;\n\tinit_waitqueue_head(&candidate->waitq);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\tkfree(candidate);\n\t\treturn -ENOMEM;\n\t}\n\t*pagep = page;\n\t/* page won't leak in error case: it eventually gets cleaned off LRU */\n\n\tif (!PageUptodate(page) && len != PAGE_CACHE_SIZE) {\n\t\tret = afs_fill_page(vnode, key, index << PAGE_CACHE_SHIFT, page);\n\t\tif (ret < 0) {\n\t\t\tkfree(candidate);\n\t\t\t_leave(\" = %d [prep]\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\ntry_again:\n\tspin_lock(&vnode->writeback_lock);\n\n\t/* see if this page is already pending a writeback under a suitable key\n\t * - if so we can just join onto that one */\n\twb = (struct afs_writeback *) page_private(page);\n\tif (wb) {\n\t\tif (wb->key == key && wb->state == AFS_WBACK_PENDING)\n\t\t\tgoto subsume_in_current_wb;\n\t\tgoto flush_conflicting_wb;\n\t}\n\n\tif (index > 0) {\n\t\t/* see if we can find an already pending writeback that we can\n\t\t * append this page to */\n\t\tlist_for_each_entry(wb, &vnode->writebacks, link) {\n\t\t\tif (wb->last == index - 1 && wb->key == key &&\n\t\t\t    wb->state == AFS_WBACK_PENDING)\n\t\t\t\tgoto append_to_previous_wb;\n\t\t}\n\t}\n\n\tlist_add_tail(&candidate->link, &vnode->writebacks);\n\tcandidate->key = key_get(key);\n\tspin_unlock(&vnode->writeback_lock);\n\tSetPagePrivate(page);\n\tset_page_private(page, (unsigned long) candidate);\n\t_leave(\" = 0 [new]\");\n\treturn 0;\n\nsubsume_in_current_wb:\n\t_debug(\"subsume\");\n\tASSERTRANGE(wb->first, <=, index, <=, wb->last);\n\tif (index == wb->first && from < wb->offset_first)\n\t\twb->offset_first = from;\n\tif (index == wb->last && to > wb->to_last)\n\t\twb->to_last = to;\n\tspin_unlock(&vnode->writeback_lock);\n\tkfree(candidate);\n\t_leave(\" = 0 [sub]\");\n\treturn 0;\n\nappend_to_previous_wb:\n\t_debug(\"append into %lx-%lx\", wb->first, wb->last);\n\twb->usage++;\n\twb->last++;\n\twb->to_last = to;\n\tspin_unlock(&vnode->writeback_lock);\n\tSetPagePrivate(page);\n\tset_page_private(page, (unsigned long) wb);\n\tkfree(candidate);\n\t_leave(\" = 0 [app]\");\n\treturn 0;\n\n\t/* the page is currently bound to another context, so if it's dirty we\n\t * need to flush it before we can use the new context */\nflush_conflicting_wb:\n\t_debug(\"flush conflict\");\n\tif (wb->state == AFS_WBACK_PENDING)\n\t\twb->state = AFS_WBACK_CONFLICTING;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (PageDirty(page)) {\n\t\tret = afs_write_back_from_locked_page(wb, page);\n\t\tif (ret < 0) {\n\t\t\tafs_put_writeback(candidate);\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* the page holds a ref on the writeback record */\n\tafs_put_writeback(wb);\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tgoto try_again;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_writeback",
          "args": [
            "wb"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "68-82",
          "snippet": "void afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nvoid afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_write_back_from_locked_page",
          "args": [
            "wb",
            "page"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "afs_write_back_from_locked_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "316-432",
          "snippet": "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *primary_page)\n{\n\tstruct page *pages[8], *page;\n\tunsigned long count;\n\tunsigned n, offset, to;\n\tpgoff_t start, first, last;\n\tint loop, ret;\n\n\t_enter(\",%lx\", primary_page->index);\n\n\tcount = 1;\n\tif (!clear_page_dirty_for_io(primary_page))\n\t\tBUG();\n\tif (test_set_page_writeback(primary_page))\n\t\tBUG();\n\n\t/* find all consecutive lockable dirty pages, stopping when we find a\n\t * page that is not immediately lockable, is not dirty or is missing,\n\t * or we reach the end of the range */\n\tstart = primary_page->index;\n\tif (start >= wb->last)\n\t\tgoto no_more;\n\tstart++;\n\tdo {\n\t\t_debug(\"more %lx [%lx]\", start, count);\n\t\tn = wb->last - start + 1;\n\t\tif (n > ARRAY_SIZE(pages))\n\t\t\tn = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  start, n, pages);\n\t\t_debug(\"fgpc %u\", n);\n\t\tif (n == 0)\n\t\t\tgoto no_more;\n\t\tif (pages[0]->index != start) {\n\t\t\tdo {\n\t\t\t\tput_page(pages[--n]);\n\t\t\t} while (n > 0);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tfor (loop = 0; loop < n; loop++) {\n\t\t\tpage = pages[loop];\n\t\t\tif (page->index > wb->last)\n\t\t\t\tbreak;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tbreak;\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    page_private(page) != (unsigned long) wb) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tBUG();\n\t\t\tif (test_set_page_writeback(page))\n\t\t\t\tBUG();\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tcount += loop;\n\t\tif (loop < n) {\n\t\t\tfor (; loop < n; loop++)\n\t\t\t\tput_page(pages[loop]);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tstart += loop;\n\t} while (start <= wb->last && count < 65536);\n\nno_more:\n\t/* we now have a contiguous set of dirty pages, each with writeback set\n\t * and the dirty mark cleared; the first page is locked and must remain\n\t * so, all the rest are unlocked */\n\tfirst = primary_page->index;\n\tlast = first + count - 1;\n\n\toffset = (first == wb->first) ? wb->offset_first : 0;\n\tto = (last == wb->last) ? wb->to_last : PAGE_SIZE;\n\n\t_debug(\"write back %lx[%u..] to %lx[..%u]\", first, offset, last, to);\n\n\tret = afs_vnode_store_data(wb, first, last, offset, to);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\t\tset_bit(AS_ENOSPC,\n\t\t\t\t&wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -EREMOTEIO:\n\t\tcase -EFBIG:\n\t\tcase -ENOENT:\n\t\tcase -ENOMEDIUM:\n\t\tcase -ENXIO:\n\t\t\tafs_kill_pages(wb->vnode, true, first, last);\n\t\t\tset_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\tcase -EPERM:\n\t\tcase -ENOKEY:\n\t\tcase -EKEYEXPIRED:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYREVOKED:\n\t\t\tafs_kill_pages(wb->vnode, false, first, last);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = count;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *primary_page)\n{\n\tstruct page *pages[8], *page;\n\tunsigned long count;\n\tunsigned n, offset, to;\n\tpgoff_t start, first, last;\n\tint loop, ret;\n\n\t_enter(\",%lx\", primary_page->index);\n\n\tcount = 1;\n\tif (!clear_page_dirty_for_io(primary_page))\n\t\tBUG();\n\tif (test_set_page_writeback(primary_page))\n\t\tBUG();\n\n\t/* find all consecutive lockable dirty pages, stopping when we find a\n\t * page that is not immediately lockable, is not dirty or is missing,\n\t * or we reach the end of the range */\n\tstart = primary_page->index;\n\tif (start >= wb->last)\n\t\tgoto no_more;\n\tstart++;\n\tdo {\n\t\t_debug(\"more %lx [%lx]\", start, count);\n\t\tn = wb->last - start + 1;\n\t\tif (n > ARRAY_SIZE(pages))\n\t\t\tn = ARRAY_SIZE(pages);\n\t\tn = find_get_pages_contig(wb->vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  start, n, pages);\n\t\t_debug(\"fgpc %u\", n);\n\t\tif (n == 0)\n\t\t\tgoto no_more;\n\t\tif (pages[0]->index != start) {\n\t\t\tdo {\n\t\t\t\tput_page(pages[--n]);\n\t\t\t} while (n > 0);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tfor (loop = 0; loop < n; loop++) {\n\t\t\tpage = pages[loop];\n\t\t\tif (page->index > wb->last)\n\t\t\t\tbreak;\n\t\t\tif (!trylock_page(page))\n\t\t\t\tbreak;\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    page_private(page) != (unsigned long) wb) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tBUG();\n\t\t\tif (test_set_page_writeback(page))\n\t\t\t\tBUG();\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\n\t\tcount += loop;\n\t\tif (loop < n) {\n\t\t\tfor (; loop < n; loop++)\n\t\t\t\tput_page(pages[loop]);\n\t\t\tgoto no_more;\n\t\t}\n\n\t\tstart += loop;\n\t} while (start <= wb->last && count < 65536);\n\nno_more:\n\t/* we now have a contiguous set of dirty pages, each with writeback set\n\t * and the dirty mark cleared; the first page is locked and must remain\n\t * so, all the rest are unlocked */\n\tfirst = primary_page->index;\n\tlast = first + count - 1;\n\n\toffset = (first == wb->first) ? wb->offset_first : 0;\n\tto = (last == wb->last) ? wb->to_last : PAGE_SIZE;\n\n\t_debug(\"write back %lx[%u..] to %lx[..%u]\", first, offset, last, to);\n\n\tret = afs_vnode_store_data(wb, first, last, offset, to);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\t\tset_bit(AS_ENOSPC,\n\t\t\t\t&wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EROFS:\n\t\tcase -EIO:\n\t\tcase -EREMOTEIO:\n\t\tcase -EFBIG:\n\t\tcase -ENOENT:\n\t\tcase -ENOMEDIUM:\n\t\tcase -ENXIO:\n\t\t\tafs_kill_pages(wb->vnode, true, first, last);\n\t\t\tset_bit(AS_EIO, &wb->vnode->vfs_inode.i_mapping->flags);\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\tcase -EPERM:\n\t\tcase -ENOKEY:\n\t\tcase -EKEYEXPIRED:\n\t\tcase -EKEYREJECTED:\n\t\tcase -EKEYREVOKED:\n\t\t\tafs_kill_pages(wb->vnode, false, first, last);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = count;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"flush conflict\""
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [app]\""
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "candidate"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long) wb"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"append into %lx-%lx\"",
            "wb->first",
            "wb->last"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "candidate"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTRANGE",
          "args": [
            "wb->first",
            "<=,index",
            "<=,wb->last"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long) candidate"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "key"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&candidate->link",
            "&vnode->writebacks"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wb",
            "&vnode->writebacks",
            "link"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "candidate"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_fill_page",
          "args": [
            "vnode",
            "key",
            "index << PAGE_CACHE_SHIFT",
            "page"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fill_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "87-114",
          "snippet": "static int afs_fill_page(struct afs_vnode *vnode, struct key *key,\n\t\t\t loff_t pos, struct page *page)\n{\n\tloff_t i_size;\n\tint ret;\n\tint len;\n\n\t_enter(\",,%llu\", (unsigned long long)pos);\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (pos + PAGE_CACHE_SIZE > i_size)\n\t\tlen = i_size - pos;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tret = afs_vnode_fetch_data(vnode, key, pos, len, page);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT) {\n\t\t\t_debug(\"got NOENT from server\"\n\t\t\t       \" - marking file deleted and stale\");\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\tret = -ESTALE;\n\t\t}\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nstatic int afs_fill_page(struct afs_vnode *vnode, struct key *key,\n\t\t\t loff_t pos, struct page *page)\n{\n\tloff_t i_size;\n\tint ret;\n\tint len;\n\n\t_enter(\",,%llu\", (unsigned long long)pos);\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (pos + PAGE_CACHE_SIZE > i_size)\n\t\tlen = i_size - pos;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tret = afs_vnode_fetch_data(vnode, key, pos, len, page);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT) {\n\t\t\t_debug(\"got NOENT from server\"\n\t\t\t       \" - marking file deleted and stale\");\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\tret = -ESTALE;\n\t\t}\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "candidate"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&candidate->waitq"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&candidate->link"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*candidate)",
            "GFP_KERNEL"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%lx},%u,%u\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "index",
            "from",
            "to"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nint afs_write_begin(struct file *file, struct address_space *mapping,\n\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct afs_writeback *candidate, *wb;\n\tstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\n\tstruct page *page;\n\tstruct key *key = file->private_data;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tint ret;\n\n\t_enter(\"{%x:%u},{%lx},%u,%u\",\n\t       vnode->fid.vid, vnode->fid.vnode, index, from, to);\n\n\tcandidate = kzalloc(sizeof(*candidate), GFP_KERNEL);\n\tif (!candidate)\n\t\treturn -ENOMEM;\n\tcandidate->vnode = vnode;\n\tcandidate->first = candidate->last = index;\n\tcandidate->offset_first = from;\n\tcandidate->to_last = to;\n\tINIT_LIST_HEAD(&candidate->link);\n\tcandidate->usage = 1;\n\tcandidate->state = AFS_WBACK_PENDING;\n\tinit_waitqueue_head(&candidate->waitq);\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\tkfree(candidate);\n\t\treturn -ENOMEM;\n\t}\n\t*pagep = page;\n\t/* page won't leak in error case: it eventually gets cleaned off LRU */\n\n\tif (!PageUptodate(page) && len != PAGE_CACHE_SIZE) {\n\t\tret = afs_fill_page(vnode, key, index << PAGE_CACHE_SHIFT, page);\n\t\tif (ret < 0) {\n\t\t\tkfree(candidate);\n\t\t\t_leave(\" = %d [prep]\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tSetPageUptodate(page);\n\t}\n\ntry_again:\n\tspin_lock(&vnode->writeback_lock);\n\n\t/* see if this page is already pending a writeback under a suitable key\n\t * - if so we can just join onto that one */\n\twb = (struct afs_writeback *) page_private(page);\n\tif (wb) {\n\t\tif (wb->key == key && wb->state == AFS_WBACK_PENDING)\n\t\t\tgoto subsume_in_current_wb;\n\t\tgoto flush_conflicting_wb;\n\t}\n\n\tif (index > 0) {\n\t\t/* see if we can find an already pending writeback that we can\n\t\t * append this page to */\n\t\tlist_for_each_entry(wb, &vnode->writebacks, link) {\n\t\t\tif (wb->last == index - 1 && wb->key == key &&\n\t\t\t    wb->state == AFS_WBACK_PENDING)\n\t\t\t\tgoto append_to_previous_wb;\n\t\t}\n\t}\n\n\tlist_add_tail(&candidate->link, &vnode->writebacks);\n\tcandidate->key = key_get(key);\n\tspin_unlock(&vnode->writeback_lock);\n\tSetPagePrivate(page);\n\tset_page_private(page, (unsigned long) candidate);\n\t_leave(\" = 0 [new]\");\n\treturn 0;\n\nsubsume_in_current_wb:\n\t_debug(\"subsume\");\n\tASSERTRANGE(wb->first, <=, index, <=, wb->last);\n\tif (index == wb->first && from < wb->offset_first)\n\t\twb->offset_first = from;\n\tif (index == wb->last && to > wb->to_last)\n\t\twb->to_last = to;\n\tspin_unlock(&vnode->writeback_lock);\n\tkfree(candidate);\n\t_leave(\" = 0 [sub]\");\n\treturn 0;\n\nappend_to_previous_wb:\n\t_debug(\"append into %lx-%lx\", wb->first, wb->last);\n\twb->usage++;\n\twb->last++;\n\twb->to_last = to;\n\tspin_unlock(&vnode->writeback_lock);\n\tSetPagePrivate(page);\n\tset_page_private(page, (unsigned long) wb);\n\tkfree(candidate);\n\t_leave(\" = 0 [app]\");\n\treturn 0;\n\n\t/* the page is currently bound to another context, so if it's dirty we\n\t * need to flush it before we can use the new context */\nflush_conflicting_wb:\n\t_debug(\"flush conflict\");\n\tif (wb->state == AFS_WBACK_PENDING)\n\t\twb->state = AFS_WBACK_CONFLICTING;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (PageDirty(page)) {\n\t\tret = afs_write_back_from_locked_page(wb, page);\n\t\tif (ret < 0) {\n\t\t\tafs_put_writeback(candidate);\n\t\t\t_leave(\" = %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* the page holds a ref on the writeback record */\n\tafs_put_writeback(wb);\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tgoto try_again;\n}"
  },
  {
    "function_name": "afs_fill_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "87-114",
    "snippet": "static int afs_fill_page(struct afs_vnode *vnode, struct key *key,\n\t\t\t loff_t pos, struct page *page)\n{\n\tloff_t i_size;\n\tint ret;\n\tint len;\n\n\t_enter(\",,%llu\", (unsigned long long)pos);\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (pos + PAGE_CACHE_SIZE > i_size)\n\t\tlen = i_size - pos;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tret = afs_vnode_fetch_data(vnode, key, pos, len, page);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT) {\n\t\t\t_debug(\"got NOENT from server\"\n\t\t\t       \" - marking file deleted and stale\");\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\tret = -ESTALE;\n\t\t}\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"got NOENT from server\"\n\t\t\t       \" - marking file deleted and stale\""
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_fetch_data",
          "args": [
            "vnode",
            "key",
            "pos",
            "len",
            "page"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_fetch_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "395-445",
          "snippet": "int afs_vnode_fetch_data(struct afs_vnode *vnode, struct key *key,\n\t\t\t off_t offset, size_t length, struct page *page)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\t/* merge in AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_data(server, key, vnode, offset, length,\n\t\t\t\t\tpage, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_data(struct afs_vnode *vnode, struct key *key,\n\t\t\t off_t offset, size_t length, struct page *page)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\t/* merge in AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_data(server, key, vnode, offset, length,\n\t\t\t\t\tpage, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",,%llu\"",
            "(unsigned long long)pos"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nstatic int afs_fill_page(struct afs_vnode *vnode, struct key *key,\n\t\t\t loff_t pos, struct page *page)\n{\n\tloff_t i_size;\n\tint ret;\n\tint len;\n\n\t_enter(\",,%llu\", (unsigned long long)pos);\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (pos + PAGE_CACHE_SIZE > i_size)\n\t\tlen = i_size - pos;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tret = afs_vnode_fetch_data(vnode, key, pos, len, page);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT) {\n\t\t\t_debug(\"got NOENT from server\"\n\t\t\t       \" - marking file deleted and stale\");\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\tret = -ESTALE;\n\t\t}\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_put_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "68-82",
    "snippet": "void afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_free_writeback",
          "args": [
            "wb"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "afs_free_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "58-63",
          "snippet": "static void afs_free_writeback(struct afs_writeback *wb)\n{\n\t_enter(\"\");\n\tkey_put(wb->key);\n\tkfree(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic void afs_free_writeback(struct afs_writeback *wb)\n{\n\t_enter(\"\");\n\tkey_put(wb->key);\n\tkfree(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_unlink_writeback",
          "args": [
            "wb"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "afs_unlink_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "36-53",
          "snippet": "static void afs_unlink_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_writeback *front;\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\tlist_del_init(&wb->link);\n\tif (!list_empty(&vnode->writebacks)) {\n\t\t/* if an fsync rises to the front of the queue then wake it\n\t\t * up */\n\t\tfront = list_entry(vnode->writebacks.next,\n\t\t\t\t   struct afs_writeback, link);\n\t\tif (front->state == AFS_WBACK_SYNCING) {\n\t\t\t_debug(\"wake up sync\");\n\t\t\tfront->state = AFS_WBACK_COMPLETE;\n\t\t\twake_up(&front->waitq);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic void afs_unlink_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_writeback *front;\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\tlist_del_init(&wb->link);\n\tif (!list_empty(&vnode->writebacks)) {\n\t\t/* if an fsync rises to the front of the queue then wake it\n\t\t * up */\n\t\tfront = list_entry(vnode->writebacks.next,\n\t\t\t\t   struct afs_writeback, link);\n\t\tif (front->state == AFS_WBACK_SYNCING) {\n\t\t\t_debug(\"wake up sync\");\n\t\t\tfront->state = AFS_WBACK_COMPLETE;\n\t\t\twake_up(&front->waitq);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->writeback_lock"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%d}\"",
            "wb->usage"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nvoid afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}"
  },
  {
    "function_name": "afs_free_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "58-63",
    "snippet": "static void afs_free_writeback(struct afs_writeback *wb)\n{\n\t_enter(\"\");\n\tkey_put(wb->key);\n\tkfree(wb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wb"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "wb->key"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic void afs_free_writeback(struct afs_writeback *wb)\n{\n\t_enter(\"\");\n\tkey_put(wb->key);\n\tkfree(wb);\n}"
  },
  {
    "function_name": "afs_unlink_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "36-53",
    "snippet": "static void afs_unlink_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_writeback *front;\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\tlist_del_init(&wb->link);\n\tif (!list_empty(&vnode->writebacks)) {\n\t\t/* if an fsync rises to the front of the queue then wake it\n\t\t * up */\n\t\tfront = list_entry(vnode->writebacks.next,\n\t\t\t\t   struct afs_writeback, link);\n\t\tif (front->state == AFS_WBACK_SYNCING) {\n\t\t\t_debug(\"wake up sync\");\n\t\t\tfront->state = AFS_WBACK_COMPLETE;\n\t\t\twake_up(&front->waitq);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&front->waitq"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "afs_wake_up_async_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "606-610",
          "snippet": "static void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_async_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct workqueue_struct *afs_async_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstatic void afs_wake_up_async_call(struct afs_call *call)\n{\n\t_enter(\"\");\n\tqueue_work(afs_async_calls, &call->async_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"wake up sync\""
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "vnode->writebacks.next",
            "structafs_writeback",
            "link"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vnode->writebacks"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wb->link"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic void afs_unlink_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_writeback *front;\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\tlist_del_init(&wb->link);\n\tif (!list_empty(&vnode->writebacks)) {\n\t\t/* if an fsync rises to the front of the queue then wake it\n\t\t * up */\n\t\tfront = list_entry(vnode->writebacks.next,\n\t\t\t\t   struct afs_writeback, link);\n\t\tif (front->state == AFS_WBACK_SYNCING) {\n\t\t\t_debug(\"wake up sync\");\n\t\t\tfront->state = AFS_WBACK_COMPLETE;\n\t\t\twake_up(&front->waitq);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "afs_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
    "lines": "26-30",
    "snippet": "int afs_set_page_dirty(struct page *page)\n{\n\t_enter(\"\");\n\treturn __set_page_dirty_nobuffers(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nint afs_set_page_dirty(struct page *page)\n{\n\t_enter(\"\");\n\treturn __set_page_dirty_nobuffers(page);\n}"
  }
]