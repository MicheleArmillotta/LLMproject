[
  {
    "function_name": "ocfs2_is_empty_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
    "lines": "266-269",
    "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
  },
  {
    "function_name": "ocfs2_rec_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
    "lines": "246-260",
    "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rec->e_leaf_clusters"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_int_clusters"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
  },
  {
    "function_name": "ocfs2_dealloc_has_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
    "lines": "215-218",
    "snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}"
  },
  {
    "function_name": "ocfs2_init_dealloc_ctxt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
    "lines": "205-209",
    "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
  },
  {
    "function_name": "ocfs2_extend_meta_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
    "lines": "157-168",
    "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "root_el->l_tree_depth"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
  }
]