[
  {
    "function_name": "nfserrno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "708-758",
    "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"nfsd: non-standard errno: %d\\n\"",
            "errno"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "nfs_errtbl"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
  },
  {
    "function_name": "nfsd_proc_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "503-515",
    "snippet": "static __be32\nnfsd_proc_statfs(struct svc_rqst * rqstp, struct nfsd_fhandle   *argp,\n\t\t\t\t\t  struct nfsd_statfsres *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: STATFS   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tnfserr = nfsd_statfs(rqstp, &argp->fh, &resp->stats,\n\t\t\tNFSD_MAY_BYPASS_GSS_ON_ROOT);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_statfs",
          "args": [
            "rqstp",
            "&argp->fh",
            "&resp->stats",
            "NFSD_MAY_BYPASS_GSS_ON_ROOT"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1989-2004",
          "snippet": "__be32\nnfsd_statfs(struct svc_rqst *rqstp, struct svc_fh *fhp, struct kstatfs *stat, int access)\n{\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP | access);\n\tif (!err) {\n\t\tstruct path path = {\n\t\t\t.mnt\t= fhp->fh_export->ex_path.mnt,\n\t\t\t.dentry\t= fhp->fh_dentry,\n\t\t};\n\t\tif (vfs_statfs(&path, stat))\n\t\t\terr = nfserr_io;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_statfs(struct svc_rqst *rqstp, struct svc_fh *fhp, struct kstatfs *stat, int access)\n{\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP | access);\n\tif (!err) {\n\t\tstruct path path = {\n\t\t\t.mnt\t= fhp->fh_export->ex_path.mnt,\n\t\t\t.dentry\t= fhp->fh_dentry,\n\t\t};\n\t\tif (vfs_statfs(&path, stat))\n\t\t\terr = nfserr_io;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: STATFS   %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_statfs(struct svc_rqst * rqstp, struct nfsd_fhandle   *argp,\n\t\t\t\t\t  struct nfsd_statfsres *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: STATFS   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tnfserr = nfsd_statfs(rqstp, &argp->fh, &resp->stats,\n\t\t\tNFSD_MAY_BYPASS_GSS_ON_ROOT);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "463-498",
    "snippet": "static __be32\nnfsd_proc_readdir(struct svc_rqst *rqstp, struct nfsd_readdirargs *argp,\n\t\t\t\t\t  struct nfsd_readdirres  *resp)\n{\n\tint\t\tcount;\n\t__be32\t\tnfserr;\n\tloff_t\t\toffset;\n\n\tdprintk(\"nfsd: READDIR  %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\t\t\n\t\targp->count, argp->cookie);\n\n\t/* Shrink to the client read size */\n\tcount = (argp->count >> 2) - 2;\n\n\t/* Make sure we've room for the NULL ptr & eof flag */\n\tcount -= 2;\n\tif (count < 0)\n\t\tcount = 0;\n\n\tresp->buffer = argp->buffer;\n\tresp->offset = NULL;\n\tresp->buflen = count;\n\tresp->common.err = nfs_ok;\n\t/* Read directory and encode entries on the fly */\n\toffset = argp->cookie;\n\tnfserr = nfsd_readdir(rqstp, &argp->fh, &offset, \n\t\t\t      &resp->common, nfssvc_encode_entry);\n\n\tresp->count = resp->buffer - argp->buffer;\n\tif (resp->offset)\n\t\t*resp->offset = htonl(offset);\n\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "offset"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_readdir",
          "args": [
            "rqstp",
            "&argp->fh",
            "&offset",
            "&resp->common",
            "nfssvc_encode_entry"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1952-1983",
          "snippet": "__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t/* NFSv2 only supports 32 bit cookies */\n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok; /* can still be found in ->err */\nout_close:\n\tnfsd_close(file);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t/* NFSv2 only supports 32 bit cookies */\n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok; /* can still be found in ->err */\nout_close:\n\tnfsd_close(file);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: READDIR  %s %d bytes at %d\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->count",
            "argp->cookie"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_readdir(struct svc_rqst *rqstp, struct nfsd_readdirargs *argp,\n\t\t\t\t\t  struct nfsd_readdirres  *resp)\n{\n\tint\t\tcount;\n\t__be32\t\tnfserr;\n\tloff_t\t\toffset;\n\n\tdprintk(\"nfsd: READDIR  %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\t\t\n\t\targp->count, argp->cookie);\n\n\t/* Shrink to the client read size */\n\tcount = (argp->count >> 2) - 2;\n\n\t/* Make sure we've room for the NULL ptr & eof flag */\n\tcount -= 2;\n\tif (count < 0)\n\t\tcount = 0;\n\n\tresp->buffer = argp->buffer;\n\tresp->offset = NULL;\n\tresp->buflen = count;\n\tresp->common.err = nfs_ok;\n\t/* Read directory and encode entries on the fly */\n\toffset = argp->cookie;\n\tnfserr = nfsd_readdir(rqstp, &argp->fh, &offset, \n\t\t\t      &resp->common, nfssvc_encode_entry);\n\n\tresp->count = resp->buffer - argp->buffer;\n\tif (resp->offset)\n\t\t*resp->offset = htonl(offset);\n\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "447-458",
    "snippet": "static __be32\nnfsd_proc_rmdir(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t \tvoid\t\t      *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: RMDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tnfserr = nfsd_unlink(rqstp, &argp->fh, S_IFDIR, argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_unlink",
          "args": [
            "rqstp",
            "&argp->fh",
            "S_IFDIR",
            "argp->name",
            "argp->len"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1771-1821",
          "snippet": "__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (!rdentry->d_inode) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = rdentry->d_inode->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (!rdentry->d_inode) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = rdentry->d_inode->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: RMDIR    %s %.*s\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->name"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_rmdir(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t \tvoid\t\t      *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: RMDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tnfserr = nfsd_unlink(rqstp, &argp->fh, S_IFDIR, argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "423-442",
    "snippet": "static __be32\nnfsd_proc_mkdir(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\n\t\t\t\t\tstruct nfsd_diropres   *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: MKDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tif (resp->fh.fh_dentry) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"nfsd_proc_mkdir: response already verified??\\n\");\n\t}\n\n\targp->attrs.ia_valid &= ~ATTR_SIZE;\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tnfserr = nfsd_create(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t    &argp->attrs, S_IFDIR, 0, &resp->fh);\n\tfh_put(&argp->fh);\n\treturn nfsd_return_dirop(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_dirop",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_dirop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "31-36",
          "snippet": "static __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_create",
          "args": [
            "rqstp",
            "&argp->fh",
            "argp->name",
            "argp->len",
            "&argp->attrs",
            "S_IFDIR",
            "0",
            "&resp->fh"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1191-1318",
          "snippet": "__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (dchild->d_inode) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (dchild->d_inode) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&resp->fh",
            "NFS_FHSIZE"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\"nfsd_proc_mkdir: response already verified??\\n\""
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: MKDIR    %s %.*s\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->name"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_mkdir(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\n\t\t\t\t\tstruct nfsd_diropres   *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: MKDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tif (resp->fh.fh_dentry) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"nfsd_proc_mkdir: response already verified??\\n\");\n\t}\n\n\targp->attrs.ia_valid &= ~ATTR_SIZE;\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tnfserr = nfsd_create(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t    &argp->attrs, S_IFDIR, 0, &resp->fh);\n\tfh_put(&argp->fh);\n\treturn nfsd_return_dirop(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "393-417",
    "snippet": "static __be32\nnfsd_proc_symlink(struct svc_rqst *rqstp, struct nfsd_symlinkargs *argp,\n\t\t\t\t          void\t\t\t  *resp)\n{\n\tstruct svc_fh\tnewfh;\n\t__be32\t\tnfserr;\n\n\tdprintk(\"nfsd: SYMLINK  %s %.*s -> %.*s\\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname,\n\t\targp->tlen, argp->tname);\n\n\tfh_init(&newfh, NFS_FHSIZE);\n\t/*\n\t * Crazy hack: the request fits in a page, and already-decoded\n\t * attributes follow argp->tname, so it's safe to just write a\n\t * null to ensure it's null-terminated:\n\t */\n\targp->tname[argp->tlen] = '\\0';\n\tnfserr = nfsd_symlink(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t\t\t argp->tname, &newfh);\n\n\tfh_put(&argp->ffh);\n\tfh_put(&newfh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&newfh"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_symlink",
          "args": [
            "rqstp",
            "&argp->ffh",
            "argp->fname",
            "argp->flen",
            "argp->tname",
            "&newfh"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1547-1596",
          "snippet": "__be32\nnfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tchar *fname, int flen,\n\t\t\t\tchar *path,\n\t\t\t\tstruct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dnew;\n\t__be32\t\terr, cerr;\n\tint\t\thost_err;\n\n\terr = nfserr_noent;\n\tif (!flen || path[0] == '\\0')\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock(fhp);\n\tdentry = fhp->fh_dentry;\n\tdnew = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\thost_err = vfs_symlink(dentry->d_inode, dnew, path);\n\terr = nfserrno(host_err);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\tfh_unlock(fhp);\n\n\tfh_drop_write(fhp);\n\n\tcerr = fh_compose(resfhp, fhp->fh_export, dnew, fhp);\n\tdput(dnew);\n\tif (err==0) err = cerr;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tchar *fname, int flen,\n\t\t\t\tchar *path,\n\t\t\t\tstruct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dnew;\n\t__be32\t\terr, cerr;\n\tint\t\thost_err;\n\n\terr = nfserr_noent;\n\tif (!flen || path[0] == '\\0')\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock(fhp);\n\tdentry = fhp->fh_dentry;\n\tdnew = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\thost_err = vfs_symlink(dentry->d_inode, dnew, path);\n\terr = nfserrno(host_err);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\tfh_unlock(fhp);\n\n\tfh_drop_write(fhp);\n\n\tcerr = fh_compose(resfhp, fhp->fh_export, dnew, fhp);\n\tdput(dnew);\n\tif (err==0) err = cerr;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&newfh",
            "NFS_FHSIZE"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: SYMLINK  %s %.*s -> %.*s\\n\"",
            "SVCFH_fmt(&argp->ffh)",
            "argp->flen",
            "argp->fname",
            "argp->tlen",
            "argp->tname"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->ffh"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_symlink(struct svc_rqst *rqstp, struct nfsd_symlinkargs *argp,\n\t\t\t\t          void\t\t\t  *resp)\n{\n\tstruct svc_fh\tnewfh;\n\t__be32\t\tnfserr;\n\n\tdprintk(\"nfsd: SYMLINK  %s %.*s -> %.*s\\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname,\n\t\targp->tlen, argp->tname);\n\n\tfh_init(&newfh, NFS_FHSIZE);\n\t/*\n\t * Crazy hack: the request fits in a page, and already-decoded\n\t * attributes follow argp->tname, so it's safe to just write a\n\t * null to ensure it's null-terminated:\n\t */\n\targp->tname[argp->tlen] = '\\0';\n\tnfserr = nfsd_symlink(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t\t\t argp->tname, &newfh);\n\n\tfh_put(&argp->ffh);\n\tfh_put(&newfh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "373-391",
    "snippet": "static __be32\nnfsd_proc_link(struct svc_rqst *rqstp, struct nfsd_linkargs *argp,\n\t\t\t\tvoid\t\t\t    *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: LINK     %s ->\\n\",\n\t\tSVCFH_fmt(&argp->ffh));\n\tdprintk(\"nfsd:    %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh),\n\t\targp->tlen,\n\t\targp->tname);\n\n\tnfserr = nfsd_link(rqstp, &argp->tfh, argp->tname, argp->tlen,\n\t\t\t\t  &argp->ffh);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->tfh"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_link",
          "args": [
            "rqstp",
            "&argp->tfh",
            "argp->tname",
            "argp->tlen",
            "&argp->ffh"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1602-1669",
          "snippet": "__be32\nnfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,\n\t\t\t\tchar *name, int len, struct svc_fh *tfhp)\n{\n\tstruct dentry\t*ddir, *dnew, *dold;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, 0, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\terr = nfserr_isdir;\n\tif (d_is_dir(tfhp->fh_dentry))\n\t\tgoto out;\n\terr = nfserr_perm;\n\tif (!len)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(name, len))\n\t\tgoto out;\n\n\thost_err = fh_want_write(tfhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\tfh_lock_nested(ffhp, I_MUTEX_PARENT);\n\tddir = ffhp->fh_dentry;\n\tdirp = ddir->d_inode;\n\n\tdnew = lookup_one_len(name, ddir, len);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\tdold = tfhp->fh_dentry;\n\n\terr = nfserr_noent;\n\tif (!dold->d_inode)\n\t\tgoto out_dput;\n\thost_err = vfs_link(dold, dirp, dnew, NULL);\n\tif (!host_err) {\n\t\terr = nfserrno(commit_metadata(ffhp));\n\t\tif (!err)\n\t\t\terr = nfserrno(commit_metadata(tfhp));\n\t} else {\n\t\tif (host_err == -EXDEV && rqstp->rq_vers == 2)\n\t\t\terr = nfserr_acces;\n\t\telse\n\t\t\terr = nfserrno(host_err);\n\t}\nout_dput:\n\tdput(dnew);\nout_unlock:\n\tfh_unlock(ffhp);\n\tfh_drop_write(tfhp);\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,\n\t\t\t\tchar *name, int len, struct svc_fh *tfhp)\n{\n\tstruct dentry\t*ddir, *dnew, *dold;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, 0, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\terr = nfserr_isdir;\n\tif (d_is_dir(tfhp->fh_dentry))\n\t\tgoto out;\n\terr = nfserr_perm;\n\tif (!len)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(name, len))\n\t\tgoto out;\n\n\thost_err = fh_want_write(tfhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\tfh_lock_nested(ffhp, I_MUTEX_PARENT);\n\tddir = ffhp->fh_dentry;\n\tdirp = ddir->d_inode;\n\n\tdnew = lookup_one_len(name, ddir, len);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\tdold = tfhp->fh_dentry;\n\n\terr = nfserr_noent;\n\tif (!dold->d_inode)\n\t\tgoto out_dput;\n\thost_err = vfs_link(dold, dirp, dnew, NULL);\n\tif (!host_err) {\n\t\terr = nfserrno(commit_metadata(ffhp));\n\t\tif (!err)\n\t\t\terr = nfserrno(commit_metadata(tfhp));\n\t} else {\n\t\tif (host_err == -EXDEV && rqstp->rq_vers == 2)\n\t\t\terr = nfserr_acces;\n\t\telse\n\t\t\terr = nfserrno(host_err);\n\t}\nout_dput:\n\tdput(dnew);\nout_unlock:\n\tfh_unlock(ffhp);\n\tfh_drop_write(tfhp);\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd:    %s %.*s\\n\"",
            "SVCFH_fmt(&argp->tfh)",
            "argp->tlen",
            "argp->tname"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->tfh"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: LINK     %s ->\\n\"",
            "SVCFH_fmt(&argp->ffh)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_link(struct svc_rqst *rqstp, struct nfsd_linkargs *argp,\n\t\t\t\tvoid\t\t\t    *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: LINK     %s ->\\n\",\n\t\tSVCFH_fmt(&argp->ffh));\n\tdprintk(\"nfsd:    %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh),\n\t\targp->tlen,\n\t\targp->tname);\n\n\tnfserr = nfsd_link(rqstp, &argp->tfh, argp->tname, argp->tlen,\n\t\t\t\t  &argp->ffh);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "355-371",
    "snippet": "static __be32\nnfsd_proc_rename(struct svc_rqst *rqstp, struct nfsd_renameargs *argp,\n\t\t\t\t  \t void\t\t        *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: RENAME   %s %.*s -> \\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname);\n\tdprintk(\"nfsd:        ->  %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh), argp->tlen, argp->tname);\n\n\tnfserr = nfsd_rename(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t    &argp->tfh, argp->tname, argp->tlen);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->tfh"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_rename",
          "args": [
            "rqstp",
            "&argp->ffh",
            "argp->fname",
            "argp->flen",
            "&argp->tfh",
            "argp->tname",
            "argp->tlen"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1675-1765",
          "snippet": "__be32\nnfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,\n\t\t\t    struct svc_fh *tfhp, char *tname, int tlen)\n{\n\tstruct dentry\t*fdentry, *tdentry, *odentry, *ndentry, *trap;\n\tstruct inode\t*fdir, *tdir;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tfdentry = ffhp->fh_dentry;\n\tfdir = fdentry->d_inode;\n\n\ttdentry = tfhp->fh_dentry;\n\ttdir = tdentry->d_inode;\n\n\terr = nfserr_perm;\n\tif (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))\n\t\tgoto out;\n\n\thost_err = fh_want_write(ffhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\t/* cannot use fh_lock as we need deadlock protective ordering\n\t * so do it by hand */\n\ttrap = lock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = 1;\n\tfill_pre_wcc(ffhp);\n\tfill_pre_wcc(tfhp);\n\n\todentry = lookup_one_len(fname, fdentry, flen);\n\thost_err = PTR_ERR(odentry);\n\tif (IS_ERR(odentry))\n\t\tgoto out_nfserr;\n\n\thost_err = -ENOENT;\n\tif (!odentry->d_inode)\n\t\tgoto out_dput_old;\n\thost_err = -EINVAL;\n\tif (odentry == trap)\n\t\tgoto out_dput_old;\n\n\tndentry = lookup_one_len(tname, tdentry, tlen);\n\thost_err = PTR_ERR(ndentry);\n\tif (IS_ERR(ndentry))\n\t\tgoto out_dput_old;\n\thost_err = -ENOTEMPTY;\n\tif (ndentry == trap)\n\t\tgoto out_dput_new;\n\n\thost_err = -EXDEV;\n\tif (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)\n\t\tgoto out_dput_new;\n\tif (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)\n\t\tgoto out_dput_new;\n\n\thost_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL, 0);\n\tif (!host_err) {\n\t\thost_err = commit_metadata(tfhp);\n\t\tif (!host_err)\n\t\t\thost_err = commit_metadata(ffhp);\n\t}\n out_dput_new:\n\tdput(ndentry);\n out_dput_old:\n\tdput(odentry);\n out_nfserr:\n\terr = nfserrno(host_err);\n\t/*\n\t * We cannot rely on fh_unlock on the two filehandles,\n\t * as that would do the wrong thing if the two directories\n\t * were the same, so again we do it by hand.\n\t */\n\tfill_post_wcc(ffhp);\n\tfill_post_wcc(tfhp);\n\tunlock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = 0;\n\tfh_drop_write(ffhp);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,\n\t\t\t    struct svc_fh *tfhp, char *tname, int tlen)\n{\n\tstruct dentry\t*fdentry, *tdentry, *odentry, *ndentry, *trap;\n\tstruct inode\t*fdir, *tdir;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tfdentry = ffhp->fh_dentry;\n\tfdir = fdentry->d_inode;\n\n\ttdentry = tfhp->fh_dentry;\n\ttdir = tdentry->d_inode;\n\n\terr = nfserr_perm;\n\tif (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))\n\t\tgoto out;\n\n\thost_err = fh_want_write(ffhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\t/* cannot use fh_lock as we need deadlock protective ordering\n\t * so do it by hand */\n\ttrap = lock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = 1;\n\tfill_pre_wcc(ffhp);\n\tfill_pre_wcc(tfhp);\n\n\todentry = lookup_one_len(fname, fdentry, flen);\n\thost_err = PTR_ERR(odentry);\n\tif (IS_ERR(odentry))\n\t\tgoto out_nfserr;\n\n\thost_err = -ENOENT;\n\tif (!odentry->d_inode)\n\t\tgoto out_dput_old;\n\thost_err = -EINVAL;\n\tif (odentry == trap)\n\t\tgoto out_dput_old;\n\n\tndentry = lookup_one_len(tname, tdentry, tlen);\n\thost_err = PTR_ERR(ndentry);\n\tif (IS_ERR(ndentry))\n\t\tgoto out_dput_old;\n\thost_err = -ENOTEMPTY;\n\tif (ndentry == trap)\n\t\tgoto out_dput_new;\n\n\thost_err = -EXDEV;\n\tif (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)\n\t\tgoto out_dput_new;\n\tif (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)\n\t\tgoto out_dput_new;\n\n\thost_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL, 0);\n\tif (!host_err) {\n\t\thost_err = commit_metadata(tfhp);\n\t\tif (!host_err)\n\t\t\thost_err = commit_metadata(ffhp);\n\t}\n out_dput_new:\n\tdput(ndentry);\n out_dput_old:\n\tdput(odentry);\n out_nfserr:\n\terr = nfserrno(host_err);\n\t/*\n\t * We cannot rely on fh_unlock on the two filehandles,\n\t * as that would do the wrong thing if the two directories\n\t * were the same, so again we do it by hand.\n\t */\n\tfill_post_wcc(ffhp);\n\tfill_post_wcc(tfhp);\n\tunlock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = 0;\n\tfh_drop_write(ffhp);\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd:        ->  %s %.*s\\n\"",
            "SVCFH_fmt(&argp->tfh)",
            "argp->tlen",
            "argp->tname"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->tfh"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: RENAME   %s %.*s -> \\n\"",
            "SVCFH_fmt(&argp->ffh)",
            "argp->flen",
            "argp->fname"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_rename(struct svc_rqst *rqstp, struct nfsd_renameargs *argp,\n\t\t\t\t  \t void\t\t        *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: RENAME   %s %.*s -> \\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname);\n\tdprintk(\"nfsd:        ->  %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh), argp->tlen, argp->tname);\n\n\tnfserr = nfsd_rename(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t    &argp->tfh, argp->tname, argp->tlen);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "340-353",
    "snippet": "static __be32\nnfsd_proc_remove(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t\t void\t\t       *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: REMOVE   %s %.*s\\n\", SVCFH_fmt(&argp->fh),\n\t\targp->len, argp->name);\n\n\t/* Unlink. -SIFDIR means file must not be a directory */\n\tnfserr = nfsd_unlink(rqstp, &argp->fh, -S_IFDIR, argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_unlink",
          "args": [
            "rqstp",
            "&argp->fh",
            "-S_IFDIR",
            "argp->name",
            "argp->len"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1771-1821",
          "snippet": "__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (!rdentry->d_inode) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = rdentry->d_inode->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (!rdentry->d_inode) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = rdentry->d_inode->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: REMOVE   %s %.*s\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->name"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_remove(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t\t void\t\t       *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: REMOVE   %s %.*s\\n\", SVCFH_fmt(&argp->fh),\n\t\targp->len, argp->name);\n\n\t/* Unlink. -SIFDIR means file must not be a directory */\n\tnfserr = nfsd_unlink(rqstp, &argp->fh, -S_IFDIR, argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "182-338",
    "snippet": "static __be32\nnfsd_proc_create(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\n\t\t\t\t\t struct nfsd_diropres   *resp)\n{\n\tsvc_fh\t\t*dirfhp = &argp->fh;\n\tsvc_fh\t\t*newfhp = &resp->fh;\n\tstruct iattr\t*attr = &argp->attrs;\n\tstruct inode\t*inode;\n\tstruct dentry\t*dchild;\n\tint\t\ttype, mode;\n\t__be32\t\tnfserr;\n\tint\t\thosterr;\n\tdev_t\t\trdev = 0, wanted = new_decode_dev(attr->ia_size);\n\n\tdprintk(\"nfsd: CREATE   %s %.*s\\n\",\n\t\tSVCFH_fmt(dirfhp), argp->len, argp->name);\n\n\t/* First verify the parent file handle */\n\tnfserr = fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (nfserr)\n\t\tgoto done; /* must fh_put dirfhp even on error */\n\n\t/* Check for NFSD_MAY_WRITE in nfsd_create if necessary */\n\n\tnfserr = nfserr_acces;\n\tif (!argp->len)\n\t\tgoto done;\n\tnfserr = nfserr_exist;\n\tif (isdotent(argp->name, argp->len))\n\t\tgoto done;\n\thosterr = fh_want_write(dirfhp);\n\tif (hosterr) {\n\t\tnfserr = nfserrno(hosterr);\n\t\tgoto done;\n\t}\n\n\tfh_lock_nested(dirfhp, I_MUTEX_PARENT);\n\tdchild = lookup_one_len(argp->name, dirfhp->fh_dentry, argp->len);\n\tif (IS_ERR(dchild)) {\n\t\tnfserr = nfserrno(PTR_ERR(dchild));\n\t\tgoto out_unlock;\n\t}\n\tfh_init(newfhp, NFS_FHSIZE);\n\tnfserr = fh_compose(newfhp, dirfhp->fh_export, dchild, dirfhp);\n\tif (!nfserr && !dchild->d_inode)\n\t\tnfserr = nfserr_noent;\n\tdput(dchild);\n\tif (nfserr) {\n\t\tif (nfserr != nfserr_noent)\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * If the new file handle wasn't verified, we can't tell\n\t\t * whether the file exists or not. Time to bail ...\n\t\t */\n\t\tnfserr = nfserr_acces;\n\t\tif (!newfhp->fh_dentry) {\n\t\t\tprintk(KERN_WARNING \n\t\t\t\t\"nfsd_proc_create: file handle not verified\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tinode = newfhp->fh_dentry->d_inode;\n\n\t/* Unfudge the mode bits */\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\ttype = attr->ia_mode & S_IFMT;\n\t\tmode = attr->ia_mode & ~S_IFMT;\n\t\tif (!type) {\n\t\t\t/* no type, so if target exists, assume same as that,\n\t\t\t * else assume a file */\n\t\t\tif (inode) {\n\t\t\t\ttype = inode->i_mode & S_IFMT;\n\t\t\t\tswitch(type) {\n\t\t\t\tcase S_IFCHR:\n\t\t\t\tcase S_IFBLK:\n\t\t\t\t\t/* reserve rdev for later checking */\n\t\t\t\t\trdev = inode->i_rdev;\n\t\t\t\t\tattr->ia_valid |= ATTR_SIZE;\n\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase S_IFIFO:\n\t\t\t\t\t/* this is probably a permission check..\n\t\t\t\t\t * at least IRIX implements perm checking on\n\t\t\t\t\t *   echo thing > device-special-file-or-pipe\n\t\t\t\t\t * by doing a CREATE with type==0\n\t\t\t\t\t */\n\t\t\t\t\tnfserr = nfsd_permission(rqstp,\n\t\t\t\t\t\t\t\t newfhp->fh_export,\n\t\t\t\t\t\t\t\t newfhp->fh_dentry,\n\t\t\t\t\t\t\t\t NFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS);\n\t\t\t\t\tif (nfserr && nfserr != nfserr_rofs)\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttype = S_IFREG;\n\t\t}\n\t} else if (inode) {\n\t\ttype = inode->i_mode & S_IFMT;\n\t\tmode = inode->i_mode & ~S_IFMT;\n\t} else {\n\t\ttype = S_IFREG;\n\t\tmode = 0;\t/* ??? */\n\t}\n\n\tattr->ia_valid |= ATTR_MODE;\n\tattr->ia_mode = mode;\n\n\t/* Special treatment for non-regular files according to the\n\t * gospel of sun micro\n\t */\n\tif (type != S_IFREG) {\n\t\tif (type != S_IFBLK && type != S_IFCHR) {\n\t\t\trdev = 0;\n\t\t} else if (type == S_IFCHR && !(attr->ia_valid & ATTR_SIZE)) {\n\t\t\t/* If you think you've seen the worst, grok this. */\n\t\t\ttype = S_IFIFO;\n\t\t} else {\n\t\t\t/* Okay, char or block special */\n\t\t\tif (!rdev)\n\t\t\t\trdev = wanted;\n\t\t}\n\n\t\t/* we've used the SIZE information, so discard it */\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n\t\t/* Make sure the type and device matches */\n\t\tnfserr = nfserr_exist;\n\t\tif (inode && type != (inode->i_mode & S_IFMT))\n\t\t\tgoto out_unlock;\n\t}\n\n\tnfserr = 0;\n\tif (!inode) {\n\t\t/* File doesn't exist. Create it and set attrs */\n\t\tnfserr = nfsd_create(rqstp, dirfhp, argp->name, argp->len,\n\t\t\t\t\tattr, type, rdev, newfhp);\n\t} else if (type == S_IFREG) {\n\t\tdprintk(\"nfsd:   existing %s, valid=%x, size=%ld\\n\",\n\t\t\targp->name, attr->ia_valid, (long) attr->ia_size);\n\t\t/* File already exists. We ignore all attributes except\n\t\t * size, so that creat() behaves exactly like\n\t\t * open(..., O_CREAT|O_TRUNC|O_WRONLY).\n\t\t */\n\t\tattr->ia_valid &= ATTR_SIZE;\n\t\tif (attr->ia_valid)\n\t\t\tnfserr = nfsd_setattr(rqstp, newfhp, attr, 0, (time_t)0);\n\t}\n\nout_unlock:\n\t/* We don't really need to unlock, as fh_put does it. */\n\tfh_unlock(dirfhp);\n\tfh_drop_write(dirfhp);\ndone:\n\tfh_put(dirfhp);\n\treturn nfsd_return_dirop(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_dirop",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_dirop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "31-36",
          "snippet": "static __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "dirfhp"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_drop_write",
          "args": [
            "dirfhp"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "fh_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.h",
          "lines": "116-122",
          "snippet": "static inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = 0;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = 0;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_unlock",
          "args": [
            "dirfhp"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "fh_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "282-290",
          "snippet": "static inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tmutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);\n\t\tfhp->fh_locked = 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tmutex_unlock(&fhp->fh_dentry->d_inode->i_mutex);\n\t\tfhp->fh_locked = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setattr",
          "args": [
            "rqstp",
            "newfhp",
            "attr",
            "0",
            "(time_t)0"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "397-480",
          "snippet": "__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd:   existing %s, valid=%x, size=%ld\\n\"",
            "argp->name",
            "attr->ia_valid",
            "(long) attr->ia_size"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_create",
          "args": [
            "rqstp",
            "dirfhp",
            "argp->name",
            "argp->len",
            "attr",
            "type",
            "rdev",
            "newfhp"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1191-1318",
          "snippet": "__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (dchild->d_inode) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = dentry->d_inode;\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (dchild->d_inode) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_permission",
          "args": [
            "rqstp",
            "newfhp->fh_export",
            "newfhp->fh_dentry",
            "NFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "2014-2094",
          "snippet": "__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = dentry->d_inode;\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = dentry->d_inode;\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \n\t\t\t\t\"nfsd_proc_create: file handle not verified\\n\""
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dchild"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "newfhp",
            "dirfhp->fh_export",
            "dchild",
            "dirfhp"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "newfhp",
            "NFS_FHSIZE"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(dchild)"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dchild"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dchild"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "argp->name",
            "dirfhp->fh_dentry",
            "argp->len"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_lock_nested",
          "args": [
            "dirfhp",
            "I_MUTEX_PARENT"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "fh_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "253-271",
          "snippet": "static inline void\nfh_lock_nested(struct svc_fh *fhp, unsigned int subclass)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\tstruct inode\t*inode;\n\n\tBUG_ON(!dentry);\n\n\tif (fhp->fh_locked) {\n\t\tprintk(KERN_WARNING \"fh_lock: %pd2 already locked!\\n\",\n\t\t\tdentry);\n\t\treturn;\n\t}\n\n\tinode = dentry->d_inode;\n\tmutex_lock_nested(&inode->i_mutex, subclass);\n\tfill_pre_wcc(fhp);\n\tfhp->fh_locked = 1;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_lock_nested(struct svc_fh *fhp, unsigned int subclass)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\tstruct inode\t*inode;\n\n\tBUG_ON(!dentry);\n\n\tif (fhp->fh_locked) {\n\t\tprintk(KERN_WARNING \"fh_lock: %pd2 already locked!\\n\",\n\t\t\tdentry);\n\t\treturn;\n\t}\n\n\tinode = dentry->d_inode;\n\tmutex_lock_nested(&inode->i_mutex, subclass);\n\tfill_pre_wcc(fhp);\n\tfhp->fh_locked = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_want_write",
          "args": [
            "dirfhp"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "fh_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.h",
          "lines": "107-114",
          "snippet": "static inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdotent",
          "args": [
            "argp->name",
            "argp->len"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "dirfhp",
            "S_IFDIR",
            "NFSD_MAY_EXEC"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: CREATE   %s %.*s\\n\"",
            "SVCFH_fmt(dirfhp)",
            "argp->len",
            "argp->name"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "dirfhp"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "attr->ia_size"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_create(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\n\t\t\t\t\t struct nfsd_diropres   *resp)\n{\n\tsvc_fh\t\t*dirfhp = &argp->fh;\n\tsvc_fh\t\t*newfhp = &resp->fh;\n\tstruct iattr\t*attr = &argp->attrs;\n\tstruct inode\t*inode;\n\tstruct dentry\t*dchild;\n\tint\t\ttype, mode;\n\t__be32\t\tnfserr;\n\tint\t\thosterr;\n\tdev_t\t\trdev = 0, wanted = new_decode_dev(attr->ia_size);\n\n\tdprintk(\"nfsd: CREATE   %s %.*s\\n\",\n\t\tSVCFH_fmt(dirfhp), argp->len, argp->name);\n\n\t/* First verify the parent file handle */\n\tnfserr = fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (nfserr)\n\t\tgoto done; /* must fh_put dirfhp even on error */\n\n\t/* Check for NFSD_MAY_WRITE in nfsd_create if necessary */\n\n\tnfserr = nfserr_acces;\n\tif (!argp->len)\n\t\tgoto done;\n\tnfserr = nfserr_exist;\n\tif (isdotent(argp->name, argp->len))\n\t\tgoto done;\n\thosterr = fh_want_write(dirfhp);\n\tif (hosterr) {\n\t\tnfserr = nfserrno(hosterr);\n\t\tgoto done;\n\t}\n\n\tfh_lock_nested(dirfhp, I_MUTEX_PARENT);\n\tdchild = lookup_one_len(argp->name, dirfhp->fh_dentry, argp->len);\n\tif (IS_ERR(dchild)) {\n\t\tnfserr = nfserrno(PTR_ERR(dchild));\n\t\tgoto out_unlock;\n\t}\n\tfh_init(newfhp, NFS_FHSIZE);\n\tnfserr = fh_compose(newfhp, dirfhp->fh_export, dchild, dirfhp);\n\tif (!nfserr && !dchild->d_inode)\n\t\tnfserr = nfserr_noent;\n\tdput(dchild);\n\tif (nfserr) {\n\t\tif (nfserr != nfserr_noent)\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * If the new file handle wasn't verified, we can't tell\n\t\t * whether the file exists or not. Time to bail ...\n\t\t */\n\t\tnfserr = nfserr_acces;\n\t\tif (!newfhp->fh_dentry) {\n\t\t\tprintk(KERN_WARNING \n\t\t\t\t\"nfsd_proc_create: file handle not verified\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tinode = newfhp->fh_dentry->d_inode;\n\n\t/* Unfudge the mode bits */\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\ttype = attr->ia_mode & S_IFMT;\n\t\tmode = attr->ia_mode & ~S_IFMT;\n\t\tif (!type) {\n\t\t\t/* no type, so if target exists, assume same as that,\n\t\t\t * else assume a file */\n\t\t\tif (inode) {\n\t\t\t\ttype = inode->i_mode & S_IFMT;\n\t\t\t\tswitch(type) {\n\t\t\t\tcase S_IFCHR:\n\t\t\t\tcase S_IFBLK:\n\t\t\t\t\t/* reserve rdev for later checking */\n\t\t\t\t\trdev = inode->i_rdev;\n\t\t\t\t\tattr->ia_valid |= ATTR_SIZE;\n\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase S_IFIFO:\n\t\t\t\t\t/* this is probably a permission check..\n\t\t\t\t\t * at least IRIX implements perm checking on\n\t\t\t\t\t *   echo thing > device-special-file-or-pipe\n\t\t\t\t\t * by doing a CREATE with type==0\n\t\t\t\t\t */\n\t\t\t\t\tnfserr = nfsd_permission(rqstp,\n\t\t\t\t\t\t\t\t newfhp->fh_export,\n\t\t\t\t\t\t\t\t newfhp->fh_dentry,\n\t\t\t\t\t\t\t\t NFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS);\n\t\t\t\t\tif (nfserr && nfserr != nfserr_rofs)\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttype = S_IFREG;\n\t\t}\n\t} else if (inode) {\n\t\ttype = inode->i_mode & S_IFMT;\n\t\tmode = inode->i_mode & ~S_IFMT;\n\t} else {\n\t\ttype = S_IFREG;\n\t\tmode = 0;\t/* ??? */\n\t}\n\n\tattr->ia_valid |= ATTR_MODE;\n\tattr->ia_mode = mode;\n\n\t/* Special treatment for non-regular files according to the\n\t * gospel of sun micro\n\t */\n\tif (type != S_IFREG) {\n\t\tif (type != S_IFBLK && type != S_IFCHR) {\n\t\t\trdev = 0;\n\t\t} else if (type == S_IFCHR && !(attr->ia_valid & ATTR_SIZE)) {\n\t\t\t/* If you think you've seen the worst, grok this. */\n\t\t\ttype = S_IFIFO;\n\t\t} else {\n\t\t\t/* Okay, char or block special */\n\t\t\tif (!rdev)\n\t\t\t\trdev = wanted;\n\t\t}\n\n\t\t/* we've used the SIZE information, so discard it */\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n\t\t/* Make sure the type and device matches */\n\t\tnfserr = nfserr_exist;\n\t\tif (inode && type != (inode->i_mode & S_IFMT))\n\t\t\tgoto out_unlock;\n\t}\n\n\tnfserr = 0;\n\tif (!inode) {\n\t\t/* File doesn't exist. Create it and set attrs */\n\t\tnfserr = nfsd_create(rqstp, dirfhp, argp->name, argp->len,\n\t\t\t\t\tattr, type, rdev, newfhp);\n\t} else if (type == S_IFREG) {\n\t\tdprintk(\"nfsd:   existing %s, valid=%x, size=%ld\\n\",\n\t\t\targp->name, attr->ia_valid, (long) attr->ia_size);\n\t\t/* File already exists. We ignore all attributes except\n\t\t * size, so that creat() behaves exactly like\n\t\t * open(..., O_CREAT|O_TRUNC|O_WRONLY).\n\t\t */\n\t\tattr->ia_valid &= ATTR_SIZE;\n\t\tif (attr->ia_valid)\n\t\t\tnfserr = nfsd_setattr(rqstp, newfhp, attr, 0, (time_t)0);\n\t}\n\nout_unlock:\n\t/* We don't really need to unlock, as fh_put does it. */\n\tfh_unlock(dirfhp);\n\tfh_drop_write(dirfhp);\ndone:\n\tfh_put(dirfhp);\n\treturn nfsd_return_dirop(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "156-174",
    "snippet": "static __be32\nnfsd_proc_write(struct svc_rqst *rqstp, struct nfsd_writeargs *argp,\n\t\t\t\t\tstruct nfsd_attrstat  *resp)\n{\n\t__be32\tnfserr;\n\tint\tstable = 1;\n\tunsigned long cnt = argp->len;\n\n\tdprintk(\"nfsd: WRITE    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->len, argp->offset);\n\n\tnfserr = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh), NULL,\n\t\t\t\t   argp->offset,\n\t\t\t\t   rqstp->rq_vec, argp->vlen,\n\t\t\t           &cnt,\n\t\t\t\t   &stable);\n\treturn nfsd_return_attrs(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_attrs",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "25-30",
          "snippet": "static __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_write",
          "args": [
            "rqstp",
            "fh_copy(&resp->fh, &argp->fh)",
            "NULL",
            "argp->offset",
            "rqstp->rq_vec",
            "argp->vlen",
            "&cnt",
            "&stable"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1074-1100",
          "snippet": "__be32\nnfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\n\t\tloff_t offset, struct kvec *vec, int vlen, unsigned long *cnt,\n\t\tint *stablep)\n{\n\t__be32\t\t\terr = 0;\n\n\tif (file) {\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen, cnt,\n\t\t\t\tstablep);\n\t} else {\n\t\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_WRITE, &file);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (cnt)\n\t\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen,\n\t\t\t\t\t     cnt, stablep);\n\t\tnfsd_close(file);\n\t}\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\n\t\tloff_t offset, struct kvec *vec, int vlen, unsigned long *cnt,\n\t\tint *stablep)\n{\n\t__be32\t\t\terr = 0;\n\n\tif (file) {\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen, cnt,\n\t\t\t\tstablep);\n\t} else {\n\t\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_WRITE, &file);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (cnt)\n\t\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen,\n\t\t\t\t\t     cnt, stablep);\n\t\tnfsd_close(file);\n\t}\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "175-180",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: WRITE    %s %d bytes at %d\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->offset"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_write(struct svc_rqst *rqstp, struct nfsd_writeargs *argp,\n\t\t\t\t\tstruct nfsd_attrstat  *resp)\n{\n\t__be32\tnfserr;\n\tint\tstable = 1;\n\tunsigned long cnt = argp->len;\n\n\tdprintk(\"nfsd: WRITE    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->len, argp->offset);\n\n\tnfserr = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh), NULL,\n\t\t\t\t   argp->offset,\n\t\t\t\t   rqstp->rq_vec, argp->vlen,\n\t\t\t           &cnt,\n\t\t\t\t   &stable);\n\treturn nfsd_return_attrs(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "118-150",
    "snippet": "static __be32\nnfsd_proc_read(struct svc_rqst *rqstp, struct nfsd_readargs *argp,\n\t\t\t\t       struct nfsd_readres  *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: READ    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->count, argp->offset);\n\n\t/* Obtain buffer pointer for payload. 19 is 1 word for\n\t * status, 17 words for fattr, and 1 word for the byte count.\n\t */\n\n\tif (NFSSVC_MAXBLKSIZE_V2 < argp->count) {\n\t\tchar buf[RPC_MAX_ADDRBUFLEN];\n\t\tprintk(KERN_NOTICE\n\t\t\t\"oversized read request from %s (%d bytes)\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)),\n\t\t\t\targp->count);\n\t\targp->count = NFSSVC_MAXBLKSIZE_V2;\n\t}\n\tsvc_reserve_auth(rqstp, (19<<2) + argp->count + 4);\n\n\tresp->count = argp->count;\n\tnfserr = nfsd_read(rqstp, fh_copy(&resp->fh, &argp->fh),\n\t\t\t\t  argp->offset,\n\t\t\t   \t  rqstp->rq_vec, argp->vlen,\n\t\t\t\t  &resp->count);\n\n\tif (nfserr) return nfserr;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.h",
          "lines": "124-129",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_read",
          "args": [
            "rqstp",
            "fh_copy(&resp->fh, &argp->fh)",
            "argp->offset",
            "rqstp->rq_vec",
            "argp->vlen",
            "&resp->count"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1051-1067",
          "snippet": "__be32 nfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\tloff_t offset, struct kvec *vec, int vlen, unsigned long *count)\n{\n\tstruct file *file;\n\tstruct raparms\t*ra;\n\t__be32 err;\n\n\terr = nfsd_get_tmp_read_open(rqstp, fhp, &file, &ra);\n\tif (err)\n\t\treturn err;\n\n\terr = nfsd_vfs_read(rqstp, file, offset, vec, vlen, count);\n\n\tnfsd_put_tmp_read_open(file, ra);\n\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\tloff_t offset, struct kvec *vec, int vlen, unsigned long *count)\n{\n\tstruct file *file;\n\tstruct raparms\t*ra;\n\t__be32 err;\n\n\terr = nfsd_get_tmp_read_open(rqstp, fhp, &file, &ra);\n\tif (err)\n\t\treturn err;\n\n\terr = nfsd_vfs_read(rqstp, file, offset, vec, vlen, count);\n\n\tnfsd_put_tmp_read_open(file, ra);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "175-180",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_reserve_auth",
          "args": [
            "rqstp",
            "(19<<2) + argp->count + 4"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE\n\t\t\t\"oversized read request from %s (%d bytes)\\n\"",
            "svc_print_addr(rqstp, buf, sizeof(buf))",
            "argp->count"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_print_addr",
          "args": [
            "rqstp",
            "buf",
            "sizeof(buf)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: READ    %s %d bytes at %d\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->count",
            "argp->offset"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_read(struct svc_rqst *rqstp, struct nfsd_readargs *argp,\n\t\t\t\t       struct nfsd_readres  *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: READ    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->count, argp->offset);\n\n\t/* Obtain buffer pointer for payload. 19 is 1 word for\n\t * status, 17 words for fattr, and 1 word for the byte count.\n\t */\n\n\tif (NFSSVC_MAXBLKSIZE_V2 < argp->count) {\n\t\tchar buf[RPC_MAX_ADDRBUFLEN];\n\t\tprintk(KERN_NOTICE\n\t\t\t\"oversized read request from %s (%d bytes)\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)),\n\t\t\t\targp->count);\n\t\targp->count = NFSSVC_MAXBLKSIZE_V2;\n\t}\n\tsvc_reserve_auth(rqstp, (19<<2) + argp->count + 4);\n\n\tresp->count = argp->count;\n\tnfserr = nfsd_read(rqstp, fh_copy(&resp->fh, &argp->fh),\n\t\t\t\t  argp->offset,\n\t\t\t   \t  rqstp->rq_vec, argp->vlen,\n\t\t\t\t  &resp->count);\n\n\tif (nfserr) return nfserr;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
  },
  {
    "function_name": "nfsd_proc_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "98-112",
    "snippet": "static __be32\nnfsd_proc_readlink(struct svc_rqst *rqstp, struct nfsd_readlinkargs *argp,\n\t\t\t\t\t   struct nfsd_readlinkres *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: READLINK %s\\n\", SVCFH_fmt(&argp->fh));\n\n\t/* Read the symlink. */\n\tresp->len = NFS_MAXPATHLEN;\n\tnfserr = nfsd_readlink(rqstp, &argp->fh, argp->buffer, &resp->len);\n\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_readlink",
          "args": [
            "rqstp",
            "&argp->fh",
            "argp->buffer",
            "&resp->len"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "1501-1541",
          "snippet": "__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\tstruct inode\t*inode;\n\tmm_segment_t\toldfs;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tstruct path path;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\terr = nfserr_inval;\n\tif (!inode->i_op->readlink)\n\t\tgoto out;\n\n\ttouch_atime(&path);\n\t/* N.B. Why does this call need a get_fs()??\n\t * Remove the set_fs and watch the fireworks:-) --okir\n\t */\n\n\toldfs = get_fs(); set_fs(KERNEL_DS);\n\thost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\n\tset_fs(oldfs);\n\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\t*lenp = host_err;\n\terr = 0;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\tstruct inode\t*inode;\n\tmm_segment_t\toldfs;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tstruct path path;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = path.dentry->d_inode;\n\n\terr = nfserr_inval;\n\tif (!inode->i_op->readlink)\n\t\tgoto out;\n\n\ttouch_atime(&path);\n\t/* N.B. Why does this call need a get_fs()??\n\t * Remove the set_fs and watch the fireworks:-) --okir\n\t */\n\n\toldfs = get_fs(); set_fs(KERNEL_DS);\n\thost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\n\tset_fs(oldfs);\n\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\t*lenp = host_err;\n\terr = 0;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: READLINK %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_readlink(struct svc_rqst *rqstp, struct nfsd_readlinkargs *argp,\n\t\t\t\t\t   struct nfsd_readlinkres *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: READLINK %s\\n\", SVCFH_fmt(&argp->fh));\n\n\t/* Read the symlink. */\n\tresp->len = NFS_MAXPATHLEN;\n\tnfserr = nfsd_readlink(rqstp, &argp->fh, argp->buffer, &resp->len);\n\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "78-93",
    "snippet": "static __be32\nnfsd_proc_lookup(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t\t struct nfsd_diropres  *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: LOOKUP   %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tnfserr = nfsd_lookup(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t &resp->fh);\n\n\tfh_put(&argp->fh);\n\treturn nfsd_return_dirop(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_dirop",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_dirop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "31-36",
          "snippet": "static __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_lookup",
          "args": [
            "rqstp",
            "&argp->fh",
            "argp->name",
            "argp->len",
            "&resp->fh"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "251-279",
          "snippet": "__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && !dentry->d_inode)\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && !dentry->d_inode)\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&resp->fh",
            "NFS_FHSIZE"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: LOOKUP   %s %.*s\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->name"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_lookup(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t\t struct nfsd_diropres  *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: LOOKUP   %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tnfserr = nfsd_lookup(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t &resp->fh);\n\n\tfh_put(&argp->fh);\n\treturn nfsd_return_dirop(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "58-70",
    "snippet": "static __be32\nnfsd_proc_setattr(struct svc_rqst *rqstp, struct nfsd_sattrargs *argp,\n\t\t\t\t\t  struct nfsd_attrstat  *resp)\n{\n\t__be32 nfserr;\n\tdprintk(\"nfsd: SETATTR  %s, valid=%x, size=%ld\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->attrs.ia_valid, (long) argp->attrs.ia_size);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tnfserr = nfsd_setattr(rqstp, &resp->fh, &argp->attrs,0, (time_t)0);\n\treturn nfsd_return_attrs(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_attrs",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "25-30",
          "snippet": "static __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setattr",
          "args": [
            "rqstp",
            "&resp->fh",
            "&argp->attrs",
            "0",
            "(time_t)0"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.c",
          "lines": "397-480",
          "snippet": "__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = dentry->d_inode;\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "175-180",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: SETATTR  %s, valid=%x, size=%ld\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->attrs.ia_valid",
            "(long) argp->attrs.ia_size"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_setattr(struct svc_rqst *rqstp, struct nfsd_sattrargs *argp,\n\t\t\t\t\t  struct nfsd_attrstat  *resp)\n{\n\t__be32 nfserr;\n\tdprintk(\"nfsd: SETATTR  %s, valid=%x, size=%ld\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->attrs.ia_valid, (long) argp->attrs.ia_size);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tnfserr = nfsd_setattr(rqstp, &resp->fh, &argp->attrs,0, (time_t)0);\n\treturn nfsd_return_attrs(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "41-52",
    "snippet": "static __be32\nnfsd_proc_getattr(struct svc_rqst *rqstp, struct nfsd_fhandle  *argp,\n\t\t\t\t\t  struct nfsd_attrstat *resp)\n{\n\t__be32 nfserr;\n\tdprintk(\"nfsd: GETATTR  %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0,\n\t\t\tNFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);\n\treturn nfsd_return_attrs(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_attrs",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "25-30",
          "snippet": "static __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&resp->fh",
            "0",
            "NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "175-180",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: GETATTR  %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "650-664",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_getattr(struct svc_rqst *rqstp, struct nfsd_fhandle  *argp,\n\t\t\t\t\t  struct nfsd_attrstat *resp)\n{\n\t__be32 nfserr;\n\tdprintk(\"nfsd: GETATTR  %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0,\n\t\t\tNFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);\n\treturn nfsd_return_attrs(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_return_dirop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "31-36",
    "snippet": "static __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.h",
          "lines": "124-129",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
  },
  {
    "function_name": "nfsd_return_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "25-30",
    "snippet": "static __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/vfs.h",
          "lines": "124-129",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
  },
  {
    "function_name": "nfsd_proc_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
    "lines": "19-23",
    "snippet": "static __be32\nnfsd_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}"
  }
]