[
  {
    "function_name": "id_mode_to_cifs_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "1051-1119",
    "snippet": "int\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 nmode,\n\t\t\tkuid_t uid, kgid_t gid)\n{\n\tint rc = 0;\n\tint aclflag = CIFS_ACL_DACL; /* default flag to set */\n\t__u32 secdesclen = 0;\n\tstruct cifs_ntsd *pntsd = NULL; /* acl obtained from server */\n\tstruct cifs_ntsd *pnntsd = NULL; /* modified acl to be sent to server */\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tcifs_dbg(NOISY, \"set ACL from mode for %s\\n\", path);\n\n\t/* Get the security descriptor */\n\n\tif (tcon->ses->server->ops->get_acl == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t&secdesclen);\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Add three ACEs for owner, group, everyone getting rid of other ACEs\n\t * as chmod disables ACEs and set the security descriptor. Allocate\n\t * memory for the smb header, set security descriptor request security\n\t * descriptor parameters, and secuirty descriptor itself\n\t */\n\tsecdesclen = max_t(u32, secdesclen, DEFAULT_SEC_DESC_LEN);\n\tpnntsd = kmalloc(secdesclen, GFP_KERNEL);\n\tif (!pnntsd) {\n\t\tkfree(pntsd);\n\t\tcifs_put_tlink(tlink);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = build_sec_desc(pntsd, pnntsd, secdesclen, nmode, uid, gid,\n\t\t\t\t&aclflag);\n\n\tcifs_dbg(NOISY, \"build_sec_desc rc: %d\\n\", rc);\n\n\tif (tcon->ses->server->ops->set_acl == NULL)\n\t\trc = -EOPNOTSUPP;\n\n\tif (!rc) {\n\t\t/* Set the security descriptor */\n\t\trc = tcon->ses->server->ops->set_acl(pnntsd, secdesclen, inode,\n\t\t\t\t\t\t     path, aclflag);\n\t\tcifs_dbg(NOISY, \"set_cifs_acl rc: %d\\n\", rc);\n\t}\n\tcifs_put_tlink(tlink);\n\n\tkfree(pnntsd);\n\tkfree(pntsd);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pntsd"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pnntsd"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"set_cifs_acl rc: %d\\n\"",
            "rc"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->set_acl",
          "args": [
            "pnntsd",
            "secdesclen",
            "inode",
            "path",
            "aclflag"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"build_sec_desc rc: %d\\n\"",
            "rc"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_sec_desc",
          "args": [
            "pntsd",
            "pnntsd",
            "secdesclen",
            "nmode",
            "uid",
            "gid",
            "&aclflag"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "build_sec_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "789-865",
          "snippet": "static int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\n\t__u32 secdesclen, __u64 nmode, kuid_t uid, kgid_t gid, int *aclflag)\n{\n\tint rc = 0;\n\t__u32 dacloffset;\n\t__u32 ndacloffset;\n\t__u32 sidsoffset;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct cifs_acl *dacl_ptr = NULL;  /* no need for SACL ptr */\n\tstruct cifs_acl *ndacl_ptr = NULL; /* no need for SACL ptr */\n\n\tif (nmode != NO_CHANGE_64) { /* chmod */\n\t\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\t\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\t\tndacloffset = sizeof(struct cifs_ntsd);\n\t\tndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\n\t\tndacl_ptr->revision = dacl_ptr->revision;\n\t\tndacl_ptr->size = 0;\n\t\tndacl_ptr->num_aces = 0;\n\n\t\trc = set_chmod_dacl(ndacl_ptr, owner_sid_ptr, group_sid_ptr,\n\t\t\t\t\tnmode);\n\t\tsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\n\t\t/* copy sec desc control portion & owner and group sids */\n\t\tcopy_sec_desc(pntsd, pnntsd, sidsoffset);\n\t\t*aclflag = CIFS_ACL_DACL;\n\t} else {\n\t\tmemcpy(pnntsd, pntsd, secdesclen);\n\t\tif (uid_valid(uid)) { /* chown */\n\t\t\tuid_t id;\n\t\t\towner_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->osidoffset));\n\t\t\tnowner_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!nowner_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kuid(&init_user_ns, uid);\n\t\t\trc = id_to_sid(id, SIDOWNER, nowner_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for owner id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(nowner_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\t\tkfree(nowner_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_OWNER;\n\t\t}\n\t\tif (gid_valid(gid)) { /* chgrp */\n\t\t\tgid_t id;\n\t\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->gsidoffset));\n\t\t\tngroup_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ngroup_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kgid(&init_user_ns, gid);\n\t\t\trc = id_to_sid(id, SIDGROUP, ngroup_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for group id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_GROUP;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\n\t__u32 secdesclen, __u64 nmode, kuid_t uid, kgid_t gid, int *aclflag)\n{\n\tint rc = 0;\n\t__u32 dacloffset;\n\t__u32 ndacloffset;\n\t__u32 sidsoffset;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct cifs_acl *dacl_ptr = NULL;  /* no need for SACL ptr */\n\tstruct cifs_acl *ndacl_ptr = NULL; /* no need for SACL ptr */\n\n\tif (nmode != NO_CHANGE_64) { /* chmod */\n\t\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\t\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\t\tndacloffset = sizeof(struct cifs_ntsd);\n\t\tndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\n\t\tndacl_ptr->revision = dacl_ptr->revision;\n\t\tndacl_ptr->size = 0;\n\t\tndacl_ptr->num_aces = 0;\n\n\t\trc = set_chmod_dacl(ndacl_ptr, owner_sid_ptr, group_sid_ptr,\n\t\t\t\t\tnmode);\n\t\tsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\n\t\t/* copy sec desc control portion & owner and group sids */\n\t\tcopy_sec_desc(pntsd, pnntsd, sidsoffset);\n\t\t*aclflag = CIFS_ACL_DACL;\n\t} else {\n\t\tmemcpy(pnntsd, pntsd, secdesclen);\n\t\tif (uid_valid(uid)) { /* chown */\n\t\t\tuid_t id;\n\t\t\towner_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->osidoffset));\n\t\t\tnowner_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!nowner_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kuid(&init_user_ns, uid);\n\t\t\trc = id_to_sid(id, SIDOWNER, nowner_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for owner id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(nowner_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\t\tkfree(nowner_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_OWNER;\n\t\t}\n\t\tif (gid_valid(gid)) { /* chgrp */\n\t\t\tgid_t id;\n\t\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->gsidoffset));\n\t\t\tngroup_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ngroup_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kgid(&init_user_ns, gid);\n\t\t\trc = id_to_sid(id, SIDGROUP, ngroup_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for group id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_GROUP;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pntsd"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "secdesclen",
            "GFP_KERNEL"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u32",
            "secdesclen",
            "DEFAULT_SEC_DESC_LEN"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: error %d getting sec desc\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pntsd"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pntsd"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->get_acl",
          "args": [
            "cifs_sb",
            "inode",
            "path",
            "&secdesclen"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"set ACL from mode for %s\\n\"",
            "path"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 nmode,\n\t\t\tkuid_t uid, kgid_t gid)\n{\n\tint rc = 0;\n\tint aclflag = CIFS_ACL_DACL; /* default flag to set */\n\t__u32 secdesclen = 0;\n\tstruct cifs_ntsd *pntsd = NULL; /* acl obtained from server */\n\tstruct cifs_ntsd *pnntsd = NULL; /* modified acl to be sent to server */\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tcifs_dbg(NOISY, \"set ACL from mode for %s\\n\", path);\n\n\t/* Get the security descriptor */\n\n\tif (tcon->ses->server->ops->get_acl == NULL) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t&secdesclen);\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t\tcifs_put_tlink(tlink);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Add three ACEs for owner, group, everyone getting rid of other ACEs\n\t * as chmod disables ACEs and set the security descriptor. Allocate\n\t * memory for the smb header, set security descriptor request security\n\t * descriptor parameters, and secuirty descriptor itself\n\t */\n\tsecdesclen = max_t(u32, secdesclen, DEFAULT_SEC_DESC_LEN);\n\tpnntsd = kmalloc(secdesclen, GFP_KERNEL);\n\tif (!pnntsd) {\n\t\tkfree(pntsd);\n\t\tcifs_put_tlink(tlink);\n\t\treturn -ENOMEM;\n\t}\n\n\trc = build_sec_desc(pntsd, pnntsd, secdesclen, nmode, uid, gid,\n\t\t\t\t&aclflag);\n\n\tcifs_dbg(NOISY, \"build_sec_desc rc: %d\\n\", rc);\n\n\tif (tcon->ses->server->ops->set_acl == NULL)\n\t\trc = -EOPNOTSUPP;\n\n\tif (!rc) {\n\t\t/* Set the security descriptor */\n\t\trc = tcon->ses->server->ops->set_acl(pnntsd, secdesclen, inode,\n\t\t\t\t\t\t     path, aclflag);\n\t\tcifs_dbg(NOISY, \"set_cifs_acl rc: %d\\n\", rc);\n\t}\n\tcifs_put_tlink(tlink);\n\n\tkfree(pnntsd);\n\tkfree(pntsd);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_acl_to_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "1007-1048",
    "snippet": "int\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t  struct inode *inode, const char *path,\n\t\t  const struct cifs_fid *pfid)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu32 acllen = 0;\n\tint rc = 0;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(NOISY, \"converting ACL to mode for %s\\n\", path);\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (pfid && (tcon->ses->server->ops->get_acl_by_fid))\n\t\tpntsd = tcon->ses->server->ops->get_acl_by_fid(cifs_sb, pfid,\n\t\t\t\t\t\t\t  &acllen);\n\telse if (tcon->ses->server->ops->get_acl)\n\t\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t\t&acllen);\n\telse {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* if we can retrieve the ACL, now parse Access Control Entries, ACEs */\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t} else {\n\t\trc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr);\n\t\tkfree(pntsd);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"parse sec desc failed rc = %d\\n\", rc);\n\t}\n\n\tcifs_put_tlink(tlink);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"parse sec desc failed rc = %d\\n\"",
            "rc"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pntsd"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_sec_desc",
          "args": [
            "cifs_sb",
            "pntsd",
            "acllen",
            "fattr"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "parse_sec_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "731-786",
          "snippet": "static int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n/*\tcifs_dump_mem(\"owner_sid: \", owner_sid_ptr, 64); */\n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\"); /* BB grant all or default perms? */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n/*\tcifs_dump_mem(\"owner_sid: \", owner_sid_ptr, 64); */\n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\"); /* BB grant all or default perms? */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: error %d getting sec desc\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pntsd"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pntsd"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->get_acl",
          "args": [
            "cifs_sb",
            "inode",
            "path",
            "&acllen"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->get_acl_by_fid",
          "args": [
            "cifs_sb",
            "pfid",
            "&acllen"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"converting ACL to mode for %s\\n\"",
            "path"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\n\t\t  struct inode *inode, const char *path,\n\t\t  const struct cifs_fid *pfid)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu32 acllen = 0;\n\tint rc = 0;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(NOISY, \"converting ACL to mode for %s\\n\", path);\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\ttcon = tlink_tcon(tlink);\n\n\tif (pfid && (tcon->ses->server->ops->get_acl_by_fid))\n\t\tpntsd = tcon->ses->server->ops->get_acl_by_fid(cifs_sb, pfid,\n\t\t\t\t\t\t\t  &acllen);\n\telse if (tcon->ses->server->ops->get_acl)\n\t\tpntsd = tcon->ses->server->ops->get_acl(cifs_sb, inode, path,\n\t\t\t\t\t\t\t&acllen);\n\telse {\n\t\tcifs_put_tlink(tlink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\t/* if we can retrieve the ACL, now parse Access Control Entries, ACEs */\n\tif (IS_ERR(pntsd)) {\n\t\trc = PTR_ERR(pntsd);\n\t\tcifs_dbg(VFS, \"%s: error %d getting sec desc\\n\", __func__, rc);\n\t} else {\n\t\trc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr);\n\t\tkfree(pntsd);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"parse sec desc failed rc = %d\\n\", rc);\n\t}\n\n\tcifs_put_tlink(tlink);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "set_cifs_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "955-1004",
    "snippet": "int set_cifs_acl(struct cifs_ntsd *pnntsd, __u32 acllen,\n\t\t\tstruct inode *inode, const char *path, int aclflag)\n{\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, access_flags, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (aclflag == CIFS_ACL_OWNER || aclflag == CIFS_ACL_GROUP)\n\t\taccess_flags = WRITE_OWNER;\n\telse\n\t\taccess_flags = WRITE_DAC;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = access_flags;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Unable to open file to set ACL\\n\");\n\t\tgoto out;\n\t}\n\n\trc = CIFSSMBSetCIFSACL(xid, tcon, fid.netfid, pnntsd, acllen, aclflag);\n\tcifs_dbg(NOISY, \"SetCIFSACL rc = %d\\n\", rc);\n\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid.netfid"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"SetCIFSACL rc = %d\\n\"",
            "rc"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBSetCIFSACL",
          "args": [
            "xid",
            "tcon",
            "fid.netfid",
            "pnntsd",
            "acllen",
            "aclflag"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBSetCIFSACL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3890-3950",
          "snippet": "int\nCIFSSMBSetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen, int aclflag)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tvoid *pSMBr;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB, &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3 /* pad */  + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(aclflag);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *)pSMBr + offsetof(struct smb_hdr, Protocol) +\n\t\t\t\tdata_offset, pntsd, acllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcifs_dbg(FYI, \"SetCIFSACL bytes_returned: %d, rc: %d\\n\",\n\t\t bytes_returned, rc);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Set CIFS ACL returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen, int aclflag)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tvoid *pSMBr;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB, &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3 /* pad */  + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(aclflag);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *)pSMBr + offsetof(struct smb_hdr, Protocol) +\n\t\t\t\tdata_offset, pntsd, acllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcifs_dbg(FYI, \"SetCIFSACL bytes_returned: %d, rc: %d\\n\",\n\t\t bytes_returned, rc);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Set CIFS ACL returned %d\\n\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Unable to open file to set ACL\\n\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint set_cifs_acl(struct cifs_ntsd *pnntsd, __u32 acllen,\n\t\t\tstruct inode *inode, const char *path, int aclflag)\n{\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, access_flags, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (aclflag == CIFS_ACL_OWNER || aclflag == CIFS_ACL_GROUP)\n\t\taccess_flags = WRITE_OWNER;\n\telse\n\t\taccess_flags = WRITE_DAC;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = access_flags;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Unable to open file to set ACL\\n\");\n\t\tgoto out;\n\t}\n\n\trc = CIFSSMBSetCIFSACL(xid, tcon, fid.netfid, pnntsd, acllen, aclflag);\n\tcifs_dbg(NOISY, \"SetCIFSACL rc = %d\\n\", rc);\n\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
  },
  {
    "function_name": "get_cifs_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "937-952",
    "snippet": "struct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t\t      u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "open_file"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cifs_acl_by_fid",
          "args": [
            "cifs_sb",
            "&open_file->fid",
            "pacllen"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "get_cifs_acl_by_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "867-889",
          "snippet": "struct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\tconst struct cifs_fid *cifsfid, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), cifsfid->netfid, &pntsd,\n\t\t\t\tpacllen);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\tconst struct cifs_fid *cifsfid, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), cifsfid->netfid, &pntsd,\n\t\t\t\tpacllen);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cifs_acl_by_path",
          "args": [
            "cifs_sb",
            "path",
            "pacllen"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "get_cifs_acl_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "891-934",
          "snippet": "static struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\tconst char *path, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = READ_CONTROL;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (!rc) {\n\t\trc = CIFSSMBGetCIFSACL(xid, tcon, fid.netfid, &pntsd, pacllen);\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\tconst char *path, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = READ_CONTROL;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (!rc) {\n\t\trc = CIFSSMBGetCIFSACL(xid, tcon, fid.netfid, &pntsd, pacllen);\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_readable_file",
          "args": [
            "CIFS_I(inode)",
            "true"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1719-1751",
          "snippet": "struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\n\t/* we could simply get the first_list_entry since write-only entries\n\t   are always at the end of the list but since the first entry might\n\t   have a close pending, we go through the whole list */\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_READ) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good file */\n\t\t\t\t/* lock it so it will not be closed on us */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} /* else might as well continue, and look for\n\t\t\t     another, or simply have the caller reopen it\n\t\t\t     again rather than trying to fix this handle */\n\t\t} else /* write only file */\n\t\t\tbreak; /* write only files are last so must be done */\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file = NULL;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\n\t/* we could simply get the first_list_entry since write-only entries\n\t   are always at the end of the list but since the first entry might\n\t   have a close pending, we go through the whole list */\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_READ) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good file */\n\t\t\t\t/* lock it so it will not be closed on us */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} /* else might as well continue, and look for\n\t\t\t     another, or simply have the caller reopen it\n\t\t\t     again rather than trying to fix this handle */\n\t\t} else /* write only file */\n\t\t\tbreak; /* write only files are last so must be done */\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t\t      u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}"
  },
  {
    "function_name": "get_cifs_acl_by_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "891-934",
    "snippet": "static struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\tconst char *path, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = READ_CONTROL;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (!rc) {\n\t\trc = CIFSSMBGetCIFSACL(xid, tcon, fid.netfid, &pntsd, pacllen);\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: rc = %d ACL len %d\\n\"",
            "__func__",
            "rc",
            "*pacllen"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid.netfid"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBGetCIFSACL",
          "args": [
            "xid",
            "tcon",
            "fid.netfid",
            "&pntsd",
            "pacllen"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBGetCIFSACL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3801-3888",
          "snippet": "int\nCIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"GetCifsACL\\n\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8 /* parm len */, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t/* BB TEST with big acls that might need to be e.g. larger than 16K */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11); /* 3 bytes pad + 8 bytes parm */\n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovec */, &buf_type,\n\t\t\t 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySecDesc = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n/* validate_nttransact */\n\t\trc = validate_ntransact(iov[0].iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\n\n\t\tcifs_dbg(FYI, \"smb %p parm %p data %p\\n\",\n\t\t\t pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n/* BB check that data area is minimum length and as big as acl_len */\n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcifs_dbg(VFS, \"acl length %d does not match %d\\n\",\n\t\t\t\t acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t/* check if buffer is big enough for the acl\n\t\t   header followed by the smallest SID */\n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcifs_dbg(VFS, \"bad acl length %d\\n\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmemdup(pdata, *pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\nqsec_out:\n\tfree_rsp_buf(buf_type, iov[0].iov_base);\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"GetCifsACL\\n\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8 /* parm len */, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t/* BB TEST with big acls that might need to be e.g. larger than 16K */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11); /* 3 bytes pad + 8 bytes parm */\n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovec */, &buf_type,\n\t\t\t 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySecDesc = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n/* validate_nttransact */\n\t\trc = validate_ntransact(iov[0].iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\n\n\t\tcifs_dbg(FYI, \"smb %p parm %p data %p\\n\",\n\t\t\t pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n/* BB check that data area is minimum length and as big as acl_len */\n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcifs_dbg(VFS, \"acl length %d does not match %d\\n\",\n\t\t\t\t acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t/* check if buffer is big enough for the acl\n\t\t   header followed by the smallest SID */\n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcifs_dbg(VFS, \"bad acl length %d\\n\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmemdup(pdata, *pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\nqsec_out:\n\tfree_rsp_buf(buf_type, iov[0].iov_base);\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tlink"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\tconst char *path, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tint oplock = 0;\n\tunsigned int xid;\n\tint rc, create_options = 0;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = READ_CONTROL;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (!rc) {\n\t\trc = CIFSSMBGetCIFSACL(xid, tcon, fid.netfid, &pntsd, pacllen);\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}"
  },
  {
    "function_name": "get_cifs_acl_by_fid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "867-889",
    "snippet": "struct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\tconst struct cifs_fid *cifsfid, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), cifsfid->netfid, &pntsd,\n\t\t\t\tpacllen);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: rc = %d ACL len %d\\n\"",
            "__func__",
            "rc",
            "*pacllen"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBGetCIFSACL",
          "args": [
            "xid",
            "tlink_tcon(tlink)",
            "cifsfid->netfid",
            "&pntsd",
            "pacllen"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBGetCIFSACL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3801-3888",
          "snippet": "int\nCIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"GetCifsACL\\n\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8 /* parm len */, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t/* BB TEST with big acls that might need to be e.g. larger than 16K */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11); /* 3 bytes pad + 8 bytes parm */\n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovec */, &buf_type,\n\t\t\t 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySecDesc = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n/* validate_nttransact */\n\t\trc = validate_ntransact(iov[0].iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\n\n\t\tcifs_dbg(FYI, \"smb %p parm %p data %p\\n\",\n\t\t\t pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n/* BB check that data area is minimum length and as big as acl_len */\n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcifs_dbg(VFS, \"acl length %d does not match %d\\n\",\n\t\t\t\t acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t/* check if buffer is big enough for the acl\n\t\t   header followed by the smallest SID */\n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcifs_dbg(VFS, \"bad acl length %d\\n\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmemdup(pdata, *pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\nqsec_out:\n\tfree_rsp_buf(buf_type, iov[0].iov_base);\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t  struct cifs_ntsd **acl_inf, __u32 *pbuflen)\n{\n\tint rc = 0;\n\tint buf_type = 0;\n\tQUERY_SEC_DESC_REQ *pSMB;\n\tstruct kvec iov[1];\n\n\tcifs_dbg(FYI, \"GetCifsACL\\n\");\n\n\t*pbuflen = 0;\n\t*acl_inf = NULL;\n\n\trc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\n\t\t\t8 /* parm len */, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\t/* BB TEST with big acls that might need to be e.g. larger than 16K */\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\n\t\t\t\t     CIFS_ACL_DACL);\n\tpSMB->ByteCount = cpu_to_le16(11); /* 3 bytes pad + 8 bytes parm */\n\tinc_rfc1001_len(pSMB, 11);\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovec */, &buf_type,\n\t\t\t 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySecDesc = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\t__le32 *parm;\n\t\t__u32 parm_len;\n\t\t__u32 acl_len;\n\t\tstruct smb_com_ntransact_rsp *pSMBr;\n\t\tchar *pdata;\n\n/* validate_nttransact */\n\t\trc = validate_ntransact(iov[0].iov_base, (char **)&parm,\n\t\t\t\t\t&pdata, &parm_len, pbuflen);\n\t\tif (rc)\n\t\t\tgoto qsec_out;\n\t\tpSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\n\n\t\tcifs_dbg(FYI, \"smb %p parm %p data %p\\n\",\n\t\t\t pSMBr, parm, *acl_inf);\n\n\t\tif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\n\t\t\trc = -EIO;      /* bad smb */\n\t\t\t*pbuflen = 0;\n\t\t\tgoto qsec_out;\n\t\t}\n\n/* BB check that data area is minimum length and as big as acl_len */\n\n\t\tacl_len = le32_to_cpu(*parm);\n\t\tif (acl_len != *pbuflen) {\n\t\t\tcifs_dbg(VFS, \"acl length %d does not match %d\\n\",\n\t\t\t\t acl_len, *pbuflen);\n\t\t\tif (*pbuflen > acl_len)\n\t\t\t\t*pbuflen = acl_len;\n\t\t}\n\n\t\t/* check if buffer is big enough for the acl\n\t\t   header followed by the smallest SID */\n\t\tif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\n\t\t    (*pbuflen >= 64 * 1024)) {\n\t\t\tcifs_dbg(VFS, \"bad acl length %d\\n\", *pbuflen);\n\t\t\trc = -EINVAL;\n\t\t\t*pbuflen = 0;\n\t\t} else {\n\t\t\t*acl_inf = kmemdup(pdata, *pbuflen, GFP_KERNEL);\n\t\t\tif (*acl_inf == NULL) {\n\t\t\t\t*pbuflen = 0;\n\t\t\t\trc = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\nqsec_out:\n\tfree_rsp_buf(buf_type, iov[0].iov_base);\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tlink"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\n\t\tconst struct cifs_fid *cifsfid, u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tunsigned int xid;\n\tint rc;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\n\txid = get_xid();\n\trc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), cifsfid->netfid, &pntsd,\n\t\t\t\tpacllen);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}"
  },
  {
    "function_name": "build_sec_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "789-865",
    "snippet": "static int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\n\t__u32 secdesclen, __u64 nmode, kuid_t uid, kgid_t gid, int *aclflag)\n{\n\tint rc = 0;\n\t__u32 dacloffset;\n\t__u32 ndacloffset;\n\t__u32 sidsoffset;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct cifs_acl *dacl_ptr = NULL;  /* no need for SACL ptr */\n\tstruct cifs_acl *ndacl_ptr = NULL; /* no need for SACL ptr */\n\n\tif (nmode != NO_CHANGE_64) { /* chmod */\n\t\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\t\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\t\tndacloffset = sizeof(struct cifs_ntsd);\n\t\tndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\n\t\tndacl_ptr->revision = dacl_ptr->revision;\n\t\tndacl_ptr->size = 0;\n\t\tndacl_ptr->num_aces = 0;\n\n\t\trc = set_chmod_dacl(ndacl_ptr, owner_sid_ptr, group_sid_ptr,\n\t\t\t\t\tnmode);\n\t\tsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\n\t\t/* copy sec desc control portion & owner and group sids */\n\t\tcopy_sec_desc(pntsd, pnntsd, sidsoffset);\n\t\t*aclflag = CIFS_ACL_DACL;\n\t} else {\n\t\tmemcpy(pnntsd, pntsd, secdesclen);\n\t\tif (uid_valid(uid)) { /* chown */\n\t\t\tuid_t id;\n\t\t\towner_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->osidoffset));\n\t\t\tnowner_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!nowner_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kuid(&init_user_ns, uid);\n\t\t\trc = id_to_sid(id, SIDOWNER, nowner_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for owner id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(nowner_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\t\tkfree(nowner_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_OWNER;\n\t\t}\n\t\tif (gid_valid(gid)) { /* chgrp */\n\t\t\tgid_t id;\n\t\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->gsidoffset));\n\t\t\tngroup_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ngroup_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kgid(&init_user_ns, gid);\n\t\t\trc = id_to_sid(id, SIDGROUP, ngroup_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for group id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_GROUP;\n\t\t}\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ngroup_sid_ptr"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_copy_sid",
          "args": [
            "group_sid_ptr",
            "ngroup_sid_ptr"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_copy_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "187-198",
          "snippet": "static void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ngroup_sid_ptr"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Mapping error %d for group id %d\\n\"",
            "__func__",
            "rc",
            "id"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id_to_sid",
          "args": [
            "id",
            "SIDGROUP",
            "ngroup_sid_ptr"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "id_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "200-257",
          "snippet": "static int\nid_to_sid(unsigned int cid, uint sidtype, struct cifs_sid *ssid)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tstruct cifs_sid *ksid;\n\tunsigned int ksid_size;\n\tchar desc[3 + 10 + 1]; /* 3 byte prefix + 10 bytes for value + NULL */\n\tconst struct cred *saved_cred;\n\n\trc = snprintf(desc, sizeof(desc), \"%ci:%u\",\n\t\t\tsidtype == SIDOWNER ? 'o' : 'g', cid);\n\tif (rc >= sizeof(desc))\n\t\treturn -EINVAL;\n\n\trc = 0;\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, desc, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map %cid %u to a SID\\n\",\n\t\t\t __func__, sidtype == SIDOWNER ? 'u' : 'g', cid);\n\t\tgoto out_revert_creds;\n\t} else if (sidkey->datalen < CIFS_SID_BASE_SIZE) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tgoto invalidate_key;\n\t}\n\n\t/*\n\t * A sid is usually too large to be embedded in payload.value, but if\n\t * there are no subauthorities and the host has 8-byte pointers, then\n\t * it could be.\n\t */\n\tksid = sidkey->datalen <= sizeof(sidkey->payload) ?\n\t\t(struct cifs_sid *)&sidkey->payload.value :\n\t\t(struct cifs_sid *)sidkey->payload.data;\n\n\tksid_size = CIFS_SID_BASE_SIZE + (ksid->num_subauth * sizeof(__le32));\n\tif (ksid_size > sidkey->datalen) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\\n\",\n\t\t\t __func__, sidkey->datalen, ksid_size);\n\t\tgoto invalidate_key;\n\t}\n\n\tcifs_copy_sid(ssid, ksid);\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\treturn rc;\n\ninvalidate_key:\n\tkey_invalidate(sidkey);\n\tgoto out_key_put;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cred *root_cred;",
            "static struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cred *root_cred;\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nstatic int\nid_to_sid(unsigned int cid, uint sidtype, struct cifs_sid *ssid)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tstruct cifs_sid *ksid;\n\tunsigned int ksid_size;\n\tchar desc[3 + 10 + 1]; /* 3 byte prefix + 10 bytes for value + NULL */\n\tconst struct cred *saved_cred;\n\n\trc = snprintf(desc, sizeof(desc), \"%ci:%u\",\n\t\t\tsidtype == SIDOWNER ? 'o' : 'g', cid);\n\tif (rc >= sizeof(desc))\n\t\treturn -EINVAL;\n\n\trc = 0;\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, desc, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map %cid %u to a SID\\n\",\n\t\t\t __func__, sidtype == SIDOWNER ? 'u' : 'g', cid);\n\t\tgoto out_revert_creds;\n\t} else if (sidkey->datalen < CIFS_SID_BASE_SIZE) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tgoto invalidate_key;\n\t}\n\n\t/*\n\t * A sid is usually too large to be embedded in payload.value, but if\n\t * there are no subauthorities and the host has 8-byte pointers, then\n\t * it could be.\n\t */\n\tksid = sidkey->datalen <= sizeof(sidkey->payload) ?\n\t\t(struct cifs_sid *)&sidkey->payload.value :\n\t\t(struct cifs_sid *)sidkey->payload.data;\n\n\tksid_size = CIFS_SID_BASE_SIZE + (ksid->num_subauth * sizeof(__le32));\n\tif (ksid_size > sidkey->datalen) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\\n\",\n\t\t\t __func__, sidkey->datalen, ksid_size);\n\t\tgoto invalidate_key;\n\t}\n\n\tcifs_copy_sid(ssid, ksid);\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\treturn rc;\n\ninvalidate_key:\n\tkey_invalidate(sidkey);\n\tgoto out_key_put;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "gid"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct cifs_sid)",
            "GFP_KERNEL"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pnntsd->gsidoffset"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nowner_sid_ptr"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nowner_sid_ptr"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Mapping error %d for owner id %d\\n\"",
            "__func__",
            "rc",
            "id"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pnntsd",
            "pntsd",
            "secdesclen"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_sec_desc",
          "args": [
            "pntsd",
            "pnntsd",
            "sidsoffset"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "copy_sec_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "401-429",
          "snippet": "static void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\n\t/* copy security descriptor control portion */\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\n\t/* copy owner sid */\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\n\t/* copy group sid */\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\n\treturn;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\n\t/* copy security descriptor control portion */\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\n\t/* copy owner sid */\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\n\t/* copy group sid */\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ndacl_ptr->size"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_chmod_dacl",
          "args": [
            "ndacl_ptr",
            "owner_sid_ptr",
            "group_sid_ptr",
            "nmode"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "set_chmod_dacl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "675-694",
          "snippet": "static int set_chmod_dacl(struct cifs_acl *pndacl, struct cifs_sid *pownersid,\n\t\t\tstruct cifs_sid *pgrpsid, __u64 nmode)\n{\n\tu16 size = 0;\n\tstruct cifs_acl *pnndacl;\n\n\tpnndacl = (struct cifs_acl *)((char *)pndacl + sizeof(struct cifs_acl));\n\n\tsize += fill_ace_for_sid((struct cifs_ace *) ((char *)pnndacl + size),\n\t\t\t\t\tpownersid, nmode, S_IRWXU);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\tpgrpsid, nmode, S_IRWXG);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\t &sid_everyone, nmode, S_IRWXO);\n\n\tpndacl->size = cpu_to_le16(size + sizeof(struct cifs_acl));\n\tpndacl->num_aces = cpu_to_le32(3);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\n\nstatic int set_chmod_dacl(struct cifs_acl *pndacl, struct cifs_sid *pownersid,\n\t\t\tstruct cifs_sid *pgrpsid, __u64 nmode)\n{\n\tu16 size = 0;\n\tstruct cifs_acl *pnndacl;\n\n\tpnndacl = (struct cifs_acl *)((char *)pndacl + sizeof(struct cifs_acl));\n\n\tsize += fill_ace_for_sid((struct cifs_ace *) ((char *)pnndacl + size),\n\t\t\t\t\tpownersid, nmode, S_IRWXU);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\tpgrpsid, nmode, S_IRWXG);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\t &sid_everyone, nmode, S_IRWXO);\n\n\tpndacl->size = cpu_to_le16(size + sizeof(struct cifs_acl));\n\tpndacl->num_aces = cpu_to_le32(3);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\n\t__u32 secdesclen, __u64 nmode, kuid_t uid, kgid_t gid, int *aclflag)\n{\n\tint rc = 0;\n\t__u32 dacloffset;\n\t__u32 ndacloffset;\n\t__u32 sidsoffset;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tstruct cifs_acl *dacl_ptr = NULL;  /* no need for SACL ptr */\n\tstruct cifs_acl *ndacl_ptr = NULL; /* no need for SACL ptr */\n\n\tif (nmode != NO_CHANGE_64) { /* chmod */\n\t\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\t\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\t\tndacloffset = sizeof(struct cifs_ntsd);\n\t\tndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\n\t\tndacl_ptr->revision = dacl_ptr->revision;\n\t\tndacl_ptr->size = 0;\n\t\tndacl_ptr->num_aces = 0;\n\n\t\trc = set_chmod_dacl(ndacl_ptr, owner_sid_ptr, group_sid_ptr,\n\t\t\t\t\tnmode);\n\t\tsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\n\t\t/* copy sec desc control portion & owner and group sids */\n\t\tcopy_sec_desc(pntsd, pnntsd, sidsoffset);\n\t\t*aclflag = CIFS_ACL_DACL;\n\t} else {\n\t\tmemcpy(pnntsd, pntsd, secdesclen);\n\t\tif (uid_valid(uid)) { /* chown */\n\t\t\tuid_t id;\n\t\t\towner_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->osidoffset));\n\t\t\tnowner_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!nowner_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kuid(&init_user_ns, uid);\n\t\t\trc = id_to_sid(id, SIDOWNER, nowner_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for owner id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(nowner_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(owner_sid_ptr, nowner_sid_ptr);\n\t\t\tkfree(nowner_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_OWNER;\n\t\t}\n\t\tif (gid_valid(gid)) { /* chgrp */\n\t\t\tgid_t id;\n\t\t\tgroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\n\t\t\t\t\tle32_to_cpu(pnntsd->gsidoffset));\n\t\t\tngroup_sid_ptr = kmalloc(sizeof(struct cifs_sid),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!ngroup_sid_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tid = from_kgid(&init_user_ns, gid);\n\t\t\trc = id_to_sid(id, SIDGROUP, ngroup_sid_ptr);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(FYI, \"%s: Mapping error %d for group id %d\\n\",\n\t\t\t\t\t __func__, rc, id);\n\t\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tcifs_copy_sid(group_sid_ptr, ngroup_sid_ptr);\n\t\t\tkfree(ngroup_sid_ptr);\n\t\t\t*aclflag = CIFS_ACL_GROUP;\n\t\t}\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_sec_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "731-786",
    "snippet": "static int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n/*\tcifs_dump_mem(\"owner_sid: \", owner_sid_ptr, 64); */\n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\"); /* BB grant all or default perms? */\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"no ACL\\n\""
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_dacl",
          "args": [
            "dacl_ptr",
            "end_of_acl",
            "owner_sid_ptr",
            "group_sid_ptr",
            "fattr"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "parse_dacl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "583-672",
          "snippet": "static void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\n\t\t       struct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\n\t\t       struct cifs_fattr *fattr)\n{\n\tint i;\n\tint num_aces = 0;\n\tint acl_size;\n\tchar *acl_base;\n\tstruct cifs_ace **ppace;\n\n\t/* BB need to add parm so we can store the SID BB */\n\n\tif (!pdacl) {\n\t\t/* no DACL in the security descriptor, set\n\t\t   all the permissions for user/group/other */\n\t\tfattr->cf_mode |= S_IRWXUGO;\n\t\treturn;\n\t}\n\n\t/* validate that we do not go past end of acl */\n\tif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tcifs_dbg(NOISY, \"DACL revision %d size %d num aces %d\\n\",\n\t\t le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t le32_to_cpu(pdacl->num_aces));\n\n\t/* reset rwx permissions for user/group/other.\n\t   Also, if num_aces is 0 i.e. DACL has no ACEs,\n\t   user/group/other have no permissions */\n\tfattr->cf_mode &= ~(S_IRWXUGO);\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct cifs_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces > 0) {\n\t\tumode_t user_mask = S_IRWXU;\n\t\tumode_t group_mask = S_IRWXG;\n\t\tumode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO;\n\n\t\tif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\n\t\t\treturn;\n\t\tppace = kmalloc(num_aces * sizeof(struct cifs_ace *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ppace)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < num_aces; ++i) {\n\t\t\tppace[i] = (struct cifs_ace *) (acl_base + acl_size);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tdump_ace(ppace[i], end_of_acl);\n#endif\n\t\t\tif (compare_sids(&(ppace[i]->sid), pownersid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &user_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), pgrpsid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &group_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_everyone) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\n\n/*\t\t\tmemcpy((void *)(&(cifscred->aces[i])),\n\t\t\t\t(void *)ppace[i],\n\t\t\t\tsizeof(struct cifs_ace)); */\n\n\t\t\tacl_base = (char *)ppace[i];\n\t\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\t}\n\n\t\tkfree(ppace);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };",
            "static const struct cifs_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\nstatic const struct cifs_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} };\n\nstatic void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\n\t\t       struct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\n\t\t       struct cifs_fattr *fattr)\n{\n\tint i;\n\tint num_aces = 0;\n\tint acl_size;\n\tchar *acl_base;\n\tstruct cifs_ace **ppace;\n\n\t/* BB need to add parm so we can store the SID BB */\n\n\tif (!pdacl) {\n\t\t/* no DACL in the security descriptor, set\n\t\t   all the permissions for user/group/other */\n\t\tfattr->cf_mode |= S_IRWXUGO;\n\t\treturn;\n\t}\n\n\t/* validate that we do not go past end of acl */\n\tif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tcifs_dbg(NOISY, \"DACL revision %d size %d num aces %d\\n\",\n\t\t le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t le32_to_cpu(pdacl->num_aces));\n\n\t/* reset rwx permissions for user/group/other.\n\t   Also, if num_aces is 0 i.e. DACL has no ACEs,\n\t   user/group/other have no permissions */\n\tfattr->cf_mode &= ~(S_IRWXUGO);\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct cifs_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces > 0) {\n\t\tumode_t user_mask = S_IRWXU;\n\t\tumode_t group_mask = S_IRWXG;\n\t\tumode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO;\n\n\t\tif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\n\t\t\treturn;\n\t\tppace = kmalloc(num_aces * sizeof(struct cifs_ace *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ppace)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < num_aces; ++i) {\n\t\t\tppace[i] = (struct cifs_ace *) (acl_base + acl_size);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tdump_ace(ppace[i], end_of_acl);\n#endif\n\t\t\tif (compare_sids(&(ppace[i]->sid), pownersid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &user_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), pgrpsid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &group_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_everyone) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\n\n/*\t\t\tmemcpy((void *)(&(cifscred->aces[i])),\n\t\t\t\t(void *)ppace[i],\n\t\t\t\tsizeof(struct cifs_ace)); */\n\n\t\t\tacl_base = (char *)ppace[i];\n\t\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\t}\n\n\t\tkfree(ppace);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Error %d mapping Group SID to gid\\n\"",
            "__func__",
            "rc"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sid_to_id",
          "args": [
            "cifs_sb",
            "group_sid_ptr",
            "fattr",
            "SIDGROUP"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "sid_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "259-338",
          "snippet": "static int\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\tstruct cifs_fattr *fattr, uint sidtype)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->mnt_uid;\n\tkgid_t fgid = cifs_sb->mnt_gid;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, \"%s: %u subauthorities is too many!\\n\",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map SID %s to a %cid\\n\",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\n\t/*\n\t * FIXME: Here we assume that uid_t and gid_t are same size. It's\n\t * probably a safe assumption but might be better to check based on\n\t * sidtype.\n\t */\n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gid_valid(gid))\n\t\t\tfgid = gid;\n\t}\n\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\tkfree(sidstr);\n\n\t/*\n\t * Note that we return 0 here unconditionally. If the mapping\n\t * fails then we just fall back to using the mnt_uid/mnt_gid.\n\t */\n\tif (sidtype == SIDOWNER)\n\t\tfattr->cf_uid = fuid;\n\telse\n\t\tfattr->cf_gid = fgid;\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cred *root_cred;",
            "static struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cred *root_cred;\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nstatic int\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\tstruct cifs_fattr *fattr, uint sidtype)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->mnt_uid;\n\tkgid_t fgid = cifs_sb->mnt_gid;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, \"%s: %u subauthorities is too many!\\n\",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map SID %s to a %cid\\n\",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\n\t/*\n\t * FIXME: Here we assume that uid_t and gid_t are same size. It's\n\t * probably a safe assumption but might be better to check based on\n\t * sidtype.\n\t */\n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gid_valid(gid))\n\t\t\tfgid = gid;\n\t}\n\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\tkfree(sidstr);\n\n\t/*\n\t * Note that we return 0 here unconditionally. If the mapping\n\t * fails then we just fall back to using the mnt_uid/mnt_gid.\n\t */\n\tif (sidtype == SIDOWNER)\n\t\tfattr->cf_uid = fuid;\n\telse\n\t\tfattr->cf_gid = fgid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Error %d mapping Owner SID to gid\\n\"",
            "__func__",
            "rc"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_sid",
          "args": [
            "group_sid_ptr",
            "end_of_acl"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "parse_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "697-727",
          "snippet": "static int parse_sid(struct cifs_sid *psid, char *end_of_acl)\n{\n\t/* BB need to add parm so we can store the SID BB */\n\n\t/* validate that we do not go past end of ACL - sid must be at least 8\n\t   bytes long (assuming no sub-auths - e.g. the null SID */\n\tif (end_of_acl < (char *)psid + 8) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (psid->num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"SID revision %d num_auth %d\\n\",\n\t\t\t psid->revision, psid->num_subauth);\n\n\t\tfor (i = 0; i < psid->num_subauth; i++) {\n\t\t\tcifs_dbg(FYI, \"SID sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(psid->sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t\tcifs_dbg(FYI, \"RID 0x%x\\n\",\n\t\t\t le32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\n\t}\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int parse_sid(struct cifs_sid *psid, char *end_of_acl)\n{\n\t/* BB need to add parm so we can store the SID BB */\n\n\t/* validate that we do not go past end of ACL - sid must be at least 8\n\t   bytes long (assuming no sub-auths - e.g. the null SID */\n\tif (end_of_acl < (char *)psid + 8) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (psid->num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"SID revision %d num_auth %d\\n\",\n\t\t\t psid->revision, psid->num_subauth);\n\n\t\tfor (i = 0; i < psid->num_subauth; i++) {\n\t\t\tcifs_dbg(FYI, \"SID sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(psid->sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t\tcifs_dbg(FYI, \"RID 0x%x\\n\",\n\t\t\t le32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\n\t}\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Error %d mapping Owner SID to uid\\n\"",
            "__func__",
            "rc"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Error %d parsing Owner SID\\n\"",
            "__func__",
            "rc"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\"",
            "pntsd->revision",
            "pntsd->type",
            "le32_to_cpu(pntsd->osidoffset)",
            "le32_to_cpu(pntsd->gsidoffset)",
            "le32_to_cpu(pntsd->sacloffset)",
            "dacloffset"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pntsd->sacloffset"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n/*\tcifs_dump_mem(\"owner_sid: \", owner_sid_ptr, 64); */\n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\"); /* BB grant all or default perms? */\n\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "697-727",
    "snippet": "static int parse_sid(struct cifs_sid *psid, char *end_of_acl)\n{\n\t/* BB need to add parm so we can store the SID BB */\n\n\t/* validate that we do not go past end of ACL - sid must be at least 8\n\t   bytes long (assuming no sub-auths - e.g. the null SID */\n\tif (end_of_acl < (char *)psid + 8) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (psid->num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"SID revision %d num_auth %d\\n\",\n\t\t\t psid->revision, psid->num_subauth);\n\n\t\tfor (i = 0; i < psid->num_subauth; i++) {\n\t\t\tcifs_dbg(FYI, \"SID sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(psid->sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t\tcifs_dbg(FYI, \"RID 0x%x\\n\",\n\t\t\t le32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\n\t}\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"RID 0x%x\\n\"",
            "le32_to_cpu(psid->sub_auth[psid->num_subauth-1])"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "psid->sub_auth[psid->num_subauth-1]"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SID sub_auth[%d]: 0x%x\\n\"",
            "i",
            "le32_to_cpu(psid->sub_auth[i])"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SID revision %d num_auth %d\\n\"",
            "psid->revision",
            "psid->num_subauth"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"ACL too small to parse SID %p\\n\"",
            "psid"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int parse_sid(struct cifs_sid *psid, char *end_of_acl)\n{\n\t/* BB need to add parm so we can store the SID BB */\n\n\t/* validate that we do not go past end of ACL - sid must be at least 8\n\t   bytes long (assuming no sub-auths - e.g. the null SID */\n\tif (end_of_acl < (char *)psid + 8) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse SID %p\\n\", psid);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_CIFS_DEBUG2\n\tif (psid->num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"SID revision %d num_auth %d\\n\",\n\t\t\t psid->revision, psid->num_subauth);\n\n\t\tfor (i = 0; i < psid->num_subauth; i++) {\n\t\t\tcifs_dbg(FYI, \"SID sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(psid->sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t\tcifs_dbg(FYI, \"RID 0x%x\\n\",\n\t\t\t le32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_chmod_dacl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "675-694",
    "snippet": "static int set_chmod_dacl(struct cifs_acl *pndacl, struct cifs_sid *pownersid,\n\t\t\tstruct cifs_sid *pgrpsid, __u64 nmode)\n{\n\tu16 size = 0;\n\tstruct cifs_acl *pnndacl;\n\n\tpnndacl = (struct cifs_acl *)((char *)pndacl + sizeof(struct cifs_acl));\n\n\tsize += fill_ace_for_sid((struct cifs_ace *) ((char *)pnndacl + size),\n\t\t\t\t\tpownersid, nmode, S_IRWXU);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\tpgrpsid, nmode, S_IRWXG);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\t &sid_everyone, nmode, S_IRWXO);\n\n\tpndacl->size = cpu_to_le16(size + sizeof(struct cifs_acl));\n\tpndacl->num_aces = cpu_to_le32(3);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "3"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "size + sizeof(struct cifs_acl)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_ace_for_sid",
          "args": [
            "(struct cifs_ace *)((char *)pnndacl + size)",
            "&sid_everyone",
            "nmode",
            "S_IRWXO"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "fill_ace_for_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "518-543",
          "snippet": "static __u16 fill_ace_for_sid(struct cifs_ace *pntace,\n\t\t\tconst struct cifs_sid *psid, __u64 nmode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = ACCESS_ALLOWED;\n\tpntace->flags = 0x0;\n\tmode_to_access_flags(nmode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic __u16 fill_ace_for_sid(struct cifs_ace *pntace,\n\t\t\tconst struct cifs_sid *psid, __u64 nmode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = ACCESS_ALLOWED;\n\tpntace->flags = 0x0;\n\tmode_to_access_flags(nmode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\n\nstatic int set_chmod_dacl(struct cifs_acl *pndacl, struct cifs_sid *pownersid,\n\t\t\tstruct cifs_sid *pgrpsid, __u64 nmode)\n{\n\tu16 size = 0;\n\tstruct cifs_acl *pnndacl;\n\n\tpnndacl = (struct cifs_acl *)((char *)pndacl + sizeof(struct cifs_acl));\n\n\tsize += fill_ace_for_sid((struct cifs_ace *) ((char *)pnndacl + size),\n\t\t\t\t\tpownersid, nmode, S_IRWXU);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\tpgrpsid, nmode, S_IRWXG);\n\tsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\n\t\t\t\t\t &sid_everyone, nmode, S_IRWXO);\n\n\tpndacl->size = cpu_to_le16(size + sizeof(struct cifs_acl));\n\tpndacl->num_aces = cpu_to_le32(3);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_dacl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "583-672",
    "snippet": "static void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\n\t\t       struct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\n\t\t       struct cifs_fattr *fattr)\n{\n\tint i;\n\tint num_aces = 0;\n\tint acl_size;\n\tchar *acl_base;\n\tstruct cifs_ace **ppace;\n\n\t/* BB need to add parm so we can store the SID BB */\n\n\tif (!pdacl) {\n\t\t/* no DACL in the security descriptor, set\n\t\t   all the permissions for user/group/other */\n\t\tfattr->cf_mode |= S_IRWXUGO;\n\t\treturn;\n\t}\n\n\t/* validate that we do not go past end of acl */\n\tif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tcifs_dbg(NOISY, \"DACL revision %d size %d num aces %d\\n\",\n\t\t le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t le32_to_cpu(pdacl->num_aces));\n\n\t/* reset rwx permissions for user/group/other.\n\t   Also, if num_aces is 0 i.e. DACL has no ACEs,\n\t   user/group/other have no permissions */\n\tfattr->cf_mode &= ~(S_IRWXUGO);\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct cifs_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces > 0) {\n\t\tumode_t user_mask = S_IRWXU;\n\t\tumode_t group_mask = S_IRWXG;\n\t\tumode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO;\n\n\t\tif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\n\t\t\treturn;\n\t\tppace = kmalloc(num_aces * sizeof(struct cifs_ace *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ppace)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < num_aces; ++i) {\n\t\t\tppace[i] = (struct cifs_ace *) (acl_base + acl_size);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tdump_ace(ppace[i], end_of_acl);\n#endif\n\t\t\tif (compare_sids(&(ppace[i]->sid), pownersid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &user_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), pgrpsid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &group_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_everyone) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\n\n/*\t\t\tmemcpy((void *)(&(cifscred->aces[i])),\n\t\t\t\t(void *)ppace[i],\n\t\t\t\tsizeof(struct cifs_ace)); */\n\n\t\t\tacl_base = (char *)ppace[i];\n\t\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\t}\n\n\t\tkfree(ppace);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };",
      "static const struct cifs_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ppace"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ppace[i]->size"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_flags_to_mode",
          "args": [
            "ppace[i]->access_req",
            "ppace[i]->type",
            "&fattr->cf_mode",
            "&other_mask"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "access_flags_to_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "437-486",
          "snippet": "static void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pbits_to_set)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t/* the order of ACEs is important.  The canonical order is to begin with\n\t   DENY entries followed by ALLOW, otherwise an allow entry could be\n\t   encountered first, making the subsequent deny entry like \"dead code\"\n\t   which would be superflous since Windows stops when a match is made\n\t   for the operation you are trying to perform for your user */\n\n\t/* For deny ACEs we change the mask so that subsequent allow access\n\t   control entries do not turn on the bits we are denying */\n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL)\n\t\t\t*pbits_to_set &= ~S_IRWXUGO;\n\n\t\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IWUGO;\n\t\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IRUGO;\n\t\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IXUGO;\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t/* else ACCESS_ALLOWED type */\n\n\tif (flags & GENERIC_ALL) {\n\t\t*pmode |= (S_IRWXUGO & (*pbits_to_set));\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t*pmode |= (S_IWUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t*pmode |= (S_IRUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t*pmode |= (S_IXUGO & (*pbits_to_set));\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now 0x%x\\n\", flags, *pmode);\n\treturn;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pbits_to_set)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t/* the order of ACEs is important.  The canonical order is to begin with\n\t   DENY entries followed by ALLOW, otherwise an allow entry could be\n\t   encountered first, making the subsequent deny entry like \"dead code\"\n\t   which would be superflous since Windows stops when a match is made\n\t   for the operation you are trying to perform for your user */\n\n\t/* For deny ACEs we change the mask so that subsequent allow access\n\t   control entries do not turn on the bits we are denying */\n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL)\n\t\t\t*pbits_to_set &= ~S_IRWXUGO;\n\n\t\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IWUGO;\n\t\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IRUGO;\n\t\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IXUGO;\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t/* else ACCESS_ALLOWED type */\n\n\tif (flags & GENERIC_ALL) {\n\t\t*pmode |= (S_IRWXUGO & (*pbits_to_set));\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t*pmode |= (S_IWUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t*pmode |= (S_IRUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t*pmode |= (S_IXUGO & (*pbits_to_set));\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now 0x%x\\n\", flags, *pmode);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_sids",
          "args": [
            "&(ppace[i]->sid)",
            "&sid_authusers"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "compare_sids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "141-185",
          "snippet": "static int\ncompare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif ((!ctsid) || (!cwsid))\n\t\treturn 1;\n\n\t/* compare the revision */\n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* compare all of the six auth values */\n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* compare all of the subauth values if any */\n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t\tle32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0; /* sids compare/match */\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncompare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif ((!ctsid) || (!cwsid))\n\t\treturn 1;\n\n\t/* compare the revision */\n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* compare all of the six auth values */\n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* compare all of the subauth values if any */\n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t\tle32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0; /* sids compare/match */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_ace",
          "args": [
            "ppace[i]",
            "end_of_acl"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "dump_ace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "547-579",
          "snippet": "static void dump_ace(struct cifs_ace *pace, char *end_of_acl)\n{\n\tint num_subauth;\n\n\t/* validate that we do not go past end of acl */\n\n\tif (le16_to_cpu(pace->size) < 16) {\n\t\tcifs_dbg(VFS, \"ACE too small %d\\n\", le16_to_cpu(pace->size));\n\t\treturn;\n\t}\n\n\tif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse ACE\\n\");\n\t\treturn;\n\t}\n\n\tnum_subauth = pace->sid.num_subauth;\n\tif (num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"ACE revision %d num_auth %d type %d flags %d size %d\\n\",\n\t\t\t pace->sid.revision, pace->sid.num_subauth, pace->type,\n\t\t\t pace->flags, le16_to_cpu(pace->size));\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tcifs_dbg(FYI, \"ACE sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(pace->sid.sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dump_ace(struct cifs_ace *pace, char *end_of_acl)\n{\n\tint num_subauth;\n\n\t/* validate that we do not go past end of acl */\n\n\tif (le16_to_cpu(pace->size) < 16) {\n\t\tcifs_dbg(VFS, \"ACE too small %d\\n\", le16_to_cpu(pace->size));\n\t\treturn;\n\t}\n\n\tif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse ACE\\n\");\n\t\treturn;\n\t}\n\n\tnum_subauth = pace->sid.num_subauth;\n\tif (num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"ACE revision %d num_auth %d type %d flags %d size %d\\n\",\n\t\t\t pace->sid.revision, pace->sid.num_subauth, pace->type,\n\t\t\t pace->flags, le16_to_cpu(pace->size));\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tcifs_dbg(FYI, \"ACE sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(pace->sid.sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "num_aces * sizeof(struct cifs_ace *)",
            "GFP_KERNEL"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pdacl->num_aces"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"DACL revision %d size %d num aces %d\\n\"",
            "le16_to_cpu(pdacl->revision)",
            "le16_to_cpu(pdacl->size)",
            "le32_to_cpu(pdacl->num_aces)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"ACL too small to parse DACL\\n\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cifs_sid sid_everyone = {\n\t1, 1, {0, 0, 0, 0, 0, 1}, {0} };\nstatic const struct cifs_sid sid_authusers = {\n\t1, 1, {0, 0, 0, 0, 0, 5}, {cpu_to_le32(11)} };\n\nstatic void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\n\t\t       struct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\n\t\t       struct cifs_fattr *fattr)\n{\n\tint i;\n\tint num_aces = 0;\n\tint acl_size;\n\tchar *acl_base;\n\tstruct cifs_ace **ppace;\n\n\t/* BB need to add parm so we can store the SID BB */\n\n\tif (!pdacl) {\n\t\t/* no DACL in the security descriptor, set\n\t\t   all the permissions for user/group/other */\n\t\tfattr->cf_mode |= S_IRWXUGO;\n\t\treturn;\n\t}\n\n\t/* validate that we do not go past end of acl */\n\tif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse DACL\\n\");\n\t\treturn;\n\t}\n\n\tcifs_dbg(NOISY, \"DACL revision %d size %d num aces %d\\n\",\n\t\t le16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\n\t\t le32_to_cpu(pdacl->num_aces));\n\n\t/* reset rwx permissions for user/group/other.\n\t   Also, if num_aces is 0 i.e. DACL has no ACEs,\n\t   user/group/other have no permissions */\n\tfattr->cf_mode &= ~(S_IRWXUGO);\n\n\tacl_base = (char *)pdacl;\n\tacl_size = sizeof(struct cifs_acl);\n\n\tnum_aces = le32_to_cpu(pdacl->num_aces);\n\tif (num_aces > 0) {\n\t\tumode_t user_mask = S_IRWXU;\n\t\tumode_t group_mask = S_IRWXG;\n\t\tumode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO;\n\n\t\tif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\n\t\t\treturn;\n\t\tppace = kmalloc(num_aces * sizeof(struct cifs_ace *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ppace)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < num_aces; ++i) {\n\t\t\tppace[i] = (struct cifs_ace *) (acl_base + acl_size);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tdump_ace(ppace[i], end_of_acl);\n#endif\n\t\t\tif (compare_sids(&(ppace[i]->sid), pownersid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &user_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), pgrpsid) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &group_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_everyone) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\t\t\tif (compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)\n\t\t\t\taccess_flags_to_mode(ppace[i]->access_req,\n\t\t\t\t\t\t     ppace[i]->type,\n\t\t\t\t\t\t     &fattr->cf_mode,\n\t\t\t\t\t\t     &other_mask);\n\n\n/*\t\t\tmemcpy((void *)(&(cifscred->aces[i])),\n\t\t\t\t(void *)ppace[i],\n\t\t\t\tsizeof(struct cifs_ace)); */\n\n\t\t\tacl_base = (char *)ppace[i];\n\t\t\tacl_size = le16_to_cpu(ppace[i]->size);\n\t\t}\n\n\t\tkfree(ppace);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "dump_ace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "547-579",
    "snippet": "static void dump_ace(struct cifs_ace *pace, char *end_of_acl)\n{\n\tint num_subauth;\n\n\t/* validate that we do not go past end of acl */\n\n\tif (le16_to_cpu(pace->size) < 16) {\n\t\tcifs_dbg(VFS, \"ACE too small %d\\n\", le16_to_cpu(pace->size));\n\t\treturn;\n\t}\n\n\tif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse ACE\\n\");\n\t\treturn;\n\t}\n\n\tnum_subauth = pace->sid.num_subauth;\n\tif (num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"ACE revision %d num_auth %d type %d flags %d size %d\\n\",\n\t\t\t pace->sid.revision, pace->sid.num_subauth, pace->type,\n\t\t\t pace->flags, le16_to_cpu(pace->size));\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tcifs_dbg(FYI, \"ACE sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(pace->sid.sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"ACE sub_auth[%d]: 0x%x\\n\"",
            "i",
            "le32_to_cpu(pace->sid.sub_auth[i])"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pace->sid.sub_auth[i]"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"ACE revision %d num_auth %d type %d flags %d size %d\\n\"",
            "pace->sid.revision",
            "pace->sid.num_subauth",
            "pace->type",
            "pace->flags",
            "le16_to_cpu(pace->size)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pace->size"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"ACL too small to parse ACE\\n\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"ACE too small %d\\n\"",
            "le16_to_cpu(pace->size)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dump_ace(struct cifs_ace *pace, char *end_of_acl)\n{\n\tint num_subauth;\n\n\t/* validate that we do not go past end of acl */\n\n\tif (le16_to_cpu(pace->size) < 16) {\n\t\tcifs_dbg(VFS, \"ACE too small %d\\n\", le16_to_cpu(pace->size));\n\t\treturn;\n\t}\n\n\tif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\n\t\tcifs_dbg(VFS, \"ACL too small to parse ACE\\n\");\n\t\treturn;\n\t}\n\n\tnum_subauth = pace->sid.num_subauth;\n\tif (num_subauth) {\n\t\tint i;\n\t\tcifs_dbg(FYI, \"ACE revision %d num_auth %d type %d flags %d size %d\\n\",\n\t\t\t pace->sid.revision, pace->sid.num_subauth, pace->type,\n\t\t\t pace->flags, le16_to_cpu(pace->size));\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tcifs_dbg(FYI, \"ACE sub_auth[%d]: 0x%x\\n\",\n\t\t\t\t i, le32_to_cpu(pace->sid.sub_auth[i]));\n\t\t}\n\n\t\t/* BB add length check to make sure that we do not have huge\n\t\t\tnum auths and therefore go off the end */\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "fill_ace_for_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "518-543",
    "snippet": "static __u16 fill_ace_for_sid(struct cifs_ace *pntace,\n\t\t\tconst struct cifs_sid *psid, __u64 nmode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = ACCESS_ALLOWED;\n\tpntace->flags = 0x0;\n\tmode_to_access_flags(nmode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "size"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "access_req"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mode_to_access_flags",
          "args": [
            "nmode",
            "bits",
            "&access_req"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "mode_to_access_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "494-516",
          "snippet": "static void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t__u32 *pace_flags)\n{\n\t/* reset access mask */\n\t*pace_flags = 0x0;\n\n\t/* bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */\n\tmode &= bits_to_use;\n\n\t/* check for R/W/X UGO since we do not know whose flags\n\t   is this but we have cleared all the bits sans RWX for\n\t   either user or group or other as per bits_to_use */\n\tif (mode & S_IRUGO)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & S_IWUGO)\n\t\t*pace_flags |= SET_FILE_WRITE_RIGHTS;\n\tif (mode & S_IXUGO)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tcifs_dbg(NOISY, \"mode: 0x%x, access flags now 0x%x\\n\",\n\t\t mode, *pace_flags);\n\treturn;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t__u32 *pace_flags)\n{\n\t/* reset access mask */\n\t*pace_flags = 0x0;\n\n\t/* bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */\n\tmode &= bits_to_use;\n\n\t/* check for R/W/X UGO since we do not know whose flags\n\t   is this but we have cleared all the bits sans RWX for\n\t   either user or group or other as per bits_to_use */\n\tif (mode & S_IRUGO)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & S_IWUGO)\n\t\t*pace_flags |= SET_FILE_WRITE_RIGHTS;\n\tif (mode & S_IXUGO)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tcifs_dbg(NOISY, \"mode: 0x%x, access flags now 0x%x\\n\",\n\t\t mode, *pace_flags);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic __u16 fill_ace_for_sid(struct cifs_ace *pntace,\n\t\t\tconst struct cifs_sid *psid, __u64 nmode, umode_t bits)\n{\n\tint i;\n\t__u16 size = 0;\n\t__u32 access_req = 0;\n\n\tpntace->type = ACCESS_ALLOWED;\n\tpntace->flags = 0x0;\n\tmode_to_access_flags(nmode, bits, &access_req);\n\tif (!access_req)\n\t\taccess_req = SET_MINIMUM_RIGHTS;\n\tpntace->access_req = cpu_to_le32(access_req);\n\n\tpntace->sid.revision = psid->revision;\n\tpntace->sid.num_subauth = psid->num_subauth;\n\tfor (i = 0; i < NUM_AUTHS; i++)\n\t\tpntace->sid.authority[i] = psid->authority[i];\n\tfor (i = 0; i < psid->num_subauth; i++)\n\t\tpntace->sid.sub_auth[i] = psid->sub_auth[i];\n\n\tsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\n\tpntace->size = cpu_to_le16(size);\n\n\treturn size;\n}"
  },
  {
    "function_name": "mode_to_access_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "494-516",
    "snippet": "static void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t__u32 *pace_flags)\n{\n\t/* reset access mask */\n\t*pace_flags = 0x0;\n\n\t/* bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */\n\tmode &= bits_to_use;\n\n\t/* check for R/W/X UGO since we do not know whose flags\n\t   is this but we have cleared all the bits sans RWX for\n\t   either user or group or other as per bits_to_use */\n\tif (mode & S_IRUGO)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & S_IWUGO)\n\t\t*pace_flags |= SET_FILE_WRITE_RIGHTS;\n\tif (mode & S_IXUGO)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tcifs_dbg(NOISY, \"mode: 0x%x, access flags now 0x%x\\n\",\n\t\t mode, *pace_flags);\n\treturn;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"mode: 0x%x, access flags now 0x%x\\n\"",
            "mode",
            "*pace_flags"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\n\t\t\t\t__u32 *pace_flags)\n{\n\t/* reset access mask */\n\t*pace_flags = 0x0;\n\n\t/* bits to use are either S_IRWXU or S_IRWXG or S_IRWXO */\n\tmode &= bits_to_use;\n\n\t/* check for R/W/X UGO since we do not know whose flags\n\t   is this but we have cleared all the bits sans RWX for\n\t   either user or group or other as per bits_to_use */\n\tif (mode & S_IRUGO)\n\t\t*pace_flags |= SET_FILE_READ_RIGHTS;\n\tif (mode & S_IWUGO)\n\t\t*pace_flags |= SET_FILE_WRITE_RIGHTS;\n\tif (mode & S_IXUGO)\n\t\t*pace_flags |= SET_FILE_EXEC_RIGHTS;\n\n\tcifs_dbg(NOISY, \"mode: 0x%x, access flags now 0x%x\\n\",\n\t\t mode, *pace_flags);\n\treturn;\n}"
  },
  {
    "function_name": "access_flags_to_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "437-486",
    "snippet": "static void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pbits_to_set)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t/* the order of ACEs is important.  The canonical order is to begin with\n\t   DENY entries followed by ALLOW, otherwise an allow entry could be\n\t   encountered first, making the subsequent deny entry like \"dead code\"\n\t   which would be superflous since Windows stops when a match is made\n\t   for the operation you are trying to perform for your user */\n\n\t/* For deny ACEs we change the mask so that subsequent allow access\n\t   control entries do not turn on the bits we are denying */\n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL)\n\t\t\t*pbits_to_set &= ~S_IRWXUGO;\n\n\t\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IWUGO;\n\t\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IRUGO;\n\t\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IXUGO;\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t/* else ACCESS_ALLOWED type */\n\n\tif (flags & GENERIC_ALL) {\n\t\t*pmode |= (S_IRWXUGO & (*pbits_to_set));\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t*pmode |= (S_IWUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t*pmode |= (S_IRUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t*pmode |= (S_IXUGO & (*pbits_to_set));\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now 0x%x\\n\", flags, *pmode);\n\treturn;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"access flags 0x%x mode now 0x%x\\n\"",
            "flags",
            "*pmode"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"all perms\\n\""
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"unknown access control type %d\\n\"",
            "type"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ace_flags"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pbits_to_set)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t/* the order of ACEs is important.  The canonical order is to begin with\n\t   DENY entries followed by ALLOW, otherwise an allow entry could be\n\t   encountered first, making the subsequent deny entry like \"dead code\"\n\t   which would be superflous since Windows stops when a match is made\n\t   for the operation you are trying to perform for your user */\n\n\t/* For deny ACEs we change the mask so that subsequent allow access\n\t   control entries do not turn on the bits we are denying */\n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL)\n\t\t\t*pbits_to_set &= ~S_IRWXUGO;\n\n\t\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IWUGO;\n\t\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IRUGO;\n\t\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IXUGO;\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t/* else ACCESS_ALLOWED type */\n\n\tif (flags & GENERIC_ALL) {\n\t\t*pmode |= (S_IRWXUGO & (*pbits_to_set));\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t*pmode |= (S_IWUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t*pmode |= (S_IRUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t*pmode |= (S_IXUGO & (*pbits_to_set));\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now 0x%x\\n\", flags, *pmode);\n\treturn;\n}"
  },
  {
    "function_name": "copy_sec_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "401-429",
    "snippet": "static void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\n\t/* copy security descriptor control portion */\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\n\t/* copy owner sid */\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\n\t/* copy group sid */\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\n\treturn;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_copy_sid",
          "args": [
            "ngroup_sid_ptr",
            "group_sid_ptr"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_copy_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "187-198",
          "snippet": "static void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "pntsd->gsidoffset"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sidsoffset + sizeof(struct cifs_sid)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sidsoffset"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sizeof(struct cifs_ntsd)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\n\t/* copy security descriptor control portion */\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\n\t/* copy owner sid */\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\n\t/* copy group sid */\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\n\treturn;\n}"
  },
  {
    "function_name": "exit_cifs_idmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "391-398",
    "snippet": "void\nexit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cred *root_cred;",
      "static struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unregistered %s key type\\n\"",
            "cifs_idmap_key_type.name"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "root_cred"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_key_type",
          "args": [
            "&cifs_idmap_key_type"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_revoke",
          "args": [
            "root_cred->thread_keyring"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cred *root_cred;\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nvoid\nexit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}"
  },
  {
    "function_name": "init_cifs_idmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "340-389",
    "snippet": "int\ninit_cifs_idmap(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_idmap_key_type.name);\n\n\t/* create an override credential set with a special thread keyring in\n\t * which requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".cifs_idmap\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&cifs_idmap_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\troot_cred = cred;\n\n\tcifs_dbg(FYI, \"cifs idmap keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cred *root_cred;",
      "static struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cred"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "keyring"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs idmap keyring: %d\\n\"",
            "key_serial(keyring)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "keyring"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KEY_FLAG_ROOT_CAN_CLEAR",
            "&keyring->flags"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_key_type",
          "args": [
            "&cifs_idmap_key_type"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "keyring"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_alloc",
          "args": [
            "\".cifs_idmap\"",
            "GLOBAL_ROOT_UID",
            "GLOBAL_ROOT_GID",
            "cred",
            "(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ",
            "KEY_ALLOC_NOT_IN_QUOTA",
            "NULL"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_kernel_cred",
          "args": [
            "NULL"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Registering the %s key type\\n\"",
            "cifs_idmap_key_type.name"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cred *root_cred;\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nint\ninit_cifs_idmap(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_idmap_key_type.name);\n\n\t/* create an override credential set with a special thread keyring in\n\t * which requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".cifs_idmap\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&cifs_idmap_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\troot_cred = cred;\n\n\tcifs_dbg(FYI, \"cifs idmap keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}"
  },
  {
    "function_name": "sid_to_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "259-338",
    "snippet": "static int\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\tstruct cifs_fattr *fattr, uint sidtype)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->mnt_uid;\n\tkgid_t fgid = cifs_sb->mnt_gid;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, \"%s: %u subauthorities is too many!\\n\",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map SID %s to a %cid\\n\",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\n\t/*\n\t * FIXME: Here we assume that uid_t and gid_t are same size. It's\n\t * probably a safe assumption but might be better to check based on\n\t * sidtype.\n\t */\n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gid_valid(gid))\n\t\t\tfgid = gid;\n\t}\n\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\tkfree(sidstr);\n\n\t/*\n\t * Note that we return 0 here unconditionally. If the mapping\n\t * fails then we just fall back to using the mnt_uid/mnt_gid.\n\t */\n\tif (sidtype == SIDOWNER)\n\t\tfattr->cf_uid = fuid;\n\telse\n\t\tfattr->cf_gid = fgid;\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cred *root_cred;",
      "static struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sidstr"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "saved_cred"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "sidkey"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "id"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&id",
            "&sidkey->payload.value",
            "sizeof(gid_t)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "id"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&id",
            "&sidkey->payload.value",
            "sizeof(uid_t)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_invalidate",
          "args": [
            "sidkey"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Downcall contained malformed key (datalen=%hu)\\n\"",
            "__func__",
            "sidkey->datalen"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(uid_t) != sizeof(gid_t)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Can't map SID %s to a %cid\\n\"",
            "__func__",
            "sidstr",
            "sidtype == SIDOWNER ? 'u' : 'g'"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sidkey"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&cifs_idmap_key_type",
            "sidstr",
            "\"\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "root_cred"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sid_to_key_str",
          "args": [
            "psid",
            "sidtype"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "sid_to_key_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "89-135",
          "snippet": "static char *\nsid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\n{\n\tint i, len;\n\tunsigned int saval;\n\tchar *sidstr, *strptr;\n\tunsigned long long id_auth_val;\n\n\t/* 3 bytes for prefix */\n\tsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\n\t\t\t GFP_KERNEL);\n\tif (!sidstr)\n\t\treturn sidstr;\n\n\tstrptr = sidstr;\n\tlen = sprintf(strptr, \"%cs:S-%hhu\", type == SIDOWNER ? 'o' : 'g',\n\t\t\tsidptr->revision);\n\tstrptr += len;\n\n\t/* The authority field is a single 48-bit number */\n\tid_auth_val = (unsigned long long)sidptr->authority[5];\n\tid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\n\tid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\n\tid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\n\tid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\n\tid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\n\n\t/*\n\t * MS-DTYP states that if the authority is >= 2^32, then it should be\n\t * expressed as a hex value.\n\t */\n\tif (id_auth_val <= UINT_MAX)\n\t\tlen = sprintf(strptr, \"-%llu\", id_auth_val);\n\telse\n\t\tlen = sprintf(strptr, \"-0x%llx\", id_auth_val);\n\n\tstrptr += len;\n\n\tfor (i = 0; i < sidptr->num_subauth; ++i) {\n\t\tsaval = le32_to_cpu(sidptr->sub_auth[i]);\n\t\tlen = sprintf(strptr, \"-%u\", saval);\n\t\tstrptr += len;\n\t}\n\n\treturn sidstr;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic char *\nsid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\n{\n\tint i, len;\n\tunsigned int saval;\n\tchar *sidstr, *strptr;\n\tunsigned long long id_auth_val;\n\n\t/* 3 bytes for prefix */\n\tsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\n\t\t\t GFP_KERNEL);\n\tif (!sidstr)\n\t\treturn sidstr;\n\n\tstrptr = sidstr;\n\tlen = sprintf(strptr, \"%cs:S-%hhu\", type == SIDOWNER ? 'o' : 'g',\n\t\t\tsidptr->revision);\n\tstrptr += len;\n\n\t/* The authority field is a single 48-bit number */\n\tid_auth_val = (unsigned long long)sidptr->authority[5];\n\tid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\n\tid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\n\tid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\n\tid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\n\tid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\n\n\t/*\n\t * MS-DTYP states that if the authority is >= 2^32, then it should be\n\t * expressed as a hex value.\n\t */\n\tif (id_auth_val <= UINT_MAX)\n\t\tlen = sprintf(strptr, \"-%llu\", id_auth_val);\n\telse\n\t\tlen = sprintf(strptr, \"-0x%llx\", id_auth_val);\n\n\tstrptr += len;\n\n\tfor (i = 0; i < sidptr->num_subauth; ++i) {\n\t\tsaval = le32_to_cpu(sidptr->sub_auth[i]);\n\t\tlen = sprintf(strptr, \"-%u\", saval);\n\t\tstrptr += len;\n\t}\n\n\treturn sidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: %u subauthorities is too many!\\n\"",
            "__func__",
            "psid->num_subauth"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "psid->num_subauth > SID_MAX_SUB_AUTHORITIES"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cred *root_cred;\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nstatic int\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\n\t\tstruct cifs_fattr *fattr, uint sidtype)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tchar *sidstr;\n\tconst struct cred *saved_cred;\n\tkuid_t fuid = cifs_sb->mnt_uid;\n\tkgid_t fgid = cifs_sb->mnt_gid;\n\n\t/*\n\t * If we have too many subauthorities, then something is really wrong.\n\t * Just return an error.\n\t */\n\tif (unlikely(psid->num_subauth > SID_MAX_SUB_AUTHORITIES)) {\n\t\tcifs_dbg(FYI, \"%s: %u subauthorities is too many!\\n\",\n\t\t\t __func__, psid->num_subauth);\n\t\treturn -EIO;\n\t}\n\n\tsidstr = sid_to_key_str(psid, sidtype);\n\tif (!sidstr)\n\t\treturn -ENOMEM;\n\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, sidstr, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map SID %s to a %cid\\n\",\n\t\t\t __func__, sidstr, sidtype == SIDOWNER ? 'u' : 'g');\n\t\tgoto out_revert_creds;\n\t}\n\n\t/*\n\t * FIXME: Here we assume that uid_t and gid_t are same size. It's\n\t * probably a safe assumption but might be better to check based on\n\t * sidtype.\n\t */\n\tBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\n\tif (sidkey->datalen != sizeof(uid_t)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tkey_invalidate(sidkey);\n\t\tgoto out_key_put;\n\t}\n\n\tif (sidtype == SIDOWNER) {\n\t\tkuid_t uid;\n\t\tuid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(uid_t));\n\t\tuid = make_kuid(&init_user_ns, id);\n\t\tif (uid_valid(uid))\n\t\t\tfuid = uid;\n\t} else {\n\t\tkgid_t gid;\n\t\tgid_t id;\n\t\tmemcpy(&id, &sidkey->payload.value, sizeof(gid_t));\n\t\tgid = make_kgid(&init_user_ns, id);\n\t\tif (gid_valid(gid))\n\t\t\tfgid = gid;\n\t}\n\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\tkfree(sidstr);\n\n\t/*\n\t * Note that we return 0 here unconditionally. If the mapping\n\t * fails then we just fall back to using the mnt_uid/mnt_gid.\n\t */\n\tif (sidtype == SIDOWNER)\n\t\tfattr->cf_uid = fuid;\n\telse\n\t\tfattr->cf_gid = fgid;\n\treturn 0;\n}"
  },
  {
    "function_name": "id_to_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "200-257",
    "snippet": "static int\nid_to_sid(unsigned int cid, uint sidtype, struct cifs_sid *ssid)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tstruct cifs_sid *ksid;\n\tunsigned int ksid_size;\n\tchar desc[3 + 10 + 1]; /* 3 byte prefix + 10 bytes for value + NULL */\n\tconst struct cred *saved_cred;\n\n\trc = snprintf(desc, sizeof(desc), \"%ci:%u\",\n\t\t\tsidtype == SIDOWNER ? 'o' : 'g', cid);\n\tif (rc >= sizeof(desc))\n\t\treturn -EINVAL;\n\n\trc = 0;\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, desc, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map %cid %u to a SID\\n\",\n\t\t\t __func__, sidtype == SIDOWNER ? 'u' : 'g', cid);\n\t\tgoto out_revert_creds;\n\t} else if (sidkey->datalen < CIFS_SID_BASE_SIZE) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tgoto invalidate_key;\n\t}\n\n\t/*\n\t * A sid is usually too large to be embedded in payload.value, but if\n\t * there are no subauthorities and the host has 8-byte pointers, then\n\t * it could be.\n\t */\n\tksid = sidkey->datalen <= sizeof(sidkey->payload) ?\n\t\t(struct cifs_sid *)&sidkey->payload.value :\n\t\t(struct cifs_sid *)sidkey->payload.data;\n\n\tksid_size = CIFS_SID_BASE_SIZE + (ksid->num_subauth * sizeof(__le32));\n\tif (ksid_size > sidkey->datalen) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\\n\",\n\t\t\t __func__, sidkey->datalen, ksid_size);\n\t\tgoto invalidate_key;\n\t}\n\n\tcifs_copy_sid(ssid, ksid);\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\treturn rc;\n\ninvalidate_key:\n\tkey_invalidate(sidkey);\n\tgoto out_key_put;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cred *root_cred;",
      "static struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_invalidate",
          "args": [
            "sidkey"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "saved_cred"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "sidkey"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_copy_sid",
          "args": [
            "ssid",
            "ksid"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_copy_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
          "lines": "187-198",
          "snippet": "static void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\\n\"",
            "__func__",
            "sidkey->datalen",
            "ksid_size"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Downcall contained malformed key (datalen=%hu)\\n\"",
            "__func__",
            "sidkey->datalen"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Can't map %cid %u to a SID\\n\"",
            "__func__",
            "sidtype == SIDOWNER ? 'u' : 'g'",
            "cid"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sidkey"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&cifs_idmap_key_type",
            "desc",
            "\"\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "root_cred"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "desc",
            "sizeof(desc)",
            "\"%ci:%u\"",
            "sidtype == SIDOWNER ? 'o' : 'g'",
            "cid"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct cred *root_cred;\nstatic struct key_type cifs_idmap_key_type = {\n\t.name        = \"cifs.idmap\",\n\t.instantiate = cifs_idmap_key_instantiate,\n\t.destroy     = cifs_idmap_key_destroy,\n\t.describe    = user_describe,\n};\n\nstatic int\nid_to_sid(unsigned int cid, uint sidtype, struct cifs_sid *ssid)\n{\n\tint rc;\n\tstruct key *sidkey;\n\tstruct cifs_sid *ksid;\n\tunsigned int ksid_size;\n\tchar desc[3 + 10 + 1]; /* 3 byte prefix + 10 bytes for value + NULL */\n\tconst struct cred *saved_cred;\n\n\trc = snprintf(desc, sizeof(desc), \"%ci:%u\",\n\t\t\tsidtype == SIDOWNER ? 'o' : 'g', cid);\n\tif (rc >= sizeof(desc))\n\t\treturn -EINVAL;\n\n\trc = 0;\n\tsaved_cred = override_creds(root_cred);\n\tsidkey = request_key(&cifs_idmap_key_type, desc, \"\");\n\tif (IS_ERR(sidkey)) {\n\t\trc = -EINVAL;\n\t\tcifs_dbg(FYI, \"%s: Can't map %cid %u to a SID\\n\",\n\t\t\t __func__, sidtype == SIDOWNER ? 'u' : 'g', cid);\n\t\tgoto out_revert_creds;\n\t} else if (sidkey->datalen < CIFS_SID_BASE_SIZE) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu)\\n\",\n\t\t\t __func__, sidkey->datalen);\n\t\tgoto invalidate_key;\n\t}\n\n\t/*\n\t * A sid is usually too large to be embedded in payload.value, but if\n\t * there are no subauthorities and the host has 8-byte pointers, then\n\t * it could be.\n\t */\n\tksid = sidkey->datalen <= sizeof(sidkey->payload) ?\n\t\t(struct cifs_sid *)&sidkey->payload.value :\n\t\t(struct cifs_sid *)sidkey->payload.data;\n\n\tksid_size = CIFS_SID_BASE_SIZE + (ksid->num_subauth * sizeof(__le32));\n\tif (ksid_size > sidkey->datalen) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"%s: Downcall contained malformed key (datalen=%hu, ksid_size=%u)\\n\",\n\t\t\t __func__, sidkey->datalen, ksid_size);\n\t\tgoto invalidate_key;\n\t}\n\n\tcifs_copy_sid(ssid, ksid);\nout_key_put:\n\tkey_put(sidkey);\nout_revert_creds:\n\trevert_creds(saved_cred);\n\treturn rc;\n\ninvalidate_key:\n\tkey_invalidate(sidkey);\n\tgoto out_key_put;\n}"
  },
  {
    "function_name": "cifs_copy_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "187-198",
    "snippet": "static void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u8",
            "src->num_subauth",
            "SID_MAX_SUB_AUTHORITIES"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void\ncifs_copy_sid(struct cifs_sid *dst, const struct cifs_sid *src)\n{\n\tint i;\n\n\tdst->revision = src->revision;\n\tdst->num_subauth = min_t(u8, src->num_subauth, SID_MAX_SUB_AUTHORITIES);\n\tfor (i = 0; i < NUM_AUTHS; ++i)\n\t\tdst->authority[i] = src->authority[i];\n\tfor (i = 0; i < dst->num_subauth; ++i)\n\t\tdst->sub_auth[i] = src->sub_auth[i];\n}"
  },
  {
    "function_name": "compare_sids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "141-185",
    "snippet": "static int\ncompare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif ((!ctsid) || (!cwsid))\n\t\treturn 1;\n\n\t/* compare the revision */\n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* compare all of the six auth values */\n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* compare all of the subauth values if any */\n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t\tle32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0; /* sids compare/match */\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cwsid->sub_auth[i]"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncompare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\n{\n\tint i;\n\tint num_subauth, num_sat, num_saw;\n\n\tif ((!ctsid) || (!cwsid))\n\t\treturn 1;\n\n\t/* compare the revision */\n\tif (ctsid->revision != cwsid->revision) {\n\t\tif (ctsid->revision > cwsid->revision)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* compare all of the six auth values */\n\tfor (i = 0; i < NUM_AUTHS; ++i) {\n\t\tif (ctsid->authority[i] != cwsid->authority[i]) {\n\t\t\tif (ctsid->authority[i] > cwsid->authority[i])\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* compare all of the subauth values if any */\n\tnum_sat = ctsid->num_subauth;\n\tnum_saw = cwsid->num_subauth;\n\tnum_subauth = num_sat < num_saw ? num_sat : num_saw;\n\tif (num_subauth) {\n\t\tfor (i = 0; i < num_subauth; ++i) {\n\t\t\tif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\n\t\t\t\tif (le32_to_cpu(ctsid->sub_auth[i]) >\n\t\t\t\t\tle32_to_cpu(cwsid->sub_auth[i]))\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0; /* sids compare/match */\n}"
  },
  {
    "function_name": "sid_to_key_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "89-135",
    "snippet": "static char *\nsid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\n{\n\tint i, len;\n\tunsigned int saval;\n\tchar *sidstr, *strptr;\n\tunsigned long long id_auth_val;\n\n\t/* 3 bytes for prefix */\n\tsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\n\t\t\t GFP_KERNEL);\n\tif (!sidstr)\n\t\treturn sidstr;\n\n\tstrptr = sidstr;\n\tlen = sprintf(strptr, \"%cs:S-%hhu\", type == SIDOWNER ? 'o' : 'g',\n\t\t\tsidptr->revision);\n\tstrptr += len;\n\n\t/* The authority field is a single 48-bit number */\n\tid_auth_val = (unsigned long long)sidptr->authority[5];\n\tid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\n\tid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\n\tid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\n\tid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\n\tid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\n\n\t/*\n\t * MS-DTYP states that if the authority is >= 2^32, then it should be\n\t * expressed as a hex value.\n\t */\n\tif (id_auth_val <= UINT_MAX)\n\t\tlen = sprintf(strptr, \"-%llu\", id_auth_val);\n\telse\n\t\tlen = sprintf(strptr, \"-0x%llx\", id_auth_val);\n\n\tstrptr += len;\n\n\tfor (i = 0; i < sidptr->num_subauth; ++i) {\n\t\tsaval = le32_to_cpu(sidptr->sub_auth[i]);\n\t\tlen = sprintf(strptr, \"-%u\", saval);\n\t\tstrptr += len;\n\t}\n\n\treturn sidstr;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "strptr",
            "\"-%u\"",
            "saval"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sidptr->sub_auth[i]"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "strptr",
            "\"-0x%llx\"",
            "id_auth_val"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "strptr",
            "\"-%llu\"",
            "id_auth_val"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "strptr",
            "\"%cs:S-%hhu\"",
            "type == SIDOWNER ? 'o' : 'g'",
            "sidptr->revision"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth)",
            "GFP_KERNEL"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic char *\nsid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\n{\n\tint i, len;\n\tunsigned int saval;\n\tchar *sidstr, *strptr;\n\tunsigned long long id_auth_val;\n\n\t/* 3 bytes for prefix */\n\tsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\n\t\t\t GFP_KERNEL);\n\tif (!sidstr)\n\t\treturn sidstr;\n\n\tstrptr = sidstr;\n\tlen = sprintf(strptr, \"%cs:S-%hhu\", type == SIDOWNER ? 'o' : 'g',\n\t\t\tsidptr->revision);\n\tstrptr += len;\n\n\t/* The authority field is a single 48-bit number */\n\tid_auth_val = (unsigned long long)sidptr->authority[5];\n\tid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\n\tid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\n\tid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\n\tid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\n\tid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\n\n\t/*\n\t * MS-DTYP states that if the authority is >= 2^32, then it should be\n\t * expressed as a hex value.\n\t */\n\tif (id_auth_val <= UINT_MAX)\n\t\tlen = sprintf(strptr, \"-%llu\", id_auth_val);\n\telse\n\t\tlen = sprintf(strptr, \"-0x%llx\", id_auth_val);\n\n\tstrptr += len;\n\n\tfor (i = 0; i < sidptr->num_subauth; ++i) {\n\t\tsaval = le32_to_cpu(sidptr->sub_auth[i]);\n\t\tlen = sprintf(strptr, \"-%u\", saval);\n\t\tstrptr += len;\n\t}\n\n\treturn sidstr;\n}"
  },
  {
    "function_name": "cifs_idmap_key_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "75-80",
    "snippet": "static inline void\ncifs_idmap_key_destroy(struct key *key)\n{\n\tif (key->datalen > sizeof(key->payload))\n\t\tkfree(key->payload.data);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key->payload.data"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void\ncifs_idmap_key_destroy(struct key *key)\n{\n\tif (key->datalen > sizeof(key->payload))\n\t\tkfree(key->payload.data);\n}"
  },
  {
    "function_name": "cifs_idmap_key_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsacl.c",
    "lines": "47-73",
    "snippet": "static int\ncifs_idmap_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\n\t/*\n\t * If the payload is less than or equal to the size of a pointer, then\n\t * an allocation here is wasteful. Just copy the data directly to the\n\t * payload.value union member instead.\n\t *\n\t * With this however, you must check the datalen before trying to\n\t * dereference payload.data!\n\t */\n\tif (prep->datalen <= sizeof(key->payload)) {\n\t\tkey->payload.value = 0;\n\t\tmemcpy(&key->payload.value, prep->data, prep->datalen);\n\t\tkey->datalen = prep->datalen;\n\t\treturn 0;\n\t}\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\treturn -ENOMEM;\n\n\tkey->payload.data = payload;\n\tkey->datalen = prep->datalen;\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsacl.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <keys/user-type.h>",
      "#include <linux/key-type.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "prep->data",
            "prep->datalen",
            "GFP_KERNEL"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&key->payload.value",
            "prep->data",
            "prep->datalen"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_idmap_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tchar *payload;\n\n\t/*\n\t * If the payload is less than or equal to the size of a pointer, then\n\t * an allocation here is wasteful. Just copy the data directly to the\n\t * payload.value union member instead.\n\t *\n\t * With this however, you must check the datalen before trying to\n\t * dereference payload.data!\n\t */\n\tif (prep->datalen <= sizeof(key->payload)) {\n\t\tkey->payload.value = 0;\n\t\tmemcpy(&key->payload.value, prep->data, prep->datalen);\n\t\tkey->datalen = prep->datalen;\n\t\treturn 0;\n\t}\n\tpayload = kmemdup(prep->data, prep->datalen, GFP_KERNEL);\n\tif (!payload)\n\t\treturn -ENOMEM;\n\n\tkey->payload.data = payload;\n\tkey->datalen = prep->datalen;\n\treturn 0;\n}"
  }
]