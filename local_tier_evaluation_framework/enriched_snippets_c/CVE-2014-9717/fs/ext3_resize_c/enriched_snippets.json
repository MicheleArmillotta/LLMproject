[
  {
    "function_name": "ext3_group_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "991-1117",
    "snippet": "int ext3_group_extend(struct super_block *sb, struct ext3_super_block *es,\n\t\t      ext3_fsblk_t n_blocks_count)\n{\n\text3_fsblk_t o_blocks_count;\n\text3_grpblk_t last;\n\text3_grpblk_t add;\n\tstruct buffer_head * bh;\n\thandle_t *handle;\n\tint err;\n\tunsigned long freed_blocks;\n\n\t/* We don't need to worry about locking wrt other resizers just\n\t * yet: we're going to revalidate es->s_blocks_count after\n\t * taking the s_resize_lock below. */\n\to_blocks_count = le32_to_cpu(es->s_blocks_count);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extending last group from \"E3FSBLK\n\t\t       \" up to \"E3FSBLK\" blocks\\n\",\n\t\t       o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT3-fs: filesystem on %s:\"\n\t\t\t\" too large to resize to \"E3FSBLK\" blocks safely\\n\",\n\t\t\tsb->s_id, n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_warning(sb, __func__,\n\t\t\t\"CONFIG_LBDAF not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't shrink FS - resize aborted\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\tlast = (o_blocks_count - le32_to_cpu(es->s_first_data_block)) %\n\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\n\tif (last == 0) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT3_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"will only finish group (\"E3FSBLK\n\t\t\t     \" blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add -1);\n\tif (!bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext3_free_blocks().\n\t */\n\thandle = ext3_journal_start_sb(sb, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text3_warning(sb, __func__, \"error %d on journal start\",err);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&EXT3_SB(sb)->s_resize_lock);\n\tif (o_blocks_count != le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\terr = -EBUSY;\n\t\tgoto exit_put;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t EXT3_SB(sb)->s_sbh))) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal write access\", err);\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\tes->s_blocks_count = cpu_to_le32(o_blocks_count + add);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal dirty metadata\", err);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\text3_debug(\"freeing blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\text3_free_blocks_sb(handle, sb, o_blocks_count, add, &freed_blocks);\n\text3_debug(\"freed blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\tif ((err = ext3_journal_stop(handle)))\n\t\tgoto exit_put;\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extended group to %u blocks\\n\",\n\t\t       le32_to_cpu(es->s_blocks_count));\n\tupdate_backups(sb, EXT3_SB(sb)->s_sbh->b_blocknr, (char *)es,\n\t\t       sizeof(struct ext3_super_block));\nexit_put:\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_backups",
          "args": [
            "sb",
            "EXT3_SB(sb)->s_sbh->b_blocknr",
            "(char *)es",
            "sizeof(struct ext3_super_block)"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "update_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "694-768",
          "snippet": "static void update_backups(struct super_block *sb,\n\t\t\t   int blk_off, char *data, int size)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tconst unsigned long last = sbi->s_groups_count;\n\tconst int bpg = EXT3_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned group;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\twhile ((group = ext3_list_backups(sb, &three, &five, &seven)) < last) {\n\t\tstruct buffer_head *bh;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (handle->h_buffer_credits == 0 &&\n\t\t    ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA) &&\n\t\t    (err = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tbh = sb_getblk(sb, group * bpg + blk_off);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text3_debug(\"update metadata backup %#04lx\\n\",\n\t\t\t  (unsigned long)bh->b_blocknr);\n\t\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't update backup for group %d (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT3_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic void update_backups(struct super_block *sb,\n\t\t\t   int blk_off, char *data, int size)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tconst unsigned long last = sbi->s_groups_count;\n\tconst int bpg = EXT3_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned group;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\twhile ((group = ext3_list_backups(sb, &three, &five, &seven)) < last) {\n\t\tstruct buffer_head *bh;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (handle->h_buffer_credits == 0 &&\n\t\t    ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA) &&\n\t\t    (err = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tbh = sb_getblk(sb, group * bpg + blk_off);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text3_debug(\"update metadata backup %#04lx\\n\",\n\t\t\t  (unsigned long)bh->b_blocknr);\n\t\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't update backup for group %d (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT3_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"EXT3-fs: extended group to %u blocks\\n\"",
            "le32_to_cpu(es->s_blocks_count)"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_blocks_count"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"freed blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\"",
            "o_blocks_count",
            "o_blocks_count + add"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_free_blocks_sb",
          "args": [
            "handle",
            "sb",
            "o_blocks_count",
            "add",
            "&freed_blocks"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "490-671",
          "snippet": "void ext3_free_blocks_sb(handle_t *handle, struct super_block *sb,\n\t\t\t ext3_fsblk_t block, unsigned long count,\n\t\t\t unsigned long *pdquot_freed_blocks)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\tunsigned long block_group;\n\text3_grpblk_t bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0, ret;\n\text3_grpblk_t group_freed;\n\n\t*pdquot_freed_blocks = 0;\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = \"E3FSBLK\", count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text3_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT3_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT3_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\tdesc = ext3_get_group_desc (sb, block_group, &gd_bh);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = \"E3FSBLK\", count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * We are about to start releasing blocks in the bitmap,\n\t * so we need undo access.\n\t */\n\t/* @@@ check errors */\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tjbd_lock_bh_state(bitmap_bh);\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\t/*\n\t\t * An HJ special.  This is expensive...\n\t\t */\n#ifdef CONFIG_JBD_DEBUG\n\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t{\n\t\t\tstruct buffer_head *debug_bh;\n\t\t\tdebug_bh = sb_find_get_block(sb, block + i);\n\t\t\tif (debug_bh) {\n\t\t\t\tBUFFER_TRACE(debug_bh, \"Deleted!\");\n\t\t\t\tif (!bh2jh(bitmap_bh)->b_committed_data)\n\t\t\t\t\tBUFFER_TRACE(debug_bh,\n\t\t\t\t\t\t\"No committed data in bitmap\");\n\t\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap\");\n\t\t\t\t__brelse(debug_bh);\n\t\t\t}\n\t\t}\n\t\tjbd_lock_bh_state(bitmap_bh);\n#endif\n\t\tif (need_resched()) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\tcond_resched();\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t}\n\t\t/* @@@ This prevents newly-allocated data from being\n\t\t * freed and then reallocated within the same\n\t\t * transaction.\n\t\t *\n\t\t * Ideally we would want to allow that to happen, but to\n\t\t * do so requires making journal_forget() capable of\n\t\t * revoking the queued write of a data block, which\n\t\t * implies blocking on the journal lock.  *forget()\n\t\t * cannot block due to truncate races.\n\t\t *\n\t\t * Eventually we can fix this by making journal_forget()\n\t\t * return a status indicating whether or not it was able\n\t\t * to revoke the buffer.  On successful revoke, it is\n\t\t * safe not to set the allocation bit in the committed\n\t\t * bitmap, because we know that there is no outstanding\n\t\t * activity on the buffer any more and so it is safe to\n\t\t * reallocate it.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"set in b_committed_data\");\n\t\tJ_ASSERT_BH(bitmap_bh,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data != NULL);\n\t\text3_set_bit_atomic(sb_bgl_lock(sbi, block_group), bit + i,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data);\n\n\t\t/*\n\t\t * We clear the bit in the bitmap after setting the committed\n\t\t * data bit, because this is the reverse order to that which\n\t\t * the allocator uses.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t block + i);\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\tjbd_unlock_bh_state(bitmap_bh);\n\n\tspin_lock(sb_bgl_lock(sbi, block_group));\n\tle16_add_cpu(&desc->bg_free_blocks_count, group_freed);\n\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\tpercpu_counter_add(&sbi->s_freeblocks_counter, count);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gd_bh);\n\tif (!err) err = ret;\n\t*pdquot_freed_blocks += group_freed;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks_sb(handle_t *handle, struct super_block *sb,\n\t\t\t ext3_fsblk_t block, unsigned long count,\n\t\t\t unsigned long *pdquot_freed_blocks)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\tunsigned long block_group;\n\text3_grpblk_t bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0, ret;\n\text3_grpblk_t group_freed;\n\n\t*pdquot_freed_blocks = 0;\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = \"E3FSBLK\", count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text3_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT3_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT3_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\tdesc = ext3_get_group_desc (sb, block_group, &gd_bh);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = \"E3FSBLK\", count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * We are about to start releasing blocks in the bitmap,\n\t * so we need undo access.\n\t */\n\t/* @@@ check errors */\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tjbd_lock_bh_state(bitmap_bh);\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\t/*\n\t\t * An HJ special.  This is expensive...\n\t\t */\n#ifdef CONFIG_JBD_DEBUG\n\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t{\n\t\t\tstruct buffer_head *debug_bh;\n\t\t\tdebug_bh = sb_find_get_block(sb, block + i);\n\t\t\tif (debug_bh) {\n\t\t\t\tBUFFER_TRACE(debug_bh, \"Deleted!\");\n\t\t\t\tif (!bh2jh(bitmap_bh)->b_committed_data)\n\t\t\t\t\tBUFFER_TRACE(debug_bh,\n\t\t\t\t\t\t\"No committed data in bitmap\");\n\t\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap\");\n\t\t\t\t__brelse(debug_bh);\n\t\t\t}\n\t\t}\n\t\tjbd_lock_bh_state(bitmap_bh);\n#endif\n\t\tif (need_resched()) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\tcond_resched();\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t}\n\t\t/* @@@ This prevents newly-allocated data from being\n\t\t * freed and then reallocated within the same\n\t\t * transaction.\n\t\t *\n\t\t * Ideally we would want to allow that to happen, but to\n\t\t * do so requires making journal_forget() capable of\n\t\t * revoking the queued write of a data block, which\n\t\t * implies blocking on the journal lock.  *forget()\n\t\t * cannot block due to truncate races.\n\t\t *\n\t\t * Eventually we can fix this by making journal_forget()\n\t\t * return a status indicating whether or not it was able\n\t\t * to revoke the buffer.  On successful revoke, it is\n\t\t * safe not to set the allocation bit in the committed\n\t\t * bitmap, because we know that there is no outstanding\n\t\t * activity on the buffer any more and so it is safe to\n\t\t * reallocate it.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"set in b_committed_data\");\n\t\tJ_ASSERT_BH(bitmap_bh,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data != NULL);\n\t\text3_set_bit_atomic(sb_bgl_lock(sbi, block_group), bit + i,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data);\n\n\t\t/*\n\t\t * We clear the bit in the bitmap after setting the committed\n\t\t * data bit, because this is the reverse order to that which\n\t\t * the allocator uses.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t block + i);\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\tjbd_unlock_bh_state(bitmap_bh);\n\n\tspin_lock(sb_bgl_lock(sbi, block_group));\n\tle16_add_cpu(&desc->bg_free_blocks_count, group_freed);\n\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\tpercpu_counter_add(&sbi->s_freeblocks_counter, count);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gd_bh);\n\tif (!err) err = ret;\n\t*pdquot_freed_blocks += group_freed;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"freeing blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\"",
            "o_blocks_count",
            "o_blocks_count + add"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"error %d on journal dirty metadata\"",
            "err"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&EXT3_SB(sb)->s_resize_lock"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "o_blocks_count + add"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&EXT3_SB(sb)->s_resize_lock"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&EXT3_SB(sb)->s_resize_lock"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&EXT3_SB(sb)->s_resize_lock"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start_sb",
          "args": [
            "sb",
            "3"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "o_blocks_count + add -1"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "~0ULL"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nint ext3_group_extend(struct super_block *sb, struct ext3_super_block *es,\n\t\t      ext3_fsblk_t n_blocks_count)\n{\n\text3_fsblk_t o_blocks_count;\n\text3_grpblk_t last;\n\text3_grpblk_t add;\n\tstruct buffer_head * bh;\n\thandle_t *handle;\n\tint err;\n\tunsigned long freed_blocks;\n\n\t/* We don't need to worry about locking wrt other resizers just\n\t * yet: we're going to revalidate es->s_blocks_count after\n\t * taking the s_resize_lock below. */\n\to_blocks_count = le32_to_cpu(es->s_blocks_count);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extending last group from \"E3FSBLK\n\t\t       \" up to \"E3FSBLK\" blocks\\n\",\n\t\t       o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT3-fs: filesystem on %s:\"\n\t\t\t\" too large to resize to \"E3FSBLK\" blocks safely\\n\",\n\t\t\tsb->s_id, n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_warning(sb, __func__,\n\t\t\t\"CONFIG_LBDAF not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't shrink FS - resize aborted\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\tlast = (o_blocks_count - le32_to_cpu(es->s_first_data_block)) %\n\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\n\tif (last == 0) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT3_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"will only finish group (\"E3FSBLK\n\t\t\t     \" blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add -1);\n\tif (!bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext3_free_blocks().\n\t */\n\thandle = ext3_journal_start_sb(sb, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text3_warning(sb, __func__, \"error %d on journal start\",err);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&EXT3_SB(sb)->s_resize_lock);\n\tif (o_blocks_count != le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\terr = -EBUSY;\n\t\tgoto exit_put;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t EXT3_SB(sb)->s_sbh))) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal write access\", err);\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\tes->s_blocks_count = cpu_to_le32(o_blocks_count + add);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal dirty metadata\", err);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\text3_debug(\"freeing blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\text3_free_blocks_sb(handle, sb, o_blocks_count, add, &freed_blocks);\n\text3_debug(\"freed blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\tif ((err = ext3_journal_stop(handle)))\n\t\tgoto exit_put;\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extended group to %u blocks\\n\",\n\t\t       le32_to_cpu(es->s_blocks_count));\n\tupdate_backups(sb, EXT3_SB(sb)->s_sbh->b_blocknr, (char *)es,\n\t\t       sizeof(struct ext3_super_block));\nexit_put:\n\treturn err;\n}"
  },
  {
    "function_name": "ext3_group_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "783-980",
    "snippet": "int ext3_group_add(struct super_block *sb, struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext3_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct buffer_head *primary = NULL;\n\tstruct ext3_group_desc *gdp;\n\tstruct inode *inode = NULL;\n\thandle_t *handle;\n\tint gdb_off, gdb_num;\n\tint err, err2;\n\n\tgdb_num = input->group / EXT3_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT3_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (le32_to_cpu(es->s_blocks_count) + input->blocks_count <\n\t    le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT3_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text3_warning(sb, __func__, \"inodes_count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT3_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT3_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext3_iget(sb, EXT3_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\tif ((err = verify_group_input(sb, input)))\n\t\tgoto exit_put;\n\n\tif ((err = setup_new_group_blocks(sb, input)))\n\t\tgoto exit_put;\n\n\t/*\n\t * We will always be modifying at least the superblock and a GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\thandle = ext3_journal_start_sb(sb,\n\t\t\t\t       ext3_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&sbi->s_resize_lock);\n\tif (input->group != sbi->s_groups_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle, sbi->s_sbh)))\n\t\tgoto exit_journal;\n\n\t/*\n\t * We will only either add reserved group blocks to a backup group\n\t * or remove reserved blocks for the first group in a new group block.\n\t * Doing both would be mean more complex code, and sane people don't\n\t * use non-sparse filesystems anymore.  This is already checked above.\n\t */\n\tif (gdb_off) {\n\t\tprimary = sbi->s_group_desc[gdb_num];\n\t\tif ((err = ext3_journal_get_write_access(handle, primary)))\n\t\t\tgoto exit_journal;\n\n\t\tif (reserved_gdb && ext3_bg_num_gdb(sb, input->group) &&\n\t\t    (err = reserve_backup_gdb(handle, inode, input)))\n\t\t\tgoto exit_journal;\n\t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n\t\tgoto exit_journal;\n\n\t/*\n\t * OK, now we've set up the new group.  Time to make it active.\n\t *\n\t * We do not lock all allocations via s_resize_lock\n\t * so we have to be safe wrt. concurrent accesses the group\n\t * data.  So we need to be careful to set all of the relevant\n\t * group descriptor data etc. *before* we enable the group.\n\t *\n\t * The key field here is sbi->s_groups_count: as long as\n\t * that retains its old value, nobody is going to access the new\n\t * group.\n\t *\n\t * So first we update all the descriptor metadata for the new\n\t * group; then we update the total disk blocks count; then we\n\t * update the groups count to enable the group; then finally we\n\t * update the free space counts so that the system can start\n\t * using the new disk blocks.\n\t */\n\n\t/* Update group descriptor block for new group */\n\tgdp = (struct ext3_group_desc *)primary->b_data + gdb_off;\n\n\tgdp->bg_block_bitmap = cpu_to_le32(input->block_bitmap);\n\tgdp->bg_inode_bitmap = cpu_to_le32(input->inode_bitmap);\n\tgdp->bg_inode_table = cpu_to_le32(input->inode_table);\n\tgdp->bg_free_blocks_count = cpu_to_le16(input->free_blocks_count);\n\tgdp->bg_free_inodes_count = cpu_to_le16(EXT3_INODES_PER_GROUP(sb));\n\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tle32_add_cpu(&es->s_blocks_count, input->blocks_count);\n\tle32_add_cpu(&es->s_inodes_count, EXT3_INODES_PER_GROUP(sb));\n\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers of s_groups_count *must* hold s_resize_lock\n\t * AND\n\t * * Writers must perform a smp_wmb() after updating all dependent\n\t *   data and before modifying the groups count\n\t *\n\t * * Readers must hold s_resize_lock over the access\n\t * OR\n\t * * Readers must perform an smp_rmb() after reading the groups count\n\t *   and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count++;\n\n\terr = ext3_journal_dirty_metadata(handle, primary);\n\tif (err)\n\t\tgoto exit_journal;\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\tle32_add_cpu(&es->s_r_blocks_count, input->reserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeblocks_counter,\n\t\t\t   input->free_blocks_count);\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT3_INODES_PER_GROUP(sb));\n\n\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\nexit_journal:\n\tmutex_unlock(&sbi->s_resize_lock);\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\tif (!err) {\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext3_super_block));\n\t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n\t\t\t       primary->b_size);\n\t}\nexit_put:\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_backups",
          "args": [
            "sb",
            "primary->b_blocknr",
            "primary->b_data",
            "primary->b_size"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "update_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "694-768",
          "snippet": "static void update_backups(struct super_block *sb,\n\t\t\t   int blk_off, char *data, int size)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tconst unsigned long last = sbi->s_groups_count;\n\tconst int bpg = EXT3_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned group;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\twhile ((group = ext3_list_backups(sb, &three, &five, &seven)) < last) {\n\t\tstruct buffer_head *bh;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (handle->h_buffer_credits == 0 &&\n\t\t    ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA) &&\n\t\t    (err = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tbh = sb_getblk(sb, group * bpg + blk_off);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text3_debug(\"update metadata backup %#04lx\\n\",\n\t\t\t  (unsigned long)bh->b_blocknr);\n\t\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't update backup for group %d (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT3_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic void update_backups(struct super_block *sb,\n\t\t\t   int blk_off, char *data, int size)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tconst unsigned long last = sbi->s_groups_count;\n\tconst int bpg = EXT3_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned group;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\twhile ((group = ext3_list_backups(sb, &three, &five, &seven)) < last) {\n\t\tstruct buffer_head *bh;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (handle->h_buffer_credits == 0 &&\n\t\t    ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA) &&\n\t\t    (err = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tbh = sb_getblk(sb, group * bpg + blk_off);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text3_debug(\"update metadata backup %#04lx\\n\",\n\t\t\t  (unsigned long)bh->b_blocknr);\n\t\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't update backup for group %d (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT3_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_resize_lock"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeinodes_counter",
            "EXT3_INODES_PER_GROUP(sb)"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeblocks_counter",
            "input->free_blocks_count"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&es->s_r_blocks_count",
            "input->reserved_blocks"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "primary"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&es->s_inodes_count",
            "EXT3_INODES_PER_GROUP(sb)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&es->s_blocks_count",
            "input->blocks_count"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT3_INODES_PER_GROUP(sb)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "input->free_blocks_count"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "input->inode_table"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "input->inode_bitmap"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "input->block_bitmap"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_new_gdb",
          "args": [
            "handle",
            "inode",
            "input",
            "&primary"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "add_new_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "427-564",
          "snippet": "static int add_new_gdb(handle_t *handle, struct inode *inode,\n\t\t       struct ext3_new_group_data *input,\n\t\t       struct buffer_head **primary)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\tunsigned long gdb_num = input->group / EXT3_DESC_PER_BLOCK(sb);\n\text3_fsblk_t gdblock = EXT3_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tstruct buffer_head *dind;\n\tint gdbackups;\n\tstruct ext3_iloc iloc;\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       \"EXT3-fs: ext3_add_new_gdb: adding group block %lu\\n\",\n\t\t       gdb_num);\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n\t * because the user tools have no way of handling this.  Probably a\n\t * bad time to do it anyways.\n\t */\n\tif (EXT3_SB(sb)->s_sbh->b_blocknr !=\n\t    le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block)) {\n\t\text3_warning(sb, __func__,\n\t\t\t\"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT3_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t*primary = sb_bread(sb, gdblock);\n\tif (!*primary)\n\t\treturn -EIO;\n\n\tif ((gdbackups = verify_reserved_gdb(sb, *primary)) < 0) {\n\t\terr = gdbackups;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = EXT3_I(inode)->i_data + EXT3_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT3_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"new group %u GDT block \"E3FSBLK\" not reserved\",\n\t\t\t     input->group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto exit_dind;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh)))\n\t\tgoto exit_dind;\n\n\tif ((err = ext3_journal_get_write_access(handle, *primary)))\n\t\tgoto exit_sbh;\n\n\tif ((err = ext3_journal_get_write_access(handle, dind)))\n\t\tgoto exit_primary;\n\n\t/* ext3_reserve_inode_write() gets a reference on the iloc */\n\tif ((err = ext3_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_dindj;\n\n\tn_group_desc = kmalloc((gdb_num + 1) * sizeof(struct buffer_head *),\n\t\t\tGFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text3_warning (sb, __func__,\n\t\t\t      \"not enough memory for %lu groups\", gdb_num + 1);\n\t\tgoto exit_inode;\n\t}\n\n\t/*\n\t * Finally, we have all of the possible failures behind us...\n\t *\n\t * Remove new GDT block from inode double-indirect block and clear out\n\t * the new GDT block for use (which also \"frees\" the backup GDT blocks\n\t * from the reserved inode).  We don't need to change the bitmaps for\n\t * these blocks, because they are marked as in-use from being in the\n\t * reserved inode, and will become GDT blocks (primary and backup).\n\t */\n\tdata[gdb_num % EXT3_ADDR_PER_BLOCK(sb)] = 0;\n\terr = ext3_journal_dirty_metadata(handle, dind);\n\tif (err)\n\t\tgoto exit_group_desc;\n\tbrelse(dind);\n\tdind = NULL;\n\tinode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (err)\n\t\tgoto exit_group_desc;\n\tmemset((*primary)->b_data, 0, sb->s_blocksize);\n\terr = ext3_journal_dirty_metadata(handle, *primary);\n\tif (err)\n\t\tgoto exit_group_desc;\n\n\to_group_desc = EXT3_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT3_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = *primary;\n\tEXT3_SB(sb)->s_group_desc = n_group_desc;\n\tEXT3_SB(sb)->s_gdb_count++;\n\tkfree(o_group_desc);\n\n\tle16_add_cpu(&es->s_reserved_gdt_blocks, -1);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto exit_inode;\n\n\treturn 0;\n\nexit_group_desc:\n\tkfree(n_group_desc);\nexit_inode:\n\t//ext3_journal_release_buffer(handle, iloc.bh);\n\tbrelse(iloc.bh);\nexit_dindj:\n\t//ext3_journal_release_buffer(handle, dind);\nexit_primary:\n\t//ext3_journal_release_buffer(handle, *primary);\nexit_sbh:\n\t//ext3_journal_release_buffer(handle, *primary);\nexit_dind:\n\tbrelse(dind);\nexit_bh:\n\tbrelse(*primary);\n\n\text3_debug(\"leaving with error %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic int add_new_gdb(handle_t *handle, struct inode *inode,\n\t\t       struct ext3_new_group_data *input,\n\t\t       struct buffer_head **primary)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\tunsigned long gdb_num = input->group / EXT3_DESC_PER_BLOCK(sb);\n\text3_fsblk_t gdblock = EXT3_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tstruct buffer_head *dind;\n\tint gdbackups;\n\tstruct ext3_iloc iloc;\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       \"EXT3-fs: ext3_add_new_gdb: adding group block %lu\\n\",\n\t\t       gdb_num);\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n\t * because the user tools have no way of handling this.  Probably a\n\t * bad time to do it anyways.\n\t */\n\tif (EXT3_SB(sb)->s_sbh->b_blocknr !=\n\t    le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block)) {\n\t\text3_warning(sb, __func__,\n\t\t\t\"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT3_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t*primary = sb_bread(sb, gdblock);\n\tif (!*primary)\n\t\treturn -EIO;\n\n\tif ((gdbackups = verify_reserved_gdb(sb, *primary)) < 0) {\n\t\terr = gdbackups;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = EXT3_I(inode)->i_data + EXT3_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT3_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"new group %u GDT block \"E3FSBLK\" not reserved\",\n\t\t\t     input->group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto exit_dind;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh)))\n\t\tgoto exit_dind;\n\n\tif ((err = ext3_journal_get_write_access(handle, *primary)))\n\t\tgoto exit_sbh;\n\n\tif ((err = ext3_journal_get_write_access(handle, dind)))\n\t\tgoto exit_primary;\n\n\t/* ext3_reserve_inode_write() gets a reference on the iloc */\n\tif ((err = ext3_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_dindj;\n\n\tn_group_desc = kmalloc((gdb_num + 1) * sizeof(struct buffer_head *),\n\t\t\tGFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text3_warning (sb, __func__,\n\t\t\t      \"not enough memory for %lu groups\", gdb_num + 1);\n\t\tgoto exit_inode;\n\t}\n\n\t/*\n\t * Finally, we have all of the possible failures behind us...\n\t *\n\t * Remove new GDT block from inode double-indirect block and clear out\n\t * the new GDT block for use (which also \"frees\" the backup GDT blocks\n\t * from the reserved inode).  We don't need to change the bitmaps for\n\t * these blocks, because they are marked as in-use from being in the\n\t * reserved inode, and will become GDT blocks (primary and backup).\n\t */\n\tdata[gdb_num % EXT3_ADDR_PER_BLOCK(sb)] = 0;\n\terr = ext3_journal_dirty_metadata(handle, dind);\n\tif (err)\n\t\tgoto exit_group_desc;\n\tbrelse(dind);\n\tdind = NULL;\n\tinode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (err)\n\t\tgoto exit_group_desc;\n\tmemset((*primary)->b_data, 0, sb->s_blocksize);\n\terr = ext3_journal_dirty_metadata(handle, *primary);\n\tif (err)\n\t\tgoto exit_group_desc;\n\n\to_group_desc = EXT3_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT3_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = *primary;\n\tEXT3_SB(sb)->s_group_desc = n_group_desc;\n\tEXT3_SB(sb)->s_gdb_count++;\n\tkfree(o_group_desc);\n\n\tle16_add_cpu(&es->s_reserved_gdt_blocks, -1);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto exit_inode;\n\n\treturn 0;\n\nexit_group_desc:\n\tkfree(n_group_desc);\nexit_inode:\n\t//ext3_journal_release_buffer(handle, iloc.bh);\n\tbrelse(iloc.bh);\nexit_dindj:\n\t//ext3_journal_release_buffer(handle, dind);\nexit_primary:\n\t//ext3_journal_release_buffer(handle, *primary);\nexit_sbh:\n\t//ext3_journal_release_buffer(handle, *primary);\nexit_dind:\n\tbrelse(dind);\nexit_bh:\n\tbrelse(*primary);\n\n\text3_debug(\"leaving with error %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_backup_gdb",
          "args": [
            "handle",
            "inode",
            "input"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_backup_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "579-676",
          "snippet": "static int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      struct ext3_new_group_data *input)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT3_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext3_iloc iloc;\n\text3_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc(reserved_gdb * sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT3_I(inode)->i_data + EXT3_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT3_SB(sb)->s_sbh->b_blocknr + 1 + EXT3_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT3_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT3_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT3_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved block \"E3FSBLK\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = sb_bread(sb, blk);\n\t\tif (!primary[res]) {\n\t\t\terr = -EIO;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif ((gdbackups = verify_reserved_gdb(sb, primary[res])) < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tif ((err = ext3_journal_get_write_access(handle, primary[i]))) {\n\t\t\t/*\n\t\t\tint j;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\text3_journal_release_buffer(handle, primary[j]);\n\t\t\t */\n\t\t\tgoto exit_bh;\n\t\t}\n\t}\n\n\tif ((err = ext3_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = input->group * EXT3_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext3_journal_dirty_metadata(handle, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;\n\text3_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      struct ext3_new_group_data *input)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT3_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext3_iloc iloc;\n\text3_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc(reserved_gdb * sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT3_I(inode)->i_data + EXT3_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT3_SB(sb)->s_sbh->b_blocknr + 1 + EXT3_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT3_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT3_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT3_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved block \"E3FSBLK\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = sb_bread(sb, blk);\n\t\tif (!primary[res]) {\n\t\t\terr = -EIO;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif ((gdbackups = verify_reserved_gdb(sb, primary[res])) < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tif ((err = ext3_journal_get_write_access(handle, primary[i]))) {\n\t\t\t/*\n\t\t\tint j;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\text3_journal_release_buffer(handle, primary[j]);\n\t\t\t */\n\t\t\tgoto exit_bh;\n\t\t}\n\t}\n\n\tif ((err = ext3_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = input->group * EXT3_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext3_journal_dirty_metadata(handle, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;\n\text3_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_num_gdb",
          "args": [
            "sb",
            "input->group"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1891-1903",
          "snippet": "unsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "primary"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "sbi->s_sbh"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"multiple resizers run on filesystem!\""
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_resize_lock"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start_sb",
          "args": [
            "sb",
            "ext3_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_has_super",
          "args": [
            "sb",
            "input->group"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1857-1864",
          "snippet": "int ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_new_group_blocks",
          "args": [
            "sb",
            "input"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_group_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "188-343",
          "snippet": "static int setup_new_group_blocks(struct super_block *sb,\n\t\t\t\t  struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\text3_fsblk_t start = ext3_group_first_block_no(sb, input->group);\n\tint reserved_gdb = ext3_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) : 0;\n\tunsigned long gdblocks = ext3_bg_num_gdb(sb, input->group);\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\text3_fsblk_t block;\n\text3_grpblk_t bit;\n\tint i;\n\tint err = 0, err2;\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tmutex_lock(&sbi->s_resize_lock);\n\tif (input->group != sbi->s_groups_count) {\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif (IS_ERR(bh = bclean(handle, sb, input->block_bitmap))) {\n\t\terr = PTR_ERR(bh);\n\t\tgoto exit_journal;\n\t}\n\n\tif (ext3_bg_has_super(sb, input->group)) {\n\t\text3_debug(\"mark backup superblock %#04lx (+0)\\n\", start);\n\t\text3_set_bit(0, bh->b_data);\n\t}\n\n\t/* Copy all of the GDT blocks into the backup in this group */\n\tfor (i = 0, bit = 1, block = start + 1;\n\t     i < gdblocks; i++, block++, bit++) {\n\t\tstruct buffer_head *gdb;\n\n\t\text3_debug(\"update backup group %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tgdb = sb_getblk(sb, block);\n\t\tif (unlikely(!gdb)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif ((err = ext3_journal_get_write_access(handle, gdb))) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tlock_buffer(gdb);\n\t\tmemcpy(gdb->b_data, sbi->s_group_desc[i]->b_data, gdb->b_size);\n\t\tset_buffer_uptodate(gdb);\n\t\tunlock_buffer(gdb);\n\t\terr = ext3_journal_dirty_metadata(handle, gdb);\n\t\tif (err) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\text3_set_bit(bit, bh->b_data);\n\t\tbrelse(gdb);\n\t}\n\n\t/* Zero out all of the reserved backup group descriptor table blocks */\n\tfor (i = 0, bit = gdblocks + 1, block = start + bit;\n\t     i < reserved_gdb; i++, block++, bit++) {\n\t\tstruct buffer_head *gdb;\n\n\t\text3_debug(\"clear reserved block %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tif (IS_ERR(gdb = bclean(handle, sb, block))) {\n\t\t\terr = PTR_ERR(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, gdb);\n\t\tif (err) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\text3_set_bit(bit, bh->b_data);\n\t\tbrelse(gdb);\n\t}\n\text3_debug(\"mark block bitmap %#04x (+%ld)\\n\", input->block_bitmap,\n\t\t   input->block_bitmap - start);\n\text3_set_bit(input->block_bitmap - start, bh->b_data);\n\text3_debug(\"mark inode bitmap %#04x (+%ld)\\n\", input->inode_bitmap,\n\t\t   input->inode_bitmap - start);\n\text3_set_bit(input->inode_bitmap - start, bh->b_data);\n\n\t/* Zero out all of the inode table blocks */\n\tfor (i = 0, block = input->inode_table, bit = block - start;\n\t     i < sbi->s_itb_per_group; i++, bit++, block++) {\n\t\tstruct buffer_head *it;\n\n\t\text3_debug(\"clear inode block %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tif (IS_ERR(it = bclean(handle, sb, block))) {\n\t\t\terr = PTR_ERR(it);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, it);\n\t\tif (err) {\n\t\t\tbrelse(it);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tbrelse(it);\n\t\text3_set_bit(bit, bh->b_data);\n\t}\n\n\terr = extend_or_restart_transaction(handle, 2, bh);\n\tif (err)\n\t\tgoto exit_bh;\n\n\tmark_bitmap_end(input->blocks_count, EXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tbh->b_data);\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\tgoto exit_bh;\n\tbrelse(bh);\n\n\t/* Mark unused entries in inode bitmap used */\n\text3_debug(\"clear inode bitmap %#04x (+%ld)\\n\",\n\t\t   input->inode_bitmap, input->inode_bitmap - start);\n\tif (IS_ERR(bh = bclean(handle, sb, input->inode_bitmap))) {\n\t\terr = PTR_ERR(bh);\n\t\tgoto exit_journal;\n\t}\n\n\tmark_bitmap_end(EXT3_INODES_PER_GROUP(sb), EXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tbh->b_data);\n\terr = ext3_journal_dirty_metadata(handle, bh);\nexit_bh:\n\tbrelse(bh);\n\nexit_journal:\n\tmutex_unlock(&sbi->s_resize_lock);\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\treturn err;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic int setup_new_group_blocks(struct super_block *sb,\n\t\t\t\t  struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\text3_fsblk_t start = ext3_group_first_block_no(sb, input->group);\n\tint reserved_gdb = ext3_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) : 0;\n\tunsigned long gdblocks = ext3_bg_num_gdb(sb, input->group);\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\text3_fsblk_t block;\n\text3_grpblk_t bit;\n\tint i;\n\tint err = 0, err2;\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tmutex_lock(&sbi->s_resize_lock);\n\tif (input->group != sbi->s_groups_count) {\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif (IS_ERR(bh = bclean(handle, sb, input->block_bitmap))) {\n\t\terr = PTR_ERR(bh);\n\t\tgoto exit_journal;\n\t}\n\n\tif (ext3_bg_has_super(sb, input->group)) {\n\t\text3_debug(\"mark backup superblock %#04lx (+0)\\n\", start);\n\t\text3_set_bit(0, bh->b_data);\n\t}\n\n\t/* Copy all of the GDT blocks into the backup in this group */\n\tfor (i = 0, bit = 1, block = start + 1;\n\t     i < gdblocks; i++, block++, bit++) {\n\t\tstruct buffer_head *gdb;\n\n\t\text3_debug(\"update backup group %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tgdb = sb_getblk(sb, block);\n\t\tif (unlikely(!gdb)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif ((err = ext3_journal_get_write_access(handle, gdb))) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tlock_buffer(gdb);\n\t\tmemcpy(gdb->b_data, sbi->s_group_desc[i]->b_data, gdb->b_size);\n\t\tset_buffer_uptodate(gdb);\n\t\tunlock_buffer(gdb);\n\t\terr = ext3_journal_dirty_metadata(handle, gdb);\n\t\tif (err) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\text3_set_bit(bit, bh->b_data);\n\t\tbrelse(gdb);\n\t}\n\n\t/* Zero out all of the reserved backup group descriptor table blocks */\n\tfor (i = 0, bit = gdblocks + 1, block = start + bit;\n\t     i < reserved_gdb; i++, block++, bit++) {\n\t\tstruct buffer_head *gdb;\n\n\t\text3_debug(\"clear reserved block %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tif (IS_ERR(gdb = bclean(handle, sb, block))) {\n\t\t\terr = PTR_ERR(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, gdb);\n\t\tif (err) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\text3_set_bit(bit, bh->b_data);\n\t\tbrelse(gdb);\n\t}\n\text3_debug(\"mark block bitmap %#04x (+%ld)\\n\", input->block_bitmap,\n\t\t   input->block_bitmap - start);\n\text3_set_bit(input->block_bitmap - start, bh->b_data);\n\text3_debug(\"mark inode bitmap %#04x (+%ld)\\n\", input->inode_bitmap,\n\t\t   input->inode_bitmap - start);\n\text3_set_bit(input->inode_bitmap - start, bh->b_data);\n\n\t/* Zero out all of the inode table blocks */\n\tfor (i = 0, block = input->inode_table, bit = block - start;\n\t     i < sbi->s_itb_per_group; i++, bit++, block++) {\n\t\tstruct buffer_head *it;\n\n\t\text3_debug(\"clear inode block %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tif (IS_ERR(it = bclean(handle, sb, block))) {\n\t\t\terr = PTR_ERR(it);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, it);\n\t\tif (err) {\n\t\t\tbrelse(it);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tbrelse(it);\n\t\text3_set_bit(bit, bh->b_data);\n\t}\n\n\terr = extend_or_restart_transaction(handle, 2, bh);\n\tif (err)\n\t\tgoto exit_bh;\n\n\tmark_bitmap_end(input->blocks_count, EXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tbh->b_data);\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\tgoto exit_bh;\n\tbrelse(bh);\n\n\t/* Mark unused entries in inode bitmap used */\n\text3_debug(\"clear inode bitmap %#04x (+%ld)\\n\",\n\t\t   input->inode_bitmap, input->inode_bitmap - start);\n\tif (IS_ERR(bh = bclean(handle, sb, input->inode_bitmap))) {\n\t\terr = PTR_ERR(bh);\n\t\tgoto exit_journal;\n\t}\n\n\tmark_bitmap_end(EXT3_INODES_PER_GROUP(sb), EXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tbh->b_data);\n\terr = ext3_journal_dirty_metadata(handle, bh);\nexit_bh:\n\tbrelse(bh);\n\nexit_journal:\n\tmutex_unlock(&sbi->s_resize_lock);\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_group_input",
          "args": [
            "sb",
            "input"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "verify_group_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "20-110",
          "snippet": "static int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\text3_fsblk_t start = le32_to_cpu(es->s_blocks_count);\n\text3_fsblk_t end = start + input->blocks_count;\n\tunsigned group = input->group;\n\text3_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead = ext3_bg_has_super(sb, group) ?\n\t\t(1 + ext3_bg_num_gdb(sb, group) +\n\t\t le16_to_cpu(es->s_reserved_gdt_blocks)) : 0;\n\text3_fsblk_t metaend = start + overhead;\n\tstruct buffer_head *bh = NULL;\n\text3_grpblk_t free_blocks_count;\n\tint err = -EINVAL;\n\n\tinput->free_blocks_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext3_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\tif (group != sbi->s_groups_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Cannot add at group %u (only %lu groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\telse if ((start - le32_to_cpu(es->s_first_data_block)) %\n\t\t EXT3_BLOCKS_PER_GROUP(sb))\n\t\text3_warning(sb, __func__, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text3_warning(sb, __func__, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text3_warning(sb, __func__, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (!(bh = sb_bread(sb, end - 1)))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Cannot read last block (\"E3FSBLK\")\",\n\t\t\t     end - 1);\n\telse if (outside(input->block_bitmap, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap not in group (block %u)\",\n\t\t\t     input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap not in group (block %u)\",\n\t\t\t     input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t         outside(itend - 1, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode table not in group (blocks %u-\"E3FSBLK\")\",\n\t\t\t     input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap same as inode bitmap (%u)\",\n\t\t\t     input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap (%u) in inode table (%u-\"E3FSBLK\")\",\n\t\t\t     input->block_bitmap, input->inode_table, itend-1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap (%u) in inode table (%u-\"E3FSBLK\")\",\n\t\t\t     input->inode_bitmap, input->inode_table, itend-1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap (%u) in GDT table\"\n\t\t\t     \" (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->block_bitmap, start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap (%u) in GDT table\"\n\t\t\t     \" (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->inode_bitmap, start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t         inside(itend - 1, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode table (%u-\"E3FSBLK\") overlaps\"\n\t\t\t     \"GDT table (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->inode_table, itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\text3_fsblk_t start = le32_to_cpu(es->s_blocks_count);\n\text3_fsblk_t end = start + input->blocks_count;\n\tunsigned group = input->group;\n\text3_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead = ext3_bg_has_super(sb, group) ?\n\t\t(1 + ext3_bg_num_gdb(sb, group) +\n\t\t le16_to_cpu(es->s_reserved_gdt_blocks)) : 0;\n\text3_fsblk_t metaend = start + overhead;\n\tstruct buffer_head *bh = NULL;\n\text3_grpblk_t free_blocks_count;\n\tint err = -EINVAL;\n\n\tinput->free_blocks_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext3_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\tif (group != sbi->s_groups_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Cannot add at group %u (only %lu groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\telse if ((start - le32_to_cpu(es->s_first_data_block)) %\n\t\t EXT3_BLOCKS_PER_GROUP(sb))\n\t\text3_warning(sb, __func__, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text3_warning(sb, __func__, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text3_warning(sb, __func__, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (!(bh = sb_bread(sb, end - 1)))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Cannot read last block (\"E3FSBLK\")\",\n\t\t\t     end - 1);\n\telse if (outside(input->block_bitmap, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap not in group (block %u)\",\n\t\t\t     input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap not in group (block %u)\",\n\t\t\t     input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t         outside(itend - 1, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode table not in group (blocks %u-\"E3FSBLK\")\",\n\t\t\t     input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap same as inode bitmap (%u)\",\n\t\t\t     input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap (%u) in inode table (%u-\"E3FSBLK\")\",\n\t\t\t     input->block_bitmap, input->inode_table, itend-1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap (%u) in inode table (%u-\"E3FSBLK\")\",\n\t\t\t     input->inode_bitmap, input->inode_table, itend-1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap (%u) in GDT table\"\n\t\t\t     \" (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->block_bitmap, start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap (%u) in GDT table\"\n\t\t\t     \" (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->inode_bitmap, start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t         inside(itend - 1, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode table (%u-\"E3FSBLK\") overlaps\"\n\t\t\t     \"GDT table (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->inode_table, itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_iget",
          "args": [
            "sb",
            "EXT3_RESIZE_INO"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2848-3023",
          "snippet": "struct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nstruct inode *ext3_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext3_iloc iloc;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_inode_info *ei;\n\tstruct buffer_head *bh;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\ttransaction_t *transaction;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT3_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\tret = __ext3_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\tbh = iloc.bh;\n\traw_inode = ext3_raw_inode(&iloc);\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif(!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\n\tei->i_state_flags = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif (inode->i_mode == 0 ||\n\t\t    !(EXT3_SB(inode->i_sb)->s_mount_state & EXT3_ORPHAN_FS)) {\n\t\t\t/* this inode is deleted */\n\t\t\tbrelse (bh);\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those. */\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n#ifdef EXT3_FRAGMENTS\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n#endif\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tif (!S_ISREG(inode->i_mode)) {\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\t} else {\n\t\tinode->i_size |=\n\t\t\t((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\t}\n\tei->i_disksize = inode->i_size;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT3_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttid_t tid;\n\n\t\tspin_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tatomic_set(&ei->i_sync_tid, tid);\n\t\tatomic_set(&ei->i_datasync_tid, tid);\n\t}\n\n\tif (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&\n\t    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {\n\t\t/*\n\t\t * When mke2fs creates big inodes it does not zero out\n\t\t * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,\n\t\t * so ignore those first few inodes.\n\t\t */\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT3_INODE_SIZE(inode->i_sb)) {\n\t\t\tbrelse (bh);\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext3_inode) -\n\t\t\t\t\t    EXT3_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\t__le32 *magic = (void *)raw_inode +\n\t\t\t\t\tEXT3_GOOD_OLD_INODE_SIZE +\n\t\t\t\t\tei->i_extra_isize;\n\t\t\tif (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))\n\t\t\t\t ext3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext3_file_inode_operations;\n\t\tinode->i_fop = &ext3_file_operations;\n\t\text3_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext3_dir_inode_operations;\n\t\tinode->i_fop = &ext3_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext3_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext3_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext3_symlink_inode_operations;\n\t\t\text3_set_aops(inode);\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext3_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (iloc.bh);\n\text3_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_reserved_gdt_blocks"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_COMPAT_RESIZE_INODE"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nint ext3_group_add(struct super_block *sb, struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext3_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct buffer_head *primary = NULL;\n\tstruct ext3_group_desc *gdp;\n\tstruct inode *inode = NULL;\n\thandle_t *handle;\n\tint gdb_off, gdb_num;\n\tint err, err2;\n\n\tgdb_num = input->group / EXT3_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT3_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (le32_to_cpu(es->s_blocks_count) + input->blocks_count <\n\t    le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT3_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text3_warning(sb, __func__, \"inodes_count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT3_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT3_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext3_iget(sb, EXT3_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\tif ((err = verify_group_input(sb, input)))\n\t\tgoto exit_put;\n\n\tif ((err = setup_new_group_blocks(sb, input)))\n\t\tgoto exit_put;\n\n\t/*\n\t * We will always be modifying at least the superblock and a GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\thandle = ext3_journal_start_sb(sb,\n\t\t\t\t       ext3_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&sbi->s_resize_lock);\n\tif (input->group != sbi->s_groups_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle, sbi->s_sbh)))\n\t\tgoto exit_journal;\n\n\t/*\n\t * We will only either add reserved group blocks to a backup group\n\t * or remove reserved blocks for the first group in a new group block.\n\t * Doing both would be mean more complex code, and sane people don't\n\t * use non-sparse filesystems anymore.  This is already checked above.\n\t */\n\tif (gdb_off) {\n\t\tprimary = sbi->s_group_desc[gdb_num];\n\t\tif ((err = ext3_journal_get_write_access(handle, primary)))\n\t\t\tgoto exit_journal;\n\n\t\tif (reserved_gdb && ext3_bg_num_gdb(sb, input->group) &&\n\t\t    (err = reserve_backup_gdb(handle, inode, input)))\n\t\t\tgoto exit_journal;\n\t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n\t\tgoto exit_journal;\n\n\t/*\n\t * OK, now we've set up the new group.  Time to make it active.\n\t *\n\t * We do not lock all allocations via s_resize_lock\n\t * so we have to be safe wrt. concurrent accesses the group\n\t * data.  So we need to be careful to set all of the relevant\n\t * group descriptor data etc. *before* we enable the group.\n\t *\n\t * The key field here is sbi->s_groups_count: as long as\n\t * that retains its old value, nobody is going to access the new\n\t * group.\n\t *\n\t * So first we update all the descriptor metadata for the new\n\t * group; then we update the total disk blocks count; then we\n\t * update the groups count to enable the group; then finally we\n\t * update the free space counts so that the system can start\n\t * using the new disk blocks.\n\t */\n\n\t/* Update group descriptor block for new group */\n\tgdp = (struct ext3_group_desc *)primary->b_data + gdb_off;\n\n\tgdp->bg_block_bitmap = cpu_to_le32(input->block_bitmap);\n\tgdp->bg_inode_bitmap = cpu_to_le32(input->inode_bitmap);\n\tgdp->bg_inode_table = cpu_to_le32(input->inode_table);\n\tgdp->bg_free_blocks_count = cpu_to_le16(input->free_blocks_count);\n\tgdp->bg_free_inodes_count = cpu_to_le16(EXT3_INODES_PER_GROUP(sb));\n\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tle32_add_cpu(&es->s_blocks_count, input->blocks_count);\n\tle32_add_cpu(&es->s_inodes_count, EXT3_INODES_PER_GROUP(sb));\n\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers of s_groups_count *must* hold s_resize_lock\n\t * AND\n\t * * Writers must perform a smp_wmb() after updating all dependent\n\t *   data and before modifying the groups count\n\t *\n\t * * Readers must hold s_resize_lock over the access\n\t * OR\n\t * * Readers must perform an smp_rmb() after reading the groups count\n\t *   and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count++;\n\n\terr = ext3_journal_dirty_metadata(handle, primary);\n\tif (err)\n\t\tgoto exit_journal;\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\tle32_add_cpu(&es->s_r_blocks_count, input->reserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeblocks_counter,\n\t\t\t   input->free_blocks_count);\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT3_INODES_PER_GROUP(sb));\n\n\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\nexit_journal:\n\tmutex_unlock(&sbi->s_resize_lock);\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\tif (!err) {\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext3_super_block));\n\t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n\t\t\t       primary->b_size);\n\t}\nexit_put:\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "update_backups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "694-768",
    "snippet": "static void update_backups(struct super_block *sb,\n\t\t\t   int blk_off, char *data, int size)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tconst unsigned long last = sbi->s_groups_count;\n\tconst int bpg = EXT3_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned group;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\twhile ((group = ext3_list_backups(sb, &three, &five, &seven)) < last) {\n\t\tstruct buffer_head *bh;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (handle->h_buffer_credits == 0 &&\n\t\t    ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA) &&\n\t\t    (err = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tbh = sb_getblk(sb, group * bpg + blk_off);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text3_debug(\"update metadata backup %#04lx\\n\",\n\t\t\t  (unsigned long)bh->b_blocknr);\n\t\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't update backup for group %d (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT3_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~EXT3_VALID_FS"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"can't update backup for group %d (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\"",
            "group",
            "err"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data + size",
            "0",
            "rest"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data",
            "data",
            "size"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"update metadata backup %#04lx\\n\"",
            "(unsigned long)bh->b_blocknr"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "group * bpg + blk_off"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_restart",
          "args": [
            "handle",
            "EXT3_MAX_TRANS_DATA"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1281-1284",
          "snippet": "static inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);",
            "int __ext3_journal_stop(const char *where, handle_t *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\nint __ext3_journal_stop(const char *where, handle_t *handle);\n\nstatic inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_extend",
          "args": [
            "handle",
            "EXT3_MAX_TRANS_DATA"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1276-1279",
          "snippet": "static inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);",
            "int __ext3_journal_stop(const char *where, handle_t *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\nint __ext3_journal_stop(const char *where, handle_t *handle);\n\nstatic inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_list_backups",
          "args": [
            "sb",
            "&three",
            "&five",
            "&seven"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_list_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "352-379",
          "snippet": "static unsigned ext3_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic unsigned ext3_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start_sb",
          "args": [
            "sb",
            "EXT3_MAX_TRANS_DATA"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic void update_backups(struct super_block *sb,\n\t\t\t   int blk_off, char *data, int size)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tconst unsigned long last = sbi->s_groups_count;\n\tconst int bpg = EXT3_BLOCKS_PER_GROUP(sb);\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned group;\n\tint rest = sb->s_blocksize - size;\n\thandle_t *handle;\n\tint err = 0, err2;\n\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\tif (IS_ERR(handle)) {\n\t\tgroup = 1;\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_err;\n\t}\n\n\twhile ((group = ext3_list_backups(sb, &three, &five, &seven)) < last) {\n\t\tstruct buffer_head *bh;\n\n\t\t/* Out of journal space, and can't get more - abort - so sad */\n\t\tif (handle->h_buffer_credits == 0 &&\n\t\t    ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA) &&\n\t\t    (err = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA)))\n\t\t\tbreak;\n\n\t\tbh = sb_getblk(sb, group * bpg + blk_off);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\text3_debug(\"update metadata backup %#04lx\\n\",\n\t\t\t  (unsigned long)bh->b_blocknr);\n\t\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data, data, size);\n\t\tif (rest)\n\t\t\tmemset(bh->b_data + size, 0, rest);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\terr = ext3_journal_dirty_metadata(handle, bh);\n\t\tbrelse(bh);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\t/*\n\t * Ugh! Need to have e2fsck write the backup copies.  It is too\n\t * late to revert the resize, we shouldn't fail just because of\n\t * the backup copies (they are only needed in case of corruption).\n\t *\n\t * However, if we got here we have a journal problem too, so we\n\t * can't really start a transaction to mark the superblock.\n\t * Chicken out and just set the flag on the hope it will be written\n\t * to disk, and if not - we will simply wait until next fsck.\n\t */\nexit_err:\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't update backup for group %d (err %d), \"\n\t\t\t     \"forcing fsck on next reboot\", group, err);\n\t\tsbi->s_mount_state &= ~EXT3_VALID_FS;\n\t\tsbi->s_es->s_state &= cpu_to_le16(~EXT3_VALID_FS);\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n}"
  },
  {
    "function_name": "reserve_backup_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "579-676",
    "snippet": "static int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      struct ext3_new_group_data *input)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT3_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext3_iloc iloc;\n\text3_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc(reserved_gdb * sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT3_I(inode)->i_data + EXT3_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT3_SB(sb)->s_sbh->b_blocknr + 1 + EXT3_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT3_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT3_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT3_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved block \"E3FSBLK\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = sb_bread(sb, blk);\n\t\tif (!primary[res]) {\n\t\t\terr = -EIO;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif ((gdbackups = verify_reserved_gdb(sb, primary[res])) < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tif ((err = ext3_journal_get_write_access(handle, primary[i]))) {\n\t\t\t/*\n\t\t\tint j;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\text3_journal_release_buffer(handle, primary[j]);\n\t\t\t */\n\t\t\tgoto exit_bh;\n\t\t}\n\t}\n\n\tif ((err = ext3_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = input->group * EXT3_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext3_journal_dirty_metadata(handle, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;\n\text3_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "primary"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dind"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3391-3403",
          "snippet": "int ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "primary[i]"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk + primary[i]->b_blocknr"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3410-3428",
          "snippet": "int\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "primary[i]"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_reserved_gdb",
          "args": [
            "sb",
            "primary[res]"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "verify_reserved_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "386-412",
          "snippet": "static int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext3_fsblk_t blk = primary->b_blocknr;\n\tconst unsigned long end = EXT3_SB(sb)->s_groups_count;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext3_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) != grp * EXT3_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved GDT \"E3FSBLK\n\t\t\t\t     \" missing grp %d (\"E3FSBLK\")\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp * EXT3_BLOCKS_PER_GROUP(sb) + blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT3_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext3_fsblk_t blk = primary->b_blocknr;\n\tconst unsigned long end = EXT3_SB(sb)->s_groups_count;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext3_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) != grp * EXT3_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved GDT \"E3FSBLK\n\t\t\t\t     \" missing grp %d (\"E3FSBLK\")\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp * EXT3_BLOCKS_PER_GROUP(sb) + blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT3_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blk"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"reserved block \"E3FSBLK\n\t\t\t\t     \" not at offset %ld\"",
            "blk",
            "(long)(data - (__le32 *)dind->b_data)"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*data"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "le32_to_cpu(*data)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "reserved_gdb * sizeof(*primary)",
            "GFP_NOFS"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "EXT3_SB(sb)->s_es->s_reserved_gdt_blocks"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic int reserve_backup_gdb(handle_t *handle, struct inode *inode,\n\t\t\t      struct ext3_new_group_data *input)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint reserved_gdb =le16_to_cpu(EXT3_SB(sb)->s_es->s_reserved_gdt_blocks);\n\tstruct buffer_head **primary;\n\tstruct buffer_head *dind;\n\tstruct ext3_iloc iloc;\n\text3_fsblk_t blk;\n\t__le32 *data, *end;\n\tint gdbackups = 0;\n\tint res, i;\n\tint err;\n\n\tprimary = kmalloc(reserved_gdb * sizeof(*primary), GFP_NOFS);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tdata = EXT3_I(inode)->i_data + EXT3_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_free;\n\t}\n\n\tblk = EXT3_SB(sb)->s_sbh->b_blocknr + 1 + EXT3_SB(sb)->s_gdb_count;\n\tdata = (__le32 *)dind->b_data + (EXT3_SB(sb)->s_gdb_count %\n\t\t\t\t\t EXT3_ADDR_PER_BLOCK(sb));\n\tend = (__le32 *)dind->b_data + EXT3_ADDR_PER_BLOCK(sb);\n\n\t/* Get each reserved primary GDT block and verify it holds backups */\n\tfor (res = 0; res < reserved_gdb; res++, blk++) {\n\t\tif (le32_to_cpu(*data) != blk) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved block \"E3FSBLK\n\t\t\t\t     \" not at offset %ld\",\n\t\t\t\t     blk,\n\t\t\t\t     (long)(data - (__le32 *)dind->b_data));\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tprimary[res] = sb_bread(sb, blk);\n\t\tif (!primary[res]) {\n\t\t\terr = -EIO;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif ((gdbackups = verify_reserved_gdb(sb, primary[res])) < 0) {\n\t\t\tbrelse(primary[res]);\n\t\t\terr = gdbackups;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif (++data >= end)\n\t\t\tdata = (__le32 *)dind->b_data;\n\t}\n\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tif ((err = ext3_journal_get_write_access(handle, primary[i]))) {\n\t\t\t/*\n\t\t\tint j;\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\text3_journal_release_buffer(handle, primary[j]);\n\t\t\t */\n\t\t\tgoto exit_bh;\n\t\t}\n\t}\n\n\tif ((err = ext3_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_bh;\n\n\t/*\n\t * Finally we can add each of the reserved backup GDT blocks from\n\t * the new group to its reserved primary GDT block.\n\t */\n\tblk = input->group * EXT3_BLOCKS_PER_GROUP(sb);\n\tfor (i = 0; i < reserved_gdb; i++) {\n\t\tint err2;\n\t\tdata = (__le32 *)primary[i]->b_data;\n\t\t/* printk(\"reserving backup %lu[%u] = %lu\\n\",\n\t\t       primary[i]->b_blocknr, gdbackups,\n\t\t       blk + primary[i]->b_blocknr); */\n\t\tdata[gdbackups] = cpu_to_le32(blk + primary[i]->b_blocknr);\n\t\terr2 = ext3_journal_dirty_metadata(handle, primary[i]);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tinode->i_blocks += reserved_gdb * sb->s_blocksize >> 9;\n\text3_mark_iloc_dirty(handle, inode, &iloc);\n\nexit_bh:\n\twhile (--res >= 0)\n\t\tbrelse(primary[res]);\n\tbrelse(dind);\n\nexit_free:\n\tkfree(primary);\n\n\treturn err;\n}"
  },
  {
    "function_name": "add_new_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "427-564",
    "snippet": "static int add_new_gdb(handle_t *handle, struct inode *inode,\n\t\t       struct ext3_new_group_data *input,\n\t\t       struct buffer_head **primary)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\tunsigned long gdb_num = input->group / EXT3_DESC_PER_BLOCK(sb);\n\text3_fsblk_t gdblock = EXT3_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tstruct buffer_head *dind;\n\tint gdbackups;\n\tstruct ext3_iloc iloc;\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       \"EXT3-fs: ext3_add_new_gdb: adding group block %lu\\n\",\n\t\t       gdb_num);\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n\t * because the user tools have no way of handling this.  Probably a\n\t * bad time to do it anyways.\n\t */\n\tif (EXT3_SB(sb)->s_sbh->b_blocknr !=\n\t    le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block)) {\n\t\text3_warning(sb, __func__,\n\t\t\t\"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT3_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t*primary = sb_bread(sb, gdblock);\n\tif (!*primary)\n\t\treturn -EIO;\n\n\tif ((gdbackups = verify_reserved_gdb(sb, *primary)) < 0) {\n\t\terr = gdbackups;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = EXT3_I(inode)->i_data + EXT3_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT3_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"new group %u GDT block \"E3FSBLK\" not reserved\",\n\t\t\t     input->group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto exit_dind;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh)))\n\t\tgoto exit_dind;\n\n\tif ((err = ext3_journal_get_write_access(handle, *primary)))\n\t\tgoto exit_sbh;\n\n\tif ((err = ext3_journal_get_write_access(handle, dind)))\n\t\tgoto exit_primary;\n\n\t/* ext3_reserve_inode_write() gets a reference on the iloc */\n\tif ((err = ext3_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_dindj;\n\n\tn_group_desc = kmalloc((gdb_num + 1) * sizeof(struct buffer_head *),\n\t\t\tGFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text3_warning (sb, __func__,\n\t\t\t      \"not enough memory for %lu groups\", gdb_num + 1);\n\t\tgoto exit_inode;\n\t}\n\n\t/*\n\t * Finally, we have all of the possible failures behind us...\n\t *\n\t * Remove new GDT block from inode double-indirect block and clear out\n\t * the new GDT block for use (which also \"frees\" the backup GDT blocks\n\t * from the reserved inode).  We don't need to change the bitmaps for\n\t * these blocks, because they are marked as in-use from being in the\n\t * reserved inode, and will become GDT blocks (primary and backup).\n\t */\n\tdata[gdb_num % EXT3_ADDR_PER_BLOCK(sb)] = 0;\n\terr = ext3_journal_dirty_metadata(handle, dind);\n\tif (err)\n\t\tgoto exit_group_desc;\n\tbrelse(dind);\n\tdind = NULL;\n\tinode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (err)\n\t\tgoto exit_group_desc;\n\tmemset((*primary)->b_data, 0, sb->s_blocksize);\n\terr = ext3_journal_dirty_metadata(handle, *primary);\n\tif (err)\n\t\tgoto exit_group_desc;\n\n\to_group_desc = EXT3_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT3_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = *primary;\n\tEXT3_SB(sb)->s_group_desc = n_group_desc;\n\tEXT3_SB(sb)->s_gdb_count++;\n\tkfree(o_group_desc);\n\n\tle16_add_cpu(&es->s_reserved_gdt_blocks, -1);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto exit_inode;\n\n\treturn 0;\n\nexit_group_desc:\n\tkfree(n_group_desc);\nexit_inode:\n\t//ext3_journal_release_buffer(handle, iloc.bh);\n\tbrelse(iloc.bh);\nexit_dindj:\n\t//ext3_journal_release_buffer(handle, dind);\nexit_primary:\n\t//ext3_journal_release_buffer(handle, *primary);\nexit_sbh:\n\t//ext3_journal_release_buffer(handle, *primary);\nexit_dind:\n\tbrelse(dind);\nexit_bh:\n\tbrelse(*primary);\n\n\text3_debug(\"leaving with error %d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"leaving with error %d\\n\"",
            "err"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*primary"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n_group_desc"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&es->s_reserved_gdt_blocks",
            "-1"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o_group_desc"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "n_group_desc",
            "o_group_desc",
            "EXT3_SB(sb)->s_gdb_count * sizeof(struct buffer_head *)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "*primary"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(*primary)->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3391-3403",
          "snippet": "int ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "dind"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"not enough memory for %lu groups\"",
            "gdb_num + 1"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(gdb_num + 1) * sizeof(struct buffer_head *)",
            "GFP_NOFS"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3410-3428",
          "snippet": "int\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "dind"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "*primary"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "data[gdb_num % EXT3_ADDR_PER_BLOCK(sb)]"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "le32_to_cpu(*data)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_reserved_gdb",
          "args": [
            "sb",
            "*primary"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "verify_reserved_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "386-412",
          "snippet": "static int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext3_fsblk_t blk = primary->b_blocknr;\n\tconst unsigned long end = EXT3_SB(sb)->s_groups_count;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext3_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) != grp * EXT3_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved GDT \"E3FSBLK\n\t\t\t\t     \" missing grp %d (\"E3FSBLK\")\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp * EXT3_BLOCKS_PER_GROUP(sb) + blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT3_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext3_fsblk_t blk = primary->b_blocknr;\n\tconst unsigned long end = EXT3_SB(sb)->s_groups_count;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext3_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) != grp * EXT3_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved GDT \"E3FSBLK\n\t\t\t\t     \" missing grp %d (\"E3FSBLK\")\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp * EXT3_BLOCKS_PER_GROUP(sb) + blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT3_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "gdblock"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t       \"EXT3-fs: ext3_add_new_gdb: adding group block %lu\\n\"",
            "gdb_num"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic int add_new_gdb(handle_t *handle, struct inode *inode,\n\t\t       struct ext3_new_group_data *input,\n\t\t       struct buffer_head **primary)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\tunsigned long gdb_num = input->group / EXT3_DESC_PER_BLOCK(sb);\n\text3_fsblk_t gdblock = EXT3_SB(sb)->s_sbh->b_blocknr + 1 + gdb_num;\n\tstruct buffer_head **o_group_desc, **n_group_desc;\n\tstruct buffer_head *dind;\n\tint gdbackups;\n\tstruct ext3_iloc iloc;\n\t__le32 *data;\n\tint err;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG\n\t\t       \"EXT3-fs: ext3_add_new_gdb: adding group block %lu\\n\",\n\t\t       gdb_num);\n\n\t/*\n\t * If we are not using the primary superblock/GDT copy don't resize,\n\t * because the user tools have no way of handling this.  Probably a\n\t * bad time to do it anyways.\n\t */\n\tif (EXT3_SB(sb)->s_sbh->b_blocknr !=\n\t    le32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block)) {\n\t\text3_warning(sb, __func__,\n\t\t\t\"won't resize using backup superblock at %llu\",\n\t\t\t(unsigned long long)EXT3_SB(sb)->s_sbh->b_blocknr);\n\t\treturn -EPERM;\n\t}\n\n\t*primary = sb_bread(sb, gdblock);\n\tif (!*primary)\n\t\treturn -EIO;\n\n\tif ((gdbackups = verify_reserved_gdb(sb, *primary)) < 0) {\n\t\terr = gdbackups;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = EXT3_I(inode)->i_data + EXT3_DIND_BLOCK;\n\tdind = sb_bread(sb, le32_to_cpu(*data));\n\tif (!dind) {\n\t\terr = -EIO;\n\t\tgoto exit_bh;\n\t}\n\n\tdata = (__le32 *)dind->b_data;\n\tif (le32_to_cpu(data[gdb_num % EXT3_ADDR_PER_BLOCK(sb)]) != gdblock) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"new group %u GDT block \"E3FSBLK\" not reserved\",\n\t\t\t     input->group, gdblock);\n\t\terr = -EINVAL;\n\t\tgoto exit_dind;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh)))\n\t\tgoto exit_dind;\n\n\tif ((err = ext3_journal_get_write_access(handle, *primary)))\n\t\tgoto exit_sbh;\n\n\tif ((err = ext3_journal_get_write_access(handle, dind)))\n\t\tgoto exit_primary;\n\n\t/* ext3_reserve_inode_write() gets a reference on the iloc */\n\tif ((err = ext3_reserve_inode_write(handle, inode, &iloc)))\n\t\tgoto exit_dindj;\n\n\tn_group_desc = kmalloc((gdb_num + 1) * sizeof(struct buffer_head *),\n\t\t\tGFP_NOFS);\n\tif (!n_group_desc) {\n\t\terr = -ENOMEM;\n\t\text3_warning (sb, __func__,\n\t\t\t      \"not enough memory for %lu groups\", gdb_num + 1);\n\t\tgoto exit_inode;\n\t}\n\n\t/*\n\t * Finally, we have all of the possible failures behind us...\n\t *\n\t * Remove new GDT block from inode double-indirect block and clear out\n\t * the new GDT block for use (which also \"frees\" the backup GDT blocks\n\t * from the reserved inode).  We don't need to change the bitmaps for\n\t * these blocks, because they are marked as in-use from being in the\n\t * reserved inode, and will become GDT blocks (primary and backup).\n\t */\n\tdata[gdb_num % EXT3_ADDR_PER_BLOCK(sb)] = 0;\n\terr = ext3_journal_dirty_metadata(handle, dind);\n\tif (err)\n\t\tgoto exit_group_desc;\n\tbrelse(dind);\n\tdind = NULL;\n\tinode->i_blocks -= (gdbackups + 1) * sb->s_blocksize >> 9;\n\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\tif (err)\n\t\tgoto exit_group_desc;\n\tmemset((*primary)->b_data, 0, sb->s_blocksize);\n\terr = ext3_journal_dirty_metadata(handle, *primary);\n\tif (err)\n\t\tgoto exit_group_desc;\n\n\to_group_desc = EXT3_SB(sb)->s_group_desc;\n\tmemcpy(n_group_desc, o_group_desc,\n\t       EXT3_SB(sb)->s_gdb_count * sizeof(struct buffer_head *));\n\tn_group_desc[gdb_num] = *primary;\n\tEXT3_SB(sb)->s_group_desc = n_group_desc;\n\tEXT3_SB(sb)->s_gdb_count++;\n\tkfree(o_group_desc);\n\n\tle16_add_cpu(&es->s_reserved_gdt_blocks, -1);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tif (err)\n\t\tgoto exit_inode;\n\n\treturn 0;\n\nexit_group_desc:\n\tkfree(n_group_desc);\nexit_inode:\n\t//ext3_journal_release_buffer(handle, iloc.bh);\n\tbrelse(iloc.bh);\nexit_dindj:\n\t//ext3_journal_release_buffer(handle, dind);\nexit_primary:\n\t//ext3_journal_release_buffer(handle, *primary);\nexit_sbh:\n\t//ext3_journal_release_buffer(handle, *primary);\nexit_dind:\n\tbrelse(dind);\nexit_bh:\n\tbrelse(*primary);\n\n\text3_debug(\"leaving with error %d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "verify_reserved_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "386-412",
    "snippet": "static int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext3_fsblk_t blk = primary->b_blocknr;\n\tconst unsigned long end = EXT3_SB(sb)->s_groups_count;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext3_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) != grp * EXT3_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved GDT \"E3FSBLK\n\t\t\t\t     \" missing grp %d (\"E3FSBLK\")\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp * EXT3_BLOCKS_PER_GROUP(sb) + blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT3_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"reserved GDT \"E3FSBLK\n\t\t\t\t     \" missing grp %d (\"E3FSBLK\")\"",
            "blk",
            "grp",
            "grp * EXT3_BLOCKS_PER_GROUP(sb) + blk"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p++"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_list_backups",
          "args": [
            "sb",
            "&three",
            "&five",
            "&seven"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_list_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "352-379",
          "snippet": "static unsigned ext3_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic unsigned ext3_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic int verify_reserved_gdb(struct super_block *sb,\n\t\t\t       struct buffer_head *primary)\n{\n\tconst ext3_fsblk_t blk = primary->b_blocknr;\n\tconst unsigned long end = EXT3_SB(sb)->s_groups_count;\n\tunsigned three = 1;\n\tunsigned five = 5;\n\tunsigned seven = 7;\n\tunsigned grp;\n\t__le32 *p = (__le32 *)primary->b_data;\n\tint gdbackups = 0;\n\n\twhile ((grp = ext3_list_backups(sb, &three, &five, &seven)) < end) {\n\t\tif (le32_to_cpu(*p++) != grp * EXT3_BLOCKS_PER_GROUP(sb) + blk){\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"reserved GDT \"E3FSBLK\n\t\t\t\t     \" missing grp %d (\"E3FSBLK\")\",\n\t\t\t\t     blk, grp,\n\t\t\t\t     grp * EXT3_BLOCKS_PER_GROUP(sb) + blk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (++gdbackups > EXT3_ADDR_PER_BLOCK(sb))\n\t\t\treturn -EFBIG;\n\t}\n\n\treturn gdbackups;\n}"
  },
  {
    "function_name": "ext3_list_backups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "352-379",
    "snippet": "static unsigned ext3_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic unsigned ext3_list_backups(struct super_block *sb, unsigned *three,\n\t\t\t\t  unsigned *five, unsigned *seven)\n{\n\tunsigned *min = three;\n\tint mult = 3;\n\tunsigned ret;\n\n\tif (!EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\tret = *min;\n\t\t*min += 1;\n\t\treturn ret;\n\t}\n\n\tif (*five < *min) {\n\t\tmin = five;\n\t\tmult = 5;\n\t}\n\tif (*seven < *min) {\n\t\tmin = seven;\n\t\tmult = 7;\n\t}\n\n\tret = *min;\n\t*min *= mult;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_new_group_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "188-343",
    "snippet": "static int setup_new_group_blocks(struct super_block *sb,\n\t\t\t\t  struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\text3_fsblk_t start = ext3_group_first_block_no(sb, input->group);\n\tint reserved_gdb = ext3_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) : 0;\n\tunsigned long gdblocks = ext3_bg_num_gdb(sb, input->group);\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\text3_fsblk_t block;\n\text3_grpblk_t bit;\n\tint i;\n\tint err = 0, err2;\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tmutex_lock(&sbi->s_resize_lock);\n\tif (input->group != sbi->s_groups_count) {\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif (IS_ERR(bh = bclean(handle, sb, input->block_bitmap))) {\n\t\terr = PTR_ERR(bh);\n\t\tgoto exit_journal;\n\t}\n\n\tif (ext3_bg_has_super(sb, input->group)) {\n\t\text3_debug(\"mark backup superblock %#04lx (+0)\\n\", start);\n\t\text3_set_bit(0, bh->b_data);\n\t}\n\n\t/* Copy all of the GDT blocks into the backup in this group */\n\tfor (i = 0, bit = 1, block = start + 1;\n\t     i < gdblocks; i++, block++, bit++) {\n\t\tstruct buffer_head *gdb;\n\n\t\text3_debug(\"update backup group %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tgdb = sb_getblk(sb, block);\n\t\tif (unlikely(!gdb)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif ((err = ext3_journal_get_write_access(handle, gdb))) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tlock_buffer(gdb);\n\t\tmemcpy(gdb->b_data, sbi->s_group_desc[i]->b_data, gdb->b_size);\n\t\tset_buffer_uptodate(gdb);\n\t\tunlock_buffer(gdb);\n\t\terr = ext3_journal_dirty_metadata(handle, gdb);\n\t\tif (err) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\text3_set_bit(bit, bh->b_data);\n\t\tbrelse(gdb);\n\t}\n\n\t/* Zero out all of the reserved backup group descriptor table blocks */\n\tfor (i = 0, bit = gdblocks + 1, block = start + bit;\n\t     i < reserved_gdb; i++, block++, bit++) {\n\t\tstruct buffer_head *gdb;\n\n\t\text3_debug(\"clear reserved block %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tif (IS_ERR(gdb = bclean(handle, sb, block))) {\n\t\t\terr = PTR_ERR(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, gdb);\n\t\tif (err) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\text3_set_bit(bit, bh->b_data);\n\t\tbrelse(gdb);\n\t}\n\text3_debug(\"mark block bitmap %#04x (+%ld)\\n\", input->block_bitmap,\n\t\t   input->block_bitmap - start);\n\text3_set_bit(input->block_bitmap - start, bh->b_data);\n\text3_debug(\"mark inode bitmap %#04x (+%ld)\\n\", input->inode_bitmap,\n\t\t   input->inode_bitmap - start);\n\text3_set_bit(input->inode_bitmap - start, bh->b_data);\n\n\t/* Zero out all of the inode table blocks */\n\tfor (i = 0, block = input->inode_table, bit = block - start;\n\t     i < sbi->s_itb_per_group; i++, bit++, block++) {\n\t\tstruct buffer_head *it;\n\n\t\text3_debug(\"clear inode block %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tif (IS_ERR(it = bclean(handle, sb, block))) {\n\t\t\terr = PTR_ERR(it);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, it);\n\t\tif (err) {\n\t\t\tbrelse(it);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tbrelse(it);\n\t\text3_set_bit(bit, bh->b_data);\n\t}\n\n\terr = extend_or_restart_transaction(handle, 2, bh);\n\tif (err)\n\t\tgoto exit_bh;\n\n\tmark_bitmap_end(input->blocks_count, EXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tbh->b_data);\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\tgoto exit_bh;\n\tbrelse(bh);\n\n\t/* Mark unused entries in inode bitmap used */\n\text3_debug(\"clear inode bitmap %#04x (+%ld)\\n\",\n\t\t   input->inode_bitmap, input->inode_bitmap - start);\n\tif (IS_ERR(bh = bclean(handle, sb, input->inode_bitmap))) {\n\t\terr = PTR_ERR(bh);\n\t\tgoto exit_journal;\n\t}\n\n\tmark_bitmap_end(EXT3_INODES_PER_GROUP(sb), EXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tbh->b_data);\n\terr = ext3_journal_dirty_metadata(handle, bh);\nexit_bh:\n\tbrelse(bh);\n\nexit_journal:\n\tmutex_unlock(&sbi->s_resize_lock);\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_resize_lock"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_bitmap_end",
          "args": [
            "EXT3_INODES_PER_GROUP(sb)",
            "EXT3_BLOCKS_PER_GROUP(sb)",
            "bh->b_data"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "mark_bitmap_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "139-151",
          "snippet": "static void mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text3_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text3_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic void mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text3_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text3_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh = bclean(handle, sb, input->inode_bitmap)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bclean",
          "args": [
            "handle",
            "sb",
            "input->inode_bitmap"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "bclean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "112-132",
          "snippet": "static struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext3_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t}\n\n\treturn bh;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext3_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t}\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"clear inode bitmap %#04x (+%ld)\\n\"",
            "input->inode_bitmap",
            "input->inode_bitmap - start"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extend_or_restart_transaction",
          "args": [
            "handle",
            "2",
            "bh"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "extend_or_restart_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "158-179",
          "snippet": "static int extend_or_restart_transaction(handle_t *handle, int thresh,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint err;\n\n\tif (handle->h_buffer_credits >= thresh)\n\t\treturn 0;\n\n\terr = ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nstatic int extend_or_restart_transaction(handle_t *handle, int thresh,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint err;\n\n\tif (handle->h_buffer_credits >= thresh)\n\t\treturn 0;\n\n\terr = ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_set_bit",
          "args": [
            "bit",
            "bh->b_data"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "it"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "it"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "it = bclean(handle, sb, block)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"clear inode block %#04lx (+%d)\\n\"",
            "block",
            "bit"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit",
          "args": [
            "input->inode_bitmap - start",
            "bh->b_data"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"mark inode bitmap %#04x (+%ld)\\n\"",
            "input->inode_bitmap",
            "input->inode_bitmap - start"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit",
          "args": [
            "input->block_bitmap - start",
            "bh->b_data"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"mark block bitmap %#04x (+%ld)\\n\"",
            "input->block_bitmap",
            "input->block_bitmap - start"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit",
          "args": [
            "bit",
            "bh->b_data"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "gdb"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gdb"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "gdb = bclean(handle, sb, block)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"clear reserved block %#04lx (+%d)\\n\"",
            "block",
            "bit"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit",
          "args": [
            "bit",
            "bh->b_data"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "gdb"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "gdb"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "gdb"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "gdb->b_data",
            "sbi->s_group_desc[i]->b_data",
            "gdb->b_size"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "gdb"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!gdb"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"update backup group %#04lx (+%d)\\n\"",
            "block",
            "bit"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit",
          "args": [
            "0",
            "bh->b_data"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"mark backup superblock %#04lx (+0)\\n\"",
            "start"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_bg_has_super",
          "args": [
            "sb",
            "input->group"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1857-1864",
          "snippet": "int ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh = bclean(handle, sb, input->block_bitmap)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_resize_lock"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start_sb",
          "args": [
            "sb",
            "EXT3_MAX_TRANS_DATA"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_num_gdb",
          "args": [
            "sb",
            "input->group"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1891-1903",
          "snippet": "unsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbi->s_es->s_reserved_gdt_blocks"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "input->group"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic int setup_new_group_blocks(struct super_block *sb,\n\t\t\t\t  struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\text3_fsblk_t start = ext3_group_first_block_no(sb, input->group);\n\tint reserved_gdb = ext3_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) : 0;\n\tunsigned long gdblocks = ext3_bg_num_gdb(sb, input->group);\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\text3_fsblk_t block;\n\text3_grpblk_t bit;\n\tint i;\n\tint err = 0, err2;\n\n\t/* This transaction may be extended/restarted along the way */\n\thandle = ext3_journal_start_sb(sb, EXT3_MAX_TRANS_DATA);\n\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tmutex_lock(&sbi->s_resize_lock);\n\tif (input->group != sbi->s_groups_count) {\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif (IS_ERR(bh = bclean(handle, sb, input->block_bitmap))) {\n\t\terr = PTR_ERR(bh);\n\t\tgoto exit_journal;\n\t}\n\n\tif (ext3_bg_has_super(sb, input->group)) {\n\t\text3_debug(\"mark backup superblock %#04lx (+0)\\n\", start);\n\t\text3_set_bit(0, bh->b_data);\n\t}\n\n\t/* Copy all of the GDT blocks into the backup in this group */\n\tfor (i = 0, bit = 1, block = start + 1;\n\t     i < gdblocks; i++, block++, bit++) {\n\t\tstruct buffer_head *gdb;\n\n\t\text3_debug(\"update backup group %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tgdb = sb_getblk(sb, block);\n\t\tif (unlikely(!gdb)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tif ((err = ext3_journal_get_write_access(handle, gdb))) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tlock_buffer(gdb);\n\t\tmemcpy(gdb->b_data, sbi->s_group_desc[i]->b_data, gdb->b_size);\n\t\tset_buffer_uptodate(gdb);\n\t\tunlock_buffer(gdb);\n\t\terr = ext3_journal_dirty_metadata(handle, gdb);\n\t\tif (err) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\text3_set_bit(bit, bh->b_data);\n\t\tbrelse(gdb);\n\t}\n\n\t/* Zero out all of the reserved backup group descriptor table blocks */\n\tfor (i = 0, bit = gdblocks + 1, block = start + bit;\n\t     i < reserved_gdb; i++, block++, bit++) {\n\t\tstruct buffer_head *gdb;\n\n\t\text3_debug(\"clear reserved block %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tif (IS_ERR(gdb = bclean(handle, sb, block))) {\n\t\t\terr = PTR_ERR(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, gdb);\n\t\tif (err) {\n\t\t\tbrelse(gdb);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\text3_set_bit(bit, bh->b_data);\n\t\tbrelse(gdb);\n\t}\n\text3_debug(\"mark block bitmap %#04x (+%ld)\\n\", input->block_bitmap,\n\t\t   input->block_bitmap - start);\n\text3_set_bit(input->block_bitmap - start, bh->b_data);\n\text3_debug(\"mark inode bitmap %#04x (+%ld)\\n\", input->inode_bitmap,\n\t\t   input->inode_bitmap - start);\n\text3_set_bit(input->inode_bitmap - start, bh->b_data);\n\n\t/* Zero out all of the inode table blocks */\n\tfor (i = 0, block = input->inode_table, bit = block - start;\n\t     i < sbi->s_itb_per_group; i++, bit++, block++) {\n\t\tstruct buffer_head *it;\n\n\t\text3_debug(\"clear inode block %#04lx (+%d)\\n\", block, bit);\n\n\t\terr = extend_or_restart_transaction(handle, 1, bh);\n\t\tif (err)\n\t\t\tgoto exit_bh;\n\n\t\tif (IS_ERR(it = bclean(handle, sb, block))) {\n\t\t\terr = PTR_ERR(it);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\terr = ext3_journal_dirty_metadata(handle, it);\n\t\tif (err) {\n\t\t\tbrelse(it);\n\t\t\tgoto exit_bh;\n\t\t}\n\t\tbrelse(it);\n\t\text3_set_bit(bit, bh->b_data);\n\t}\n\n\terr = extend_or_restart_transaction(handle, 2, bh);\n\tif (err)\n\t\tgoto exit_bh;\n\n\tmark_bitmap_end(input->blocks_count, EXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tbh->b_data);\n\terr = ext3_journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\tgoto exit_bh;\n\tbrelse(bh);\n\n\t/* Mark unused entries in inode bitmap used */\n\text3_debug(\"clear inode bitmap %#04x (+%ld)\\n\",\n\t\t   input->inode_bitmap, input->inode_bitmap - start);\n\tif (IS_ERR(bh = bclean(handle, sb, input->inode_bitmap))) {\n\t\terr = PTR_ERR(bh);\n\t\tgoto exit_journal;\n\t}\n\n\tmark_bitmap_end(EXT3_INODES_PER_GROUP(sb), EXT3_BLOCKS_PER_GROUP(sb),\n\t\t\tbh->b_data);\n\terr = ext3_journal_dirty_metadata(handle, bh);\nexit_bh:\n\tbrelse(bh);\n\nexit_journal:\n\tmutex_unlock(&sbi->s_resize_lock);\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\n\treturn err;\n}"
  },
  {
    "function_name": "extend_or_restart_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "158-179",
    "snippet": "static int extend_or_restart_transaction(handle_t *handle, int thresh,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint err;\n\n\tif (handle->h_buffer_credits >= thresh)\n\t\treturn 0;\n\n\terr = ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_restart",
          "args": [
            "handle",
            "EXT3_MAX_TRANS_DATA"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1281-1284",
          "snippet": "static inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);",
            "int __ext3_journal_stop(const char *where, handle_t *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\nint __ext3_journal_stop(const char *where, handle_t *handle);\n\nstatic inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_extend",
          "args": [
            "handle",
            "EXT3_MAX_TRANS_DATA"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1276-1279",
          "snippet": "static inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);",
            "int __ext3_journal_stop(const char *where, handle_t *handle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\nint __ext3_journal_stop(const char *where, handle_t *handle);\n\nstatic inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic int extend_or_restart_transaction(handle_t *handle, int thresh,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint err;\n\n\tif (handle->h_buffer_credits >= thresh)\n\t\treturn 0;\n\n\terr = ext3_journal_extend(handle, EXT3_MAX_TRANS_DATA);\n\tif (err < 0)\n\t\treturn err;\n\tif (err) {\n\t\terr = ext3_journal_restart(handle, EXT3_MAX_TRANS_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext3_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mark_bitmap_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "139-151",
    "snippet": "static void mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text3_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text3_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bitmap + (i >> 3)",
            "0xff",
            "(end_bit - i) >> 3"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit",
          "args": [
            "i",
            "bitmap"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"mark end bits +%d through +%d used\\n\"",
            "start_bit",
            "end_bit"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic void mark_bitmap_end(int start_bit, int end_bit, char *bitmap)\n{\n\tint i;\n\n\tif (start_bit >= end_bit)\n\t\treturn;\n\n\text3_debug(\"mark end bits +%d through +%d used\\n\", start_bit, end_bit);\n\tfor (i = start_bit; i < ((start_bit + 7) & ~7UL); i++)\n\t\text3_set_bit(i, bitmap);\n\tif (i < end_bit)\n\t\tmemset(bitmap + (i >> 3), 0xff, (end_bit - i) >> 3);\n}"
  },
  {
    "function_name": "bclean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "112-132",
    "snippet": "static struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext3_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t}\n\n\treturn bh;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "blk"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic struct buffer_head *bclean(handle_t *handle, struct super_block *sb,\n\t\t\t\t  ext3_fsblk_t blk)\n{\n\tstruct buffer_head *bh;\n\tint err;\n\n\tbh = sb_getblk(sb, blk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif ((err = ext3_journal_get_write_access(handle, bh))) {\n\t\tbrelse(bh);\n\t\tbh = ERR_PTR(err);\n\t} else {\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t}\n\n\treturn bh;\n}"
  },
  {
    "function_name": "verify_group_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
    "lines": "20-110",
    "snippet": "static int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\text3_fsblk_t start = le32_to_cpu(es->s_blocks_count);\n\text3_fsblk_t end = start + input->blocks_count;\n\tunsigned group = input->group;\n\text3_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead = ext3_bg_has_super(sb, group) ?\n\t\t(1 + ext3_bg_num_gdb(sb, group) +\n\t\t le16_to_cpu(es->s_reserved_gdt_blocks)) : 0;\n\text3_fsblk_t metaend = start + overhead;\n\tstruct buffer_head *bh = NULL;\n\text3_grpblk_t free_blocks_count;\n\tint err = -EINVAL;\n\n\tinput->free_blocks_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext3_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\tif (group != sbi->s_groups_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Cannot add at group %u (only %lu groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\telse if ((start - le32_to_cpu(es->s_first_data_block)) %\n\t\t EXT3_BLOCKS_PER_GROUP(sb))\n\t\text3_warning(sb, __func__, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text3_warning(sb, __func__, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text3_warning(sb, __func__, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (!(bh = sb_bread(sb, end - 1)))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Cannot read last block (\"E3FSBLK\")\",\n\t\t\t     end - 1);\n\telse if (outside(input->block_bitmap, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap not in group (block %u)\",\n\t\t\t     input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap not in group (block %u)\",\n\t\t\t     input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t         outside(itend - 1, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode table not in group (blocks %u-\"E3FSBLK\")\",\n\t\t\t     input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap same as inode bitmap (%u)\",\n\t\t\t     input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap (%u) in inode table (%u-\"E3FSBLK\")\",\n\t\t\t     input->block_bitmap, input->inode_table, itend-1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap (%u) in inode table (%u-\"E3FSBLK\")\",\n\t\t\t     input->inode_bitmap, input->inode_table, itend-1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap (%u) in GDT table\"\n\t\t\t     \" (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->block_bitmap, start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap (%u) in GDT table\"\n\t\t\t     \" (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->inode_bitmap, start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t         inside(itend - 1, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode table (%u-\"E3FSBLK\") overlaps\"\n\t\t\t     \"GDT table (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->inode_table, itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"Inode table (%u-\"E3FSBLK\") overlaps\"\n\t\t\t     \"GDT table (\"E3FSBLK\"-\"E3FSBLK\")\"",
            "input->inode_table",
            "itend - 1",
            "start",
            "metaend - 1"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "itend - 1",
            "start",
            "metaend"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->inode_table",
            "start",
            "metaend"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->inode_bitmap",
            "start",
            "metaend"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->block_bitmap",
            "start",
            "metaend"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->inode_bitmap",
            "input->inode_table",
            "itend"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside",
          "args": [
            "input->block_bitmap",
            "input->inode_table",
            "itend"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outside",
          "args": [
            "itend - 1",
            "start",
            "end"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outside",
          "args": [
            "input->inode_table",
            "start",
            "end"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outside",
          "args": [
            "input->inode_bitmap",
            "start",
            "end"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outside",
          "args": [
            "input->block_bitmap",
            "start",
            "end"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "end - 1"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_first_data_block"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"EXT3-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\"",
            "ext3_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\"",
            "input->group",
            "input->blocks_count",
            "free_blocks_count",
            "input->reserved_blocks"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_has_super",
          "args": [
            "sb",
            "input->group"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1857-1864",
          "snippet": "int ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_reserved_gdt_blocks"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_num_gdb",
          "args": [
            "sb",
            "group"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1891-1903",
          "snippet": "unsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nstatic int verify_group_input(struct super_block *sb,\n\t\t\t      struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\text3_fsblk_t start = le32_to_cpu(es->s_blocks_count);\n\text3_fsblk_t end = start + input->blocks_count;\n\tunsigned group = input->group;\n\text3_fsblk_t itend = input->inode_table + sbi->s_itb_per_group;\n\tunsigned overhead = ext3_bg_has_super(sb, group) ?\n\t\t(1 + ext3_bg_num_gdb(sb, group) +\n\t\t le16_to_cpu(es->s_reserved_gdt_blocks)) : 0;\n\text3_fsblk_t metaend = start + overhead;\n\tstruct buffer_head *bh = NULL;\n\text3_grpblk_t free_blocks_count;\n\tint err = -EINVAL;\n\n\tinput->free_blocks_count = free_blocks_count =\n\t\tinput->blocks_count - 2 - overhead - sbi->s_itb_per_group;\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: adding %s group %u: %u blocks \"\n\t\t       \"(%d free, %u reserved)\\n\",\n\t\t       ext3_bg_has_super(sb, input->group) ? \"normal\" :\n\t\t       \"no-super\", input->group, input->blocks_count,\n\t\t       free_blocks_count, input->reserved_blocks);\n\n\tif (group != sbi->s_groups_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Cannot add at group %u (only %lu groups)\",\n\t\t\t     input->group, sbi->s_groups_count);\n\telse if ((start - le32_to_cpu(es->s_first_data_block)) %\n\t\t EXT3_BLOCKS_PER_GROUP(sb))\n\t\text3_warning(sb, __func__, \"Last group not full\");\n\telse if (input->reserved_blocks > input->blocks_count / 5)\n\t\text3_warning(sb, __func__, \"Reserved blocks too high (%u)\",\n\t\t\t     input->reserved_blocks);\n\telse if (free_blocks_count < 0)\n\t\text3_warning(sb, __func__, \"Bad blocks count %u\",\n\t\t\t     input->blocks_count);\n\telse if (!(bh = sb_bread(sb, end - 1)))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Cannot read last block (\"E3FSBLK\")\",\n\t\t\t     end - 1);\n\telse if (outside(input->block_bitmap, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap not in group (block %u)\",\n\t\t\t     input->block_bitmap);\n\telse if (outside(input->inode_bitmap, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap not in group (block %u)\",\n\t\t\t     input->inode_bitmap);\n\telse if (outside(input->inode_table, start, end) ||\n\t         outside(itend - 1, start, end))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode table not in group (blocks %u-\"E3FSBLK\")\",\n\t\t\t     input->inode_table, itend - 1);\n\telse if (input->inode_bitmap == input->block_bitmap)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap same as inode bitmap (%u)\",\n\t\t\t     input->block_bitmap);\n\telse if (inside(input->block_bitmap, input->inode_table, itend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap (%u) in inode table (%u-\"E3FSBLK\")\",\n\t\t\t     input->block_bitmap, input->inode_table, itend-1);\n\telse if (inside(input->inode_bitmap, input->inode_table, itend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap (%u) in inode table (%u-\"E3FSBLK\")\",\n\t\t\t     input->inode_bitmap, input->inode_table, itend-1);\n\telse if (inside(input->block_bitmap, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Block bitmap (%u) in GDT table\"\n\t\t\t     \" (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->block_bitmap, start, metaend - 1);\n\telse if (inside(input->inode_bitmap, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode bitmap (%u) in GDT table\"\n\t\t\t     \" (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->inode_bitmap, start, metaend - 1);\n\telse if (inside(input->inode_table, start, metaend) ||\n\t         inside(itend - 1, start, metaend))\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Inode table (%u-\"E3FSBLK\") overlaps\"\n\t\t\t     \"GDT table (\"E3FSBLK\"-\"E3FSBLK\")\",\n\t\t\t     input->inode_table, itend - 1, start, metaend - 1);\n\telse\n\t\terr = 0;\n\tbrelse(bh);\n\n\treturn err;\n}"
  }
]