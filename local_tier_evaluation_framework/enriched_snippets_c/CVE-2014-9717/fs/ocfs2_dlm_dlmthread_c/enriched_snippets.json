[
  {
    "function_name": "dlm_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "628-756",
    "snippet": "static int dlm_thread(void *data)\n{\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned long timeout = msecs_to_jiffies(DLM_THREAD_TIMEOUT_MS);\n\n\tmlog(0, \"dlm thread running for %s...\\n\", dlm->name);\n\n\twhile (!kthread_should_stop()) {\n\t\tint n = DLM_THREAD_MAX_DIRTY;\n\n\t\t/* dlm_shutting_down is very point-in-time, but that\n\t\t * doesn't matter as we'll just loop back around if we\n\t\t * get false on the leading edge of a state\n\t\t * transition. */\n\t\tdlm_run_purge_list(dlm, dlm_shutting_down(dlm));\n\n\t\t/* We really don't want to hold dlm->spinlock while\n\t\t * calling dlm_shuffle_lists on each lockres that\n\t\t * needs to have its queues adjusted and AST/BASTs\n\t\t * run.  So let's pull each entry off the dirty_list\n\t\t * and drop dlm->spinlock ASAP.  Once off the list,\n\t\t * res->spinlock needs to be taken again to protect\n\t\t * the queues while calling dlm_shuffle_lists.  */\n\t\tspin_lock(&dlm->spinlock);\n\t\twhile (!list_empty(&dlm->dirty_list)) {\n\t\t\tint delay = 0;\n\t\t\tres = list_entry(dlm->dirty_list.next,\n\t\t\t\t\t struct dlm_lock_resource, dirty);\n\n\t\t\t/* peel a lockres off, remove it from the list,\n\t\t\t * unset the dirty flag and drop the dlm lock */\n\t\t\tBUG_ON(!res);\n\t\t\tdlm_lockres_get(res);\n\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* We clear the DLM_LOCK_RES_DIRTY state once we shuffle lists below */\n\t\t\tlist_del_init(&res->dirty);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t/* Drop dirty_list ref */\n\t\t\tdlm_lockres_put(res);\n\n\t\t \t/* lockres can be re-dirtied/re-added to the\n\t\t\t * dirty_list in this gap, but that is ok */\n\n\t\t\tspin_lock(&dlm->ast_lock);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (res->owner != dlm->node_num) {\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tmlog(ML_ERROR, \"%s: inprog %d, mig %d, reco %d,\"\n\t\t\t\t     \" dirty %d\\n\", dlm->name,\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_IN_PROGRESS),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_MIGRATING),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_RECOVERING),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_DIRTY));\n\t\t\t}\n\t\t\tBUG_ON(res->owner != dlm->node_num);\n\n\t\t\t/* it is now ok to move lockreses in these states\n\t\t\t * to the dirty list, assuming that they will only be\n\t\t\t * dirty for a short while. */\n\t\t\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\t\t\tif (res->state & (DLM_LOCK_RES_IN_PROGRESS |\n\t\t\t\t\t  DLM_LOCK_RES_RECOVERING)) {\n\t\t\t\t/* move it to the tail and keep going */\n\t\t\t\tres->state &= ~DLM_LOCK_RES_DIRTY;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tspin_unlock(&dlm->ast_lock);\n\t\t\t\tmlog(0, \"%s: res %.*s, inprogress, delay list \"\n\t\t\t\t     \"shuffle, state %d\\n\", dlm->name,\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     res->state);\n\t\t\t\tdelay = 1;\n\t\t\t\tgoto in_progress;\n\t\t\t}\n\n\t\t\t/* at this point the lockres is not migrating/\n\t\t\t * recovering/in-progress.  we have the lockres\n\t\t\t * spinlock and do NOT have the dlm lock.\n\t\t\t * safe to reserve/queue asts and run the lists. */\n\n\t\t\t/* called while holding lockres lock */\n\t\t\tdlm_shuffle_lists(dlm, res);\n\t\t\tres->state &= ~DLM_LOCK_RES_DIRTY;\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tspin_unlock(&dlm->ast_lock);\n\n\t\t\tdlm_lockres_calc_usage(dlm, res);\n\nin_progress:\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\t/* if the lock was in-progress, stick\n\t\t\t * it on the back of the list */\n\t\t\tif (delay) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t}\n\t\t\tdlm_lockres_put(res);\n\n\t\t\t/* unlikely, but we may need to give time to\n\t\t\t * other tasks */\n\t\t\tif (!--n) {\n\t\t\t\tmlog(0, \"%s: Throttling dlm thread\\n\",\n\t\t\t\t     dlm->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_flush_asts(dlm);\n\n\t\t/* yield and continue right away if there is more work to do */\n\t\tif (!n) {\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\n\t\twait_event_interruptible_timeout(dlm->dlm_thread_wq,\n\t\t\t\t\t\t !dlm_dirty_list_empty(dlm) ||\n\t\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t\t timeout);\n\t}\n\n\tmlog(0, \"quitting DLM thread\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_THREAD_MAX_DIRTY  100",
      "#define DLM_THREAD_TIMEOUT_MS (4 * 1000)"
    ],
    "globals_used": [
      "static int dlm_thread(void *data);",
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"quitting DLM thread\\n\""
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "dlm->dlm_thread_wq",
            "!dlm_dirty_list_empty(dlm) ||\n\t\t\t\t\t\t kthread_should_stop()",
            "timeout"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dirty_list_empty",
          "args": [
            "dlm"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_flush_asts",
          "args": [
            "dlm"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_flush_asts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "516-621",
          "snippet": "static void dlm_flush_asts(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\tstruct dlm_lock *lock;\n\tstruct dlm_lock_resource *res;\n\tu8 hi;\n\n\tspin_lock(&dlm->ast_lock);\n\twhile (!list_empty(&dlm->pending_asts)) {\n\t\tlock = list_entry(dlm->pending_asts.next,\n\t\t\t\t  struct dlm_lock, ast_list);\n\t\t/* get an extra ref on lock */\n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\t\tmlog(0, \"%s: res %.*s, Flush AST for lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.type, lock->ml.node);\n\n\t\tBUG_ON(!lock->ast_pending);\n\n\t\t/* remove from list (including ref) */\n\t\tlist_del_init(&lock->ast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_do_remote_ast(dlm, res, lock);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_ast(dlm, res, lock);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t/* possible that another ast was queued while\n\t\t * we were delivering the last one */\n\t\tif (!list_empty(&lock->ast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, AST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->ast_pending = 0;\n\n\t\t/* drop the extra ref.\n\t\t * this may drop it completely. */\n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\n\twhile (!list_empty(&dlm->pending_basts)) {\n\t\tlock = list_entry(dlm->pending_basts.next,\n\t\t\t\t  struct dlm_lock, bast_list);\n\t\t/* get an extra ref on lock */\n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\n\t\tBUG_ON(!lock->bast_pending);\n\n\t\t/* get the highest blocked lock, and reset */\n\t\tspin_lock(&lock->spinlock);\n\t\tBUG_ON(lock->ml.highest_blocked <= LKM_IVMODE);\n\t\thi = lock->ml.highest_blocked;\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\tspin_unlock(&lock->spinlock);\n\n\t\t/* remove from list (including ref) */\n\t\tlist_del_init(&lock->bast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tmlog(0, \"%s: res %.*s, Flush BAST for lock %u:%llu, \"\n\t\t     \"blocked %d, node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     hi, lock->ml.node);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_send_proxy_bast(dlm, res, lock, hi);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_bast(dlm, res, lock, hi);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t/* possible that another bast was queued while\n\t\t * we were delivering the last one */\n\t\tif (!list_empty(&lock->bast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, BAST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->bast_pending = 0;\n\n\t\t/* drop the extra ref.\n\t\t * this may drop it completely. */\n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\twake_up(&dlm->ast_wq);\n\tspin_unlock(&dlm->ast_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\tstruct dlm_lock *lock;\n\tstruct dlm_lock_resource *res;\n\tu8 hi;\n\n\tspin_lock(&dlm->ast_lock);\n\twhile (!list_empty(&dlm->pending_asts)) {\n\t\tlock = list_entry(dlm->pending_asts.next,\n\t\t\t\t  struct dlm_lock, ast_list);\n\t\t/* get an extra ref on lock */\n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\t\tmlog(0, \"%s: res %.*s, Flush AST for lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.type, lock->ml.node);\n\n\t\tBUG_ON(!lock->ast_pending);\n\n\t\t/* remove from list (including ref) */\n\t\tlist_del_init(&lock->ast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_do_remote_ast(dlm, res, lock);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_ast(dlm, res, lock);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t/* possible that another ast was queued while\n\t\t * we were delivering the last one */\n\t\tif (!list_empty(&lock->ast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, AST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->ast_pending = 0;\n\n\t\t/* drop the extra ref.\n\t\t * this may drop it completely. */\n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\n\twhile (!list_empty(&dlm->pending_basts)) {\n\t\tlock = list_entry(dlm->pending_basts.next,\n\t\t\t\t  struct dlm_lock, bast_list);\n\t\t/* get an extra ref on lock */\n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\n\t\tBUG_ON(!lock->bast_pending);\n\n\t\t/* get the highest blocked lock, and reset */\n\t\tspin_lock(&lock->spinlock);\n\t\tBUG_ON(lock->ml.highest_blocked <= LKM_IVMODE);\n\t\thi = lock->ml.highest_blocked;\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\tspin_unlock(&lock->spinlock);\n\n\t\t/* remove from list (including ref) */\n\t\tlist_del_init(&lock->bast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tmlog(0, \"%s: res %.*s, Flush BAST for lock %u:%llu, \"\n\t\t     \"blocked %d, node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     hi, lock->ml.node);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_send_proxy_bast(dlm, res, lock, hi);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_bast(dlm, res, lock, hi);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t/* possible that another bast was queued while\n\t\t * we were delivering the last one */\n\t\tif (!list_empty(&lock->bast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, BAST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->bast_pending = 0;\n\n\t\t/* drop the extra ref.\n\t\t * this may drop it completely. */\n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\twake_up(&dlm->ast_wq);\n\tspin_unlock(&dlm->ast_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Throttling dlm thread\\n\"",
            "dlm->name"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_dirty_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_dirty_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "457-478",
          "snippet": "void __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_shuffle_lists",
          "args": [
            "dlm",
            "res"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_shuffle_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "288-442",
          "snippet": "static void dlm_shuffle_lists(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock, *target;\n\tint can_grant = 1;\n\n\t/*\n\t * Because this function is called with the lockres\n\t * spinlock, and because we know that it is not migrating/\n\t * recovering/in-progress, it is fine to reserve asts and\n\t * basts right before queueing them all throughout\n\t */\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON((res->state & (DLM_LOCK_RES_MIGRATING|\n\t\t\t      DLM_LOCK_RES_RECOVERING|\n\t\t\t      DLM_LOCK_RES_IN_PROGRESS)));\n\nconverting:\n\tif (list_empty(&res->converting))\n\t\tgoto blocked;\n\tmlog(0, \"%s: res %.*s has locks on the convert queue\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name);\n\n\ttarget = list_entry(res->converting.next, struct dlm_lock, list);\n\tif (target->ml.convert_type == LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s converting lock to invalid mode\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tBUG();\n\t}\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\t/* queue the BAST if not already */\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\t/* update the highest_blocked if needed */\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\t/* we can convert the lock */\n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Converting lock %u:%llu, type \"\n\t\t     \"%d => %d, node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type,\n\t\t     target->ml.convert_type, target->ml.node);\n\n\t\ttarget->ml.type = target->ml.convert_type;\n\t\ttarget->ml.convert_type = LKM_IVMODE;\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t/* go back and check for more */\n\t\tgoto converting;\n\t}\n\nblocked:\n\tif (list_empty(&res->blocked))\n\t\tgoto leave;\n\ttarget = list_entry(res->blocked.next, struct dlm_lock, list);\n\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\t/* we can grant the blocked lock (only\n\t * possible if converting list empty) */\n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Blocked lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type, target->ml.node);\n\n\t\t/* target->ml.type is already correct */\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t/* go back and check for more */\n\t\tgoto converting;\n\t}\n\nleave:\n\treturn;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic void dlm_shuffle_lists(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock, *target;\n\tint can_grant = 1;\n\n\t/*\n\t * Because this function is called with the lockres\n\t * spinlock, and because we know that it is not migrating/\n\t * recovering/in-progress, it is fine to reserve asts and\n\t * basts right before queueing them all throughout\n\t */\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON((res->state & (DLM_LOCK_RES_MIGRATING|\n\t\t\t      DLM_LOCK_RES_RECOVERING|\n\t\t\t      DLM_LOCK_RES_IN_PROGRESS)));\n\nconverting:\n\tif (list_empty(&res->converting))\n\t\tgoto blocked;\n\tmlog(0, \"%s: res %.*s has locks on the convert queue\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name);\n\n\ttarget = list_entry(res->converting.next, struct dlm_lock, list);\n\tif (target->ml.convert_type == LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s converting lock to invalid mode\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tBUG();\n\t}\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\t/* queue the BAST if not already */\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\t/* update the highest_blocked if needed */\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\t/* we can convert the lock */\n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Converting lock %u:%llu, type \"\n\t\t     \"%d => %d, node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type,\n\t\t     target->ml.convert_type, target->ml.node);\n\n\t\ttarget->ml.type = target->ml.convert_type;\n\t\ttarget->ml.convert_type = LKM_IVMODE;\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t/* go back and check for more */\n\t\tgoto converting;\n\t}\n\nblocked:\n\tif (list_empty(&res->blocked))\n\t\tgoto leave;\n\ttarget = list_entry(res->blocked.next, struct dlm_lock, list);\n\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\t/* we can grant the blocked lock (only\n\t * possible if converting list empty) */\n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Blocked lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type, target->ml.node);\n\n\t\t/* target->ml.type is already correct */\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t/* go back and check for more */\n\t\tgoto converting;\n\t}\n\nleave:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, inprogress, delay list \"\n\t\t\t\t     \"shuffle, state %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->state"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->state & DLM_LOCK_RES_MIGRATING"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->owner != dlm->node_num"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: inprog %d, mig %d, reco %d,\"\n\t\t\t\t     \" dirty %d\\n\"",
            "dlm->name",
            "!!(res->state & DLM_LOCK_RES_IN_PROGRESS)",
            "!!(res->state & DLM_LOCK_RES_MIGRATING)",
            "!!(res->state & DLM_LOCK_RES_RECOVERING)",
            "!!(res->state & DLM_LOCK_RES_DIRTY)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&res->dirty"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!res"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "dlm->dirty_list.next",
            "structdlm_lock_resource",
            "dirty"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_run_purge_list",
          "args": [
            "dlm",
            "dlm_shutting_down(dlm)"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_run_purge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "224-286",
          "snippet": "static void dlm_run_purge_list(struct dlm_ctxt *dlm,\n\t\t\t       int purge_now)\n{\n\tunsigned int run_max, unused;\n\tunsigned long purge_jiffies;\n\tstruct dlm_lock_resource *lockres;\n\n\tspin_lock(&dlm->spinlock);\n\trun_max = dlm->purge_count;\n\n\twhile(run_max && !list_empty(&dlm->purge_list)) {\n\t\trun_max--;\n\n\t\tlockres = list_entry(dlm->purge_list.next,\n\t\t\t\t     struct dlm_lock_resource, purge);\n\n\t\tspin_lock(&lockres->spinlock);\n\n\t\tpurge_jiffies = lockres->last_used +\n\t\t\tmsecs_to_jiffies(DLM_PURGE_INTERVAL_MS);\n\n\t\t/* Make sure that we want to be processing this guy at\n\t\t * this time. */\n\t\tif (!purge_now && time_after(purge_jiffies, jiffies)) {\n\t\t\t/* Since resources are added to the purge list\n\t\t\t * in tail order, we can stop at the first\n\t\t\t * unpurgable resource -- anyone added after\n\t\t\t * him will have a greater last_used value */\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Status of the lockres *might* change so double\n\t\t * check. If the lockres is unused, holding the dlm\n\t\t * spinlock will prevent people from getting and more\n\t\t * refs on it. */\n\t\tunused = __dlm_lockres_unused(lockres);\n\t\tif (!unused ||\n\t\t    (lockres->state & DLM_LOCK_RES_MIGRATING) ||\n\t\t    (lockres->inflight_assert_workers != 0)) {\n\t\t\tmlog(0, \"%s: res %.*s is in use or being remastered, \"\n\t\t\t     \"used %d, state %d, assert master workers %u\\n\",\n\t\t\t     dlm->name, lockres->lockname.len,\n\t\t\t     lockres->lockname.name,\n\t\t\t     !unused, lockres->state,\n\t\t\t     lockres->inflight_assert_workers);\n\t\t\tlist_move_tail(&lockres->purge, &dlm->purge_list);\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_lockres_get(lockres);\n\n\t\tdlm_purge_lockres(dlm, lockres);\n\n\t\tdlm_lockres_put(lockres);\n\n\t\t/* Avoid adding any scheduling latencies */\n\t\tcond_resched_lock(&dlm->spinlock);\n\t}\n\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic void dlm_run_purge_list(struct dlm_ctxt *dlm,\n\t\t\t       int purge_now)\n{\n\tunsigned int run_max, unused;\n\tunsigned long purge_jiffies;\n\tstruct dlm_lock_resource *lockres;\n\n\tspin_lock(&dlm->spinlock);\n\trun_max = dlm->purge_count;\n\n\twhile(run_max && !list_empty(&dlm->purge_list)) {\n\t\trun_max--;\n\n\t\tlockres = list_entry(dlm->purge_list.next,\n\t\t\t\t     struct dlm_lock_resource, purge);\n\n\t\tspin_lock(&lockres->spinlock);\n\n\t\tpurge_jiffies = lockres->last_used +\n\t\t\tmsecs_to_jiffies(DLM_PURGE_INTERVAL_MS);\n\n\t\t/* Make sure that we want to be processing this guy at\n\t\t * this time. */\n\t\tif (!purge_now && time_after(purge_jiffies, jiffies)) {\n\t\t\t/* Since resources are added to the purge list\n\t\t\t * in tail order, we can stop at the first\n\t\t\t * unpurgable resource -- anyone added after\n\t\t\t * him will have a greater last_used value */\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Status of the lockres *might* change so double\n\t\t * check. If the lockres is unused, holding the dlm\n\t\t * spinlock will prevent people from getting and more\n\t\t * refs on it. */\n\t\tunused = __dlm_lockres_unused(lockres);\n\t\tif (!unused ||\n\t\t    (lockres->state & DLM_LOCK_RES_MIGRATING) ||\n\t\t    (lockres->inflight_assert_workers != 0)) {\n\t\t\tmlog(0, \"%s: res %.*s is in use or being remastered, \"\n\t\t\t     \"used %d, state %d, assert master workers %u\\n\",\n\t\t\t     dlm->name, lockres->lockname.len,\n\t\t\t     lockres->lockname.name,\n\t\t\t     !unused, lockres->state,\n\t\t\t     lockres->inflight_assert_workers);\n\t\t\tlist_move_tail(&lockres->purge, &dlm->purge_list);\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_lockres_get(lockres);\n\n\t\tdlm_purge_lockres(dlm, lockres);\n\n\t\tdlm_lockres_put(lockres);\n\n\t\t/* Avoid adding any scheduling latencies */\n\t\tcond_resched_lock(&dlm->spinlock);\n\t}\n\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_shutting_down",
          "args": [
            "dlm"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_shutting_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "677-689",
          "snippet": "int dlm_shutting_down(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tif (dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_shutting_down(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tif (dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN)\n\t\tret = 1;\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "DLM_THREAD_TIMEOUT_MS"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_THREAD_MAX_DIRTY  100\n#define DLM_THREAD_TIMEOUT_MS (4 * 1000)\n\nstatic int dlm_thread(void *data);\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_thread(void *data)\n{\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned long timeout = msecs_to_jiffies(DLM_THREAD_TIMEOUT_MS);\n\n\tmlog(0, \"dlm thread running for %s...\\n\", dlm->name);\n\n\twhile (!kthread_should_stop()) {\n\t\tint n = DLM_THREAD_MAX_DIRTY;\n\n\t\t/* dlm_shutting_down is very point-in-time, but that\n\t\t * doesn't matter as we'll just loop back around if we\n\t\t * get false on the leading edge of a state\n\t\t * transition. */\n\t\tdlm_run_purge_list(dlm, dlm_shutting_down(dlm));\n\n\t\t/* We really don't want to hold dlm->spinlock while\n\t\t * calling dlm_shuffle_lists on each lockres that\n\t\t * needs to have its queues adjusted and AST/BASTs\n\t\t * run.  So let's pull each entry off the dirty_list\n\t\t * and drop dlm->spinlock ASAP.  Once off the list,\n\t\t * res->spinlock needs to be taken again to protect\n\t\t * the queues while calling dlm_shuffle_lists.  */\n\t\tspin_lock(&dlm->spinlock);\n\t\twhile (!list_empty(&dlm->dirty_list)) {\n\t\t\tint delay = 0;\n\t\t\tres = list_entry(dlm->dirty_list.next,\n\t\t\t\t\t struct dlm_lock_resource, dirty);\n\n\t\t\t/* peel a lockres off, remove it from the list,\n\t\t\t * unset the dirty flag and drop the dlm lock */\n\t\t\tBUG_ON(!res);\n\t\t\tdlm_lockres_get(res);\n\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* We clear the DLM_LOCK_RES_DIRTY state once we shuffle lists below */\n\t\t\tlist_del_init(&res->dirty);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t/* Drop dirty_list ref */\n\t\t\tdlm_lockres_put(res);\n\n\t\t \t/* lockres can be re-dirtied/re-added to the\n\t\t\t * dirty_list in this gap, but that is ok */\n\n\t\t\tspin_lock(&dlm->ast_lock);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (res->owner != dlm->node_num) {\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tmlog(ML_ERROR, \"%s: inprog %d, mig %d, reco %d,\"\n\t\t\t\t     \" dirty %d\\n\", dlm->name,\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_IN_PROGRESS),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_MIGRATING),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_RECOVERING),\n\t\t\t\t     !!(res->state & DLM_LOCK_RES_DIRTY));\n\t\t\t}\n\t\t\tBUG_ON(res->owner != dlm->node_num);\n\n\t\t\t/* it is now ok to move lockreses in these states\n\t\t\t * to the dirty list, assuming that they will only be\n\t\t\t * dirty for a short while. */\n\t\t\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\t\t\tif (res->state & (DLM_LOCK_RES_IN_PROGRESS |\n\t\t\t\t\t  DLM_LOCK_RES_RECOVERING)) {\n\t\t\t\t/* move it to the tail and keep going */\n\t\t\t\tres->state &= ~DLM_LOCK_RES_DIRTY;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tspin_unlock(&dlm->ast_lock);\n\t\t\t\tmlog(0, \"%s: res %.*s, inprogress, delay list \"\n\t\t\t\t     \"shuffle, state %d\\n\", dlm->name,\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     res->state);\n\t\t\t\tdelay = 1;\n\t\t\t\tgoto in_progress;\n\t\t\t}\n\n\t\t\t/* at this point the lockres is not migrating/\n\t\t\t * recovering/in-progress.  we have the lockres\n\t\t\t * spinlock and do NOT have the dlm lock.\n\t\t\t * safe to reserve/queue asts and run the lists. */\n\n\t\t\t/* called while holding lockres lock */\n\t\t\tdlm_shuffle_lists(dlm, res);\n\t\t\tres->state &= ~DLM_LOCK_RES_DIRTY;\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tspin_unlock(&dlm->ast_lock);\n\n\t\t\tdlm_lockres_calc_usage(dlm, res);\n\nin_progress:\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\t/* if the lock was in-progress, stick\n\t\t\t * it on the back of the list */\n\t\t\tif (delay) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t}\n\t\t\tdlm_lockres_put(res);\n\n\t\t\t/* unlikely, but we may need to give time to\n\t\t\t * other tasks */\n\t\t\tif (!--n) {\n\t\t\t\tmlog(0, \"%s: Throttling dlm thread\\n\",\n\t\t\t\t     dlm->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_flush_asts(dlm);\n\n\t\t/* yield and continue right away if there is more work to do */\n\t\tif (!n) {\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t}\n\n\t\twait_event_interruptible_timeout(dlm->dlm_thread_wq,\n\t\t\t\t\t\t !dlm_dirty_list_empty(dlm) ||\n\t\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t\t timeout);\n\t}\n\n\tmlog(0, \"quitting DLM thread\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_flush_asts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "516-621",
    "snippet": "static void dlm_flush_asts(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\tstruct dlm_lock *lock;\n\tstruct dlm_lock_resource *res;\n\tu8 hi;\n\n\tspin_lock(&dlm->ast_lock);\n\twhile (!list_empty(&dlm->pending_asts)) {\n\t\tlock = list_entry(dlm->pending_asts.next,\n\t\t\t\t  struct dlm_lock, ast_list);\n\t\t/* get an extra ref on lock */\n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\t\tmlog(0, \"%s: res %.*s, Flush AST for lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.type, lock->ml.node);\n\n\t\tBUG_ON(!lock->ast_pending);\n\n\t\t/* remove from list (including ref) */\n\t\tlist_del_init(&lock->ast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_do_remote_ast(dlm, res, lock);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_ast(dlm, res, lock);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t/* possible that another ast was queued while\n\t\t * we were delivering the last one */\n\t\tif (!list_empty(&lock->ast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, AST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->ast_pending = 0;\n\n\t\t/* drop the extra ref.\n\t\t * this may drop it completely. */\n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\n\twhile (!list_empty(&dlm->pending_basts)) {\n\t\tlock = list_entry(dlm->pending_basts.next,\n\t\t\t\t  struct dlm_lock, bast_list);\n\t\t/* get an extra ref on lock */\n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\n\t\tBUG_ON(!lock->bast_pending);\n\n\t\t/* get the highest blocked lock, and reset */\n\t\tspin_lock(&lock->spinlock);\n\t\tBUG_ON(lock->ml.highest_blocked <= LKM_IVMODE);\n\t\thi = lock->ml.highest_blocked;\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\tspin_unlock(&lock->spinlock);\n\n\t\t/* remove from list (including ref) */\n\t\tlist_del_init(&lock->bast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tmlog(0, \"%s: res %.*s, Flush BAST for lock %u:%llu, \"\n\t\t     \"blocked %d, node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     hi, lock->ml.node);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_send_proxy_bast(dlm, res, lock, hi);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_bast(dlm, res, lock, hi);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t/* possible that another bast was queued while\n\t\t * we were delivering the last one */\n\t\tif (!list_empty(&lock->bast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, BAST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->bast_pending = 0;\n\n\t\t/* drop the extra ref.\n\t\t * this may drop it completely. */\n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\twake_up(&dlm->ast_wq);\n\tspin_unlock(&dlm->ast_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm->ast_wq"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_release_ast",
          "args": [
            "dlm",
            "res"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_release_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3419-3436",
          "snippet": "void dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, BAST queued while flushing last \"\n\t\t\t     \"one\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lock->bast_list"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_do_local_bast",
          "args": [
            "dlm",
            "res",
            "lock",
            "hi"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_local_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "267-281",
          "snippet": "void dlm_do_local_bast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t       struct dlm_lock *lock, int blocked_type)\n{\n\tdlm_bastlockfunc_t *fn = lock->bast;\n\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     blocked_type);\n\n\t(*fn)(lock->astdata, blocked_type);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_do_local_bast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t       struct dlm_lock *lock, int blocked_type)\n{\n\tdlm_bastlockfunc_t *fn = lock->bast;\n\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     blocked_type);\n\n\t(*fn)(lock->astdata, blocked_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_proxy_bast",
          "args": [
            "dlm",
            "res",
            "lock",
            "hi"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_proxy_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "936-943",
          "snippet": "static inline int dlm_send_proxy_bast(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t      int blocked_type)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_BAST,\n\t\t\t\t      blocked_type, 0);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_send_proxy_bast(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t      int blocked_type)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_BAST,\n\t\t\t\t      blocked_type, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Flush BAST for lock %u:%llu, \"\n\t\t     \"blocked %d, node %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))",
            "hi",
            "lock->ml.node"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->bast_list"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ml.highest_blocked <= LKM_IVMODE"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lock->bast_pending"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "dlm->pending_basts.next",
            "structdlm_lock",
            "bast_list"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, AST queued while flushing last \"\n\t\t\t     \"one\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_do_local_ast",
          "args": [
            "dlm",
            "res",
            "lock"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_local_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "223-240",
          "snippet": "void dlm_do_local_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tdlm_astlockfunc_t *fn;\n\tstruct dlm_lockstatus *lksb;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tfn = lock->ast;\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tdlm_update_lvb(dlm, res, lock);\n\t(*fn)(lock->astdata);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_do_local_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tdlm_astlockfunc_t *fn;\n\tstruct dlm_lockstatus *lksb;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tfn = lock->ast;\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tdlm_update_lvb(dlm, res, lock);\n\t(*fn)(lock->astdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_do_remote_ast",
          "args": [
            "dlm",
            "res",
            "lock"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_remote_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "243-265",
          "snippet": "int dlm_do_remote_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tint ret;\n\tstruct dlm_lockstatus *lksb;\n\tint lksbflags;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Remote AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tBUG_ON(lock->ml.node == dlm->node_num);\n\n\tlksbflags = lksb->flags;\n\tdlm_update_lvb(dlm, res, lock);\n\n\t/* lock request came from another node\n\t * go do the ast over there */\n\tret = dlm_send_proxy_ast(dlm, res, lock, lksbflags);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nint dlm_do_remote_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tint ret;\n\tstruct dlm_lockstatus *lksb;\n\tint lksbflags;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Remote AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tBUG_ON(lock->ml.node == dlm->node_num);\n\n\tlksbflags = lksb->flags;\n\tdlm_update_lvb(dlm, res, lock);\n\n\t/* lock request came from another node\n\t * go do the ast over there */\n\tret = dlm_send_proxy_ast(dlm, res, lock, lksbflags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->ast_list"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lock->ast_pending"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Flush AST for lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))",
            "lock->ml.type",
            "lock->ml.node"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "dlm->pending_asts.next",
            "structdlm_lock",
            "ast_list"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\tstruct dlm_lock *lock;\n\tstruct dlm_lock_resource *res;\n\tu8 hi;\n\n\tspin_lock(&dlm->ast_lock);\n\twhile (!list_empty(&dlm->pending_asts)) {\n\t\tlock = list_entry(dlm->pending_asts.next,\n\t\t\t\t  struct dlm_lock, ast_list);\n\t\t/* get an extra ref on lock */\n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\t\tmlog(0, \"%s: res %.*s, Flush AST for lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.type, lock->ml.node);\n\n\t\tBUG_ON(!lock->ast_pending);\n\n\t\t/* remove from list (including ref) */\n\t\tlist_del_init(&lock->ast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_do_remote_ast(dlm, res, lock);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_ast(dlm, res, lock);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t/* possible that another ast was queued while\n\t\t * we were delivering the last one */\n\t\tif (!list_empty(&lock->ast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, AST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->ast_pending = 0;\n\n\t\t/* drop the extra ref.\n\t\t * this may drop it completely. */\n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\n\twhile (!list_empty(&dlm->pending_basts)) {\n\t\tlock = list_entry(dlm->pending_basts.next,\n\t\t\t\t  struct dlm_lock, bast_list);\n\t\t/* get an extra ref on lock */\n\t\tdlm_lock_get(lock);\n\t\tres = lock->lockres;\n\n\t\tBUG_ON(!lock->bast_pending);\n\n\t\t/* get the highest blocked lock, and reset */\n\t\tspin_lock(&lock->spinlock);\n\t\tBUG_ON(lock->ml.highest_blocked <= LKM_IVMODE);\n\t\thi = lock->ml.highest_blocked;\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\tspin_unlock(&lock->spinlock);\n\n\t\t/* remove from list (including ref) */\n\t\tlist_del_init(&lock->bast_list);\n\t\tdlm_lock_put(lock);\n\t\tspin_unlock(&dlm->ast_lock);\n\n\t\tmlog(0, \"%s: res %.*s, Flush BAST for lock %u:%llu, \"\n\t\t     \"blocked %d, node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     hi, lock->ml.node);\n\n\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\tret = dlm_send_proxy_bast(dlm, res, lock, hi);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tdlm_do_local_bast(dlm, res, lock, hi);\n\n\t\tspin_lock(&dlm->ast_lock);\n\n\t\t/* possible that another bast was queued while\n\t\t * we were delivering the last one */\n\t\tif (!list_empty(&lock->bast_list)) {\n\t\t\tmlog(0, \"%s: res %.*s, BAST queued while flushing last \"\n\t\t\t     \"one\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t} else\n\t\t\tlock->bast_pending = 0;\n\n\t\t/* drop the extra ref.\n\t\t * this may drop it completely. */\n\t\tdlm_lock_put(lock);\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\twake_up(&dlm->ast_wq);\n\tspin_unlock(&dlm->ast_lock);\n}"
  },
  {
    "function_name": "dlm_dirty_list_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "505-514",
    "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dlm->dirty_list"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
  },
  {
    "function_name": "dlm_complete_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "496-503",
    "snippet": "void dlm_complete_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_thread_task) {\n\t\tmlog(ML_KTHREAD, \"Waiting for dlm thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_thread_task);\n\t\tdlm->dlm_thread_task = NULL;\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "dlm->dlm_thread_task"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_KTHREAD",
            "\"Waiting for dlm thread to exit\\n\""
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_complete_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_thread_task) {\n\t\tmlog(ML_KTHREAD, \"Waiting for dlm thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_thread_task);\n\t\tdlm->dlm_thread_task = NULL;\n\t}\n}"
  },
  {
    "function_name": "dlm_launch_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "482-494",
    "snippet": "int dlm_launch_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"Starting dlm_thread...\\n\");\n\n\tdlm->dlm_thread_task = kthread_run(dlm_thread, dlm, \"dlm_thread\");\n\tif (IS_ERR(dlm->dlm_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_thread_task));\n\t\tdlm->dlm_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(dlm->dlm_thread_task)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dlm->dlm_thread_task"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dlm->dlm_thread_task"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "dlm_thread",
            "dlm",
            "\"dlm_thread\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Starting dlm_thread...\\n\""
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nint dlm_launch_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"Starting dlm_thread...\\n\");\n\n\tdlm->dlm_thread_task = kthread_run(dlm_thread, dlm, \"dlm_thread\");\n\tif (IS_ERR(dlm->dlm_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_thread_task));\n\t\tdlm->dlm_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__dlm_dirty_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "457-478",
    "snippet": "void __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&res->dirty",
            "&dlm->dirty_list"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->dirty"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}"
  },
  {
    "function_name": "dlm_kick_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "445-455",
    "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm->dlm_thread_wq"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_dirty_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_dirty_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "457-478",
          "snippet": "void __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
  },
  {
    "function_name": "dlm_shuffle_lists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "288-442",
    "snippet": "static void dlm_shuffle_lists(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock, *target;\n\tint can_grant = 1;\n\n\t/*\n\t * Because this function is called with the lockres\n\t * spinlock, and because we know that it is not migrating/\n\t * recovering/in-progress, it is fine to reserve asts and\n\t * basts right before queueing them all throughout\n\t */\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON((res->state & (DLM_LOCK_RES_MIGRATING|\n\t\t\t      DLM_LOCK_RES_RECOVERING|\n\t\t\t      DLM_LOCK_RES_IN_PROGRESS)));\n\nconverting:\n\tif (list_empty(&res->converting))\n\t\tgoto blocked;\n\tmlog(0, \"%s: res %.*s has locks on the convert queue\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name);\n\n\ttarget = list_entry(res->converting.next, struct dlm_lock, list);\n\tif (target->ml.convert_type == LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s converting lock to invalid mode\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tBUG();\n\t}\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\t/* queue the BAST if not already */\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\t/* update the highest_blocked if needed */\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\t/* we can convert the lock */\n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Converting lock %u:%llu, type \"\n\t\t     \"%d => %d, node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type,\n\t\t     target->ml.convert_type, target->ml.node);\n\n\t\ttarget->ml.type = target->ml.convert_type;\n\t\ttarget->ml.convert_type = LKM_IVMODE;\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t/* go back and check for more */\n\t\tgoto converting;\n\t}\n\nblocked:\n\tif (list_empty(&res->blocked))\n\t\tgoto leave;\n\ttarget = list_entry(res->blocked.next, struct dlm_lock, list);\n\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\t/* we can grant the blocked lock (only\n\t * possible if converting list empty) */\n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Blocked lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type, target->ml.node);\n\n\t\t/* target->ml.type is already correct */\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t/* go back and check for more */\n\t\tgoto converting;\n\t}\n\nleave:\n\treturn;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_queue_ast",
          "args": [
            "dlm",
            "target"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_queue_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "91-144",
          "snippet": "void __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tres = lock->lockres;\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tif (!list_empty(&lock->ast_list)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, lock %u:%llu, \"\n\t\t     \"AST list not empty, pending %d, newlevel %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ast_pending, lock->ml.type);\n\t\tBUG();\n\t}\n\tif (lock->ast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, AST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\n\t/* check to see if this ast obsoletes the bast */\n\tif (dlm_should_cancel_bast(dlm, lock)) {\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Cancelling BAST\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\t\tlock->bast_pending = 0;\n\t\tlist_del_init(&lock->bast_list);\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\t/* removing lock from list, remove a ref.  guaranteed\n\t\t * this won't be the last ref because of the get above,\n\t\t * so res->spinlock will not be taken here */\n\t\tdlm_lock_put(lock);\n\t\t/* free up the reserved bast that we are cancelling.\n\t\t * guaranteed that this will not be the last reserved\n\t\t * ast because *both* an ast and a bast were reserved\n\t\t * to get to this point.  the res->spinlock will not be\n\t\t * taken here */\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\tlist_add_tail(&lock->ast_list, &dlm->pending_asts);\n\tlock->ast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tres = lock->lockres;\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tif (!list_empty(&lock->ast_list)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, lock %u:%llu, \"\n\t\t     \"AST list not empty, pending %d, newlevel %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ast_pending, lock->ml.type);\n\t\tBUG();\n\t}\n\tif (lock->ast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, AST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\n\t/* check to see if this ast obsoletes the bast */\n\tif (dlm_should_cancel_bast(dlm, lock)) {\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Cancelling BAST\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\t\tlock->bast_pending = 0;\n\t\tlist_del_init(&lock->bast_list);\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\t/* removing lock from list, remove a ref.  guaranteed\n\t\t * this won't be the last ref because of the get above,\n\t\t * so res->spinlock will not be taken here */\n\t\tdlm_lock_put(lock);\n\t\t/* free up the reserved bast that we are cancelling.\n\t\t * guaranteed that this will not be the last reserved\n\t\t * ast because *both* an ast and a bast were reserved\n\t\t * to get to this point.  the res->spinlock will not be\n\t\t * taken here */\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\tlist_add_tail(&lock->ast_list, &dlm->pending_asts);\n\tlock->ast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_reserve_ast",
          "args": [
            "res"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_reserve_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3395-3404",
          "snippet": "void __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&target->spinlock"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!target->lksb"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&target->list",
            "&res->granted"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, AST for Blocked lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie))",
            "target->ml.type",
            "target->ml.node"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(target->ml.cookie)"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "target->ml.cookie"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(target->ml.cookie)"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "target->ml.cookie"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "target->ml.highest_blocked != LKM_IVMODE"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&target->spinlock"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_queue_bast",
          "args": [
            "dlm",
            "lock"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_queue_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "157-181",
          "snippet": "void __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tres = lock->lockres;\n\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tif (lock->bast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, BAST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\tlist_add_tail(&lock->bast_list, &dlm->pending_basts);\n\tlock->bast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tres = lock->lockres;\n\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tif (lock->bast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, BAST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\tlist_add_tail(&lock->bast_list, &dlm->pending_basts);\n\tlock->bast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_compatible",
          "args": [
            "lock->ml.type",
            "target->ml.type"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_compatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1064-1080",
          "snippet": "static inline int dlm_lock_compatible(int existing, int request)\n{\n\t/* NO_LOCK compatible with all */\n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t/* EX incompatible with all non-NO_LOCK */\n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t/* request must be PR, which is compatible with PR */\n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_compatible(int existing, int request)\n{\n\t/* NO_LOCK compatible with all */\n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t/* EX incompatible with all non-NO_LOCK */\n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t/* request must be PR, which is compatible with PR */\n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&res->converting",
            "list"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&res->granted",
            "list"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "res->blocked.next",
            "structdlm_lock",
            "list"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->blocked"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!target->lksb"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&target->list",
            "&res->granted"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, AST for Converting lock %u:%llu, type \"\n\t\t     \"%d => %d, node %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie))",
            "target->ml.type",
            "target->ml.convert_type",
            "target->ml.node"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "target->ml.cookie"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "target->ml.cookie"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "target->ml.highest_blocked != LKM_IVMODE"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&res->converting",
            "list"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&res->granted",
            "list"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s converting lock to invalid mode\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "res->converting.next",
            "structdlm_lock",
            "list"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s has locks on the convert queue\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(res->state & (DLM_LOCK_RES_MIGRATING|\n\t\t\t      DLM_LOCK_RES_RECOVERING|\n\t\t\t      DLM_LOCK_RES_IN_PROGRESS))"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic void dlm_shuffle_lists(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock, *target;\n\tint can_grant = 1;\n\n\t/*\n\t * Because this function is called with the lockres\n\t * spinlock, and because we know that it is not migrating/\n\t * recovering/in-progress, it is fine to reserve asts and\n\t * basts right before queueing them all throughout\n\t */\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON((res->state & (DLM_LOCK_RES_MIGRATING|\n\t\t\t      DLM_LOCK_RES_RECOVERING|\n\t\t\t      DLM_LOCK_RES_IN_PROGRESS)));\n\nconverting:\n\tif (list_empty(&res->converting))\n\t\tgoto blocked;\n\tmlog(0, \"%s: res %.*s has locks on the convert queue\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name);\n\n\ttarget = list_entry(res->converting.next, struct dlm_lock, list);\n\tif (target->ml.convert_type == LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s converting lock to invalid mode\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tBUG();\n\t}\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\t/* queue the BAST if not already */\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\t/* update the highest_blocked if needed */\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type,\n\t\t\t\t\t target->ml.convert_type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.convert_type)\n\t\t\t\tlock->ml.highest_blocked =\n\t\t\t\t\ttarget->ml.convert_type;\n\t\t}\n\t}\n\n\t/* we can convert the lock */\n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Converting lock %u:%llu, type \"\n\t\t     \"%d => %d, node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type,\n\t\t     target->ml.convert_type, target->ml.node);\n\n\t\ttarget->ml.type = target->ml.convert_type;\n\t\ttarget->ml.convert_type = LKM_IVMODE;\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t/* go back and check for more */\n\t\tgoto converting;\n\t}\n\nblocked:\n\tif (list_empty(&res->blocked))\n\t\tgoto leave;\n\ttarget = list_entry(res->blocked.next, struct dlm_lock, list);\n\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\tif (lock==target)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(lock->ml.type, target->ml.type)) {\n\t\t\tcan_grant = 0;\n\t\t\tif (lock->ml.highest_blocked == LKM_IVMODE) {\n\t\t\t\t__dlm_lockres_reserve_ast(res);\n\t\t\t\t__dlm_queue_bast(dlm, lock);\n\t\t\t}\n\t\t\tif (lock->ml.highest_blocked < target->ml.type)\n\t\t\t\tlock->ml.highest_blocked = target->ml.type;\n\t\t}\n\t}\n\n\t/* we can grant the blocked lock (only\n\t * possible if converting list empty) */\n\tif (can_grant) {\n\t\tspin_lock(&target->spinlock);\n\t\tBUG_ON(target->ml.highest_blocked != LKM_IVMODE);\n\n\t\tmlog(0, \"%s: res %.*s, AST for Blocked lock %u:%llu, type %d, \"\n\t\t     \"node %u\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(target->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(target->ml.cookie)),\n\t\t     target->ml.type, target->ml.node);\n\n\t\t/* target->ml.type is already correct */\n\t\tlist_move_tail(&target->list, &res->granted);\n\n\t\tBUG_ON(!target->lksb);\n\t\ttarget->lksb->status = DLM_NORMAL;\n\n\t\tspin_unlock(&target->spinlock);\n\n\t\t__dlm_lockres_reserve_ast(res);\n\t\t__dlm_queue_ast(dlm, target);\n\t\t/* go back and check for more */\n\t\tgoto converting;\n\t}\n\nleave:\n\treturn;\n}"
  },
  {
    "function_name": "dlm_run_purge_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "224-286",
    "snippet": "static void dlm_run_purge_list(struct dlm_ctxt *dlm,\n\t\t\t       int purge_now)\n{\n\tunsigned int run_max, unused;\n\tunsigned long purge_jiffies;\n\tstruct dlm_lock_resource *lockres;\n\n\tspin_lock(&dlm->spinlock);\n\trun_max = dlm->purge_count;\n\n\twhile(run_max && !list_empty(&dlm->purge_list)) {\n\t\trun_max--;\n\n\t\tlockres = list_entry(dlm->purge_list.next,\n\t\t\t\t     struct dlm_lock_resource, purge);\n\n\t\tspin_lock(&lockres->spinlock);\n\n\t\tpurge_jiffies = lockres->last_used +\n\t\t\tmsecs_to_jiffies(DLM_PURGE_INTERVAL_MS);\n\n\t\t/* Make sure that we want to be processing this guy at\n\t\t * this time. */\n\t\tif (!purge_now && time_after(purge_jiffies, jiffies)) {\n\t\t\t/* Since resources are added to the purge list\n\t\t\t * in tail order, we can stop at the first\n\t\t\t * unpurgable resource -- anyone added after\n\t\t\t * him will have a greater last_used value */\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Status of the lockres *might* change so double\n\t\t * check. If the lockres is unused, holding the dlm\n\t\t * spinlock will prevent people from getting and more\n\t\t * refs on it. */\n\t\tunused = __dlm_lockres_unused(lockres);\n\t\tif (!unused ||\n\t\t    (lockres->state & DLM_LOCK_RES_MIGRATING) ||\n\t\t    (lockres->inflight_assert_workers != 0)) {\n\t\t\tmlog(0, \"%s: res %.*s is in use or being remastered, \"\n\t\t\t     \"used %d, state %d, assert master workers %u\\n\",\n\t\t\t     dlm->name, lockres->lockname.len,\n\t\t\t     lockres->lockname.name,\n\t\t\t     !unused, lockres->state,\n\t\t\t     lockres->inflight_assert_workers);\n\t\t\tlist_move_tail(&lockres->purge, &dlm->purge_list);\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_lockres_get(lockres);\n\n\t\tdlm_purge_lockres(dlm, lockres);\n\n\t\tdlm_lockres_put(lockres);\n\n\t\t/* Avoid adding any scheduling latencies */\n\t\tcond_resched_lock(&dlm->spinlock);\n\t}\n\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "lockres"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_purge_lockres",
          "args": [
            "dlm",
            "lockres"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_purge_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "162-222",
          "snippet": "static void dlm_purge_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tint master;\n\tint ret = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tmaster = (res->owner == dlm->node_num);\n\n\tmlog(0, \"%s: Purging res %.*s, master %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, master);\n\n\tif (!master) {\n\t\tres->state |= DLM_LOCK_RES_DROPPING_REF;\n\t\t/* drop spinlock...  retake below */\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tspin_lock(&res->spinlock);\n\t\t/* This ensures that clear refmap is sent after the set */\n\t\t__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_SETREF_INPROG);\n\t\tspin_unlock(&res->spinlock);\n\n\t\t/* clear our bit from the master's refmap, ignore errors */\n\t\tret = dlm_drop_lockres_ref(dlm, res);\n\t\tif (ret < 0) {\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t}\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t}\n\n\tif (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purgelist, master %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, master);\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n\n\tif (!__dlm_lockres_unused(res)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s in use after deref\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t__dlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\n\t__dlm_unhash_lockres(dlm, res);\n\n\t/* lockres is not in the hash now.  drop the flag and wake up\n\t * any processes waiting in dlm_get_lock_resource. */\n\tif (!master) {\n\t\tres->state &= ~DLM_LOCK_RES_DROPPING_REF;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t} else\n\t\tspin_unlock(&res->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic void dlm_purge_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tint master;\n\tint ret = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tmaster = (res->owner == dlm->node_num);\n\n\tmlog(0, \"%s: Purging res %.*s, master %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, master);\n\n\tif (!master) {\n\t\tres->state |= DLM_LOCK_RES_DROPPING_REF;\n\t\t/* drop spinlock...  retake below */\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tspin_lock(&res->spinlock);\n\t\t/* This ensures that clear refmap is sent after the set */\n\t\t__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_SETREF_INPROG);\n\t\tspin_unlock(&res->spinlock);\n\n\t\t/* clear our bit from the master's refmap, ignore errors */\n\t\tret = dlm_drop_lockres_ref(dlm, res);\n\t\tif (ret < 0) {\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t}\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t}\n\n\tif (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purgelist, master %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, master);\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n\n\tif (!__dlm_lockres_unused(res)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s in use after deref\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t__dlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\n\t__dlm_unhash_lockres(dlm, res);\n\n\t/* lockres is not in the hash now.  drop the flag and wake up\n\t * any processes waiting in dlm_get_lock_resource. */\n\tif (!master) {\n\t\tres->state &= ~DLM_LOCK_RES_DROPPING_REF;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t} else\n\t\tspin_unlock(&res->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "lockres"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lockres->purge",
            "&dlm->purge_list"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s is in use or being remastered, \"\n\t\t\t     \"used %d, state %d, assert master workers %u\\n\"",
            "dlm->name",
            "lockres->lockname.len",
            "lockres->lockname.name",
            "!unused",
            "lockres->state",
            "lockres->inflight_assert_workers"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_unused",
          "args": [
            "lockres"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "93-118",
          "snippet": "int __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t/* Locks are in the process of being created */\n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\t/* Another node has this resource with this node as the master */\n\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t/* Locks are in the process of being created */\n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\t/* Another node has this resource with this node as the master */\n\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "purge_jiffies",
            "jiffies"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "DLM_PURGE_INTERVAL_MS"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->spinlock"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "dlm->purge_list.next",
            "structdlm_lock_resource",
            "purge"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dlm->purge_list"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic void dlm_run_purge_list(struct dlm_ctxt *dlm,\n\t\t\t       int purge_now)\n{\n\tunsigned int run_max, unused;\n\tunsigned long purge_jiffies;\n\tstruct dlm_lock_resource *lockres;\n\n\tspin_lock(&dlm->spinlock);\n\trun_max = dlm->purge_count;\n\n\twhile(run_max && !list_empty(&dlm->purge_list)) {\n\t\trun_max--;\n\n\t\tlockres = list_entry(dlm->purge_list.next,\n\t\t\t\t     struct dlm_lock_resource, purge);\n\n\t\tspin_lock(&lockres->spinlock);\n\n\t\tpurge_jiffies = lockres->last_used +\n\t\t\tmsecs_to_jiffies(DLM_PURGE_INTERVAL_MS);\n\n\t\t/* Make sure that we want to be processing this guy at\n\t\t * this time. */\n\t\tif (!purge_now && time_after(purge_jiffies, jiffies)) {\n\t\t\t/* Since resources are added to the purge list\n\t\t\t * in tail order, we can stop at the first\n\t\t\t * unpurgable resource -- anyone added after\n\t\t\t * him will have a greater last_used value */\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Status of the lockres *might* change so double\n\t\t * check. If the lockres is unused, holding the dlm\n\t\t * spinlock will prevent people from getting and more\n\t\t * refs on it. */\n\t\tunused = __dlm_lockres_unused(lockres);\n\t\tif (!unused ||\n\t\t    (lockres->state & DLM_LOCK_RES_MIGRATING) ||\n\t\t    (lockres->inflight_assert_workers != 0)) {\n\t\t\tmlog(0, \"%s: res %.*s is in use or being remastered, \"\n\t\t\t     \"used %d, state %d, assert master workers %u\\n\",\n\t\t\t     dlm->name, lockres->lockname.len,\n\t\t\t     lockres->lockname.name,\n\t\t\t     !unused, lockres->state,\n\t\t\t     lockres->inflight_assert_workers);\n\t\t\tlist_move_tail(&lockres->purge, &dlm->purge_list);\n\t\t\tspin_unlock(&lockres->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_lockres_get(lockres);\n\n\t\tdlm_purge_lockres(dlm, lockres);\n\n\t\tdlm_lockres_put(lockres);\n\n\t\t/* Avoid adding any scheduling latencies */\n\t\tcond_resched_lock(&dlm->spinlock);\n\t}\n\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "dlm_purge_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "162-222",
    "snippet": "static void dlm_purge_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tint master;\n\tint ret = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tmaster = (res->owner == dlm->node_num);\n\n\tmlog(0, \"%s: Purging res %.*s, master %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, master);\n\n\tif (!master) {\n\t\tres->state |= DLM_LOCK_RES_DROPPING_REF;\n\t\t/* drop spinlock...  retake below */\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tspin_lock(&res->spinlock);\n\t\t/* This ensures that clear refmap is sent after the set */\n\t\t__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_SETREF_INPROG);\n\t\tspin_unlock(&res->spinlock);\n\n\t\t/* clear our bit from the master's refmap, ignore errors */\n\t\tret = dlm_drop_lockres_ref(dlm, res);\n\t\tif (ret < 0) {\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t}\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t}\n\n\tif (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purgelist, master %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, master);\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n\n\tif (!__dlm_lockres_unused(res)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s in use after deref\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t__dlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\n\t__dlm_unhash_lockres(dlm, res);\n\n\t/* lockres is not in the hash now.  drop the flag and wake up\n\t * any processes waiting in dlm_get_lock_resource. */\n\tif (!master) {\n\t\tres->state &= ~DLM_LOCK_RES_DROPPING_REF;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t} else\n\t\tspin_unlock(&res->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_unhash_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_unhash_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "158-167",
          "snippet": "void __dlm_unhash_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (hlist_unhashed(&res->hash_node))\n\t\treturn;\n\n\tmlog(0, \"%s: Unhash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\thlist_del_init(&res->hash_node);\n\tdlm_lockres_put(res);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid __dlm_unhash_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (hlist_unhashed(&res->hash_node))\n\t\treturn;\n\n\tmlog(0, \"%s: Unhash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\thlist_del_init(&res->hash_node);\n\tdlm_lockres_put(res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s in use after deref\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_unused",
          "args": [
            "res"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "93-118",
          "snippet": "int __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t/* Locks are in the process of being created */\n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\t/* Another node has this resource with this node as the master */\n\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t/* Locks are in the process of being created */\n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\t/* Another node has this resource with this node as the master */\n\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&res->purge"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Removing res %.*s from purgelist, master %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "master"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->purge"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_drop_lockres_ref",
          "args": [
            "dlm",
            "res"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_drop_lockres_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2236-2265",
          "snippet": "int dlm_drop_lockres_ref(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct dlm_deref_lockres deref;\n\tint ret = 0, r;\n\tconst char *lockname;\n\tunsigned int namelen;\n\n\tlockname = res->lockname.name;\n\tnamelen = res->lockname.len;\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tmemset(&deref, 0, sizeof(deref));\n\tderef.node_idx = dlm->node_num;\n\tderef.namelen = namelen;\n\tmemcpy(deref.name, lockname, namelen);\n\n\tret = o2net_send_message(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t &deref, sizeof(deref), res->owner, &r);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send DEREF to node %u\\n\",\n\t\t     dlm->name, namelen, lockname, ret, res->owner);\n\telse if (r < 0) {\n\t\t/* BAD.  other node says I did not have a ref. */\n\t\tmlog(ML_ERROR, \"%s: res %.*s, DEREF to node %u got %d\\n\",\n\t\t     dlm->name, namelen, lockname, res->owner, r);\n\t\tdlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_drop_lockres_ref(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct dlm_deref_lockres deref;\n\tint ret = 0, r;\n\tconst char *lockname;\n\tunsigned int namelen;\n\n\tlockname = res->lockname.name;\n\tnamelen = res->lockname.len;\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tmemset(&deref, 0, sizeof(deref));\n\tderef.node_idx = dlm->node_num;\n\tderef.namelen = namelen;\n\tmemcpy(deref.name, lockname, namelen);\n\n\tret = o2net_send_message(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t &deref, sizeof(deref), res->owner, &r);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send DEREF to node %u\\n\",\n\t\t     dlm->name, namelen, lockname, ret, res->owner);\n\telse if (r < 0) {\n\t\t/* BAD.  other node says I did not have a ref. */\n\t\tmlog(ML_ERROR, \"%s: res %.*s, DEREF to node %u got %d\\n\",\n\t\t     dlm->name, namelen, lockname, res->owner, r);\n\t\tdlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres_flags",
          "args": [
            "res",
            "DLM_LOCK_RES_SETREF_INPROG"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "61-78",
          "snippet": "void __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Purging res %.*s, master %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "master"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic void dlm_purge_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tint master;\n\tint ret = 0;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tmaster = (res->owner == dlm->node_num);\n\n\tmlog(0, \"%s: Purging res %.*s, master %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, master);\n\n\tif (!master) {\n\t\tres->state |= DLM_LOCK_RES_DROPPING_REF;\n\t\t/* drop spinlock...  retake below */\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tspin_lock(&res->spinlock);\n\t\t/* This ensures that clear refmap is sent after the set */\n\t\t__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_SETREF_INPROG);\n\t\tspin_unlock(&res->spinlock);\n\n\t\t/* clear our bit from the master's refmap, ignore errors */\n\t\tret = dlm_drop_lockres_ref(dlm, res);\n\t\tif (ret < 0) {\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t}\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t}\n\n\tif (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purgelist, master %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, master);\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n\n\tif (!__dlm_lockres_unused(res)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s in use after deref\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t__dlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\n\t__dlm_unhash_lockres(dlm, res);\n\n\t/* lockres is not in the hash now.  drop the flag and wake up\n\t * any processes waiting in dlm_get_lock_resource. */\n\tif (!master) {\n\t\tres->state &= ~DLM_LOCK_RES_DROPPING_REF;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t} else\n\t\tspin_unlock(&res->spinlock);\n}"
  },
  {
    "function_name": "dlm_lockres_calc_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "150-160",
    "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "124-148",
          "snippet": "void __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "__dlm_lockres_calc_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "124-148",
    "snippet": "void __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&res->purge"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Removing res %.*s from purge list\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->purge"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&res->purge",
            "&dlm->purge_list"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Adding res %.*s to purge list\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_unused",
          "args": [
            "res"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "93-118",
          "snippet": "int __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t/* Locks are in the process of being created */\n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\t/* Another node has this resource with this node as the master */\n\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t/* Locks are in the process of being created */\n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\t/* Another node has this resource with this node as the master */\n\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}"
  },
  {
    "function_name": "__dlm_lockres_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "93-118",
    "snippet": "int __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t/* Locks are in the process of being created */\n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\t/* Another node has this resource with this node as the master */\n\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "res->refmap",
            "O2NM_MAX_NODES",
            "0"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->dirty"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_has_locks",
          "args": [
            "res"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_has_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "80-87",
          "snippet": "int __dlm_lockres_has_locks(struct dlm_lock_resource *res)\n{\n\tif (list_empty(&res->granted) &&\n\t    list_empty(&res->converting) &&\n\t    list_empty(&res->blocked))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint __dlm_lockres_has_locks(struct dlm_lock_resource *res)\n{\n\tif (list_empty(&res->granted) &&\n\t    list_empty(&res->converting) &&\n\t    list_empty(&res->blocked))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint __dlm_lockres_unused(struct dlm_lock_resource *res)\n{\n\tint bit;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_has_locks(res))\n\t\treturn 0;\n\n\t/* Locks are in the process of being created */\n\tif (res->inflight_locks)\n\t\treturn 0;\n\n\tif (!list_empty(&res->dirty) || res->state & DLM_LOCK_RES_DIRTY)\n\t\treturn 0;\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\t/* Another node has this resource with this node as the master */\n\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\tif (bit < O2NM_MAX_NODES)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "__dlm_lockres_has_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "80-87",
    "snippet": "int __dlm_lockres_has_locks(struct dlm_lock_resource *res)\n{\n\tif (list_empty(&res->granted) &&\n\t    list_empty(&res->converting) &&\n\t    list_empty(&res->blocked))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->blocked"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint __dlm_lockres_has_locks(struct dlm_lock_resource *res)\n{\n\tif (list_empty(&res->granted) &&\n\t    list_empty(&res->converting) &&\n\t    list_empty(&res->blocked))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "__dlm_wait_on_lockres_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
    "lines": "61-78",
    "snippet": "void __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&res->wq",
            "&wait"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&res->wq",
            "&wait"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}"
  }
]