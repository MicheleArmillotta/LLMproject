[
  {
    "function_name": "dlm_force_free_mles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3438-3474",
    "snippet": "void dlm_force_free_mles(struct dlm_ctxt *dlm)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_master_list_entry *mle;\n\tstruct hlist_node *tmp;\n\n\t/*\n\t * We notified all other nodes that we are exiting the domain and\n\t * marked the dlm state to DLM_CTXT_LEAVING. If any mles are still\n\t * around we force free them and wake any processes that are waiting\n\t * on the mles\n\t */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\n\tBUG_ON(dlm->dlm_state != DLM_CTXT_LEAVING);\n\tBUG_ON((find_next_bit(dlm->domain_map, O2NM_MAX_NODES, 0) < O2NM_MAX_NODES));\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry_safe(mle, tmp, bucket, master_hash_node) {\n\t\t\tif (mle->type != DLM_MLE_BLOCK) {\n\t\t\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t}\n\t\t\tatomic_set(&mle->woken, 1);\n\t\t\twake_up(&mle->wq);\n\n\t\t\t__dlm_unlink_mle(dlm, mle);\n\t\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "229-244",
          "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3468
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "187-192",
          "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_unlink_mle",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_unlink_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "319-326",
          "snippet": "void __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&mle->wq"
          ],
          "line": 3465
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mle->woken",
            "1"
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_mle",
          "args": [
            "mle"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_one_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "328-337",
          "snippet": "void dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bad mle: %p\\n\"",
            "mle"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "mle",
            "tmp",
            "bucket",
            "master_hash_node"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_master_hash",
          "args": [
            "dlm",
            "i"
          ],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_master_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "195-200",
          "snippet": "static inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(find_next_bit(dlm->domain_map, O2NM_MAX_NODES, 0) < O2NM_MAX_NODES)"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "dlm->domain_map",
            "O2NM_MAX_NODES",
            "0"
          ],
          "line": 3455
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dlm->dlm_state != DLM_CTXT_LEAVING"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\n\nvoid dlm_force_free_mles(struct dlm_ctxt *dlm)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_master_list_entry *mle;\n\tstruct hlist_node *tmp;\n\n\t/*\n\t * We notified all other nodes that we are exiting the domain and\n\t * marked the dlm state to DLM_CTXT_LEAVING. If any mles are still\n\t * around we force free them and wake any processes that are waiting\n\t * on the mles\n\t */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\n\tBUG_ON(dlm->dlm_state != DLM_CTXT_LEAVING);\n\tBUG_ON((find_next_bit(dlm->domain_map, O2NM_MAX_NODES, 0) < O2NM_MAX_NODES));\n\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry_safe(mle, tmp, bucket, master_hash_node) {\n\t\t\tif (mle->type != DLM_MLE_BLOCK) {\n\t\t\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t}\n\t\t\tatomic_set(&mle->woken, 1);\n\t\t\twake_up(&mle->wq);\n\n\t\t\t__dlm_unlink_mle(dlm, mle);\n\t\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "dlm_lockres_release_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3419-3436",
    "snippet": "void dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm->migration_wq"
          ],
          "line": 3435
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 3433
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->state & DLM_LOCK_RES_MIGRATING"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&res->asts_reserved",
            "&res->spinlock"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}"
  },
  {
    "function_name": "__dlm_lockres_reserve_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3395-3404",
    "snippet": "void __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&res->asts_reserved"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->state & DLM_LOCK_RES_MIGRATING"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}"
  },
  {
    "function_name": "dlm_finish_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3321-3384",
    "snippet": "int dlm_finish_migration(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t u8 old_master)\n{\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tclear_bit(old_master, iter.node_map);\n\tclear_bit(dlm->node_num, iter.node_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* ownership of the lockres is changing.  account for the\n\t * mastery reference here since old_master will briefly have\n\t * a reference after the migration completes */\n\tspin_lock(&res->spinlock);\n\tdlm_lockres_set_refmap_bit(dlm, res, old_master);\n\tspin_unlock(&res->spinlock);\n\n\tmlog(0, \"now time to do a migrate request to other nodes\\n\");\n\tret = dlm_do_migrate_request(dlm, res, old_master,\n\t\t\t\t     dlm->node_num, &iter);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"doing assert master of %.*s to all except the original node\\n\",\n\t     res->lockname.len, res->lockname.name);\n\t/* this call now finishes out the nodemap\n\t * even if one or more nodes die */\n\tret = dlm_do_assert_master(dlm, res, iter.node_map,\n\t\t\t\t   DLM_ASSERT_MASTER_FINISH_MIGRATION);\n\tif (ret < 0) {\n\t\t/* no longer need to retry.  all living nodes contacted. */\n\t\tmlog_errno(ret);\n\t\tret = 0;\n\t}\n\n\tmemset(iter.node_map, 0, sizeof(iter.node_map));\n\tset_bit(old_master, iter.node_map);\n\tmlog(0, \"doing assert master of %.*s back to %u\\n\",\n\t     res->lockname.len, res->lockname.name, old_master);\n\tret = dlm_do_assert_master(dlm, res, iter.node_map,\n\t\t\t\t   DLM_ASSERT_MASTER_FINISH_MIGRATION);\n\tif (ret < 0) {\n\t\tmlog(0, \"assert master to original master failed \"\n\t\t     \"with %d.\\n\", ret);\n\t\t/* the only nonzero status here would be because of\n\t\t * a dead original node.  we're done. */\n\t\tret = 0;\n\t}\n\n\t/* all done, set the owner, clear the flag */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, dlm->node_num);\n\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\t/* re-dirty it on the new master */\n\tdlm_kick_thread(dlm, res);\n\twake_up(&res->wq);\nleave:\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_lockres_owner",
          "args": [
            "dlm",
            "res",
            "dlm->node_num"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1131-1138",
          "snippet": "static inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"assert master to original master failed \"\n\t\t     \"with %d.\\n\"",
            "ret"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_do_assert_master",
          "args": [
            "dlm",
            "res",
            "iter.node_map",
            "DLM_ASSERT_MASTER_FINISH_MIGRATION"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_assert_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1670-1768",
          "snippet": "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags)\n{\n\tstruct dlm_assert_master assert;\n\tint to, tmpret;\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\tint reassert;\n\tconst char *lockname = res->lockname.name;\n\tunsigned int namelen = res->lockname.len;\n\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tspin_lock(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\nagain:\n\treassert = 0;\n\n\t/* note that if this nodemap is empty, it returns 0 */\n\tdlm_node_iter_init(nodemap, &iter);\n\twhile ((to = dlm_node_iter_next(&iter)) >= 0) {\n\t\tint r = 0;\n\t\tstruct dlm_master_list_entry *mle = NULL;\n\n\t\tmlog(0, \"sending assert master to %d (%.*s)\\n\", to,\n\t\t     namelen, lockname);\n\t\tmemset(&assert, 0, sizeof(assert));\n\t\tassert.node_idx = dlm->node_num;\n\t\tassert.namelen = namelen;\n\t\tmemcpy(assert.name, lockname, namelen);\n\t\tassert.flags = cpu_to_be32(flags);\n\n\t\ttmpret = o2net_send_message(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\t    &assert, sizeof(assert), to, &r);\n\t\tif (tmpret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", tmpret,\n\t\t\t     DLM_ASSERT_MASTER_MSG, dlm->key, to);\n\t\t\tif (!dlm_is_host_down(tmpret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", tmpret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* a node died.  finish out the rest of the nodes. */\n\t\t\tmlog(0, \"link to %d went down!\\n\", to);\n\t\t\t/* any nonzero status return will do */\n\t\t\tret = tmpret;\n\t\t\tr = 0;\n\t\t} else if (r < 0) {\n\t\t\t/* ok, something horribly messed.  kill thyself. */\n\t\t\tmlog(ML_ERROR,\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\", namelen, lockname, to, r);\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tspin_lock(&dlm->master_lock);\n\t\t\tif (dlm_find_mle(dlm, &mle, (char *)lockname,\n\t\t\t\t\t namelen)) {\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t}\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT &&\n\t\t    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {\n\t\t\t\tmlog(ML_ERROR, \"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\",\n\t\t\t\t     namelen, lockname, to);\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT) {\n\t\t\tmlog(0, \"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\treassert = 1;\n\t\t}\n\t\tif (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {\n\t\t\tmlog(0, \"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, to);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (reassert)\n\t\tgoto again;\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags)\n{\n\tstruct dlm_assert_master assert;\n\tint to, tmpret;\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\tint reassert;\n\tconst char *lockname = res->lockname.name;\n\tunsigned int namelen = res->lockname.len;\n\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tspin_lock(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\nagain:\n\treassert = 0;\n\n\t/* note that if this nodemap is empty, it returns 0 */\n\tdlm_node_iter_init(nodemap, &iter);\n\twhile ((to = dlm_node_iter_next(&iter)) >= 0) {\n\t\tint r = 0;\n\t\tstruct dlm_master_list_entry *mle = NULL;\n\n\t\tmlog(0, \"sending assert master to %d (%.*s)\\n\", to,\n\t\t     namelen, lockname);\n\t\tmemset(&assert, 0, sizeof(assert));\n\t\tassert.node_idx = dlm->node_num;\n\t\tassert.namelen = namelen;\n\t\tmemcpy(assert.name, lockname, namelen);\n\t\tassert.flags = cpu_to_be32(flags);\n\n\t\ttmpret = o2net_send_message(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\t    &assert, sizeof(assert), to, &r);\n\t\tif (tmpret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", tmpret,\n\t\t\t     DLM_ASSERT_MASTER_MSG, dlm->key, to);\n\t\t\tif (!dlm_is_host_down(tmpret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", tmpret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* a node died.  finish out the rest of the nodes. */\n\t\t\tmlog(0, \"link to %d went down!\\n\", to);\n\t\t\t/* any nonzero status return will do */\n\t\t\tret = tmpret;\n\t\t\tr = 0;\n\t\t} else if (r < 0) {\n\t\t\t/* ok, something horribly messed.  kill thyself. */\n\t\t\tmlog(ML_ERROR,\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\", namelen, lockname, to, r);\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tspin_lock(&dlm->master_lock);\n\t\t\tif (dlm_find_mle(dlm, &mle, (char *)lockname,\n\t\t\t\t\t namelen)) {\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t}\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT &&\n\t\t    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {\n\t\t\t\tmlog(ML_ERROR, \"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\",\n\t\t\t\t     namelen, lockname, to);\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT) {\n\t\t\tmlog(0, \"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\treassert = 1;\n\t\t}\n\t\tif (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {\n\t\t\tmlog(0, \"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, to);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (reassert)\n\t\tgoto again;\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"doing assert master of %.*s back to %u\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "old_master"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "old_master",
            "iter.node_map"
          ],
          "line": 3361
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iter.node_map",
            "0",
            "sizeof(iter.node_map)"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"doing assert master of %.*s to all except the original node\\n\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_do_migrate_request",
          "args": [
            "dlm",
            "res",
            "old_master",
            "dlm->node_num",
            "&iter"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_migrate_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2945-3012",
          "snippet": "static int dlm_do_migrate_request(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  u8 master, u8 new_master,\n\t\t\t\t  struct dlm_node_iter *iter)\n{\n\tstruct dlm_migrate_request migrate;\n\tint ret, skip, status = 0;\n\tint nodenum;\n\n\tmemset(&migrate, 0, sizeof(migrate));\n\tmigrate.namelen = res->lockname.len;\n\tmemcpy(migrate.name, res->lockname.name, migrate.namelen);\n\tmigrate.new_master = new_master;\n\tmigrate.master = master;\n\n\tret = 0;\n\n\t/* send message to all nodes, except the master and myself */\n\twhile ((nodenum = dlm_node_iter_next(iter)) >= 0) {\n\t\tif (nodenum == master ||\n\t\t    nodenum == new_master)\n\t\t\tcontinue;\n\n\t\t/* We could race exit domain. If exited, skip. */\n\t\tspin_lock(&dlm->spinlock);\n\t\tskip = (!test_bit(nodenum, dlm->domain_map));\n\t\tspin_unlock(&dlm->spinlock);\n\t\tif (skip) {\n\t\t\tclear_bit(nodenum, iter->node_map);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = o2net_send_message(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\t &migrate, sizeof(migrate), nodenum,\n\t\t\t\t\t &status);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send \"\n\t\t\t     \"MIGRATE_REQUEST to node %u\\n\", dlm->name,\n\t\t\t     migrate.namelen, migrate.name, ret, nodenum);\n\t\t\tif (!dlm_is_host_down(ret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", ret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tclear_bit(nodenum, iter->node_map);\n\t\t\tret = 0;\n\t\t} else if (status < 0) {\n\t\t\tmlog(0, \"migrate request (node %u) returned %d!\\n\",\n\t\t\t     nodenum, status);\n\t\t\tret = status;\n\t\t} else if (status == DLM_MIGRATE_RESPONSE_MASTERY_REF) {\n\t\t\t/* during the migration request we short-circuited\n\t\t\t * the mastery of the lockres.  make sure we have\n\t\t\t * a mastery ref for nodenum */\n\t\t\tmlog(0, \"%s:%.*s: need ref for node %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     nodenum);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, nodenum);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tmlog(0, \"returning ret=%d\\n\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_migrate_request(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  u8 master, u8 new_master,\n\t\t\t\t  struct dlm_node_iter *iter)\n{\n\tstruct dlm_migrate_request migrate;\n\tint ret, skip, status = 0;\n\tint nodenum;\n\n\tmemset(&migrate, 0, sizeof(migrate));\n\tmigrate.namelen = res->lockname.len;\n\tmemcpy(migrate.name, res->lockname.name, migrate.namelen);\n\tmigrate.new_master = new_master;\n\tmigrate.master = master;\n\n\tret = 0;\n\n\t/* send message to all nodes, except the master and myself */\n\twhile ((nodenum = dlm_node_iter_next(iter)) >= 0) {\n\t\tif (nodenum == master ||\n\t\t    nodenum == new_master)\n\t\t\tcontinue;\n\n\t\t/* We could race exit domain. If exited, skip. */\n\t\tspin_lock(&dlm->spinlock);\n\t\tskip = (!test_bit(nodenum, dlm->domain_map));\n\t\tspin_unlock(&dlm->spinlock);\n\t\tif (skip) {\n\t\t\tclear_bit(nodenum, iter->node_map);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = o2net_send_message(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\t &migrate, sizeof(migrate), nodenum,\n\t\t\t\t\t &status);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send \"\n\t\t\t     \"MIGRATE_REQUEST to node %u\\n\", dlm->name,\n\t\t\t     migrate.namelen, migrate.name, ret, nodenum);\n\t\t\tif (!dlm_is_host_down(ret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", ret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tclear_bit(nodenum, iter->node_map);\n\t\t\tret = 0;\n\t\t} else if (status < 0) {\n\t\t\tmlog(0, \"migrate request (node %u) returned %d!\\n\",\n\t\t\t     nodenum, status);\n\t\t\tret = status;\n\t\t} else if (status == DLM_MIGRATE_RESPONSE_MASTERY_REF) {\n\t\t\t/* during the migration request we short-circuited\n\t\t\t * the mastery of the lockres.  make sure we have\n\t\t\t * a mastery ref for nodenum */\n\t\t\tmlog(0, \"%s:%.*s: need ref for node %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     nodenum);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, nodenum);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tmlog(0, \"returning ret=%d\\n\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"now time to do a migrate request to other nodes\\n\""
          ],
          "line": 3340
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_set_refmap_bit",
          "args": [
            "dlm",
            "res",
            "old_master"
          ],
          "line": 3337
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_set_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "633-642",
          "snippet": "void dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "dlm->node_num",
            "iter.node_map"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_init",
          "args": [
            "dlm->domain_map",
            "&iter"
          ],
          "line": 3328
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1112-1117",
          "snippet": "static inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_finish_migration(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t u8 old_master)\n{\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tclear_bit(old_master, iter.node_map);\n\tclear_bit(dlm->node_num, iter.node_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* ownership of the lockres is changing.  account for the\n\t * mastery reference here since old_master will briefly have\n\t * a reference after the migration completes */\n\tspin_lock(&res->spinlock);\n\tdlm_lockres_set_refmap_bit(dlm, res, old_master);\n\tspin_unlock(&res->spinlock);\n\n\tmlog(0, \"now time to do a migrate request to other nodes\\n\");\n\tret = dlm_do_migrate_request(dlm, res, old_master,\n\t\t\t\t     dlm->node_num, &iter);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"doing assert master of %.*s to all except the original node\\n\",\n\t     res->lockname.len, res->lockname.name);\n\t/* this call now finishes out the nodemap\n\t * even if one or more nodes die */\n\tret = dlm_do_assert_master(dlm, res, iter.node_map,\n\t\t\t\t   DLM_ASSERT_MASTER_FINISH_MIGRATION);\n\tif (ret < 0) {\n\t\t/* no longer need to retry.  all living nodes contacted. */\n\t\tmlog_errno(ret);\n\t\tret = 0;\n\t}\n\n\tmemset(iter.node_map, 0, sizeof(iter.node_map));\n\tset_bit(old_master, iter.node_map);\n\tmlog(0, \"doing assert master of %.*s back to %u\\n\",\n\t     res->lockname.len, res->lockname.name, old_master);\n\tret = dlm_do_assert_master(dlm, res, iter.node_map,\n\t\t\t\t   DLM_ASSERT_MASTER_FINISH_MIGRATION);\n\tif (ret < 0) {\n\t\tmlog(0, \"assert master to original master failed \"\n\t\t     \"with %d.\\n\", ret);\n\t\t/* the only nonzero status here would be because of\n\t\t * a dead original node.  we're done. */\n\t\tret = 0;\n\t}\n\n\t/* all done, set the owner, clear the flag */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, dlm->node_num);\n\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\t/* re-dirty it on the new master */\n\tdlm_kick_thread(dlm, res);\n\twake_up(&res->wq);\nleave:\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_clean_master_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3246-3319",
    "snippet": "void dlm_clean_master_list(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_master_list_entry *mle;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_head *bucket;\n\tstruct hlist_node *tmp;\n\tunsigned int i;\n\n\tmlog(0, \"dlm=%s, dead node=%u\\n\", dlm->name, dead_node);\ntop:\n\tassert_spin_locked(&dlm->spinlock);\n\n\t/* clean the master list */\n\tspin_lock(&dlm->master_lock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry_safe(mle, tmp, bucket, master_hash_node) {\n\t\t\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t\t\t       mle->type != DLM_MLE_MASTER &&\n\t\t\t       mle->type != DLM_MLE_MIGRATION);\n\n\t\t\t/* MASTER mles are initiated locally. The waiting\n\t\t\t * process will notice the node map change shortly.\n\t\t\t * Let that happen as normal. */\n\t\t\tif (mle->type == DLM_MLE_MASTER)\n\t\t\t\tcontinue;\n\n\t\t\t/* BLOCK mles are initiated by other nodes. Need to\n\t\t\t * clean up if the dead node would have been the\n\t\t\t * master. */\n\t\t\tif (mle->type == DLM_MLE_BLOCK) {\n\t\t\t\tdlm_clean_block_mle(dlm, mle, dead_node);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Everything else is a MIGRATION mle */\n\n\t\t\t/* The rule for MIGRATION mles is that the master\n\t\t\t * becomes UNKNOWN if *either* the original or the new\n\t\t\t * master dies. All UNKNOWN lockres' are sent to\n\t\t\t * whichever node becomes the recovery master. The new\n\t\t\t * master is responsible for determining if there is\n\t\t\t * still a master for this lockres, or if he needs to\n\t\t\t * take over mastery. Either way, this node should\n\t\t\t * expect another message to resolve this. */\n\n\t\t\tif (mle->master != dead_node &&\n\t\t\t    mle->new_master != dead_node)\n\t\t\t\tcontinue;\n\n\t\t\t/* If we have reached this point, this mle needs to be\n\t\t\t * removed from the list and freed. */\n\t\t\tdlm_clean_migration_mle(dlm, mle);\n\n\t\t\tmlog(0, \"%s: node %u died during migration from \"\n\t\t\t     \"%u to %u!\\n\", dlm->name, dead_node, mle->master,\n\t\t\t     mle->new_master);\n\n\t\t\t/* If we find a lockres associated with the mle, we've\n\t\t\t * hit this rare case that messes up our lock ordering.\n\t\t\t * If so, we need to drop the master lock so that we can\n\t\t\t * take the lockres lock, meaning that we will have to\n\t\t\t * restart from the head of list. */\n\t\t\tres = dlm_reset_mleres_owner(dlm, mle);\n\t\t\tif (res)\n\t\t\t\t/* restart */\n\t\t\t\tgoto top;\n\n\t\t\t/* This may be the last reference */\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 3318
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "229-244",
          "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_reset_mleres_owner",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_reset_mleres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3174-3202",
          "snippet": "static struct dlm_lock_resource *dlm_reset_mleres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_master_list_entry *mle)\n{\n\tstruct dlm_lock_resource *res;\n\n\t/* Find the lockres associated to the mle and set its owner to UNK */\n\tres = __dlm_lookup_lockres(dlm, mle->mname, mle->mnamelen,\n\t\t\t\t   mle->mnamehash);\n\tif (res) {\n\t\tspin_unlock(&dlm->master_lock);\n\n\t\t/* move lockres onto recovery list */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_set_lockres_owner(dlm, res, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\tdlm_move_lockres_to_recovery_list(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_lockres_put(res);\n\n\t\t/* about to get rid of mle, detach from heartbeat */\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\t\t/* dump the mle */\n\t\tspin_lock(&dlm->master_lock);\n\t\t__dlm_put_mle(mle);\n\t\tspin_unlock(&dlm->master_lock);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic struct dlm_lock_resource *dlm_reset_mleres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_master_list_entry *mle)\n{\n\tstruct dlm_lock_resource *res;\n\n\t/* Find the lockres associated to the mle and set its owner to UNK */\n\tres = __dlm_lookup_lockres(dlm, mle->mname, mle->mnamelen,\n\t\t\t\t   mle->mnamehash);\n\tif (res) {\n\t\tspin_unlock(&dlm->master_lock);\n\n\t\t/* move lockres onto recovery list */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_set_lockres_owner(dlm, res, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\tdlm_move_lockres_to_recovery_list(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_lockres_put(res);\n\n\t\t/* about to get rid of mle, detach from heartbeat */\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\t\t/* dump the mle */\n\t\tspin_lock(&dlm->master_lock);\n\t\t__dlm_put_mle(mle);\n\t\tspin_unlock(&dlm->master_lock);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: node %u died during migration from \"\n\t\t\t     \"%u to %u!\\n\"",
            "dlm->name",
            "dead_node",
            "mle->master",
            "mle->new_master"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_clean_migration_mle",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_clean_migration_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3204-3215",
          "snippet": "static void dlm_clean_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\tspin_lock(&mle->spinlock);\n\t__dlm_unlink_mle(dlm, mle);\n\tatomic_set(&mle->woken, 1);\n\tspin_unlock(&mle->spinlock);\n\n\twake_up(&mle->wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_clean_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\tspin_lock(&mle->spinlock);\n\t__dlm_unlink_mle(dlm, mle);\n\tatomic_set(&mle->woken, 1);\n\tspin_unlock(&mle->spinlock);\n\n\twake_up(&mle->wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_clean_block_mle",
          "args": [
            "dlm",
            "mle",
            "dead_node"
          ],
          "line": 3277
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_clean_block_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3217-3244",
          "snippet": "static void dlm_clean_block_mle(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_master_list_entry *mle, u8 dead_node)\n{\n\tint bit;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK);\n\n\tspin_lock(&mle->spinlock);\n\tbit = find_next_bit(mle->maybe_map, O2NM_MAX_NODES, 0);\n\tif (bit != dead_node) {\n\t\tmlog(0, \"mle found, but dead node %u would not have been \"\n\t\t     \"master\\n\", dead_node);\n\t\tspin_unlock(&mle->spinlock);\n\t} else {\n\t\t/* Must drop the refcount by one since the assert_master will\n\t\t * never arrive. This may result in the mle being unlinked and\n\t\t * freed, but there may still be a process waiting in the\n\t\t * dlmlock path which is fine. */\n\t\tmlog(0, \"node %u was expected master\\n\", dead_node);\n\t\tatomic_set(&mle->woken, 1);\n\t\tspin_unlock(&mle->spinlock);\n\t\twake_up(&mle->wq);\n\n\t\t/* Do not need events any longer, so detach from heartbeat */\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t__dlm_put_mle(mle);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\n\nstatic void dlm_clean_block_mle(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_master_list_entry *mle, u8 dead_node)\n{\n\tint bit;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK);\n\n\tspin_lock(&mle->spinlock);\n\tbit = find_next_bit(mle->maybe_map, O2NM_MAX_NODES, 0);\n\tif (bit != dead_node) {\n\t\tmlog(0, \"mle found, but dead node %u would not have been \"\n\t\t     \"master\\n\", dead_node);\n\t\tspin_unlock(&mle->spinlock);\n\t} else {\n\t\t/* Must drop the refcount by one since the assert_master will\n\t\t * never arrive. This may result in the mle being unlinked and\n\t\t * freed, but there may still be a process waiting in the\n\t\t * dlmlock path which is fine. */\n\t\tmlog(0, \"node %u was expected master\\n\", dead_node);\n\t\tatomic_set(&mle->woken, 1);\n\t\tspin_unlock(&mle->spinlock);\n\t\twake_up(&mle->wq);\n\n\t\t/* Do not need events any longer, so detach from heartbeat */\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t__dlm_put_mle(mle);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mle->type != DLM_MLE_BLOCK &&\n\t\t\t       mle->type != DLM_MLE_MASTER &&\n\t\t\t       mle->type != DLM_MLE_MIGRATION"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "mle",
            "tmp",
            "bucket",
            "master_hash_node"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_master_hash",
          "args": [
            "dlm",
            "i"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_master_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "195-200",
          "snippet": "static inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm=%s, dead node=%u\\n\"",
            "dlm->name",
            "dead_node"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_clean_master_list(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_master_list_entry *mle;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_head *bucket;\n\tstruct hlist_node *tmp;\n\tunsigned int i;\n\n\tmlog(0, \"dlm=%s, dead node=%u\\n\", dlm->name, dead_node);\ntop:\n\tassert_spin_locked(&dlm->spinlock);\n\n\t/* clean the master list */\n\tspin_lock(&dlm->master_lock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry_safe(mle, tmp, bucket, master_hash_node) {\n\t\t\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t\t\t       mle->type != DLM_MLE_MASTER &&\n\t\t\t       mle->type != DLM_MLE_MIGRATION);\n\n\t\t\t/* MASTER mles are initiated locally. The waiting\n\t\t\t * process will notice the node map change shortly.\n\t\t\t * Let that happen as normal. */\n\t\t\tif (mle->type == DLM_MLE_MASTER)\n\t\t\t\tcontinue;\n\n\t\t\t/* BLOCK mles are initiated by other nodes. Need to\n\t\t\t * clean up if the dead node would have been the\n\t\t\t * master. */\n\t\t\tif (mle->type == DLM_MLE_BLOCK) {\n\t\t\t\tdlm_clean_block_mle(dlm, mle, dead_node);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Everything else is a MIGRATION mle */\n\n\t\t\t/* The rule for MIGRATION mles is that the master\n\t\t\t * becomes UNKNOWN if *either* the original or the new\n\t\t\t * master dies. All UNKNOWN lockres' are sent to\n\t\t\t * whichever node becomes the recovery master. The new\n\t\t\t * master is responsible for determining if there is\n\t\t\t * still a master for this lockres, or if he needs to\n\t\t\t * take over mastery. Either way, this node should\n\t\t\t * expect another message to resolve this. */\n\n\t\t\tif (mle->master != dead_node &&\n\t\t\t    mle->new_master != dead_node)\n\t\t\t\tcontinue;\n\n\t\t\t/* If we have reached this point, this mle needs to be\n\t\t\t * removed from the list and freed. */\n\t\t\tdlm_clean_migration_mle(dlm, mle);\n\n\t\t\tmlog(0, \"%s: node %u died during migration from \"\n\t\t\t     \"%u to %u!\\n\", dlm->name, dead_node, mle->master,\n\t\t\t     mle->new_master);\n\n\t\t\t/* If we find a lockres associated with the mle, we've\n\t\t\t * hit this rare case that messes up our lock ordering.\n\t\t\t * If so, we need to drop the master lock so that we can\n\t\t\t * take the lockres lock, meaning that we will have to\n\t\t\t * restart from the head of list. */\n\t\t\tres = dlm_reset_mleres_owner(dlm, mle);\n\t\t\tif (res)\n\t\t\t\t/* restart */\n\t\t\t\tgoto top;\n\n\t\t\t/* This may be the last reference */\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n}"
  },
  {
    "function_name": "dlm_clean_block_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3217-3244",
    "snippet": "static void dlm_clean_block_mle(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_master_list_entry *mle, u8 dead_node)\n{\n\tint bit;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK);\n\n\tspin_lock(&mle->spinlock);\n\tbit = find_next_bit(mle->maybe_map, O2NM_MAX_NODES, 0);\n\tif (bit != dead_node) {\n\t\tmlog(0, \"mle found, but dead node %u would not have been \"\n\t\t     \"master\\n\", dead_node);\n\t\tspin_unlock(&mle->spinlock);\n\t} else {\n\t\t/* Must drop the refcount by one since the assert_master will\n\t\t * never arrive. This may result in the mle being unlinked and\n\t\t * freed, but there may still be a process waiting in the\n\t\t * dlmlock path which is fine. */\n\t\tmlog(0, \"node %u was expected master\\n\", dead_node);\n\t\tatomic_set(&mle->woken, 1);\n\t\tspin_unlock(&mle->spinlock);\n\t\twake_up(&mle->wq);\n\n\t\t/* Do not need events any longer, so detach from heartbeat */\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t__dlm_put_mle(mle);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "229-244",
          "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "187-192",
          "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&mle->wq"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mle->woken",
            "1"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u was expected master\\n\"",
            "dead_node"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "mle->maybe_map",
            "O2NM_MAX_NODES",
            "0"
          ],
          "line": 3225
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mle->type != DLM_MLE_BLOCK"
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\n\nstatic void dlm_clean_block_mle(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_master_list_entry *mle, u8 dead_node)\n{\n\tint bit;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK);\n\n\tspin_lock(&mle->spinlock);\n\tbit = find_next_bit(mle->maybe_map, O2NM_MAX_NODES, 0);\n\tif (bit != dead_node) {\n\t\tmlog(0, \"mle found, but dead node %u would not have been \"\n\t\t     \"master\\n\", dead_node);\n\t\tspin_unlock(&mle->spinlock);\n\t} else {\n\t\t/* Must drop the refcount by one since the assert_master will\n\t\t * never arrive. This may result in the mle being unlinked and\n\t\t * freed, but there may still be a process waiting in the\n\t\t * dlmlock path which is fine. */\n\t\tmlog(0, \"node %u was expected master\\n\", dead_node);\n\t\tatomic_set(&mle->woken, 1);\n\t\tspin_unlock(&mle->spinlock);\n\t\twake_up(&mle->wq);\n\n\t\t/* Do not need events any longer, so detach from heartbeat */\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t__dlm_put_mle(mle);\n\t}\n}"
  },
  {
    "function_name": "dlm_clean_migration_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3204-3215",
    "snippet": "static void dlm_clean_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\tspin_lock(&mle->spinlock);\n\t__dlm_unlink_mle(dlm, mle);\n\tatomic_set(&mle->woken, 1);\n\tspin_unlock(&mle->spinlock);\n\n\twake_up(&mle->wq);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&mle->wq"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 3212
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mle->woken",
            "1"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_unlink_mle",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_unlink_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "319-326",
          "snippet": "void __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "187-192",
          "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_clean_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\tspin_lock(&mle->spinlock);\n\t__dlm_unlink_mle(dlm, mle);\n\tatomic_set(&mle->woken, 1);\n\tspin_unlock(&mle->spinlock);\n\n\twake_up(&mle->wq);\n}"
  },
  {
    "function_name": "dlm_reset_mleres_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3174-3202",
    "snippet": "static struct dlm_lock_resource *dlm_reset_mleres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_master_list_entry *mle)\n{\n\tstruct dlm_lock_resource *res;\n\n\t/* Find the lockres associated to the mle and set its owner to UNK */\n\tres = __dlm_lookup_lockres(dlm, mle->mname, mle->mnamelen,\n\t\t\t\t   mle->mnamehash);\n\tif (res) {\n\t\tspin_unlock(&dlm->master_lock);\n\n\t\t/* move lockres onto recovery list */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_set_lockres_owner(dlm, res, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\tdlm_move_lockres_to_recovery_list(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_lockres_put(res);\n\n\t\t/* about to get rid of mle, detach from heartbeat */\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\t\t/* dump the mle */\n\t\tspin_lock(&dlm->master_lock);\n\t\t__dlm_put_mle(mle);\n\t\tspin_unlock(&dlm->master_lock);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "229-244",
          "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 3196
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "187-192",
          "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_move_lockres_to_recovery_list",
          "args": [
            "dlm",
            "res"
          ],
          "line": 3188
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_move_lockres_to_recovery_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2035-2113",
          "snippet": "void dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tint i;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_RECOVERING;\n\tif (!list_empty(&res->recovering)) {\n\t\tmlog(0,\n\t\t     \"Recovering res %s:%.*s, is already on recovery list!\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tlist_del_init(&res->recovering);\n\t\tdlm_lockres_put(res);\n\t}\n\t/* We need to hold a reference while on the recovery list */\n\tdlm_lockres_get(res);\n\tlist_add_tail(&res->recovering, &dlm->reco.resources);\n\n\t/* find any pending locks and put them back on proper list */\n\tfor (i=DLM_BLOCKED_LIST; i>=DLM_GRANTED_LIST; i--) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tdlm_lock_get(lock);\n\t\t\tif (lock->convert_pending) {\n\t\t\t\t/* move converting lock back to granted */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with convert pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_revert_pending_convert(res, lock);\n\t\t\t\tlock->convert_pending = 0;\n\t\t\t} else if (lock->lock_pending) {\n\t\t\t\t/* remove pending lock requests completely */\n\t\t\t\tBUG_ON(i != DLM_BLOCKED_LIST);\n\t\t\t\tmlog(0, \"node died with lock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\t/* lock will be floating until ref in\n\t\t\t\t * dlmlock_remote is freed after the network\n\t\t\t\t * call returns.  ok for it to not be on any\n\t\t\t\t * list since no ast can be called\n\t\t\t\t * (the master is dead). */\n\t\t\t\tdlm_revert_pending_lock(res, lock);\n\t\t\t\tlock->lock_pending = 0;\n\t\t\t} else if (lock->unlock_pending) {\n\t\t\t\t/* if an unlock was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master.  note that the dlm_unlock\n\t\t\t\t * call is still responsible for calling\n\t\t\t\t * the unlockast.  that will happen after\n\t\t\t\t * the network call times out.  for now,\n\t\t\t\t * just move lists to prepare the new\n\t\t\t\t * recovery master.  */\n\t\t\t\tBUG_ON(i != DLM_GRANTED_LIST);\n\t\t\t\tmlog(0, \"node died with unlock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_unlock(res, lock);\n\t\t\t\tlock->unlock_pending = 0;\n\t\t\t} else if (lock->cancel_pending) {\n\t\t\t\t/* if a cancel was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with cancel pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_cancel(res, lock);\n\t\t\t\tlock->cancel_pending = 0;\n\t\t\t}\n\t\t\tdlm_lock_put(lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tint i;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_RECOVERING;\n\tif (!list_empty(&res->recovering)) {\n\t\tmlog(0,\n\t\t     \"Recovering res %s:%.*s, is already on recovery list!\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tlist_del_init(&res->recovering);\n\t\tdlm_lockres_put(res);\n\t}\n\t/* We need to hold a reference while on the recovery list */\n\tdlm_lockres_get(res);\n\tlist_add_tail(&res->recovering, &dlm->reco.resources);\n\n\t/* find any pending locks and put them back on proper list */\n\tfor (i=DLM_BLOCKED_LIST; i>=DLM_GRANTED_LIST; i--) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tdlm_lock_get(lock);\n\t\t\tif (lock->convert_pending) {\n\t\t\t\t/* move converting lock back to granted */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with convert pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_revert_pending_convert(res, lock);\n\t\t\t\tlock->convert_pending = 0;\n\t\t\t} else if (lock->lock_pending) {\n\t\t\t\t/* remove pending lock requests completely */\n\t\t\t\tBUG_ON(i != DLM_BLOCKED_LIST);\n\t\t\t\tmlog(0, \"node died with lock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\t/* lock will be floating until ref in\n\t\t\t\t * dlmlock_remote is freed after the network\n\t\t\t\t * call returns.  ok for it to not be on any\n\t\t\t\t * list since no ast can be called\n\t\t\t\t * (the master is dead). */\n\t\t\t\tdlm_revert_pending_lock(res, lock);\n\t\t\t\tlock->lock_pending = 0;\n\t\t\t} else if (lock->unlock_pending) {\n\t\t\t\t/* if an unlock was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master.  note that the dlm_unlock\n\t\t\t\t * call is still responsible for calling\n\t\t\t\t * the unlockast.  that will happen after\n\t\t\t\t * the network call times out.  for now,\n\t\t\t\t * just move lists to prepare the new\n\t\t\t\t * recovery master.  */\n\t\t\t\tBUG_ON(i != DLM_GRANTED_LIST);\n\t\t\t\tmlog(0, \"node died with unlock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_unlock(res, lock);\n\t\t\t\tlock->unlock_pending = 0;\n\t\t\t} else if (lock->cancel_pending) {\n\t\t\t\t/* if a cancel was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with cancel pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_cancel(res, lock);\n\t\t\t\tlock->cancel_pending = 0;\n\t\t\t}\n\t\t\tdlm_lock_put(lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_lockres_owner",
          "args": [
            "dlm",
            "res",
            "DLM_LOCK_RES_OWNER_UNKNOWN"
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1131-1138",
          "snippet": "static inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres",
          "args": [
            "dlm",
            "mle->mname",
            "mle->mnamelen",
            "mle->mnamehash"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "221-244",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic struct dlm_lock_resource *dlm_reset_mleres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct dlm_master_list_entry *mle)\n{\n\tstruct dlm_lock_resource *res;\n\n\t/* Find the lockres associated to the mle and set its owner to UNK */\n\tres = __dlm_lookup_lockres(dlm, mle->mname, mle->mnamelen,\n\t\t\t\t   mle->mnamehash);\n\tif (res) {\n\t\tspin_unlock(&dlm->master_lock);\n\n\t\t/* move lockres onto recovery list */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_set_lockres_owner(dlm, res, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\tdlm_move_lockres_to_recovery_list(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_lockres_put(res);\n\n\t\t/* about to get rid of mle, detach from heartbeat */\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\t\t/* dump the mle */\n\t\tspin_lock(&dlm->master_lock);\n\t\t__dlm_put_mle(mle);\n\t\tspin_unlock(&dlm->master_lock);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "dlm_add_migration_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3099-3169",
    "snippet": "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master)\n{\n\tint found;\n\tint ret = 0;\n\n\t*oldmle = NULL;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\t/* caller is responsible for any ref taken here on oldmle */\n\tfound = dlm_find_mle(dlm, oldmle, (char *)name, namelen);\n\tif (found) {\n\t\tstruct dlm_master_list_entry *tmp = *oldmle;\n\t\tspin_lock(&tmp->spinlock);\n\t\tif (tmp->type == DLM_MLE_MIGRATION) {\n\t\t\tif (master == dlm->node_num) {\n\t\t\t\t/* ah another process raced me to it */\n\t\t\t\tmlog(0, \"tried to migrate %.*s, but some \"\n\t\t\t\t     \"process beat me to it\\n\",\n\t\t\t\t     namelen, name);\n\t\t\t\tret = -EEXIST;\n\t\t\t} else {\n\t\t\t\t/* bad.  2 NODES are trying to migrate! */\n\t\t\t\tmlog(ML_ERROR, \"migration error  mle: \"\n\t\t\t\t     \"master=%u new_master=%u // request: \"\n\t\t\t\t     \"master=%u new_master=%u // \"\n\t\t\t\t     \"lockres=%.*s\\n\",\n\t\t\t\t     tmp->master, tmp->new_master,\n\t\t\t\t     master, new_master,\n\t\t\t\t     namelen, name);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is essentially what assert_master does */\n\t\t\ttmp->master = master;\n\t\t\tatomic_set(&tmp->woken, 1);\n\t\t\twake_up(&tmp->wq);\n\t\t\t/* remove it so that only one mle will be found */\n\t\t\t__dlm_unlink_mle(dlm, tmp);\n\t\t\t__dlm_mle_detach_hb_events(dlm, tmp);\n\t\t\tif (tmp->type == DLM_MLE_MASTER) {\n\t\t\t\tret = DLM_MIGRATE_RESPONSE_MASTERY_REF;\n\t\t\t\tmlog(0, \"%s:%.*s: master=%u, newmaster=%u, \"\n\t\t\t\t\t\t\"telling master to get ref \"\n\t\t\t\t\t\t\"for cleared out mle during \"\n\t\t\t\t\t\t\"migration\\n\", dlm->name,\n\t\t\t\t\t\tnamelen, name, master,\n\t\t\t\t\t\tnew_master);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&tmp->spinlock);\n\t}\n\n\t/* now add a migration mle to the tail of the list */\n\tdlm_init_mle(mle, DLM_MLE_MIGRATION, dlm, res, name, namelen);\n\tmle->new_master = new_master;\n\t/* the new master will be sending an assert master for this.\n\t * at that point we will get the refmap reference */\n\tmle->master = master;\n\t/* do this for consistency with other mle types */\n\tset_bit(new_master, mle->maybe_map);\n\t__dlm_insert_mle(dlm, mle);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_insert_mle",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_insert_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "328-336",
          "snippet": "void __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\tbucket = dlm_master_hash(dlm, mle->mnamehash);\n\thlist_add_head(&mle->master_hash_node, bucket);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\tbucket = dlm_master_hash(dlm, mle->mnamehash);\n\thlist_add_head(&mle->master_hash_node, bucket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "new_master",
            "mle->maybe_map"
          ],
          "line": 3165
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_mle",
          "args": [
            "mle",
            "DLM_MLE_MIGRATION",
            "dlm",
            "res",
            "name",
            "namelen"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "265-317",
          "snippet": "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tmle->dlm = dlm;\n\tmle->type = type;\n\tINIT_HLIST_NODE(&mle->master_hash_node);\n\tINIT_LIST_HEAD(&mle->hb_events);\n\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\tspin_lock_init(&mle->spinlock);\n\tinit_waitqueue_head(&mle->wq);\n\tatomic_set(&mle->woken, 0);\n\tkref_init(&mle->mle_refs);\n\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\tmle->master = O2NM_MAX_NODES;\n\tmle->new_master = O2NM_MAX_NODES;\n\tmle->inuse = 0;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION);\n\n\tif (mle->type == DLM_MLE_MASTER) {\n\t\tBUG_ON(!res);\n\t\tmle->mleres = res;\n\t\tmemcpy(mle->mname, res->lockname.name, res->lockname.len);\n\t\tmle->mnamelen = res->lockname.len;\n\t\tmle->mnamehash = res->lockname.hash;\n\t} else {\n\t\tBUG_ON(!name);\n\t\tmle->mleres = NULL;\n\t\tmemcpy(mle->mname, name, namelen);\n\t\tmle->mnamelen = namelen;\n\t\tmle->mnamehash = dlm_lockid_hash(name, namelen);\n\t}\n\n\tatomic_inc(&dlm->mle_tot_count[mle->type]);\n\tatomic_inc(&dlm->mle_cur_count[mle->type]);\n\n\t/* copy off the node_map and register hb callbacks on our copy */\n\tmemcpy(mle->node_map, dlm->domain_map, sizeof(mle->node_map));\n\tmemcpy(mle->vote_map, dlm->domain_map, sizeof(mle->vote_map));\n\tclear_bit(dlm->node_num, mle->vote_map);\n\tclear_bit(dlm->node_num, mle->node_map);\n\n\t/* attach the mle to the domain node up/down events */\n\t__dlm_mle_attach_hb_events(dlm, mle);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tmle->dlm = dlm;\n\tmle->type = type;\n\tINIT_HLIST_NODE(&mle->master_hash_node);\n\tINIT_LIST_HEAD(&mle->hb_events);\n\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\tspin_lock_init(&mle->spinlock);\n\tinit_waitqueue_head(&mle->wq);\n\tatomic_set(&mle->woken, 0);\n\tkref_init(&mle->mle_refs);\n\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\tmle->master = O2NM_MAX_NODES;\n\tmle->new_master = O2NM_MAX_NODES;\n\tmle->inuse = 0;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION);\n\n\tif (mle->type == DLM_MLE_MASTER) {\n\t\tBUG_ON(!res);\n\t\tmle->mleres = res;\n\t\tmemcpy(mle->mname, res->lockname.name, res->lockname.len);\n\t\tmle->mnamelen = res->lockname.len;\n\t\tmle->mnamehash = res->lockname.hash;\n\t} else {\n\t\tBUG_ON(!name);\n\t\tmle->mleres = NULL;\n\t\tmemcpy(mle->mname, name, namelen);\n\t\tmle->mnamelen = namelen;\n\t\tmle->mnamehash = dlm_lockid_hash(name, namelen);\n\t}\n\n\tatomic_inc(&dlm->mle_tot_count[mle->type]);\n\tatomic_inc(&dlm->mle_cur_count[mle->type]);\n\n\t/* copy off the node_map and register hb callbacks on our copy */\n\tmemcpy(mle->node_map, dlm->domain_map, sizeof(mle->node_map));\n\tmemcpy(mle->vote_map, dlm->domain_map, sizeof(mle->vote_map));\n\tclear_bit(dlm->node_num, mle->vote_map);\n\tclear_bit(dlm->node_num, mle->node_map);\n\n\t/* attach the mle to the domain node up/down events */\n\t__dlm_mle_attach_hb_events(dlm, mle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tmp->spinlock"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: master=%u, newmaster=%u, \"\n\t\t\t\t\t\t\"telling master to get ref \"\n\t\t\t\t\t\t\"for cleared out mle during \"\n\t\t\t\t\t\t\"migration\\n\"",
            "dlm->name",
            "namelen",
            "name",
            "master",
            "new_master"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "tmp"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "187-192",
          "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_unlink_mle",
          "args": [
            "dlm",
            "tmp"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_unlink_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "319-326",
          "snippet": "void __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&tmp->wq"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tmp->woken",
            "1"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"migration error  mle: \"\n\t\t\t\t     \"master=%u new_master=%u // request: \"\n\t\t\t\t     \"master=%u new_master=%u // \"\n\t\t\t\t     \"lockres=%.*s\\n\"",
            "tmp->master",
            "tmp->new_master",
            "master",
            "new_master",
            "namelen",
            "name"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"tried to migrate %.*s, but some \"\n\t\t\t\t     \"process beat me to it\\n\"",
            "namelen",
            "name"
          ],
          "line": 3122
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tmp->spinlock"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_mle",
          "args": [
            "dlm",
            "oldmle",
            "(char *)name",
            "namelen"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "339-359",
          "snippet": "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\n\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master)\n{\n\tint found;\n\tint ret = 0;\n\n\t*oldmle = NULL;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\t/* caller is responsible for any ref taken here on oldmle */\n\tfound = dlm_find_mle(dlm, oldmle, (char *)name, namelen);\n\tif (found) {\n\t\tstruct dlm_master_list_entry *tmp = *oldmle;\n\t\tspin_lock(&tmp->spinlock);\n\t\tif (tmp->type == DLM_MLE_MIGRATION) {\n\t\t\tif (master == dlm->node_num) {\n\t\t\t\t/* ah another process raced me to it */\n\t\t\t\tmlog(0, \"tried to migrate %.*s, but some \"\n\t\t\t\t     \"process beat me to it\\n\",\n\t\t\t\t     namelen, name);\n\t\t\t\tret = -EEXIST;\n\t\t\t} else {\n\t\t\t\t/* bad.  2 NODES are trying to migrate! */\n\t\t\t\tmlog(ML_ERROR, \"migration error  mle: \"\n\t\t\t\t     \"master=%u new_master=%u // request: \"\n\t\t\t\t     \"master=%u new_master=%u // \"\n\t\t\t\t     \"lockres=%.*s\\n\",\n\t\t\t\t     tmp->master, tmp->new_master,\n\t\t\t\t     master, new_master,\n\t\t\t\t     namelen, name);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is essentially what assert_master does */\n\t\t\ttmp->master = master;\n\t\t\tatomic_set(&tmp->woken, 1);\n\t\t\twake_up(&tmp->wq);\n\t\t\t/* remove it so that only one mle will be found */\n\t\t\t__dlm_unlink_mle(dlm, tmp);\n\t\t\t__dlm_mle_detach_hb_events(dlm, tmp);\n\t\t\tif (tmp->type == DLM_MLE_MASTER) {\n\t\t\t\tret = DLM_MIGRATE_RESPONSE_MASTERY_REF;\n\t\t\t\tmlog(0, \"%s:%.*s: master=%u, newmaster=%u, \"\n\t\t\t\t\t\t\"telling master to get ref \"\n\t\t\t\t\t\t\"for cleared out mle during \"\n\t\t\t\t\t\t\"migration\\n\", dlm->name,\n\t\t\t\t\t\tnamelen, name, master,\n\t\t\t\t\t\tnew_master);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&tmp->spinlock);\n\t}\n\n\t/* now add a migration mle to the tail of the list */\n\tdlm_init_mle(mle, DLM_MLE_MIGRATION, dlm, res, name, namelen);\n\tmle->new_master = new_master;\n\t/* the new master will be sending an assert master for this.\n\t * at that point we will get the refmap reference */\n\tmle->master = master;\n\t/* do this for consistency with other mle types */\n\tset_bit(new_master, mle->maybe_map);\n\t__dlm_insert_mle(dlm, mle);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_migrate_request_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "3022-3090",
    "snippet": "int dlm_migrate_request_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\tvoid **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_migrate_request *migrate = (struct dlm_migrate_request *) msg->buf;\n\tstruct dlm_master_list_entry *mle = NULL, *oldmle = NULL;\n\tconst char *name;\n\tunsigned int namelen, hash;\n\tint ret = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tname = migrate->name;\n\tnamelen = migrate->namelen;\n\thash = dlm_lockid_hash(name, namelen);\n\n\t/* preallocate.. if this fails, abort */\n\tmle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\n\tif (!mle) {\n\t\tret = -ENOMEM;\n\t\tgoto leave;\n\t}\n\n\t/* check for pre-existing lock */\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, namelen, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\t\t/* if all is working ok, this can only mean that we got\n\t\t \t* a migrate request from a node that we now see as\n\t\t \t* dead.  what can we do here?  drop it to the floor? */\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tmlog(ML_ERROR, \"Got a migrate request, but the \"\n\t\t\t     \"lockres is marked as recovering!\");\n\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tret = -EINVAL; /* need a better solution */\n\t\t\tgoto unlock;\n\t\t}\n\t\tres->state |= DLM_LOCK_RES_MIGRATING;\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\tspin_lock(&dlm->master_lock);\n\t/* ignore status.  only nonzero status would BUG. */\n\tret = dlm_add_migration_mle(dlm, res, mle, &oldmle,\n\t\t\t\t    name, namelen,\n\t\t\t\t    migrate->new_master,\n\t\t\t\t    migrate->master);\n\n\tspin_unlock(&dlm->master_lock);\nunlock:\n\tspin_unlock(&dlm->spinlock);\n\n\tif (oldmle) {\n\t\t/* master is known, detach if not already detached */\n\t\tdlm_mle_detach_hb_events(dlm, oldmle);\n\t\tdlm_put_mle(oldmle);\n\t}\n\n\tif (res)\n\t\tdlm_lockres_put(res);\nleave:\n\tdlm_put(dlm);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_assert_master_worker(struct dlm_work_item *item, void *data);",
      "static void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);",
      "static struct kmem_cache *dlm_mle_cache;",
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "oldmle"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "195-201",
          "snippet": "static inline void dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_add_migration_mle",
          "args": [
            "dlm",
            "res",
            "mle",
            "&oldmle",
            "name",
            "namelen",
            "migrate->new_master",
            "migrate->master"
          ],
          "line": 3070
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_migration_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3099-3169",
          "snippet": "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master)\n{\n\tint found;\n\tint ret = 0;\n\n\t*oldmle = NULL;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\t/* caller is responsible for any ref taken here on oldmle */\n\tfound = dlm_find_mle(dlm, oldmle, (char *)name, namelen);\n\tif (found) {\n\t\tstruct dlm_master_list_entry *tmp = *oldmle;\n\t\tspin_lock(&tmp->spinlock);\n\t\tif (tmp->type == DLM_MLE_MIGRATION) {\n\t\t\tif (master == dlm->node_num) {\n\t\t\t\t/* ah another process raced me to it */\n\t\t\t\tmlog(0, \"tried to migrate %.*s, but some \"\n\t\t\t\t     \"process beat me to it\\n\",\n\t\t\t\t     namelen, name);\n\t\t\t\tret = -EEXIST;\n\t\t\t} else {\n\t\t\t\t/* bad.  2 NODES are trying to migrate! */\n\t\t\t\tmlog(ML_ERROR, \"migration error  mle: \"\n\t\t\t\t     \"master=%u new_master=%u // request: \"\n\t\t\t\t     \"master=%u new_master=%u // \"\n\t\t\t\t     \"lockres=%.*s\\n\",\n\t\t\t\t     tmp->master, tmp->new_master,\n\t\t\t\t     master, new_master,\n\t\t\t\t     namelen, name);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is essentially what assert_master does */\n\t\t\ttmp->master = master;\n\t\t\tatomic_set(&tmp->woken, 1);\n\t\t\twake_up(&tmp->wq);\n\t\t\t/* remove it so that only one mle will be found */\n\t\t\t__dlm_unlink_mle(dlm, tmp);\n\t\t\t__dlm_mle_detach_hb_events(dlm, tmp);\n\t\t\tif (tmp->type == DLM_MLE_MASTER) {\n\t\t\t\tret = DLM_MIGRATE_RESPONSE_MASTERY_REF;\n\t\t\t\tmlog(0, \"%s:%.*s: master=%u, newmaster=%u, \"\n\t\t\t\t\t\t\"telling master to get ref \"\n\t\t\t\t\t\t\"for cleared out mle during \"\n\t\t\t\t\t\t\"migration\\n\", dlm->name,\n\t\t\t\t\t\tnamelen, name, master,\n\t\t\t\t\t\tnew_master);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&tmp->spinlock);\n\t}\n\n\t/* now add a migration mle to the tail of the list */\n\tdlm_init_mle(mle, DLM_MLE_MIGRATION, dlm, res, name, namelen);\n\tmle->new_master = new_master;\n\t/* the new master will be sending an assert master for this.\n\t * at that point we will get the refmap reference */\n\tmle->master = master;\n\t/* do this for consistency with other mle types */\n\tset_bit(new_master, mle->maybe_map);\n\t__dlm_insert_mle(dlm, mle);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master)\n{\n\tint found;\n\tint ret = 0;\n\n\t*oldmle = NULL;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\t/* caller is responsible for any ref taken here on oldmle */\n\tfound = dlm_find_mle(dlm, oldmle, (char *)name, namelen);\n\tif (found) {\n\t\tstruct dlm_master_list_entry *tmp = *oldmle;\n\t\tspin_lock(&tmp->spinlock);\n\t\tif (tmp->type == DLM_MLE_MIGRATION) {\n\t\t\tif (master == dlm->node_num) {\n\t\t\t\t/* ah another process raced me to it */\n\t\t\t\tmlog(0, \"tried to migrate %.*s, but some \"\n\t\t\t\t     \"process beat me to it\\n\",\n\t\t\t\t     namelen, name);\n\t\t\t\tret = -EEXIST;\n\t\t\t} else {\n\t\t\t\t/* bad.  2 NODES are trying to migrate! */\n\t\t\t\tmlog(ML_ERROR, \"migration error  mle: \"\n\t\t\t\t     \"master=%u new_master=%u // request: \"\n\t\t\t\t     \"master=%u new_master=%u // \"\n\t\t\t\t     \"lockres=%.*s\\n\",\n\t\t\t\t     tmp->master, tmp->new_master,\n\t\t\t\t     master, new_master,\n\t\t\t\t     namelen, name);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is essentially what assert_master does */\n\t\t\ttmp->master = master;\n\t\t\tatomic_set(&tmp->woken, 1);\n\t\t\twake_up(&tmp->wq);\n\t\t\t/* remove it so that only one mle will be found */\n\t\t\t__dlm_unlink_mle(dlm, tmp);\n\t\t\t__dlm_mle_detach_hb_events(dlm, tmp);\n\t\t\tif (tmp->type == DLM_MLE_MASTER) {\n\t\t\t\tret = DLM_MIGRATE_RESPONSE_MASTERY_REF;\n\t\t\t\tmlog(0, \"%s:%.*s: master=%u, newmaster=%u, \"\n\t\t\t\t\t\t\"telling master to get ref \"\n\t\t\t\t\t\t\"for cleared out mle during \"\n\t\t\t\t\t\t\"migration\\n\", dlm->name,\n\t\t\t\t\t\tnamelen, name, master,\n\t\t\t\t\t\tnew_master);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&tmp->spinlock);\n\t}\n\n\t/* now add a migration mle to the tail of the list */\n\tdlm_init_mle(mle, DLM_MLE_MIGRATION, dlm, res, name, namelen);\n\tmle->new_master = new_master;\n\t/* the new master will be sending an assert master for this.\n\t * at that point we will get the refmap reference */\n\tmle->master = master;\n\t/* do this for consistency with other mle types */\n\tset_bit(new_master, mle->maybe_map);\n\t__dlm_insert_mle(dlm, mle);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_mle_cache",
            "mle"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Got a migrate request, but the \"\n\t\t\t     \"lockres is marked as recovering!\""
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres",
          "args": [
            "dlm",
            "name",
            "namelen",
            "hash"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "221-244",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "dlm_mle_cache",
            "GFP_NOFS"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "name",
            "namelen"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_assert_master_worker(struct dlm_work_item *item, void *data);\nstatic void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);\nstatic struct kmem_cache *dlm_mle_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_migrate_request_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\tvoid **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_migrate_request *migrate = (struct dlm_migrate_request *) msg->buf;\n\tstruct dlm_master_list_entry *mle = NULL, *oldmle = NULL;\n\tconst char *name;\n\tunsigned int namelen, hash;\n\tint ret = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tname = migrate->name;\n\tnamelen = migrate->namelen;\n\thash = dlm_lockid_hash(name, namelen);\n\n\t/* preallocate.. if this fails, abort */\n\tmle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\n\tif (!mle) {\n\t\tret = -ENOMEM;\n\t\tgoto leave;\n\t}\n\n\t/* check for pre-existing lock */\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, namelen, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\t\t/* if all is working ok, this can only mean that we got\n\t\t \t* a migrate request from a node that we now see as\n\t\t \t* dead.  what can we do here?  drop it to the floor? */\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tmlog(ML_ERROR, \"Got a migrate request, but the \"\n\t\t\t     \"lockres is marked as recovering!\");\n\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tret = -EINVAL; /* need a better solution */\n\t\t\tgoto unlock;\n\t\t}\n\t\tres->state |= DLM_LOCK_RES_MIGRATING;\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\tspin_lock(&dlm->master_lock);\n\t/* ignore status.  only nonzero status would BUG. */\n\tret = dlm_add_migration_mle(dlm, res, mle, &oldmle,\n\t\t\t\t    name, namelen,\n\t\t\t\t    migrate->new_master,\n\t\t\t\t    migrate->master);\n\n\tspin_unlock(&dlm->master_lock);\nunlock:\n\tspin_unlock(&dlm->spinlock);\n\n\tif (oldmle) {\n\t\t/* master is known, detach if not already detached */\n\t\tdlm_mle_detach_hb_events(dlm, oldmle);\n\t\tdlm_put_mle(oldmle);\n\t}\n\n\tif (res)\n\t\tdlm_lockres_put(res);\nleave:\n\tdlm_put(dlm);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_do_migrate_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2945-3012",
    "snippet": "static int dlm_do_migrate_request(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  u8 master, u8 new_master,\n\t\t\t\t  struct dlm_node_iter *iter)\n{\n\tstruct dlm_migrate_request migrate;\n\tint ret, skip, status = 0;\n\tint nodenum;\n\n\tmemset(&migrate, 0, sizeof(migrate));\n\tmigrate.namelen = res->lockname.len;\n\tmemcpy(migrate.name, res->lockname.name, migrate.namelen);\n\tmigrate.new_master = new_master;\n\tmigrate.master = master;\n\n\tret = 0;\n\n\t/* send message to all nodes, except the master and myself */\n\twhile ((nodenum = dlm_node_iter_next(iter)) >= 0) {\n\t\tif (nodenum == master ||\n\t\t    nodenum == new_master)\n\t\t\tcontinue;\n\n\t\t/* We could race exit domain. If exited, skip. */\n\t\tspin_lock(&dlm->spinlock);\n\t\tskip = (!test_bit(nodenum, dlm->domain_map));\n\t\tspin_unlock(&dlm->spinlock);\n\t\tif (skip) {\n\t\t\tclear_bit(nodenum, iter->node_map);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = o2net_send_message(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\t &migrate, sizeof(migrate), nodenum,\n\t\t\t\t\t &status);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send \"\n\t\t\t     \"MIGRATE_REQUEST to node %u\\n\", dlm->name,\n\t\t\t     migrate.namelen, migrate.name, ret, nodenum);\n\t\t\tif (!dlm_is_host_down(ret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", ret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tclear_bit(nodenum, iter->node_map);\n\t\t\tret = 0;\n\t\t} else if (status < 0) {\n\t\t\tmlog(0, \"migrate request (node %u) returned %d!\\n\",\n\t\t\t     nodenum, status);\n\t\t\tret = status;\n\t\t} else if (status == DLM_MIGRATE_RESPONSE_MASTERY_REF) {\n\t\t\t/* during the migration request we short-circuited\n\t\t\t * the mastery of the lockres.  make sure we have\n\t\t\t * a mastery ref for nodenum */\n\t\t\tmlog(0, \"%s:%.*s: need ref for node %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     nodenum);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, nodenum);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tmlog(0, \"returning ret=%d\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"returning ret=%d\\n\"",
            "ret"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_set_refmap_bit",
          "args": [
            "dlm",
            "res",
            "nodenum"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_set_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "633-642",
          "snippet": "void dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: need ref for node %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "nodenum"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"migrate request (node %u) returned %d!\\n\"",
            "nodenum",
            "status"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "nodenum",
            "iter->node_map"
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, Error %d send \"\n\t\t\t     \"MIGRATE_REQUEST to node %u\\n\"",
            "dlm->name",
            "migrate.namelen",
            "migrate.name",
            "ret",
            "nodenum"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_MIGRATE_REQUEST_MSG",
            "dlm->key",
            "&migrate",
            "sizeof(migrate)",
            "nodenum",
            "&status"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "nodenum",
            "dlm->domain_map"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_next",
          "args": [
            "iter"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1119-1129",
          "snippet": "static inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "migrate.name",
            "res->lockname.name",
            "migrate.namelen"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&migrate",
            "0",
            "sizeof(migrate)"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_migrate_request(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  u8 master, u8 new_master,\n\t\t\t\t  struct dlm_node_iter *iter)\n{\n\tstruct dlm_migrate_request migrate;\n\tint ret, skip, status = 0;\n\tint nodenum;\n\n\tmemset(&migrate, 0, sizeof(migrate));\n\tmigrate.namelen = res->lockname.len;\n\tmemcpy(migrate.name, res->lockname.name, migrate.namelen);\n\tmigrate.new_master = new_master;\n\tmigrate.master = master;\n\n\tret = 0;\n\n\t/* send message to all nodes, except the master and myself */\n\twhile ((nodenum = dlm_node_iter_next(iter)) >= 0) {\n\t\tif (nodenum == master ||\n\t\t    nodenum == new_master)\n\t\t\tcontinue;\n\n\t\t/* We could race exit domain. If exited, skip. */\n\t\tspin_lock(&dlm->spinlock);\n\t\tskip = (!test_bit(nodenum, dlm->domain_map));\n\t\tspin_unlock(&dlm->spinlock);\n\t\tif (skip) {\n\t\t\tclear_bit(nodenum, iter->node_map);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = o2net_send_message(DLM_MIGRATE_REQUEST_MSG, dlm->key,\n\t\t\t\t\t &migrate, sizeof(migrate), nodenum,\n\t\t\t\t\t &status);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send \"\n\t\t\t     \"MIGRATE_REQUEST to node %u\\n\", dlm->name,\n\t\t\t     migrate.namelen, migrate.name, ret, nodenum);\n\t\t\tif (!dlm_is_host_down(ret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", ret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tclear_bit(nodenum, iter->node_map);\n\t\t\tret = 0;\n\t\t} else if (status < 0) {\n\t\t\tmlog(0, \"migrate request (node %u) returned %d!\\n\",\n\t\t\t     nodenum, status);\n\t\t\tret = status;\n\t\t} else if (status == DLM_MIGRATE_RESPONSE_MASTERY_REF) {\n\t\t\t/* during the migration request we short-circuited\n\t\t\t * the mastery of the lockres.  make sure we have\n\t\t\t * a mastery ref for nodenum */\n\t\t\tmlog(0, \"%s:%.*s: need ref for node %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     nodenum);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, nodenum);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tmlog(0, \"returning ret=%d\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_pick_migration_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2899-2941",
    "snippet": "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res)\n{\n\tenum dlm_lockres_list idx;\n\tstruct list_head *queue = &res->granted;\n\tstruct dlm_lock *lock;\n\tint noderef;\n\tu8 nodenum = O2NM_MAX_NODES;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* Go through all the locks */\n\tfor (idx = DLM_GRANTED_LIST; idx <= DLM_BLOCKED_LIST; idx++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, idx);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == dlm->node_num)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(lock->ml.node, dlm->exit_domain_map))\n\t\t\t\tcontinue;\n\t\t\tnodenum = lock->ml.node;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Go thru the refmap */\n\tnoderef = -1;\n\twhile (1) {\n\t\tnoderef = find_next_bit(res->refmap, O2NM_MAX_NODES,\n\t\t\t\t\tnoderef + 1);\n\t\tif (noderef >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (noderef == dlm->node_num)\n\t\t\tcontinue;\n\t\tif (test_bit(noderef, dlm->exit_domain_map))\n\t\t\tcontinue;\n\t\tnodenum = noderef;\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn nodenum;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
      "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "noderef",
            "dlm->exit_domain_map"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "res->refmap",
            "O2NM_MAX_NODES",
            "noderef + 1"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "queue",
            "list"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_list_idx_to_ptr",
          "args": [
            "res",
            "idx"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_list_idx_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "417-430",
          "snippet": "static inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res)\n{\n\tenum dlm_lockres_list idx;\n\tstruct list_head *queue = &res->granted;\n\tstruct dlm_lock *lock;\n\tint noderef;\n\tu8 nodenum = O2NM_MAX_NODES;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* Go through all the locks */\n\tfor (idx = DLM_GRANTED_LIST; idx <= DLM_BLOCKED_LIST; idx++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, idx);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == dlm->node_num)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(lock->ml.node, dlm->exit_domain_map))\n\t\t\t\tcontinue;\n\t\t\tnodenum = lock->ml.node;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Go thru the refmap */\n\tnoderef = -1;\n\twhile (1) {\n\t\tnoderef = find_next_bit(res->refmap, O2NM_MAX_NODES,\n\t\t\t\t\tnoderef + 1);\n\t\tif (noderef >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (noderef == dlm->node_num)\n\t\t\tcontinue;\n\t\tif (test_bit(noderef, dlm->exit_domain_map))\n\t\t\tcontinue;\n\t\tnodenum = noderef;\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn nodenum;\n}"
  },
  {
    "function_name": "dlm_remove_nonlocal_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2845-2892",
    "snippet": "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct list_head *queue = &res->granted;\n\tint i, bit;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->owner == dlm->node_num);\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\t\tmlog(0, \"putting lock for node %u\\n\",\n\t\t\t\t     lock->ml.node);\n\t\t\t\t/* be extra careful */\n\t\t\t\tBUG_ON(!list_empty(&lock->ast_list));\n\t\t\t\tBUG_ON(!list_empty(&lock->bast_list));\n\t\t\t\tBUG_ON(lock->ast_pending);\n\t\t\t\tBUG_ON(lock->bast_pending);\n\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res,\n\t\t\t\t\t\t\t     lock->ml.node);\n\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t/* In a normal unlock, we would have added a\n\t\t\t\t * DLM_UNLOCK_FREE_LOCK action. Force it. */\n\t\t\t\tdlm_lock_put(lock);\n\t\t\t}\n\t\t}\n\t\tqueue++;\n\t}\n\tbit = 0;\n\twhile (1) {\n\t\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, bit);\n\t\tif (bit >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\t/* do not clear the local node reference, if there is a\n\t\t * process holding this, let it drop the ref itself */\n\t\tif (bit != dlm->node_num) {\n\t\t\tmlog(0, \"%s:%.*s: node %u had a ref to this \"\n\t\t\t     \"migrating lockres, clearing\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, bit);\n\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, bit);\n\t\t}\n\t\tbit++;\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_clear_refmap_bit",
          "args": [
            "dlm",
            "res",
            "bit"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_clear_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "644-653",
          "snippet": "void dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: node %u had a ref to this \"\n\t\t\t     \"migrating lockres, clearing\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "bit"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "res->refmap",
            "O2NM_MAX_NODES",
            "bit"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->bast_pending"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ast_pending"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&lock->bast_list)"
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lock->bast_list"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&lock->ast_list)"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"putting lock for node %u\\n\"",
            "lock->ml.node"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lock",
            "next",
            "queue",
            "list"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->owner == dlm->node_num"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct list_head *queue = &res->granted;\n\tint i, bit;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->owner == dlm->node_num);\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\t\tmlog(0, \"putting lock for node %u\\n\",\n\t\t\t\t     lock->ml.node);\n\t\t\t\t/* be extra careful */\n\t\t\t\tBUG_ON(!list_empty(&lock->ast_list));\n\t\t\t\tBUG_ON(!list_empty(&lock->bast_list));\n\t\t\t\tBUG_ON(lock->ast_pending);\n\t\t\t\tBUG_ON(lock->bast_pending);\n\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res,\n\t\t\t\t\t\t\t     lock->ml.node);\n\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t/* In a normal unlock, we would have added a\n\t\t\t\t * DLM_UNLOCK_FREE_LOCK action. Force it. */\n\t\t\t\tdlm_lock_put(lock);\n\t\t\t}\n\t\t}\n\t\tqueue++;\n\t}\n\tbit = 0;\n\twhile (1) {\n\t\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, bit);\n\t\tif (bit >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\t/* do not clear the local node reference, if there is a\n\t\t * process holding this, let it drop the ref itself */\n\t\tif (bit != dlm->node_num) {\n\t\t\tmlog(0, \"%s:%.*s: node %u had a ref to this \"\n\t\t\t     \"migrating lockres, clearing\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, bit);\n\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, bit);\n\t\t}\n\t\tbit++;\n\t}\n}"
  },
  {
    "function_name": "dlm_mark_lockres_migrating",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2755-2840",
    "snippet": "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target)\n{\n\tint ret = 0;\n\n\tmlog(0, \"dlm_mark_lockres_migrating: %.*s, from %u to %u\\n\",\n\t       res->lockname.len, res->lockname.name, dlm->node_num,\n\t       target);\n\t/* need to set MIGRATING flag on lockres.  this is done by\n\t * ensuring that all asts have been flushed for this lockres. */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->migration_pending);\n\tres->migration_pending = 1;\n\t/* strategy is to reserve an extra ast then release\n\t * it below, letting the release do all of the work */\n\t__dlm_lockres_reserve_ast(res);\n\tspin_unlock(&res->spinlock);\n\n\t/* now flush all the pending asts */\n\tdlm_kick_thread(dlm, res);\n\t/* before waiting on DIRTY, block processes which may\n\t * try to dirty the lockres before MIGRATING is set */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->state & DLM_LOCK_RES_BLOCK_DIRTY);\n\tres->state |= DLM_LOCK_RES_BLOCK_DIRTY;\n\tspin_unlock(&res->spinlock);\n\t/* now wait on any pending asts and the DIRTY state */\n\twait_event(dlm->ast_wq, !dlm_lockres_is_dirty(dlm, res));\n\tdlm_lockres_release_ast(dlm, res);\n\n\tmlog(0, \"about to wait on migration_wq, dirty=%s\\n\",\n\t       res->state & DLM_LOCK_RES_DIRTY ? \"yes\" : \"no\");\n\t/* if the extra ref we just put was the final one, this\n\t * will pass thru immediately.  otherwise, we need to wait\n\t * for the last ast to finish. */\nagain:\n\tret = wait_event_interruptible_timeout(dlm->migration_wq,\n\t\t   dlm_migration_can_proceed(dlm, res, target),\n\t\t   msecs_to_jiffies(1000));\n\tif (ret < 0) {\n\t\tmlog(0, \"woken again: migrating? %s, dead? %s\\n\",\n\t\t       res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\",\n\t\t       test_bit(target, dlm->domain_map) ? \"no\":\"yes\");\n\t} else {\n\t\tmlog(0, \"all is well: migrating? %s, dead? %s\\n\",\n\t\t       res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\",\n\t\t       test_bit(target, dlm->domain_map) ? \"no\":\"yes\");\n\t}\n\tif (!dlm_migration_can_proceed(dlm, res, target)) {\n\t\tmlog(0, \"trying again...\\n\");\n\t\tgoto again;\n\t}\n\n\tret = 0;\n\t/* did the target go down or die? */\n\tspin_lock(&dlm->spinlock);\n\tif (!test_bit(target, dlm->domain_map)) {\n\t\tmlog(ML_ERROR, \"aha. migration target %u just went down\\n\",\n\t\t     target);\n\t\tret = -EHOSTDOWN;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\t/*\n\t * if target is down, we need to clear DLM_LOCK_RES_BLOCK_DIRTY for\n\t * another try; otherwise, we are sure the MIGRATING state is there,\n\t * drop the unneded state which blocked threads trying to DIRTY\n\t */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(!(res->state & DLM_LOCK_RES_BLOCK_DIRTY));\n\tres->state &= ~DLM_LOCK_RES_BLOCK_DIRTY;\n\tif (!ret)\n\t\tBUG_ON(!(res->state & DLM_LOCK_RES_MIGRATING));\n\tspin_unlock(&res->spinlock);\n\n\t/*\n\t * at this point:\n\t *\n\t *   o the DLM_LOCK_RES_MIGRATING flag is set if target not down\n\t *   o there are no pending asts on this lockres\n\t *   o all processes trying to reserve an ast on this\n\t *     lockres must wait for the MIGRATING flag to clear\n\t */\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
      "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(res->state & DLM_LOCK_RES_MIGRATING)"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(res->state & DLM_LOCK_RES_BLOCK_DIRTY)"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"aha. migration target %u just went down\\n\"",
            "target"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "target",
            "dlm->domain_map"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"trying again...\\n\""
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_migration_can_proceed",
          "args": [
            "dlm",
            "res",
            "target"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_migration_can_proceed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2726-2742",
          "snippet": "static int dlm_migration_can_proceed(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     u8 mig_target)\n{\n\tint can_proceed;\n\tspin_lock(&res->spinlock);\n\tcan_proceed = !!(res->state & DLM_LOCK_RES_MIGRATING);\n\tspin_unlock(&res->spinlock);\n\n\t/* target has died, so make the caller break out of the\n\t * wait_event, but caller must recheck the domain_map */\n\tspin_lock(&dlm->spinlock);\n\tif (!test_bit(mig_target, dlm->domain_map))\n\t\tcan_proceed = 1;\n\tspin_unlock(&dlm->spinlock);\n\treturn can_proceed;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_migration_can_proceed(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     u8 mig_target)\n{\n\tint can_proceed;\n\tspin_lock(&res->spinlock);\n\tcan_proceed = !!(res->state & DLM_LOCK_RES_MIGRATING);\n\tspin_unlock(&res->spinlock);\n\n\t/* target has died, so make the caller break out of the\n\t * wait_event, but caller must recheck the domain_map */\n\tspin_lock(&dlm->spinlock);\n\tif (!test_bit(mig_target, dlm->domain_map))\n\t\tcan_proceed = 1;\n\tspin_unlock(&dlm->spinlock);\n\treturn can_proceed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"all is well: migrating? %s, dead? %s\\n\"",
            "res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\"",
            "test_bit(target, dlm->domain_map) ? \"no\":\"yes\""
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "dlm->migration_wq",
            "dlm_migration_can_proceed(dlm, res, target)",
            "msecs_to_jiffies(1000)"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "1000"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_release_ast",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_release_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3419-3436",
          "snippet": "void dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "dlm->ast_wq",
            "!dlm_lockres_is_dirty(dlm, res)"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_is_dirty",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_is_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2744-2752",
          "snippet": "static int dlm_lockres_is_dirty(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res)\n{\n\tint ret;\n\tspin_lock(&res->spinlock);\n\tret = !!(res->state & DLM_LOCK_RES_DIRTY);\n\tspin_unlock(&res->spinlock);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_lockres_is_dirty(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res)\n{\n\tint ret;\n\tspin_lock(&res->spinlock);\n\tret = !!(res->state & DLM_LOCK_RES_DIRTY);\n\tspin_unlock(&res->spinlock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->state & DLM_LOCK_RES_BLOCK_DIRTY"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_reserve_ast",
          "args": [
            "res"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_reserve_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3395-3404",
          "snippet": "void __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->migration_pending"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm_mark_lockres_migrating: %.*s, from %u to %u\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "dlm->node_num",
            "target"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target)\n{\n\tint ret = 0;\n\n\tmlog(0, \"dlm_mark_lockres_migrating: %.*s, from %u to %u\\n\",\n\t       res->lockname.len, res->lockname.name, dlm->node_num,\n\t       target);\n\t/* need to set MIGRATING flag on lockres.  this is done by\n\t * ensuring that all asts have been flushed for this lockres. */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->migration_pending);\n\tres->migration_pending = 1;\n\t/* strategy is to reserve an extra ast then release\n\t * it below, letting the release do all of the work */\n\t__dlm_lockres_reserve_ast(res);\n\tspin_unlock(&res->spinlock);\n\n\t/* now flush all the pending asts */\n\tdlm_kick_thread(dlm, res);\n\t/* before waiting on DIRTY, block processes which may\n\t * try to dirty the lockres before MIGRATING is set */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->state & DLM_LOCK_RES_BLOCK_DIRTY);\n\tres->state |= DLM_LOCK_RES_BLOCK_DIRTY;\n\tspin_unlock(&res->spinlock);\n\t/* now wait on any pending asts and the DIRTY state */\n\twait_event(dlm->ast_wq, !dlm_lockres_is_dirty(dlm, res));\n\tdlm_lockres_release_ast(dlm, res);\n\n\tmlog(0, \"about to wait on migration_wq, dirty=%s\\n\",\n\t       res->state & DLM_LOCK_RES_DIRTY ? \"yes\" : \"no\");\n\t/* if the extra ref we just put was the final one, this\n\t * will pass thru immediately.  otherwise, we need to wait\n\t * for the last ast to finish. */\nagain:\n\tret = wait_event_interruptible_timeout(dlm->migration_wq,\n\t\t   dlm_migration_can_proceed(dlm, res, target),\n\t\t   msecs_to_jiffies(1000));\n\tif (ret < 0) {\n\t\tmlog(0, \"woken again: migrating? %s, dead? %s\\n\",\n\t\t       res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\",\n\t\t       test_bit(target, dlm->domain_map) ? \"no\":\"yes\");\n\t} else {\n\t\tmlog(0, \"all is well: migrating? %s, dead? %s\\n\",\n\t\t       res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\",\n\t\t       test_bit(target, dlm->domain_map) ? \"no\":\"yes\");\n\t}\n\tif (!dlm_migration_can_proceed(dlm, res, target)) {\n\t\tmlog(0, \"trying again...\\n\");\n\t\tgoto again;\n\t}\n\n\tret = 0;\n\t/* did the target go down or die? */\n\tspin_lock(&dlm->spinlock);\n\tif (!test_bit(target, dlm->domain_map)) {\n\t\tmlog(ML_ERROR, \"aha. migration target %u just went down\\n\",\n\t\t     target);\n\t\tret = -EHOSTDOWN;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\t/*\n\t * if target is down, we need to clear DLM_LOCK_RES_BLOCK_DIRTY for\n\t * another try; otherwise, we are sure the MIGRATING state is there,\n\t * drop the unneded state which blocked threads trying to DIRTY\n\t */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(!(res->state & DLM_LOCK_RES_BLOCK_DIRTY));\n\tres->state &= ~DLM_LOCK_RES_BLOCK_DIRTY;\n\tif (!ret)\n\t\tBUG_ON(!(res->state & DLM_LOCK_RES_MIGRATING));\n\tspin_unlock(&res->spinlock);\n\n\t/*\n\t * at this point:\n\t *\n\t *   o the DLM_LOCK_RES_MIGRATING flag is set if target not down\n\t *   o there are no pending asts on this lockres\n\t *   o all processes trying to reserve an ast on this\n\t *     lockres must wait for the MIGRATING flag to clear\n\t */\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_lockres_is_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2744-2752",
    "snippet": "static int dlm_lockres_is_dirty(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res)\n{\n\tint ret;\n\tspin_lock(&res->spinlock);\n\tret = !!(res->state & DLM_LOCK_RES_DIRTY);\n\tspin_unlock(&res->spinlock);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_lockres_is_dirty(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res)\n{\n\tint ret;\n\tspin_lock(&res->spinlock);\n\tret = !!(res->state & DLM_LOCK_RES_DIRTY);\n\tspin_unlock(&res->spinlock);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_migration_can_proceed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2726-2742",
    "snippet": "static int dlm_migration_can_proceed(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     u8 mig_target)\n{\n\tint can_proceed;\n\tspin_lock(&res->spinlock);\n\tcan_proceed = !!(res->state & DLM_LOCK_RES_MIGRATING);\n\tspin_unlock(&res->spinlock);\n\n\t/* target has died, so make the caller break out of the\n\t * wait_event, but caller must recheck the domain_map */\n\tspin_lock(&dlm->spinlock);\n\tif (!test_bit(mig_target, dlm->domain_map))\n\t\tcan_proceed = 1;\n\tspin_unlock(&dlm->spinlock);\n\treturn can_proceed;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "mig_target",
            "dlm->domain_map"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_migration_can_proceed(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     u8 mig_target)\n{\n\tint can_proceed;\n\tspin_lock(&res->spinlock);\n\tcan_proceed = !!(res->state & DLM_LOCK_RES_MIGRATING);\n\tspin_unlock(&res->spinlock);\n\n\t/* target has died, so make the caller break out of the\n\t * wait_event, but caller must recheck the domain_map */\n\tspin_lock(&dlm->spinlock);\n\tif (!test_bit(mig_target, dlm->domain_map))\n\t\tcan_proceed = 1;\n\tspin_unlock(&dlm->spinlock);\n\treturn can_proceed;\n}"
  },
  {
    "function_name": "dlm_lock_basts_flushed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2715-2724",
    "snippet": "int dlm_lock_basts_flushed(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tint ret;\n\tspin_lock(&dlm->ast_lock);\n\tspin_lock(&lock->spinlock);\n\tret = (list_empty(&lock->bast_list) && !lock->bast_pending);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&dlm->ast_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lock->bast_list"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lock->spinlock"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_lock_basts_flushed(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tint ret;\n\tspin_lock(&dlm->ast_lock);\n\tspin_lock(&lock->spinlock);\n\tret = (list_empty(&lock->bast_list) && !lock->bast_pending);\n\tspin_unlock(&lock->spinlock);\n\tspin_unlock(&dlm->ast_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_empty_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2686-2713",
    "snippet": "int dlm_empty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tint ret;\n\tint lock_dropped = 0;\n\tu8 target = O2NM_MAX_NODES;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tspin_lock(&res->spinlock);\n\tif (dlm_is_lockres_migrateable(dlm, res))\n\t\ttarget = dlm_pick_migration_target(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (target == O2NM_MAX_NODES)\n\t\tgoto leave;\n\n\t/* Wheee! Migrate lockres here! Will sleep so drop spinlock. */\n\tspin_unlock(&dlm->spinlock);\n\tlock_dropped = 1;\n\tret = dlm_migrate_lockres(dlm, res, target);\n\tif (ret)\n\t\tmlog(0, \"%s: res %.*s, Migrate to node %u failed with %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     target, ret);\n\tspin_lock(&dlm->spinlock);\nleave:\n\treturn lock_dropped;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Migrate to node %u failed with %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "target",
            "ret"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_migrate_lockres",
          "args": [
            "dlm",
            "res",
            "target"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_migrate_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2459-2672",
          "snippet": "static int dlm_migrate_lockres(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 target)\n{\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_master_list_entry *oldmle = NULL;\n \tstruct dlm_migratable_lockres *mres = NULL;\n\tint ret = 0;\n\tconst char *name;\n\tunsigned int namelen;\n\tint mle_added = 0;\n\tint wake = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tBUG_ON(target == O2NM_MAX_NODES);\n\n\tname = res->lockname.name;\n\tnamelen = res->lockname.len;\n\n\tmlog(0, \"%s: Migrating %.*s to node %u\\n\", dlm->name, namelen, name,\n\t     target);\n\n\t/* preallocate up front. if this fails, abort */\n\tret = -ENOMEM;\n\tmres = (struct dlm_migratable_lockres *) __get_free_page(GFP_NOFS);\n\tif (!mres) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tmle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\tif (!mle) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\tret = 0;\n\n\t/*\n\t * clear any existing master requests and\n\t * add the migration mle to the list\n\t */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tret = dlm_add_migration_mle(dlm, res, mle, &oldmle, name,\n\t\t\t\t    namelen, target, dlm->node_num);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret == -EEXIST) {\n\t\tmlog(0, \"another process is already migrating it\\n\");\n\t\tgoto fail;\n\t}\n\tmle_added = 1;\n\n\t/*\n\t * set the MIGRATING flag and flush asts\n\t * if we fail after this we need to re-dirty the lockres\n\t */\n\tif (dlm_mark_lockres_migrating(dlm, res, target) < 0) {\n\t\tmlog(ML_ERROR, \"tried to migrate %.*s to %u, but \"\n\t\t     \"the target went down.\\n\", res->lockname.len,\n\t\t     res->lockname.name, target);\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\twake = 1;\n\t\tspin_unlock(&res->spinlock);\n\t\tret = -EINVAL;\n\t}\n\nfail:\n\tif (oldmle) {\n\t\t/* master is known, detach if not already detached */\n\t\tdlm_mle_detach_hb_events(dlm, oldmle);\n\t\tdlm_put_mle(oldmle);\n\t}\n\n\tif (ret < 0) {\n\t\tif (mle_added) {\n\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\tdlm_put_mle(mle);\n\t\t} else if (mle) {\n\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tmle = NULL;\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * at this point, we have a migration target, an mle\n\t * in the master list, and the MIGRATING flag set on\n\t * the lockres\n\t */\n\n\t/* now that remote nodes are spinning on the MIGRATING flag,\n\t * ensure that all assert_master work is flushed. */\n\tflush_workqueue(dlm->dlm_worker);\n\n\t/* get an extra reference on the mle.\n\t * otherwise the assert_master from the new\n\t * master will destroy this.\n\t * also, make sure that all callers of dlm_get_mle\n\t * take both dlm->spinlock and dlm->master_lock */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tdlm_get_mle_inuse(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* notify new node and send all lock state */\n\t/* call send_one_lockres with migration flag.\n\t * this serves as notice to the target node that a\n\t * migration is starting. */\n\tret = dlm_send_one_lockres(dlm, res, mres, target,\n\t\t\t\t   DLM_MRES_MIGRATION);\n\n\tif (ret < 0) {\n\t\tmlog(0, \"migration to node %u failed with %d\\n\",\n\t\t     target, ret);\n\t\t/* migration failed, detach and clean up mle */\n\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\tdlm_put_mle(mle);\n\t\tdlm_put_mle_inuse(mle);\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\twake = 1;\n\t\tspin_unlock(&res->spinlock);\n\t\tif (dlm_is_host_down(ret))\n\t\t\tdlm_wait_for_node_death(dlm, target,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\tgoto leave;\n\t}\n\n\t/* at this point, the target sends a message to all nodes,\n\t * (using dlm_do_migrate_request).  this node is skipped since\n\t * we had to put an mle in the list to begin the process.  this\n\t * node now waits for target to do an assert master.  this node\n\t * will be the last one notified, ensuring that the migration\n\t * is complete everywhere.  if the target dies while this is\n\t * going on, some nodes could potentially see the target as the\n\t * master, so it is important that my recovery finds the migration\n\t * mle and sets the master to UNKNOWN. */\n\n\n\t/* wait for new node to assert master */\n\twhile (1) {\n\t\tret = wait_event_interruptible_timeout(mle->wq,\n\t\t\t\t\t(atomic_read(&mle->woken) == 1),\n\t\t\t\t\tmsecs_to_jiffies(5000));\n\n\t\tif (ret >= 0) {\n\t\t       \tif (atomic_read(&mle->woken) == 1 ||\n\t\t\t    res->owner == target)\n\t\t\t\tbreak;\n\n\t\t\tmlog(0, \"%s:%.*s: timed out during migration\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t\t/* avoid hang during shutdown when migrating lockres\n\t\t\t * to a node which also goes down */\n\t\t\tif (dlm_is_node_dead(dlm, target)) {\n\t\t\t\tmlog(0, \"%s:%.*s: expected migration \"\n\t\t\t\t     \"target %u is no longer up, restarting\\n\",\n\t\t\t\t     dlm->name, res->lockname.len,\n\t\t\t\t     res->lockname.name, target);\n\t\t\t\tret = -EINVAL;\n\t\t\t\t/* migration failed, detach and clean up mle */\n\t\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\t\tdlm_put_mle(mle);\n\t\t\t\tdlm_put_mle_inuse(mle);\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\t\t\twake = 1;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t} else\n\t\t\tmlog(0, \"%s:%.*s: caught signal during migration\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n\n\t/* all done, set the owner, clear the flag */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, target);\n\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\tdlm_remove_nonlocal_locks(dlm, res);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* master is known, detach if not already detached */\n\tdlm_mle_detach_hb_events(dlm, mle);\n\tdlm_put_mle_inuse(mle);\n\tret = 0;\n\n\tdlm_lockres_calc_usage(dlm, res);\n\nleave:\n\t/* re-dirty the lockres if we failed */\n\tif (ret < 0)\n\t\tdlm_kick_thread(dlm, res);\n\n\t/* wake up waiters if the MIGRATING flag got set\n\t * but migration failed */\n\tif (wake)\n\t\twake_up(&res->wq);\n\n\tif (mres)\n\t\tfree_page((unsigned long)mres);\n\n\tdlm_put(dlm);\n\n\tmlog(0, \"%s: Migrating %.*s to %u, returns %d\\n\", dlm->name, namelen,\n\t     name, target, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_mle_cache;",
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_mle_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_migrate_lockres(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 target)\n{\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_master_list_entry *oldmle = NULL;\n \tstruct dlm_migratable_lockres *mres = NULL;\n\tint ret = 0;\n\tconst char *name;\n\tunsigned int namelen;\n\tint mle_added = 0;\n\tint wake = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tBUG_ON(target == O2NM_MAX_NODES);\n\n\tname = res->lockname.name;\n\tnamelen = res->lockname.len;\n\n\tmlog(0, \"%s: Migrating %.*s to node %u\\n\", dlm->name, namelen, name,\n\t     target);\n\n\t/* preallocate up front. if this fails, abort */\n\tret = -ENOMEM;\n\tmres = (struct dlm_migratable_lockres *) __get_free_page(GFP_NOFS);\n\tif (!mres) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tmle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\tif (!mle) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\tret = 0;\n\n\t/*\n\t * clear any existing master requests and\n\t * add the migration mle to the list\n\t */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tret = dlm_add_migration_mle(dlm, res, mle, &oldmle, name,\n\t\t\t\t    namelen, target, dlm->node_num);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret == -EEXIST) {\n\t\tmlog(0, \"another process is already migrating it\\n\");\n\t\tgoto fail;\n\t}\n\tmle_added = 1;\n\n\t/*\n\t * set the MIGRATING flag and flush asts\n\t * if we fail after this we need to re-dirty the lockres\n\t */\n\tif (dlm_mark_lockres_migrating(dlm, res, target) < 0) {\n\t\tmlog(ML_ERROR, \"tried to migrate %.*s to %u, but \"\n\t\t     \"the target went down.\\n\", res->lockname.len,\n\t\t     res->lockname.name, target);\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\twake = 1;\n\t\tspin_unlock(&res->spinlock);\n\t\tret = -EINVAL;\n\t}\n\nfail:\n\tif (oldmle) {\n\t\t/* master is known, detach if not already detached */\n\t\tdlm_mle_detach_hb_events(dlm, oldmle);\n\t\tdlm_put_mle(oldmle);\n\t}\n\n\tif (ret < 0) {\n\t\tif (mle_added) {\n\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\tdlm_put_mle(mle);\n\t\t} else if (mle) {\n\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tmle = NULL;\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * at this point, we have a migration target, an mle\n\t * in the master list, and the MIGRATING flag set on\n\t * the lockres\n\t */\n\n\t/* now that remote nodes are spinning on the MIGRATING flag,\n\t * ensure that all assert_master work is flushed. */\n\tflush_workqueue(dlm->dlm_worker);\n\n\t/* get an extra reference on the mle.\n\t * otherwise the assert_master from the new\n\t * master will destroy this.\n\t * also, make sure that all callers of dlm_get_mle\n\t * take both dlm->spinlock and dlm->master_lock */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tdlm_get_mle_inuse(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* notify new node and send all lock state */\n\t/* call send_one_lockres with migration flag.\n\t * this serves as notice to the target node that a\n\t * migration is starting. */\n\tret = dlm_send_one_lockres(dlm, res, mres, target,\n\t\t\t\t   DLM_MRES_MIGRATION);\n\n\tif (ret < 0) {\n\t\tmlog(0, \"migration to node %u failed with %d\\n\",\n\t\t     target, ret);\n\t\t/* migration failed, detach and clean up mle */\n\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\tdlm_put_mle(mle);\n\t\tdlm_put_mle_inuse(mle);\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\twake = 1;\n\t\tspin_unlock(&res->spinlock);\n\t\tif (dlm_is_host_down(ret))\n\t\t\tdlm_wait_for_node_death(dlm, target,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\tgoto leave;\n\t}\n\n\t/* at this point, the target sends a message to all nodes,\n\t * (using dlm_do_migrate_request).  this node is skipped since\n\t * we had to put an mle in the list to begin the process.  this\n\t * node now waits for target to do an assert master.  this node\n\t * will be the last one notified, ensuring that the migration\n\t * is complete everywhere.  if the target dies while this is\n\t * going on, some nodes could potentially see the target as the\n\t * master, so it is important that my recovery finds the migration\n\t * mle and sets the master to UNKNOWN. */\n\n\n\t/* wait for new node to assert master */\n\twhile (1) {\n\t\tret = wait_event_interruptible_timeout(mle->wq,\n\t\t\t\t\t(atomic_read(&mle->woken) == 1),\n\t\t\t\t\tmsecs_to_jiffies(5000));\n\n\t\tif (ret >= 0) {\n\t\t       \tif (atomic_read(&mle->woken) == 1 ||\n\t\t\t    res->owner == target)\n\t\t\t\tbreak;\n\n\t\t\tmlog(0, \"%s:%.*s: timed out during migration\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t\t/* avoid hang during shutdown when migrating lockres\n\t\t\t * to a node which also goes down */\n\t\t\tif (dlm_is_node_dead(dlm, target)) {\n\t\t\t\tmlog(0, \"%s:%.*s: expected migration \"\n\t\t\t\t     \"target %u is no longer up, restarting\\n\",\n\t\t\t\t     dlm->name, res->lockname.len,\n\t\t\t\t     res->lockname.name, target);\n\t\t\t\tret = -EINVAL;\n\t\t\t\t/* migration failed, detach and clean up mle */\n\t\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\t\tdlm_put_mle(mle);\n\t\t\t\tdlm_put_mle_inuse(mle);\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\t\t\twake = 1;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t} else\n\t\t\tmlog(0, \"%s:%.*s: caught signal during migration\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n\n\t/* all done, set the owner, clear the flag */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, target);\n\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\tdlm_remove_nonlocal_locks(dlm, res);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* master is known, detach if not already detached */\n\tdlm_mle_detach_hb_events(dlm, mle);\n\tdlm_put_mle_inuse(mle);\n\tret = 0;\n\n\tdlm_lockres_calc_usage(dlm, res);\n\nleave:\n\t/* re-dirty the lockres if we failed */\n\tif (ret < 0)\n\t\tdlm_kick_thread(dlm, res);\n\n\t/* wake up waiters if the MIGRATING flag got set\n\t * but migration failed */\n\tif (wake)\n\t\twake_up(&res->wq);\n\n\tif (mres)\n\t\tfree_page((unsigned long)mres);\n\n\tdlm_put(dlm);\n\n\tmlog(0, \"%s: Migrating %.*s to %u, returns %d\\n\", dlm->name, namelen,\n\t     name, target, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_pick_migration_target",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_pick_migration_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2899-2941",
          "snippet": "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res)\n{\n\tenum dlm_lockres_list idx;\n\tstruct list_head *queue = &res->granted;\n\tstruct dlm_lock *lock;\n\tint noderef;\n\tu8 nodenum = O2NM_MAX_NODES;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* Go through all the locks */\n\tfor (idx = DLM_GRANTED_LIST; idx <= DLM_BLOCKED_LIST; idx++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, idx);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == dlm->node_num)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(lock->ml.node, dlm->exit_domain_map))\n\t\t\t\tcontinue;\n\t\t\tnodenum = lock->ml.node;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Go thru the refmap */\n\tnoderef = -1;\n\twhile (1) {\n\t\tnoderef = find_next_bit(res->refmap, O2NM_MAX_NODES,\n\t\t\t\t\tnoderef + 1);\n\t\tif (noderef >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (noderef == dlm->node_num)\n\t\t\tcontinue;\n\t\tif (test_bit(noderef, dlm->exit_domain_map))\n\t\t\tcontinue;\n\t\tnodenum = noderef;\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn nodenum;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
            "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res)\n{\n\tenum dlm_lockres_list idx;\n\tstruct list_head *queue = &res->granted;\n\tstruct dlm_lock *lock;\n\tint noderef;\n\tu8 nodenum = O2NM_MAX_NODES;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* Go through all the locks */\n\tfor (idx = DLM_GRANTED_LIST; idx <= DLM_BLOCKED_LIST; idx++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, idx);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == dlm->node_num)\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(lock->ml.node, dlm->exit_domain_map))\n\t\t\t\tcontinue;\n\t\t\tnodenum = lock->ml.node;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Go thru the refmap */\n\tnoderef = -1;\n\twhile (1) {\n\t\tnoderef = find_next_bit(res->refmap, O2NM_MAX_NODES,\n\t\t\t\t\tnoderef + 1);\n\t\tif (noderef >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\tif (noderef == dlm->node_num)\n\t\t\tcontinue;\n\t\tif (test_bit(noderef, dlm->exit_domain_map))\n\t\t\tcontinue;\n\t\tnodenum = noderef;\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn nodenum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_lockres_migrateable",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_lockres_migrateable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2402-2452",
          "snippet": "static int dlm_is_lockres_migrateable(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res)\n{\n\tenum dlm_lockres_list idx;\n\tint nonlocal = 0, node_ref;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tu64 cookie;\n\n\tassert_spin_locked(&res->spinlock);\n\n\t/* delay migration when the lockres is in MIGRATING state */\n\tif (res->state & DLM_LOCK_RES_MIGRATING)\n\t\treturn 0;\n\n\t/* delay migration when the lockres is in RECOCERING state */\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\tif (res->owner != dlm->node_num)\n\t\treturn 0;\n\n        for (idx = DLM_GRANTED_LIST; idx <= DLM_BLOCKED_LIST; idx++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, idx);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\t\tnonlocal++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcookie = be64_to_cpu(lock->ml.cookie);\n\t\t\tmlog(0, \"%s: Not migrateable res %.*s, lock %u:%llu on \"\n\t\t\t     \"%s list\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     dlm_get_lock_cookie_node(cookie),\n\t\t\t     dlm_get_lock_cookie_seq(cookie),\n\t\t\t     dlm_list_in_text(idx));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!nonlocal) {\n\t\tnode_ref = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\t\tif (node_ref >= O2NM_MAX_NODES)\n\t\t\treturn 0;\n\t}\n\n\tmlog(0, \"%s: res %.*s, Migrateable\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
            "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_is_lockres_migrateable(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res)\n{\n\tenum dlm_lockres_list idx;\n\tint nonlocal = 0, node_ref;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tu64 cookie;\n\n\tassert_spin_locked(&res->spinlock);\n\n\t/* delay migration when the lockres is in MIGRATING state */\n\tif (res->state & DLM_LOCK_RES_MIGRATING)\n\t\treturn 0;\n\n\t/* delay migration when the lockres is in RECOCERING state */\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\tif (res->owner != dlm->node_num)\n\t\treturn 0;\n\n        for (idx = DLM_GRANTED_LIST; idx <= DLM_BLOCKED_LIST; idx++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, idx);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\t\tnonlocal++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcookie = be64_to_cpu(lock->ml.cookie);\n\t\t\tmlog(0, \"%s: Not migrateable res %.*s, lock %u:%llu on \"\n\t\t\t     \"%s list\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     dlm_get_lock_cookie_node(cookie),\n\t\t\t     dlm_get_lock_cookie_seq(cookie),\n\t\t\t     dlm_list_in_text(idx));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!nonlocal) {\n\t\tnode_ref = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\t\tif (node_ref >= O2NM_MAX_NODES)\n\t\t\treturn 0;\n\t}\n\n\tmlog(0, \"%s: res %.*s, Migrateable\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_empty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tint ret;\n\tint lock_dropped = 0;\n\tu8 target = O2NM_MAX_NODES;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tspin_lock(&res->spinlock);\n\tif (dlm_is_lockres_migrateable(dlm, res))\n\t\ttarget = dlm_pick_migration_target(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (target == O2NM_MAX_NODES)\n\t\tgoto leave;\n\n\t/* Wheee! Migrate lockres here! Will sleep so drop spinlock. */\n\tspin_unlock(&dlm->spinlock);\n\tlock_dropped = 1;\n\tret = dlm_migrate_lockres(dlm, res, target);\n\tif (ret)\n\t\tmlog(0, \"%s: res %.*s, Migrate to node %u failed with %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     target, ret);\n\tspin_lock(&dlm->spinlock);\nleave:\n\treturn lock_dropped;\n}"
  },
  {
    "function_name": "dlm_migrate_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2459-2672",
    "snippet": "static int dlm_migrate_lockres(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 target)\n{\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_master_list_entry *oldmle = NULL;\n \tstruct dlm_migratable_lockres *mres = NULL;\n\tint ret = 0;\n\tconst char *name;\n\tunsigned int namelen;\n\tint mle_added = 0;\n\tint wake = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tBUG_ON(target == O2NM_MAX_NODES);\n\n\tname = res->lockname.name;\n\tnamelen = res->lockname.len;\n\n\tmlog(0, \"%s: Migrating %.*s to node %u\\n\", dlm->name, namelen, name,\n\t     target);\n\n\t/* preallocate up front. if this fails, abort */\n\tret = -ENOMEM;\n\tmres = (struct dlm_migratable_lockres *) __get_free_page(GFP_NOFS);\n\tif (!mres) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tmle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\tif (!mle) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\tret = 0;\n\n\t/*\n\t * clear any existing master requests and\n\t * add the migration mle to the list\n\t */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tret = dlm_add_migration_mle(dlm, res, mle, &oldmle, name,\n\t\t\t\t    namelen, target, dlm->node_num);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret == -EEXIST) {\n\t\tmlog(0, \"another process is already migrating it\\n\");\n\t\tgoto fail;\n\t}\n\tmle_added = 1;\n\n\t/*\n\t * set the MIGRATING flag and flush asts\n\t * if we fail after this we need to re-dirty the lockres\n\t */\n\tif (dlm_mark_lockres_migrating(dlm, res, target) < 0) {\n\t\tmlog(ML_ERROR, \"tried to migrate %.*s to %u, but \"\n\t\t     \"the target went down.\\n\", res->lockname.len,\n\t\t     res->lockname.name, target);\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\twake = 1;\n\t\tspin_unlock(&res->spinlock);\n\t\tret = -EINVAL;\n\t}\n\nfail:\n\tif (oldmle) {\n\t\t/* master is known, detach if not already detached */\n\t\tdlm_mle_detach_hb_events(dlm, oldmle);\n\t\tdlm_put_mle(oldmle);\n\t}\n\n\tif (ret < 0) {\n\t\tif (mle_added) {\n\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\tdlm_put_mle(mle);\n\t\t} else if (mle) {\n\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tmle = NULL;\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * at this point, we have a migration target, an mle\n\t * in the master list, and the MIGRATING flag set on\n\t * the lockres\n\t */\n\n\t/* now that remote nodes are spinning on the MIGRATING flag,\n\t * ensure that all assert_master work is flushed. */\n\tflush_workqueue(dlm->dlm_worker);\n\n\t/* get an extra reference on the mle.\n\t * otherwise the assert_master from the new\n\t * master will destroy this.\n\t * also, make sure that all callers of dlm_get_mle\n\t * take both dlm->spinlock and dlm->master_lock */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tdlm_get_mle_inuse(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* notify new node and send all lock state */\n\t/* call send_one_lockres with migration flag.\n\t * this serves as notice to the target node that a\n\t * migration is starting. */\n\tret = dlm_send_one_lockres(dlm, res, mres, target,\n\t\t\t\t   DLM_MRES_MIGRATION);\n\n\tif (ret < 0) {\n\t\tmlog(0, \"migration to node %u failed with %d\\n\",\n\t\t     target, ret);\n\t\t/* migration failed, detach and clean up mle */\n\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\tdlm_put_mle(mle);\n\t\tdlm_put_mle_inuse(mle);\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\twake = 1;\n\t\tspin_unlock(&res->spinlock);\n\t\tif (dlm_is_host_down(ret))\n\t\t\tdlm_wait_for_node_death(dlm, target,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\tgoto leave;\n\t}\n\n\t/* at this point, the target sends a message to all nodes,\n\t * (using dlm_do_migrate_request).  this node is skipped since\n\t * we had to put an mle in the list to begin the process.  this\n\t * node now waits for target to do an assert master.  this node\n\t * will be the last one notified, ensuring that the migration\n\t * is complete everywhere.  if the target dies while this is\n\t * going on, some nodes could potentially see the target as the\n\t * master, so it is important that my recovery finds the migration\n\t * mle and sets the master to UNKNOWN. */\n\n\n\t/* wait for new node to assert master */\n\twhile (1) {\n\t\tret = wait_event_interruptible_timeout(mle->wq,\n\t\t\t\t\t(atomic_read(&mle->woken) == 1),\n\t\t\t\t\tmsecs_to_jiffies(5000));\n\n\t\tif (ret >= 0) {\n\t\t       \tif (atomic_read(&mle->woken) == 1 ||\n\t\t\t    res->owner == target)\n\t\t\t\tbreak;\n\n\t\t\tmlog(0, \"%s:%.*s: timed out during migration\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t\t/* avoid hang during shutdown when migrating lockres\n\t\t\t * to a node which also goes down */\n\t\t\tif (dlm_is_node_dead(dlm, target)) {\n\t\t\t\tmlog(0, \"%s:%.*s: expected migration \"\n\t\t\t\t     \"target %u is no longer up, restarting\\n\",\n\t\t\t\t     dlm->name, res->lockname.len,\n\t\t\t\t     res->lockname.name, target);\n\t\t\t\tret = -EINVAL;\n\t\t\t\t/* migration failed, detach and clean up mle */\n\t\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\t\tdlm_put_mle(mle);\n\t\t\t\tdlm_put_mle_inuse(mle);\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\t\t\twake = 1;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t} else\n\t\t\tmlog(0, \"%s:%.*s: caught signal during migration\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n\n\t/* all done, set the owner, clear the flag */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, target);\n\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\tdlm_remove_nonlocal_locks(dlm, res);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* master is known, detach if not already detached */\n\tdlm_mle_detach_hb_events(dlm, mle);\n\tdlm_put_mle_inuse(mle);\n\tret = 0;\n\n\tdlm_lockres_calc_usage(dlm, res);\n\nleave:\n\t/* re-dirty the lockres if we failed */\n\tif (ret < 0)\n\t\tdlm_kick_thread(dlm, res);\n\n\t/* wake up waiters if the MIGRATING flag got set\n\t * but migration failed */\n\tif (wake)\n\t\twake_up(&res->wq);\n\n\tif (mres)\n\t\tfree_page((unsigned long)mres);\n\n\tdlm_put(dlm);\n\n\tmlog(0, \"%s: Migrating %.*s to %u, returns %d\\n\", dlm->name, namelen,\n\t     name, target, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_mle_cache;",
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Migrating %.*s to %u, returns %d\\n\"",
            "dlm->name",
            "namelen",
            "name",
            "target",
            "ret"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)mres"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_mle_inuse",
          "args": [
            "mle"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle_inuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "214-226",
          "snippet": "static void dlm_put_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tmle->inuse--;\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tmle->inuse--;\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "195-201",
          "snippet": "static inline void dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_remove_nonlocal_locks",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_remove_nonlocal_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2845-2892",
          "snippet": "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct list_head *queue = &res->granted;\n\tint i, bit;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->owner == dlm->node_num);\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\t\tmlog(0, \"putting lock for node %u\\n\",\n\t\t\t\t     lock->ml.node);\n\t\t\t\t/* be extra careful */\n\t\t\t\tBUG_ON(!list_empty(&lock->ast_list));\n\t\t\t\tBUG_ON(!list_empty(&lock->bast_list));\n\t\t\t\tBUG_ON(lock->ast_pending);\n\t\t\t\tBUG_ON(lock->bast_pending);\n\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res,\n\t\t\t\t\t\t\t     lock->ml.node);\n\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t/* In a normal unlock, we would have added a\n\t\t\t\t * DLM_UNLOCK_FREE_LOCK action. Force it. */\n\t\t\t\tdlm_lock_put(lock);\n\t\t\t}\n\t\t}\n\t\tqueue++;\n\t}\n\tbit = 0;\n\twhile (1) {\n\t\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, bit);\n\t\tif (bit >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\t/* do not clear the local node reference, if there is a\n\t\t * process holding this, let it drop the ref itself */\n\t\tif (bit != dlm->node_num) {\n\t\t\tmlog(0, \"%s:%.*s: node %u had a ref to this \"\n\t\t\t     \"migrating lockres, clearing\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, bit);\n\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, bit);\n\t\t}\n\t\tbit++;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res)\n{\n\tstruct list_head *queue = &res->granted;\n\tint i, bit;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->owner == dlm->node_num);\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\t\tmlog(0, \"putting lock for node %u\\n\",\n\t\t\t\t     lock->ml.node);\n\t\t\t\t/* be extra careful */\n\t\t\t\tBUG_ON(!list_empty(&lock->ast_list));\n\t\t\t\tBUG_ON(!list_empty(&lock->bast_list));\n\t\t\t\tBUG_ON(lock->ast_pending);\n\t\t\t\tBUG_ON(lock->bast_pending);\n\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res,\n\t\t\t\t\t\t\t     lock->ml.node);\n\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t/* In a normal unlock, we would have added a\n\t\t\t\t * DLM_UNLOCK_FREE_LOCK action. Force it. */\n\t\t\t\tdlm_lock_put(lock);\n\t\t\t}\n\t\t}\n\t\tqueue++;\n\t}\n\tbit = 0;\n\twhile (1) {\n\t\tbit = find_next_bit(res->refmap, O2NM_MAX_NODES, bit);\n\t\tif (bit >= O2NM_MAX_NODES)\n\t\t\tbreak;\n\t\t/* do not clear the local node reference, if there is a\n\t\t * process holding this, let it drop the ref itself */\n\t\tif (bit != dlm->node_num) {\n\t\t\tmlog(0, \"%s:%.*s: node %u had a ref to this \"\n\t\t\t     \"migrating lockres, clearing\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, bit);\n\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, bit);\n\t\t}\n\t\tbit++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_lockres_owner",
          "args": [
            "dlm",
            "res",
            "target"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1131-1138",
          "snippet": "static inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: caught signal during migration\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: expected migration \"\n\t\t\t\t     \"target %u is no longer up, restarting\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "target"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_node_dead",
          "args": [
            "dlm",
            "target"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_node_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "341-348",
          "snippet": "int dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nint dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: timed out during migration\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mle->woken"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "mle->wq",
            "(atomic_read(&mle->woken) == 1)",
            "msecs_to_jiffies(5000)"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "5000"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mle->woken"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_wait_for_node_death",
          "args": [
            "dlm",
            "target",
            "DLM_NODE_DEATH_WAIT_MAX"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_for_node_death",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "362-377",
          "snippet": "void dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"migration to node %u failed with %d\\n\"",
            "target",
            "ret"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_one_lockres",
          "args": [
            "dlm",
            "res",
            "mres",
            "target",
            "DLM_MRES_MIGRATION"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_one_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1279-1347",
          "snippet": "int dlm_send_one_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t struct dlm_migratable_lockres *mres,\n\t\t\t u8 send_to, u8 flags)\n{\n\tstruct list_head *queue;\n\tint total_locks, i;\n\tu64 mig_cookie = 0;\n\tstruct dlm_lock *lock;\n\tint ret = 0;\n\n\tBUG_ON(!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\tmlog(0, \"sending to %u\\n\", send_to);\n\n\ttotal_locks = dlm_num_locks_in_lockres(res);\n\tif (total_locks > DLM_MAX_MIGRATABLE_LOCKS) {\n\t\t/* rare, but possible */\n\t\tmlog(0, \"argh.  lockres has %d locks.  this will \"\n\t\t\t  \"require more than one network packet to \"\n\t\t\t  \"migrate\\n\", total_locks);\n\t\tmig_cookie = dlm_get_next_mig_cookie();\n\t}\n\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, total_locks,\n\t\t\t\t    mig_cookie, flags, res->owner);\n\n\ttotal_locks = 0;\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_BLOCKED_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\t/* add another lock. */\n\t\t\ttotal_locks++;\n\t\t\tif (!dlm_add_lock_to_array(lock, mres, i))\n\t\t\t\tcontinue;\n\n\t\t\t/* this filled the lock message,\n\t\t\t * we must send it immediately. */\n\t\t\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to,\n\t\t\t\t\t\t       res, total_locks);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (total_locks == 0) {\n\t\t/* send a dummy lock to indicate a mastery reference only */\n\t\tmlog(0, \"%s:%.*s: sending dummy lock to %u, %s\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     send_to, flags & DLM_MRES_RECOVERY ? \"recovery\" :\n\t\t     \"migration\");\n\t\tdlm_add_dummy_lock(dlm, mres);\n\t}\n\t/* flush any remaining locks */\n\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to, res, total_locks);\n\tif (ret < 0)\n\t\tgoto error;\n\treturn ret;\n\nerror:\n\tmlog(ML_ERROR, \"%s: dlm_send_mig_lockres_msg returned %d\\n\",\n\t     dlm->name, ret);\n\tif (!dlm_is_host_down(ret))\n\t\tBUG();\n\tmlog(0, \"%s: node %u went down while sending %s \"\n\t     \"lockres %.*s\\n\", dlm->name, send_to,\n\t     flags & DLM_MRES_RECOVERY ?  \"recovery\" : \"migration\",\n\t     res->lockname.len, res->lockname.name);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);",
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);",
            "static u64 dlm_get_next_mig_cookie(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);\nstatic u64 dlm_get_next_mig_cookie(void);\n\nint dlm_send_one_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t struct dlm_migratable_lockres *mres,\n\t\t\t u8 send_to, u8 flags)\n{\n\tstruct list_head *queue;\n\tint total_locks, i;\n\tu64 mig_cookie = 0;\n\tstruct dlm_lock *lock;\n\tint ret = 0;\n\n\tBUG_ON(!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\tmlog(0, \"sending to %u\\n\", send_to);\n\n\ttotal_locks = dlm_num_locks_in_lockres(res);\n\tif (total_locks > DLM_MAX_MIGRATABLE_LOCKS) {\n\t\t/* rare, but possible */\n\t\tmlog(0, \"argh.  lockres has %d locks.  this will \"\n\t\t\t  \"require more than one network packet to \"\n\t\t\t  \"migrate\\n\", total_locks);\n\t\tmig_cookie = dlm_get_next_mig_cookie();\n\t}\n\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, total_locks,\n\t\t\t\t    mig_cookie, flags, res->owner);\n\n\ttotal_locks = 0;\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_BLOCKED_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\t/* add another lock. */\n\t\t\ttotal_locks++;\n\t\t\tif (!dlm_add_lock_to_array(lock, mres, i))\n\t\t\t\tcontinue;\n\n\t\t\t/* this filled the lock message,\n\t\t\t * we must send it immediately. */\n\t\t\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to,\n\t\t\t\t\t\t       res, total_locks);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (total_locks == 0) {\n\t\t/* send a dummy lock to indicate a mastery reference only */\n\t\tmlog(0, \"%s:%.*s: sending dummy lock to %u, %s\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     send_to, flags & DLM_MRES_RECOVERY ? \"recovery\" :\n\t\t     \"migration\");\n\t\tdlm_add_dummy_lock(dlm, mres);\n\t}\n\t/* flush any remaining locks */\n\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to, res, total_locks);\n\tif (ret < 0)\n\t\tgoto error;\n\treturn ret;\n\nerror:\n\tmlog(ML_ERROR, \"%s: dlm_send_mig_lockres_msg returned %d\\n\",\n\t     dlm->name, ret);\n\tif (!dlm_is_host_down(ret))\n\t\tBUG();\n\tmlog(0, \"%s: node %u went down while sending %s \"\n\t     \"lockres %.*s\\n\", dlm->name, send_to,\n\t     flags & DLM_MRES_RECOVERY ?  \"recovery\" : \"migration\",\n\t     res->lockname.len, res->lockname.name);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_mle_inuse",
          "args": [
            "mle"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_mle_inuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "203-212",
          "snippet": "static void dlm_get_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tmle->inuse++;\n\tkref_get(&mle->mle_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_get_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tmle->inuse++;\n\tkref_get(&mle->mle_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "dlm->dlm_worker"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_mle_cache",
            "mle"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"tried to migrate %.*s to %u, but \"\n\t\t     \"the target went down.\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "target"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_mark_lockres_migrating",
          "args": [
            "dlm",
            "res",
            "target"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_mark_lockres_migrating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2755-2840",
          "snippet": "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target)\n{\n\tint ret = 0;\n\n\tmlog(0, \"dlm_mark_lockres_migrating: %.*s, from %u to %u\\n\",\n\t       res->lockname.len, res->lockname.name, dlm->node_num,\n\t       target);\n\t/* need to set MIGRATING flag on lockres.  this is done by\n\t * ensuring that all asts have been flushed for this lockres. */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->migration_pending);\n\tres->migration_pending = 1;\n\t/* strategy is to reserve an extra ast then release\n\t * it below, letting the release do all of the work */\n\t__dlm_lockres_reserve_ast(res);\n\tspin_unlock(&res->spinlock);\n\n\t/* now flush all the pending asts */\n\tdlm_kick_thread(dlm, res);\n\t/* before waiting on DIRTY, block processes which may\n\t * try to dirty the lockres before MIGRATING is set */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->state & DLM_LOCK_RES_BLOCK_DIRTY);\n\tres->state |= DLM_LOCK_RES_BLOCK_DIRTY;\n\tspin_unlock(&res->spinlock);\n\t/* now wait on any pending asts and the DIRTY state */\n\twait_event(dlm->ast_wq, !dlm_lockres_is_dirty(dlm, res));\n\tdlm_lockres_release_ast(dlm, res);\n\n\tmlog(0, \"about to wait on migration_wq, dirty=%s\\n\",\n\t       res->state & DLM_LOCK_RES_DIRTY ? \"yes\" : \"no\");\n\t/* if the extra ref we just put was the final one, this\n\t * will pass thru immediately.  otherwise, we need to wait\n\t * for the last ast to finish. */\nagain:\n\tret = wait_event_interruptible_timeout(dlm->migration_wq,\n\t\t   dlm_migration_can_proceed(dlm, res, target),\n\t\t   msecs_to_jiffies(1000));\n\tif (ret < 0) {\n\t\tmlog(0, \"woken again: migrating? %s, dead? %s\\n\",\n\t\t       res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\",\n\t\t       test_bit(target, dlm->domain_map) ? \"no\":\"yes\");\n\t} else {\n\t\tmlog(0, \"all is well: migrating? %s, dead? %s\\n\",\n\t\t       res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\",\n\t\t       test_bit(target, dlm->domain_map) ? \"no\":\"yes\");\n\t}\n\tif (!dlm_migration_can_proceed(dlm, res, target)) {\n\t\tmlog(0, \"trying again...\\n\");\n\t\tgoto again;\n\t}\n\n\tret = 0;\n\t/* did the target go down or die? */\n\tspin_lock(&dlm->spinlock);\n\tif (!test_bit(target, dlm->domain_map)) {\n\t\tmlog(ML_ERROR, \"aha. migration target %u just went down\\n\",\n\t\t     target);\n\t\tret = -EHOSTDOWN;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\t/*\n\t * if target is down, we need to clear DLM_LOCK_RES_BLOCK_DIRTY for\n\t * another try; otherwise, we are sure the MIGRATING state is there,\n\t * drop the unneded state which blocked threads trying to DIRTY\n\t */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(!(res->state & DLM_LOCK_RES_BLOCK_DIRTY));\n\tres->state &= ~DLM_LOCK_RES_BLOCK_DIRTY;\n\tif (!ret)\n\t\tBUG_ON(!(res->state & DLM_LOCK_RES_MIGRATING));\n\tspin_unlock(&res->spinlock);\n\n\t/*\n\t * at this point:\n\t *\n\t *   o the DLM_LOCK_RES_MIGRATING flag is set if target not down\n\t *   o there are no pending asts on this lockres\n\t *   o all processes trying to reserve an ast on this\n\t *     lockres must wait for the MIGRATING flag to clear\n\t */\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
            "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target)\n{\n\tint ret = 0;\n\n\tmlog(0, \"dlm_mark_lockres_migrating: %.*s, from %u to %u\\n\",\n\t       res->lockname.len, res->lockname.name, dlm->node_num,\n\t       target);\n\t/* need to set MIGRATING flag on lockres.  this is done by\n\t * ensuring that all asts have been flushed for this lockres. */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->migration_pending);\n\tres->migration_pending = 1;\n\t/* strategy is to reserve an extra ast then release\n\t * it below, letting the release do all of the work */\n\t__dlm_lockres_reserve_ast(res);\n\tspin_unlock(&res->spinlock);\n\n\t/* now flush all the pending asts */\n\tdlm_kick_thread(dlm, res);\n\t/* before waiting on DIRTY, block processes which may\n\t * try to dirty the lockres before MIGRATING is set */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->state & DLM_LOCK_RES_BLOCK_DIRTY);\n\tres->state |= DLM_LOCK_RES_BLOCK_DIRTY;\n\tspin_unlock(&res->spinlock);\n\t/* now wait on any pending asts and the DIRTY state */\n\twait_event(dlm->ast_wq, !dlm_lockres_is_dirty(dlm, res));\n\tdlm_lockres_release_ast(dlm, res);\n\n\tmlog(0, \"about to wait on migration_wq, dirty=%s\\n\",\n\t       res->state & DLM_LOCK_RES_DIRTY ? \"yes\" : \"no\");\n\t/* if the extra ref we just put was the final one, this\n\t * will pass thru immediately.  otherwise, we need to wait\n\t * for the last ast to finish. */\nagain:\n\tret = wait_event_interruptible_timeout(dlm->migration_wq,\n\t\t   dlm_migration_can_proceed(dlm, res, target),\n\t\t   msecs_to_jiffies(1000));\n\tif (ret < 0) {\n\t\tmlog(0, \"woken again: migrating? %s, dead? %s\\n\",\n\t\t       res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\",\n\t\t       test_bit(target, dlm->domain_map) ? \"no\":\"yes\");\n\t} else {\n\t\tmlog(0, \"all is well: migrating? %s, dead? %s\\n\",\n\t\t       res->state & DLM_LOCK_RES_MIGRATING ? \"yes\":\"no\",\n\t\t       test_bit(target, dlm->domain_map) ? \"no\":\"yes\");\n\t}\n\tif (!dlm_migration_can_proceed(dlm, res, target)) {\n\t\tmlog(0, \"trying again...\\n\");\n\t\tgoto again;\n\t}\n\n\tret = 0;\n\t/* did the target go down or die? */\n\tspin_lock(&dlm->spinlock);\n\tif (!test_bit(target, dlm->domain_map)) {\n\t\tmlog(ML_ERROR, \"aha. migration target %u just went down\\n\",\n\t\t     target);\n\t\tret = -EHOSTDOWN;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\t/*\n\t * if target is down, we need to clear DLM_LOCK_RES_BLOCK_DIRTY for\n\t * another try; otherwise, we are sure the MIGRATING state is there,\n\t * drop the unneded state which blocked threads trying to DIRTY\n\t */\n\tspin_lock(&res->spinlock);\n\tBUG_ON(!(res->state & DLM_LOCK_RES_BLOCK_DIRTY));\n\tres->state &= ~DLM_LOCK_RES_BLOCK_DIRTY;\n\tif (!ret)\n\t\tBUG_ON(!(res->state & DLM_LOCK_RES_MIGRATING));\n\tspin_unlock(&res->spinlock);\n\n\t/*\n\t * at this point:\n\t *\n\t *   o the DLM_LOCK_RES_MIGRATING flag is set if target not down\n\t *   o there are no pending asts on this lockres\n\t *   o all processes trying to reserve an ast on this\n\t *     lockres must wait for the MIGRATING flag to clear\n\t */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"another process is already migrating it\\n\""
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_add_migration_mle",
          "args": [
            "dlm",
            "res",
            "mle",
            "&oldmle",
            "name",
            "namelen",
            "target",
            "dlm->node_num"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_migration_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3099-3169",
          "snippet": "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master)\n{\n\tint found;\n\tint ret = 0;\n\n\t*oldmle = NULL;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\t/* caller is responsible for any ref taken here on oldmle */\n\tfound = dlm_find_mle(dlm, oldmle, (char *)name, namelen);\n\tif (found) {\n\t\tstruct dlm_master_list_entry *tmp = *oldmle;\n\t\tspin_lock(&tmp->spinlock);\n\t\tif (tmp->type == DLM_MLE_MIGRATION) {\n\t\t\tif (master == dlm->node_num) {\n\t\t\t\t/* ah another process raced me to it */\n\t\t\t\tmlog(0, \"tried to migrate %.*s, but some \"\n\t\t\t\t     \"process beat me to it\\n\",\n\t\t\t\t     namelen, name);\n\t\t\t\tret = -EEXIST;\n\t\t\t} else {\n\t\t\t\t/* bad.  2 NODES are trying to migrate! */\n\t\t\t\tmlog(ML_ERROR, \"migration error  mle: \"\n\t\t\t\t     \"master=%u new_master=%u // request: \"\n\t\t\t\t     \"master=%u new_master=%u // \"\n\t\t\t\t     \"lockres=%.*s\\n\",\n\t\t\t\t     tmp->master, tmp->new_master,\n\t\t\t\t     master, new_master,\n\t\t\t\t     namelen, name);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is essentially what assert_master does */\n\t\t\ttmp->master = master;\n\t\t\tatomic_set(&tmp->woken, 1);\n\t\t\twake_up(&tmp->wq);\n\t\t\t/* remove it so that only one mle will be found */\n\t\t\t__dlm_unlink_mle(dlm, tmp);\n\t\t\t__dlm_mle_detach_hb_events(dlm, tmp);\n\t\t\tif (tmp->type == DLM_MLE_MASTER) {\n\t\t\t\tret = DLM_MIGRATE_RESPONSE_MASTERY_REF;\n\t\t\t\tmlog(0, \"%s:%.*s: master=%u, newmaster=%u, \"\n\t\t\t\t\t\t\"telling master to get ref \"\n\t\t\t\t\t\t\"for cleared out mle during \"\n\t\t\t\t\t\t\"migration\\n\", dlm->name,\n\t\t\t\t\t\tnamelen, name, master,\n\t\t\t\t\t\tnew_master);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&tmp->spinlock);\n\t}\n\n\t/* now add a migration mle to the tail of the list */\n\tdlm_init_mle(mle, DLM_MLE_MIGRATION, dlm, res, name, namelen);\n\tmle->new_master = new_master;\n\t/* the new master will be sending an assert master for this.\n\t * at that point we will get the refmap reference */\n\tmle->master = master;\n\t/* do this for consistency with other mle types */\n\tset_bit(new_master, mle->maybe_map);\n\t__dlm_insert_mle(dlm, mle);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master)\n{\n\tint found;\n\tint ret = 0;\n\n\t*oldmle = NULL;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\t/* caller is responsible for any ref taken here on oldmle */\n\tfound = dlm_find_mle(dlm, oldmle, (char *)name, namelen);\n\tif (found) {\n\t\tstruct dlm_master_list_entry *tmp = *oldmle;\n\t\tspin_lock(&tmp->spinlock);\n\t\tif (tmp->type == DLM_MLE_MIGRATION) {\n\t\t\tif (master == dlm->node_num) {\n\t\t\t\t/* ah another process raced me to it */\n\t\t\t\tmlog(0, \"tried to migrate %.*s, but some \"\n\t\t\t\t     \"process beat me to it\\n\",\n\t\t\t\t     namelen, name);\n\t\t\t\tret = -EEXIST;\n\t\t\t} else {\n\t\t\t\t/* bad.  2 NODES are trying to migrate! */\n\t\t\t\tmlog(ML_ERROR, \"migration error  mle: \"\n\t\t\t\t     \"master=%u new_master=%u // request: \"\n\t\t\t\t     \"master=%u new_master=%u // \"\n\t\t\t\t     \"lockres=%.*s\\n\",\n\t\t\t\t     tmp->master, tmp->new_master,\n\t\t\t\t     master, new_master,\n\t\t\t\t     namelen, name);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is essentially what assert_master does */\n\t\t\ttmp->master = master;\n\t\t\tatomic_set(&tmp->woken, 1);\n\t\t\twake_up(&tmp->wq);\n\t\t\t/* remove it so that only one mle will be found */\n\t\t\t__dlm_unlink_mle(dlm, tmp);\n\t\t\t__dlm_mle_detach_hb_events(dlm, tmp);\n\t\t\tif (tmp->type == DLM_MLE_MASTER) {\n\t\t\t\tret = DLM_MIGRATE_RESPONSE_MASTERY_REF;\n\t\t\t\tmlog(0, \"%s:%.*s: master=%u, newmaster=%u, \"\n\t\t\t\t\t\t\"telling master to get ref \"\n\t\t\t\t\t\t\"for cleared out mle during \"\n\t\t\t\t\t\t\"migration\\n\", dlm->name,\n\t\t\t\t\t\tnamelen, name, master,\n\t\t\t\t\t\tnew_master);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&tmp->spinlock);\n\t}\n\n\t/* now add a migration mle to the tail of the list */\n\tdlm_init_mle(mle, DLM_MLE_MIGRATION, dlm, res, name, namelen);\n\tmle->new_master = new_master;\n\t/* the new master will be sending an assert master for this.\n\t * at that point we will get the refmap reference */\n\tmle->master = master;\n\t/* do this for consistency with other mle types */\n\tset_bit(new_master, mle->maybe_map);\n\t__dlm_insert_mle(dlm, mle);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "dlm_mle_cache",
            "GFP_NOFS"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Migrating %.*s to node %u\\n\"",
            "dlm->name",
            "namelen",
            "name",
            "target"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "target == O2NM_MAX_NODES"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_mle_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_mark_lockres_migrating(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t       u8 target);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_migrate_lockres(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 target)\n{\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_master_list_entry *oldmle = NULL;\n \tstruct dlm_migratable_lockres *mres = NULL;\n\tint ret = 0;\n\tconst char *name;\n\tunsigned int namelen;\n\tint mle_added = 0;\n\tint wake = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tBUG_ON(target == O2NM_MAX_NODES);\n\n\tname = res->lockname.name;\n\tnamelen = res->lockname.len;\n\n\tmlog(0, \"%s: Migrating %.*s to node %u\\n\", dlm->name, namelen, name,\n\t     target);\n\n\t/* preallocate up front. if this fails, abort */\n\tret = -ENOMEM;\n\tmres = (struct dlm_migratable_lockres *) __get_free_page(GFP_NOFS);\n\tif (!mres) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tmle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\tif (!mle) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\tret = 0;\n\n\t/*\n\t * clear any existing master requests and\n\t * add the migration mle to the list\n\t */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tret = dlm_add_migration_mle(dlm, res, mle, &oldmle, name,\n\t\t\t\t    namelen, target, dlm->node_num);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (ret == -EEXIST) {\n\t\tmlog(0, \"another process is already migrating it\\n\");\n\t\tgoto fail;\n\t}\n\tmle_added = 1;\n\n\t/*\n\t * set the MIGRATING flag and flush asts\n\t * if we fail after this we need to re-dirty the lockres\n\t */\n\tif (dlm_mark_lockres_migrating(dlm, res, target) < 0) {\n\t\tmlog(ML_ERROR, \"tried to migrate %.*s to %u, but \"\n\t\t     \"the target went down.\\n\", res->lockname.len,\n\t\t     res->lockname.name, target);\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\twake = 1;\n\t\tspin_unlock(&res->spinlock);\n\t\tret = -EINVAL;\n\t}\n\nfail:\n\tif (oldmle) {\n\t\t/* master is known, detach if not already detached */\n\t\tdlm_mle_detach_hb_events(dlm, oldmle);\n\t\tdlm_put_mle(oldmle);\n\t}\n\n\tif (ret < 0) {\n\t\tif (mle_added) {\n\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\tdlm_put_mle(mle);\n\t\t} else if (mle) {\n\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tmle = NULL;\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * at this point, we have a migration target, an mle\n\t * in the master list, and the MIGRATING flag set on\n\t * the lockres\n\t */\n\n\t/* now that remote nodes are spinning on the MIGRATING flag,\n\t * ensure that all assert_master work is flushed. */\n\tflush_workqueue(dlm->dlm_worker);\n\n\t/* get an extra reference on the mle.\n\t * otherwise the assert_master from the new\n\t * master will destroy this.\n\t * also, make sure that all callers of dlm_get_mle\n\t * take both dlm->spinlock and dlm->master_lock */\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tdlm_get_mle_inuse(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* notify new node and send all lock state */\n\t/* call send_one_lockres with migration flag.\n\t * this serves as notice to the target node that a\n\t * migration is starting. */\n\tret = dlm_send_one_lockres(dlm, res, mres, target,\n\t\t\t\t   DLM_MRES_MIGRATION);\n\n\tif (ret < 0) {\n\t\tmlog(0, \"migration to node %u failed with %d\\n\",\n\t\t     target, ret);\n\t\t/* migration failed, detach and clean up mle */\n\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\tdlm_put_mle(mle);\n\t\tdlm_put_mle_inuse(mle);\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\twake = 1;\n\t\tspin_unlock(&res->spinlock);\n\t\tif (dlm_is_host_down(ret))\n\t\t\tdlm_wait_for_node_death(dlm, target,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\tgoto leave;\n\t}\n\n\t/* at this point, the target sends a message to all nodes,\n\t * (using dlm_do_migrate_request).  this node is skipped since\n\t * we had to put an mle in the list to begin the process.  this\n\t * node now waits for target to do an assert master.  this node\n\t * will be the last one notified, ensuring that the migration\n\t * is complete everywhere.  if the target dies while this is\n\t * going on, some nodes could potentially see the target as the\n\t * master, so it is important that my recovery finds the migration\n\t * mle and sets the master to UNKNOWN. */\n\n\n\t/* wait for new node to assert master */\n\twhile (1) {\n\t\tret = wait_event_interruptible_timeout(mle->wq,\n\t\t\t\t\t(atomic_read(&mle->woken) == 1),\n\t\t\t\t\tmsecs_to_jiffies(5000));\n\n\t\tif (ret >= 0) {\n\t\t       \tif (atomic_read(&mle->woken) == 1 ||\n\t\t\t    res->owner == target)\n\t\t\t\tbreak;\n\n\t\t\tmlog(0, \"%s:%.*s: timed out during migration\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\t\t/* avoid hang during shutdown when migrating lockres\n\t\t\t * to a node which also goes down */\n\t\t\tif (dlm_is_node_dead(dlm, target)) {\n\t\t\t\tmlog(0, \"%s:%.*s: expected migration \"\n\t\t\t\t     \"target %u is no longer up, restarting\\n\",\n\t\t\t\t     dlm->name, res->lockname.len,\n\t\t\t\t     res->lockname.name, target);\n\t\t\t\tret = -EINVAL;\n\t\t\t\t/* migration failed, detach and clean up mle */\n\t\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\t\tdlm_put_mle(mle);\n\t\t\t\tdlm_put_mle_inuse(mle);\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\t\t\twake = 1;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t} else\n\t\t\tmlog(0, \"%s:%.*s: caught signal during migration\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n\n\t/* all done, set the owner, clear the flag */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, target);\n\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\tdlm_remove_nonlocal_locks(dlm, res);\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\t/* master is known, detach if not already detached */\n\tdlm_mle_detach_hb_events(dlm, mle);\n\tdlm_put_mle_inuse(mle);\n\tret = 0;\n\n\tdlm_lockres_calc_usage(dlm, res);\n\nleave:\n\t/* re-dirty the lockres if we failed */\n\tif (ret < 0)\n\t\tdlm_kick_thread(dlm, res);\n\n\t/* wake up waiters if the MIGRATING flag got set\n\t * but migration failed */\n\tif (wake)\n\t\twake_up(&res->wq);\n\n\tif (mres)\n\t\tfree_page((unsigned long)mres);\n\n\tdlm_put(dlm);\n\n\tmlog(0, \"%s: Migrating %.*s to %u, returns %d\\n\", dlm->name, namelen,\n\t     name, target, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_is_lockres_migrateable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2402-2452",
    "snippet": "static int dlm_is_lockres_migrateable(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res)\n{\n\tenum dlm_lockres_list idx;\n\tint nonlocal = 0, node_ref;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tu64 cookie;\n\n\tassert_spin_locked(&res->spinlock);\n\n\t/* delay migration when the lockres is in MIGRATING state */\n\tif (res->state & DLM_LOCK_RES_MIGRATING)\n\t\treturn 0;\n\n\t/* delay migration when the lockres is in RECOCERING state */\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\tif (res->owner != dlm->node_num)\n\t\treturn 0;\n\n        for (idx = DLM_GRANTED_LIST; idx <= DLM_BLOCKED_LIST; idx++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, idx);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\t\tnonlocal++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcookie = be64_to_cpu(lock->ml.cookie);\n\t\t\tmlog(0, \"%s: Not migrateable res %.*s, lock %u:%llu on \"\n\t\t\t     \"%s list\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     dlm_get_lock_cookie_node(cookie),\n\t\t\t     dlm_get_lock_cookie_seq(cookie),\n\t\t\t     dlm_list_in_text(idx));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!nonlocal) {\n\t\tnode_ref = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\t\tif (node_ref >= O2NM_MAX_NODES)\n\t\t\treturn 0;\n\t}\n\n\tmlog(0, \"%s: res %.*s, Migrateable\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
      "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Migrateable\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "res->refmap",
            "O2NM_MAX_NODES",
            "0"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: Not migrateable res %.*s, lock %u:%llu on \"\n\t\t\t     \"%s list\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(cookie)",
            "dlm_get_lock_cookie_seq(cookie)",
            "dlm_list_in_text(idx)"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_list_in_text",
          "args": [
            "idx"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_list_in_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "405-415",
          "snippet": "static inline char *dlm_list_in_text(enum dlm_lockres_list idx)\n{\n\tif (idx == DLM_GRANTED_LIST)\n\t\treturn \"granted\";\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\treturn \"converting\";\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\treturn \"blocked\";\n\telse\n\t\treturn \"unknown\";\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline char *dlm_list_in_text(enum dlm_lockres_list idx)\n{\n\tif (idx == DLM_GRANTED_LIST)\n\t\treturn \"granted\";\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\treturn \"converting\";\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\treturn \"blocked\";\n\telse\n\t\treturn \"unknown\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "cookie"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "cookie"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "queue",
            "list"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_list_idx_to_ptr",
          "args": [
            "res",
            "idx"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_list_idx_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "417-430",
          "snippet": "static inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_is_lockres_migrateable(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res)\n{\n\tenum dlm_lockres_list idx;\n\tint nonlocal = 0, node_ref;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tu64 cookie;\n\n\tassert_spin_locked(&res->spinlock);\n\n\t/* delay migration when the lockres is in MIGRATING state */\n\tif (res->state & DLM_LOCK_RES_MIGRATING)\n\t\treturn 0;\n\n\t/* delay migration when the lockres is in RECOCERING state */\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\treturn 0;\n\n\tif (res->owner != dlm->node_num)\n\t\treturn 0;\n\n        for (idx = DLM_GRANTED_LIST; idx <= DLM_BLOCKED_LIST; idx++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, idx);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node != dlm->node_num) {\n\t\t\t\tnonlocal++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcookie = be64_to_cpu(lock->ml.cookie);\n\t\t\tmlog(0, \"%s: Not migrateable res %.*s, lock %u:%llu on \"\n\t\t\t     \"%s list\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name,\n\t\t\t     dlm_get_lock_cookie_node(cookie),\n\t\t\t     dlm_get_lock_cookie_seq(cookie),\n\t\t\t     dlm_list_in_text(idx));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!nonlocal) {\n\t\tnode_ref = find_next_bit(res->refmap, O2NM_MAX_NODES, 0);\n\t\tif (node_ref >= O2NM_MAX_NODES)\n\t\t\treturn 0;\n\t}\n\n\tmlog(0, \"%s: res %.*s, Migrateable\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "dlm_deref_lockres_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2361-2393",
    "snippet": "static void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_ctxt *dlm;\n\tstruct dlm_lock_resource *res;\n\tu8 node;\n\tu8 cleared = 0;\n\n\tdlm = item->dlm;\n\tres = item->u.dl.deref_res;\n\tnode = item->u.dl.deref_node;\n\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->state & DLM_LOCK_RES_DROPPING_REF);\n\tif (test_bit(node, res->refmap)) {\n\t\t__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_SETREF_INPROG);\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, node);\n\t\tcleared = 1;\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (cleared) {\n\t\tmlog(0, \"%s:%.*s node %u ref dropped in dispatch\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, node);\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t} else {\n\t\tmlog(ML_ERROR, \"%s:%.*s: node %u trying to drop ref \"\n\t\t     \"but it is already dropped!\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, node);\n\t\tdlm_print_one_lock_resource(res);\n\t}\n\n\tdlm_lockres_put(res);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_assert_master_worker(struct dlm_work_item *item, void *data);",
      "static void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s:%.*s: node %u trying to drop ref \"\n\t\t     \"but it is already dropped!\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "node"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s node %u ref dropped in dispatch\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "node"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_clear_refmap_bit",
          "args": [
            "dlm",
            "res",
            "node"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_clear_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "644-653",
          "snippet": "void dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres_flags",
          "args": [
            "res",
            "DLM_LOCK_RES_SETREF_INPROG"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "61-78",
          "snippet": "void __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "node",
            "res->refmap"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->state & DLM_LOCK_RES_DROPPING_REF"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_assert_master_worker(struct dlm_work_item *item, void *data);\nstatic void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_ctxt *dlm;\n\tstruct dlm_lock_resource *res;\n\tu8 node;\n\tu8 cleared = 0;\n\n\tdlm = item->dlm;\n\tres = item->u.dl.deref_res;\n\tnode = item->u.dl.deref_node;\n\n\tspin_lock(&res->spinlock);\n\tBUG_ON(res->state & DLM_LOCK_RES_DROPPING_REF);\n\tif (test_bit(node, res->refmap)) {\n\t\t__dlm_wait_on_lockres_flags(res, DLM_LOCK_RES_SETREF_INPROG);\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, node);\n\t\tcleared = 1;\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (cleared) {\n\t\tmlog(0, \"%s:%.*s node %u ref dropped in dispatch\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, node);\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t} else {\n\t\tmlog(ML_ERROR, \"%s:%.*s: node %u trying to drop ref \"\n\t\t     \"but it is already dropped!\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, node);\n\t\tdlm_print_one_lock_resource(res);\n\t}\n\n\tdlm_lockres_put(res);\n}"
  },
  {
    "function_name": "dlm_deref_lockres_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2267-2359",
    "snippet": "int dlm_deref_lockres_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_deref_lockres *deref = (struct dlm_deref_lockres *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tchar *name;\n\tunsigned int namelen;\n\tint ret = -EINVAL;\n\tu8 node;\n\tunsigned int hash;\n\tstruct dlm_work_item *item;\n\tint cleared = 0;\n\tint dispatch = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tname = deref->name;\n\tnamelen = deref->namelen;\n\tnode = deref->node_idx;\n\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tmlog(ML_ERROR, \"Invalid name length!\");\n\t\tgoto done;\n\t}\n\tif (deref->node_idx >= O2NM_MAX_NODES) {\n\t\tmlog(ML_ERROR, \"Invalid node number: %u\\n\", node);\n\t\tgoto done;\n\t}\n\n\thash = dlm_lockid_hash(name, namelen);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres_full(dlm, name, namelen, hash);\n\tif (!res) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tmlog(ML_ERROR, \"%s:%.*s: bad lockres name\\n\",\n\t\t     dlm->name, namelen, name);\n\t\tgoto done;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_SETREF_INPROG)\n\t\tdispatch = 1;\n\telse {\n\t\tBUG_ON(res->state & DLM_LOCK_RES_DROPPING_REF);\n\t\tif (test_bit(node, res->refmap)) {\n\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, node);\n\t\t\tcleared = 1;\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (!dispatch) {\n\t\tif (cleared)\n\t\t\tdlm_lockres_calc_usage(dlm, res);\n\t\telse {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: node %u trying to drop ref \"\n\t\t     \t\"but it is already dropped!\\n\", dlm->name,\n\t\t     \tres->lockname.len, res->lockname.name, node);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t}\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (!item) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto done;\n\t}\n\n\tdlm_init_work_item(dlm, item, dlm_deref_lockres_worker, NULL);\n\titem->u.dl.deref_res = res;\n\titem->u.dl.deref_node = node;\n\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\treturn 0;\n\ndone:\n\tif (res)\n\t\tdlm_lockres_put(res);\n\tdlm_put(dlm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_assert_master_worker(struct dlm_work_item *item, void *data);",
      "static void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);",
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "dlm->dlm_worker",
            "&dlm->dispatched_work"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->list",
            "&dlm->work_list"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_work_item",
          "args": [
            "dlm",
            "item",
            "dlm_deref_lockres_worker",
            "NULL"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_work_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "254-263",
          "snippet": "static inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*item)",
            "GFP_NOFS"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s:%.*s: node %u trying to drop ref \"\n\t\t     \t\"but it is already dropped!\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "node"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "150-160",
          "snippet": "void dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_lock_resource *res)\n{\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&res->spinlock);\n\n\t__dlm_lockres_calc_usage(dlm, res);\n\n\tspin_unlock(&res->spinlock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_clear_refmap_bit",
          "args": [
            "dlm",
            "res",
            "node"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_clear_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "644-653",
          "snippet": "void dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "node",
            "res->refmap"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->state & DLM_LOCK_RES_DROPPING_REF"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s:%.*s: bad lockres name\\n\"",
            "dlm->name",
            "namelen",
            "name"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres_full",
          "args": [
            "dlm",
            "name",
            "namelen",
            "hash"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "188-213",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "name",
            "namelen"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Invalid node number: %u\\n\"",
            "node"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Invalid name length!\""
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_assert_master_worker(struct dlm_work_item *item, void *data);\nstatic void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_deref_lockres_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_deref_lockres *deref = (struct dlm_deref_lockres *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tchar *name;\n\tunsigned int namelen;\n\tint ret = -EINVAL;\n\tu8 node;\n\tunsigned int hash;\n\tstruct dlm_work_item *item;\n\tint cleared = 0;\n\tint dispatch = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tname = deref->name;\n\tnamelen = deref->namelen;\n\tnode = deref->node_idx;\n\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tmlog(ML_ERROR, \"Invalid name length!\");\n\t\tgoto done;\n\t}\n\tif (deref->node_idx >= O2NM_MAX_NODES) {\n\t\tmlog(ML_ERROR, \"Invalid node number: %u\\n\", node);\n\t\tgoto done;\n\t}\n\n\thash = dlm_lockid_hash(name, namelen);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres_full(dlm, name, namelen, hash);\n\tif (!res) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tmlog(ML_ERROR, \"%s:%.*s: bad lockres name\\n\",\n\t\t     dlm->name, namelen, name);\n\t\tgoto done;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_SETREF_INPROG)\n\t\tdispatch = 1;\n\telse {\n\t\tBUG_ON(res->state & DLM_LOCK_RES_DROPPING_REF);\n\t\tif (test_bit(node, res->refmap)) {\n\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, node);\n\t\t\tcleared = 1;\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (!dispatch) {\n\t\tif (cleared)\n\t\t\tdlm_lockres_calc_usage(dlm, res);\n\t\telse {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: node %u trying to drop ref \"\n\t\t     \t\"but it is already dropped!\\n\", dlm->name,\n\t\t     \tres->lockname.len, res->lockname.name, node);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t}\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (!item) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto done;\n\t}\n\n\tdlm_init_work_item(dlm, item, dlm_deref_lockres_worker, NULL);\n\titem->u.dl.deref_res = res;\n\titem->u.dl.deref_node = node;\n\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\treturn 0;\n\ndone:\n\tif (res)\n\t\tdlm_lockres_put(res);\n\tdlm_put(dlm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_drop_lockres_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2236-2265",
    "snippet": "int dlm_drop_lockres_ref(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct dlm_deref_lockres deref;\n\tint ret = 0, r;\n\tconst char *lockname;\n\tunsigned int namelen;\n\n\tlockname = res->lockname.name;\n\tnamelen = res->lockname.len;\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tmemset(&deref, 0, sizeof(deref));\n\tderef.node_idx = dlm->node_num;\n\tderef.namelen = namelen;\n\tmemcpy(deref.name, lockname, namelen);\n\n\tret = o2net_send_message(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t &deref, sizeof(deref), res->owner, &r);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send DEREF to node %u\\n\",\n\t\t     dlm->name, namelen, lockname, ret, res->owner);\n\telse if (r < 0) {\n\t\t/* BAD.  other node says I did not have a ref. */\n\t\tmlog(ML_ERROR, \"%s: res %.*s, DEREF to node %u got %d\\n\",\n\t\t     dlm->name, namelen, lockname, res->owner, r);\n\t\tdlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, DEREF to node %u got %d\\n\"",
            "dlm->name",
            "namelen",
            "lockname",
            "res->owner",
            "r"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, error %d send DEREF to node %u\\n\"",
            "dlm->name",
            "namelen",
            "lockname",
            "ret",
            "res->owner"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_DEREF_LOCKRES_MSG",
            "dlm->key",
            "&deref",
            "sizeof(deref)",
            "res->owner",
            "&r"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "deref.name",
            "lockname",
            "namelen"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&deref",
            "0",
            "sizeof(deref)"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "namelen > O2NM_MAX_NAME_LEN"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_drop_lockres_ref(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct dlm_deref_lockres deref;\n\tint ret = 0, r;\n\tconst char *lockname;\n\tunsigned int namelen;\n\n\tlockname = res->lockname.name;\n\tnamelen = res->lockname.len;\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tmemset(&deref, 0, sizeof(deref));\n\tderef.node_idx = dlm->node_num;\n\tderef.namelen = namelen;\n\tmemcpy(deref.name, lockname, namelen);\n\n\tret = o2net_send_message(DLM_DEREF_LOCKRES_MSG, dlm->key,\n\t\t\t\t &deref, sizeof(deref), res->owner, &r);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send DEREF to node %u\\n\",\n\t\t     dlm->name, namelen, lockname, ret, res->owner);\n\telse if (r < 0) {\n\t\t/* BAD.  other node says I did not have a ref. */\n\t\tmlog(ML_ERROR, \"%s: res %.*s, DEREF to node %u got %d\\n\",\n\t\t     dlm->name, namelen, lockname, res->owner, r);\n\t\tdlm_print_one_lock_resource(res);\n\t\tBUG();\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_pre_master_reco_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2186-2230",
    "snippet": "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\tu8 master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t/* do not send to self */\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, &master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t/* host is down, so answer for that node would be\n\t\t\t * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */\n\t\t\tret = 0;\n\t\t}\n\n\t\tif (master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t/* check to see if this master is in the recovery map */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (test_bit(master, dlm->recovery_map)) {\n\t\t\t\tmlog(ML_NOTICE, \"%s: node %u has not seen \"\n\t\t\t\t     \"node %u go down yet, and thinks the \"\n\t\t\t\t     \"dead node is mastering the recovery \"\n\t\t\t\t     \"lock.  must wait.\\n\", dlm->name,\n\t\t\t\t     nodenum, master);\n\t\t\t\tret = -EAGAIN;\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"%s: reco lock master is %u\\n\", dlm->name,\n\t\t\t     master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: reco lock master is %u\\n\"",
            "dlm->name",
            "master"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s: node %u has not seen \"\n\t\t\t\t     \"node %u go down yet, and thinks the \"\n\t\t\t\t     \"dead node is mastering the recovery \"\n\t\t\t\t     \"lock.  must wait.\\n\"",
            "dlm->name",
            "nodenum",
            "master"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "master",
            "dlm->recovery_map"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_do_master_requery",
          "args": [
            "dlm",
            "res",
            "nodenum",
            "&master"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_master_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1650-1682",
          "snippet": "int dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t  u8 nodenum, u8 *real_master)\n{\n\tint ret = -EINVAL;\n\tstruct dlm_master_requery req;\n\tint status = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.node_idx = dlm->node_num;\n\treq.namelen = res->lockname.len;\n\tmemcpy(req.name, res->lockname.name, res->lockname.len);\n\nresend:\n\tret = o2net_send_message(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t &req, sizeof(req), nodenum, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t     \"0x%x) to node %u\\n\", ret, DLM_MASTER_REQUERY_MSG,\n\t\t     dlm->key, nodenum);\n\telse if (status == -ENOMEM) {\n\t\tmlog_errno(status);\n\t\tmsleep(50);\n\t\tgoto resend;\n\t} else {\n\t\tBUG_ON(status < 0);\n\t\tBUG_ON(status > DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t*real_master = (u8) (status & 0xff);\n\t\tmlog(0, \"node %u responded to master requery with %u\\n\",\n\t\t\t  nodenum, *real_master);\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);\n\nint dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t  u8 nodenum, u8 *real_master)\n{\n\tint ret = -EINVAL;\n\tstruct dlm_master_requery req;\n\tint status = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.node_idx = dlm->node_num;\n\treq.namelen = res->lockname.len;\n\tmemcpy(req.name, res->lockname.name, res->lockname.len);\n\nresend:\n\tret = o2net_send_message(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t &req, sizeof(req), nodenum, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t     \"0x%x) to node %u\\n\", ret, DLM_MASTER_REQUERY_MSG,\n\t\t     dlm->key, nodenum);\n\telse if (status == -ENOMEM) {\n\t\tmlog_errno(status);\n\t\tmsleep(50);\n\t\tgoto resend;\n\t} else {\n\t\tBUG_ON(status < 0);\n\t\tBUG_ON(status > DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t*real_master = (u8) (status & 0xff);\n\t\tmlog(0, \"node %u responded to master requery with %u\\n\",\n\t\t\t  nodenum, *real_master);\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_next",
          "args": [
            "&iter"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1119-1129",
          "snippet": "static inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_init",
          "args": [
            "dlm->domain_map",
            "&iter"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1112-1117",
          "snippet": "static inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\tu8 master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t/* do not send to self */\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, &master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t/* host is down, so answer for that node would be\n\t\t\t * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */\n\t\t\tret = 0;\n\t\t}\n\n\t\tif (master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t/* check to see if this master is in the recovery map */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (test_bit(master, dlm->recovery_map)) {\n\t\t\t\tmlog(ML_NOTICE, \"%s: node %u has not seen \"\n\t\t\t\t     \"node %u go down yet, and thinks the \"\n\t\t\t\t     \"dead node is mastering the recovery \"\n\t\t\t\t     \"lock.  must wait.\\n\", dlm->name,\n\t\t\t\t     nodenum, master);\n\t\t\t\tret = -EAGAIN;\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"%s: reco lock master is %u\\n\", dlm->name,\n\t\t\t     master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_assert_master_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2100-2174",
    "snippet": "static void dlm_assert_master_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tint ret = 0;\n\tstruct dlm_lock_resource *res;\n\tunsigned long nodemap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint ignore_higher;\n\tint bit;\n\tu8 request_from;\n\tu32 flags;\n\n\tdlm = item->dlm;\n\tres = item->u.am.lockres;\n\tignore_higher = item->u.am.ignore_higher;\n\trequest_from = item->u.am.request_from;\n\tflags = item->u.am.flags;\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(nodemap, dlm->domain_map, sizeof(nodemap));\n\tspin_unlock(&dlm->spinlock);\n\n\tclear_bit(dlm->node_num, nodemap);\n\tif (ignore_higher) {\n\t\t/* if is this just to clear up mles for nodes below\n\t\t * this node, do not send the message to the original\n\t\t * caller or any node number higher than this */\n\t\tclear_bit(request_from, nodemap);\n\t\tbit = dlm->node_num;\n\t\twhile (1) {\n\t\t\tbit = find_next_bit(nodemap, O2NM_MAX_NODES,\n\t\t\t\t\t    bit+1);\n\t\t       \tif (bit >= O2NM_MAX_NODES)\n\t\t\t\tbreak;\n\t\t\tclear_bit(bit, nodemap);\n\t\t}\n\t}\n\n\t/*\n\t * If we're migrating this lock to someone else, we are no\n\t * longer allowed to assert out own mastery.  OTOH, we need to\n\t * prevent migration from starting while we're still asserting\n\t * our dominance.  The reserved ast delays migration.\n\t */\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tmlog(0, \"Someone asked us to assert mastery, but we're \"\n\t\t     \"in the middle of migration.  Skipping assert, \"\n\t\t     \"the new master will handle that.\\n\");\n\t\tspin_unlock(&res->spinlock);\n\t\tgoto put;\n\t} else\n\t\t__dlm_lockres_reserve_ast(res);\n\tspin_unlock(&res->spinlock);\n\n\t/* this call now finishes out the nodemap\n\t * even if one or more nodes die */\n\tmlog(0, \"worker about to master %.*s here, this=%u\\n\",\n\t\t     res->lockname.len, res->lockname.name, dlm->node_num);\n\tret = dlm_do_assert_master(dlm, res, nodemap, flags);\n\tif (ret < 0) {\n\t\t/* no need to restart, we are done */\n\t\tif (!dlm_is_host_down(ret))\n\t\t\tmlog_errno(ret);\n\t}\n\n\t/* Ok, we've asserted ourselves.  Let's let migration start. */\n\tdlm_lockres_release_ast(dlm, res);\n\nput:\n\tdlm_lockres_drop_inflight_worker(dlm, res);\n\n\tdlm_lockres_put(res);\n\n\tmlog(0, \"finished with dlm_assert_master_worker\\n\");\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_assert_master_worker(struct dlm_work_item *item, void *data);",
      "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
      "static void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"finished with dlm_assert_master_worker\\n\""
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_drop_inflight_worker",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_drop_inflight_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "709-715",
          "snippet": "static void dlm_lockres_drop_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tspin_lock(&res->spinlock);\n\t__dlm_lockres_drop_inflight_worker(dlm, res);\n\tspin_unlock(&res->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_lockres_drop_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tspin_lock(&res->spinlock);\n\t__dlm_lockres_drop_inflight_worker(dlm, res);\n\tspin_unlock(&res->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_release_ast",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_release_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3419-3436",
          "snippet": "void dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_do_assert_master",
          "args": [
            "dlm",
            "res",
            "nodemap",
            "flags"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_assert_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1670-1768",
          "snippet": "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags)\n{\n\tstruct dlm_assert_master assert;\n\tint to, tmpret;\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\tint reassert;\n\tconst char *lockname = res->lockname.name;\n\tunsigned int namelen = res->lockname.len;\n\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tspin_lock(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\nagain:\n\treassert = 0;\n\n\t/* note that if this nodemap is empty, it returns 0 */\n\tdlm_node_iter_init(nodemap, &iter);\n\twhile ((to = dlm_node_iter_next(&iter)) >= 0) {\n\t\tint r = 0;\n\t\tstruct dlm_master_list_entry *mle = NULL;\n\n\t\tmlog(0, \"sending assert master to %d (%.*s)\\n\", to,\n\t\t     namelen, lockname);\n\t\tmemset(&assert, 0, sizeof(assert));\n\t\tassert.node_idx = dlm->node_num;\n\t\tassert.namelen = namelen;\n\t\tmemcpy(assert.name, lockname, namelen);\n\t\tassert.flags = cpu_to_be32(flags);\n\n\t\ttmpret = o2net_send_message(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\t    &assert, sizeof(assert), to, &r);\n\t\tif (tmpret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", tmpret,\n\t\t\t     DLM_ASSERT_MASTER_MSG, dlm->key, to);\n\t\t\tif (!dlm_is_host_down(tmpret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", tmpret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* a node died.  finish out the rest of the nodes. */\n\t\t\tmlog(0, \"link to %d went down!\\n\", to);\n\t\t\t/* any nonzero status return will do */\n\t\t\tret = tmpret;\n\t\t\tr = 0;\n\t\t} else if (r < 0) {\n\t\t\t/* ok, something horribly messed.  kill thyself. */\n\t\t\tmlog(ML_ERROR,\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\", namelen, lockname, to, r);\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tspin_lock(&dlm->master_lock);\n\t\t\tif (dlm_find_mle(dlm, &mle, (char *)lockname,\n\t\t\t\t\t namelen)) {\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t}\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT &&\n\t\t    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {\n\t\t\t\tmlog(ML_ERROR, \"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\",\n\t\t\t\t     namelen, lockname, to);\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT) {\n\t\t\tmlog(0, \"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\treassert = 1;\n\t\t}\n\t\tif (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {\n\t\t\tmlog(0, \"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, to);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (reassert)\n\t\tgoto again;\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags)\n{\n\tstruct dlm_assert_master assert;\n\tint to, tmpret;\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\tint reassert;\n\tconst char *lockname = res->lockname.name;\n\tunsigned int namelen = res->lockname.len;\n\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tspin_lock(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\nagain:\n\treassert = 0;\n\n\t/* note that if this nodemap is empty, it returns 0 */\n\tdlm_node_iter_init(nodemap, &iter);\n\twhile ((to = dlm_node_iter_next(&iter)) >= 0) {\n\t\tint r = 0;\n\t\tstruct dlm_master_list_entry *mle = NULL;\n\n\t\tmlog(0, \"sending assert master to %d (%.*s)\\n\", to,\n\t\t     namelen, lockname);\n\t\tmemset(&assert, 0, sizeof(assert));\n\t\tassert.node_idx = dlm->node_num;\n\t\tassert.namelen = namelen;\n\t\tmemcpy(assert.name, lockname, namelen);\n\t\tassert.flags = cpu_to_be32(flags);\n\n\t\ttmpret = o2net_send_message(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\t    &assert, sizeof(assert), to, &r);\n\t\tif (tmpret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", tmpret,\n\t\t\t     DLM_ASSERT_MASTER_MSG, dlm->key, to);\n\t\t\tif (!dlm_is_host_down(tmpret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", tmpret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* a node died.  finish out the rest of the nodes. */\n\t\t\tmlog(0, \"link to %d went down!\\n\", to);\n\t\t\t/* any nonzero status return will do */\n\t\t\tret = tmpret;\n\t\t\tr = 0;\n\t\t} else if (r < 0) {\n\t\t\t/* ok, something horribly messed.  kill thyself. */\n\t\t\tmlog(ML_ERROR,\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\", namelen, lockname, to, r);\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tspin_lock(&dlm->master_lock);\n\t\t\tif (dlm_find_mle(dlm, &mle, (char *)lockname,\n\t\t\t\t\t namelen)) {\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t}\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT &&\n\t\t    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {\n\t\t\t\tmlog(ML_ERROR, \"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\",\n\t\t\t\t     namelen, lockname, to);\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT) {\n\t\t\tmlog(0, \"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\treassert = 1;\n\t\t}\n\t\tif (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {\n\t\t\tmlog(0, \"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, to);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (reassert)\n\t\tgoto again;\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"worker about to master %.*s here, this=%u\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "dlm->node_num"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_reserve_ast",
          "args": [
            "res"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_reserve_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3395-3404",
          "snippet": "void __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "bit",
            "nodemap"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "nodemap",
            "O2NM_MAX_NODES",
            "bit+1"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nodemap",
            "dlm->domain_map",
            "sizeof(nodemap)"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "O2NM_MAX_NODES"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_assert_master_worker(struct dlm_work_item *item, void *data);\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_assert_master_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tint ret = 0;\n\tstruct dlm_lock_resource *res;\n\tunsigned long nodemap[BITS_TO_LONGS(O2NM_MAX_NODES)];\n\tint ignore_higher;\n\tint bit;\n\tu8 request_from;\n\tu32 flags;\n\n\tdlm = item->dlm;\n\tres = item->u.am.lockres;\n\tignore_higher = item->u.am.ignore_higher;\n\trequest_from = item->u.am.request_from;\n\tflags = item->u.am.flags;\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(nodemap, dlm->domain_map, sizeof(nodemap));\n\tspin_unlock(&dlm->spinlock);\n\n\tclear_bit(dlm->node_num, nodemap);\n\tif (ignore_higher) {\n\t\t/* if is this just to clear up mles for nodes below\n\t\t * this node, do not send the message to the original\n\t\t * caller or any node number higher than this */\n\t\tclear_bit(request_from, nodemap);\n\t\tbit = dlm->node_num;\n\t\twhile (1) {\n\t\t\tbit = find_next_bit(nodemap, O2NM_MAX_NODES,\n\t\t\t\t\t    bit+1);\n\t\t       \tif (bit >= O2NM_MAX_NODES)\n\t\t\t\tbreak;\n\t\t\tclear_bit(bit, nodemap);\n\t\t}\n\t}\n\n\t/*\n\t * If we're migrating this lock to someone else, we are no\n\t * longer allowed to assert out own mastery.  OTOH, we need to\n\t * prevent migration from starting while we're still asserting\n\t * our dominance.  The reserved ast delays migration.\n\t */\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tmlog(0, \"Someone asked us to assert mastery, but we're \"\n\t\t     \"in the middle of migration.  Skipping assert, \"\n\t\t     \"the new master will handle that.\\n\");\n\t\tspin_unlock(&res->spinlock);\n\t\tgoto put;\n\t} else\n\t\t__dlm_lockres_reserve_ast(res);\n\tspin_unlock(&res->spinlock);\n\n\t/* this call now finishes out the nodemap\n\t * even if one or more nodes die */\n\tmlog(0, \"worker about to master %.*s here, this=%u\\n\",\n\t\t     res->lockname.len, res->lockname.name, dlm->node_num);\n\tret = dlm_do_assert_master(dlm, res, nodemap, flags);\n\tif (ret < 0) {\n\t\t/* no need to restart, we are done */\n\t\tif (!dlm_is_host_down(ret))\n\t\t\tmlog_errno(ret);\n\t}\n\n\t/* Ok, we've asserted ourselves.  Let's let migration start. */\n\tdlm_lockres_release_ast(dlm, res);\n\nput:\n\tdlm_lockres_drop_inflight_worker(dlm, res);\n\n\tdlm_lockres_put(res);\n\n\tmlog(0, \"finished with dlm_assert_master_worker\\n\");\n}"
  },
  {
    "function_name": "dlm_dispatch_assert_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2069-2098",
    "snippet": "int dlm_dispatch_assert_master(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res,\n\t\t\t       int ignore_higher, u8 request_from, u32 flags)\n{\n\tstruct dlm_work_item *item;\n\titem = kzalloc(sizeof(*item), GFP_ATOMIC);\n\tif (!item)\n\t\treturn -ENOMEM;\n\n\n\t/* queue up work for dlm_assert_master_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tdlm_init_work_item(dlm, item, dlm_assert_master_worker, NULL);\n\titem->u.am.lockres = res; /* already have a ref */\n\t/* can optionally ignore node numbers higher than this node */\n\titem->u.am.ignore_higher = ignore_higher;\n\titem->u.am.request_from = request_from;\n\titem->u.am.flags = flags;\n\n\tif (ignore_higher)\n\t\tmlog(0, \"IGNORE HIGHER: %.*s\\n\", res->lockname.len,\n\t\t     res->lockname.name);\n\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "dlm->dlm_worker",
            "&dlm->dispatched_work"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->list",
            "&dlm->work_list"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"IGNORE HIGHER: %.*s\\n\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_work_item",
          "args": [
            "dlm",
            "item",
            "dlm_assert_master_worker",
            "NULL"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_work_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "254-263",
          "snippet": "static inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*item)",
            "GFP_ATOMIC"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_dispatch_assert_master(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res,\n\t\t\t       int ignore_higher, u8 request_from, u32 flags)\n{\n\tstruct dlm_work_item *item;\n\titem = kzalloc(sizeof(*item), GFP_ATOMIC);\n\tif (!item)\n\t\treturn -ENOMEM;\n\n\n\t/* queue up work for dlm_assert_master_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tdlm_init_work_item(dlm, item, dlm_assert_master_worker, NULL);\n\titem->u.am.lockres = res; /* already have a ref */\n\t/* can optionally ignore node numbers higher than this node */\n\titem->u.am.ignore_higher = ignore_higher;\n\titem->u.am.request_from = request_from;\n\titem->u.am.flags = flags;\n\n\tif (ignore_higher)\n\t\tmlog(0, \"IGNORE HIGHER: %.*s\\n\", res->lockname.len,\n\t\t     res->lockname.name);\n\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_assert_master_post_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "2055-2067",
    "snippet": "void dlm_assert_master_post_handler(int status, void *data, void *ret_data)\n{\n\tstruct dlm_lock_resource *res = (struct dlm_lock_resource *)ret_data;\n\n\tif (ret_data) {\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t\tdlm_lockres_put(res);\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_assert_master_worker(struct dlm_work_item *item, void *data);",
      "static void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_assert_master_worker(struct dlm_work_item *item, void *data);\nstatic void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_assert_master_post_handler(int status, void *data, void *ret_data)\n{\n\tstruct dlm_lock_resource *res = (struct dlm_lock_resource *)ret_data;\n\n\tif (ret_data) {\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t\tdlm_lockres_put(res);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "dlm_assert_master_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "1779-2053",
    "snippet": "int dlm_assert_master_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_assert_master *assert = (struct dlm_assert_master *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tchar *name;\n\tunsigned int namelen, hash;\n\tu32 flags;\n\tint master_request = 0, have_lockres_ref = 0;\n\tint ret = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tname = assert->name;\n\tnamelen = assert->namelen;\n\thash = dlm_lockid_hash(name, namelen);\n\tflags = be32_to_cpu(assert->flags);\n\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tmlog(ML_ERROR, \"Invalid name length!\");\n\t\tgoto done;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\n\tif (flags)\n\t\tmlog(0, \"assert_master with flags: %u\\n\", flags);\n\n\t/* find the MLE */\n\tspin_lock(&dlm->master_lock);\n\tif (!dlm_find_mle(dlm, &mle, name, namelen)) {\n\t\t/* not an error, could be master just re-asserting */\n\t\tmlog(0, \"just got an assert_master from %u, but no \"\n\t\t     \"MLE for it! (%.*s)\\n\", assert->node_idx,\n\t\t     namelen, name);\n\t} else {\n\t\tint bit = find_next_bit (mle->maybe_map, O2NM_MAX_NODES, 0);\n\t\tif (bit >= O2NM_MAX_NODES) {\n\t\t\t/* not necessarily an error, though less likely.\n\t\t\t * could be master just re-asserting. */\n\t\t\tmlog(0, \"no bits set in the maybe_map, but %u \"\n\t\t\t     \"is asserting! (%.*s)\\n\", assert->node_idx,\n\t\t\t     namelen, name);\n\t\t} else if (bit != assert->node_idx) {\n\t\t\tif (flags & DLM_ASSERT_MASTER_MLE_CLEANUP) {\n\t\t\t\tmlog(0, \"master %u was found, %u should \"\n\t\t\t\t     \"back off\\n\", assert->node_idx, bit);\n\t\t\t} else {\n\t\t\t\t/* with the fix for bug 569, a higher node\n\t\t\t\t * number winning the mastery will respond\n\t\t\t\t * YES to mastery requests, but this node\n\t\t\t\t * had no way of knowing.  let it pass. */\n\t\t\t\tmlog(0, \"%u is the lowest node, \"\n\t\t\t\t     \"%u is asserting. (%.*s)  %u must \"\n\t\t\t\t     \"have begun after %u won.\\n\", bit,\n\t\t\t\t     assert->node_idx, namelen, name, bit,\n\t\t\t\t     assert->node_idx);\n\t\t\t}\n\t\t}\n\t\tif (mle->type == DLM_MLE_MIGRATION) {\n\t\t\tif (flags & DLM_ASSERT_MASTER_MLE_CLEANUP) {\n\t\t\t\tmlog(0, \"%s:%.*s: got cleanup assert\"\n\t\t\t\t     \" from %u for migration\\n\",\n\t\t\t\t     dlm->name, namelen, name,\n\t\t\t\t     assert->node_idx);\n\t\t\t} else if (!(flags & DLM_ASSERT_MASTER_FINISH_MIGRATION)) {\n\t\t\t\tmlog(0, \"%s:%.*s: got unrelated assert\"\n\t\t\t\t     \" from %u for migration, ignoring\\n\",\n\t\t\t\t     dlm->name, namelen, name,\n\t\t\t\t     assert->node_idx);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n\n\t/* ok everything checks out with the MLE\n\t * now check to see if there is a lockres */\n\tres = __dlm_lookup_lockres(dlm, name, namelen, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_RECOVERING)  {\n\t\t\tmlog(ML_ERROR, \"%u asserting but %.*s is \"\n\t\t\t     \"RECOVERING!\\n\", assert->node_idx, namelen, name);\n\t\t\tgoto kill;\n\t\t}\n\t\tif (!mle) {\n\t\t\tif (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN &&\n\t\t\t    res->owner != assert->node_idx) {\n\t\t\t\tmlog(ML_ERROR, \"DIE! Mastery assert from %u, \"\n\t\t\t\t     \"but current owner is %u! (%.*s)\\n\",\n\t\t\t\t     assert->node_idx, res->owner, namelen,\n\t\t\t\t     name);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else if (mle->type != DLM_MLE_MIGRATION) {\n\t\t\tif (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t\t/* owner is just re-asserting */\n\t\t\t\tif (res->owner == assert->node_idx) {\n\t\t\t\t\tmlog(0, \"owner %u re-asserting on \"\n\t\t\t\t\t     \"lock %.*s\\n\", assert->node_idx,\n\t\t\t\t\t     namelen, name);\n\t\t\t\t\tgoto ok;\n\t\t\t\t}\n\t\t\t\tmlog(ML_ERROR, \"got assert_master from \"\n\t\t\t\t     \"node %u, but %u is the owner! \"\n\t\t\t\t     \"(%.*s)\\n\", assert->node_idx,\n\t\t\t\t     res->owner, namelen, name);\n\t\t\t\tgoto kill;\n\t\t\t}\n\t\t\tif (!(res->state & DLM_LOCK_RES_IN_PROGRESS)) {\n\t\t\t\tmlog(ML_ERROR, \"got assert from %u, but lock \"\n\t\t\t\t     \"with no owner should be \"\n\t\t\t\t     \"in-progress! (%.*s)\\n\",\n\t\t\t\t     assert->node_idx,\n\t\t\t\t     namelen, name);\n\t\t\t\tgoto kill;\n\t\t\t}\n\t\t} else /* mle->type == DLM_MLE_MIGRATION */ {\n\t\t\t/* should only be getting an assert from new master */\n\t\t\tif (assert->node_idx != mle->new_master) {\n\t\t\t\tmlog(ML_ERROR, \"got assert from %u, but \"\n\t\t\t\t     \"new master is %u, and old master \"\n\t\t\t\t     \"was %u (%.*s)\\n\",\n\t\t\t\t     assert->node_idx, mle->new_master,\n\t\t\t\t     mle->master, namelen, name);\n\t\t\t\tgoto kill;\n\t\t\t}\n\n\t\t}\nok:\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\t// mlog(0, \"woo!  got an assert_master from node %u!\\n\",\n\t// \t     assert->node_idx);\n\tif (mle) {\n\t\tint extra_ref = 0;\n\t\tint nn = -1;\n\t\tint rr, err = 0;\n\n\t\tspin_lock(&mle->spinlock);\n\t\tif (mle->type == DLM_MLE_BLOCK || mle->type == DLM_MLE_MIGRATION)\n\t\t\textra_ref = 1;\n\t\telse {\n\t\t\t/* MASTER mle: if any bits set in the response map\n\t\t\t * then the calling node needs to re-assert to clear\n\t\t\t * up nodes that this node contacted */\n\t\t\twhile ((nn = find_next_bit (mle->response_map, O2NM_MAX_NODES,\n\t\t\t\t\t\t    nn+1)) < O2NM_MAX_NODES) {\n\t\t\t\tif (nn != dlm->node_num && nn != assert->node_idx) {\n\t\t\t\t\tmaster_request = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmle->master = assert->node_idx;\n\t\tatomic_set(&mle->woken, 1);\n\t\twake_up(&mle->wq);\n\t\tspin_unlock(&mle->spinlock);\n\n\t\tif (res) {\n\t\t\tint wake = 0;\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (mle->type == DLM_MLE_MIGRATION) {\n\t\t\t\tmlog(0, \"finishing off migration of lockres %.*s, \"\n\t\t\t     \t\t\"from %u to %u\\n\",\n\t\t\t       \t\tres->lockname.len, res->lockname.name,\n\t\t\t       \t\tdlm->node_num, mle->new_master);\n\t\t\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\t\t\twake = 1;\n\t\t\t\tdlm_change_lockres_owner(dlm, res, mle->new_master);\n\t\t\t\tBUG_ON(res->state & DLM_LOCK_RES_DIRTY);\n\t\t\t} else {\n\t\t\t\tdlm_change_lockres_owner(dlm, res, mle->master);\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\thave_lockres_ref = 1;\n\t\t\tif (wake)\n\t\t\t\twake_up(&res->wq);\n\t\t}\n\n\t\t/* master is known, detach if not already detached.\n\t\t * ensures that only one assert_master call will happen\n\t\t * on this mle. */\n\t\tspin_lock(&dlm->master_lock);\n\n\t\trr = atomic_read(&mle->mle_refs.refcount);\n\t\tif (mle->inuse > 0) {\n\t\t\tif (extra_ref && rr < 3)\n\t\t\t\terr = 1;\n\t\t\telse if (!extra_ref && rr < 2)\n\t\t\t\terr = 1;\n\t\t} else {\n\t\t\tif (extra_ref && rr < 2)\n\t\t\t\terr = 1;\n\t\t\telse if (!extra_ref && rr < 1)\n\t\t\t\terr = 1;\n\t\t}\n\t\tif (err) {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: got assert master from %u \"\n\t\t\t     \"that will mess up this node, refs=%d, extra=%d, \"\n\t\t\t     \"inuse=%d\\n\", dlm->name, namelen, name,\n\t\t\t     assert->node_idx, rr, extra_ref, mle->inuse);\n\t\t\tdlm_print_one_mle(mle);\n\t\t}\n\t\t__dlm_unlink_mle(dlm, mle);\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t__dlm_put_mle(mle);\n\t\tif (extra_ref) {\n\t\t\t/* the assert master message now balances the extra\n\t\t \t * ref given by the master / migration request message.\n\t\t \t * if this is the last put, it will be removed\n\t\t \t * from the list. */\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t\tspin_unlock(&dlm->master_lock);\n\t} else if (res) {\n\t\tif (res->owner != assert->node_idx) {\n\t\t\tmlog(0, \"assert_master from %u, but current \"\n\t\t\t     \"owner is %u (%.*s), no mle\\n\", assert->node_idx,\n\t\t\t     res->owner, namelen, name);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n\ndone:\n\tret = 0;\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\t\tspin_unlock(&res->spinlock);\n\t\t*ret_data = (void *)res;\n\t}\n\tdlm_put(dlm);\n\tif (master_request) {\n\t\tmlog(0, \"need to tell master to reassert\\n\");\n\t\t/* positive. negative would shoot down the node. */\n\t\tret |= DLM_ASSERT_RESPONSE_REASSERT;\n\t\tif (!have_lockres_ref) {\n\t\t\tmlog(ML_ERROR, \"strange, got assert from %u, MASTER \"\n\t\t\t     \"mle present here for %s:%.*s, but no lockres!\\n\",\n\t\t\t     assert->node_idx, dlm->name, namelen, name);\n\t\t}\n\t}\n\tif (have_lockres_ref) {\n\t\t/* let the master know we have a reference to the lockres */\n\t\tret |= DLM_ASSERT_RESPONSE_MASTERY_REF;\n\t\tmlog(0, \"%s:%.*s: got assert from %u, need a ref\\n\",\n\t\t     dlm->name, namelen, name, assert->node_idx);\n\t}\n\treturn ret;\n\nkill:\n\t/* kill the caller! */\n\tmlog(ML_ERROR, \"Bad message received from another node.  Dumping state \"\n\t     \"and killing the other node now!  This node is OK and can continue.\\n\");\n\t__dlm_print_one_lock_resource(res);\n\tspin_unlock(&res->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tif (mle)\n\t\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\t*ret_data = (void *)res;\n\tdlm_put(dlm);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_assert_master_worker(struct dlm_work_item *item, void *data);",
      "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
      "static void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);",
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "229-244",
          "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Bad message received from another node.  Dumping state \"\n\t     \"and killing the other node now!  This node is OK and can continue.\\n\""
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: got assert from %u, need a ref\\n\"",
            "dlm->name",
            "namelen",
            "name",
            "assert->node_idx"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"strange, got assert from %u, MASTER \"\n\t\t\t     \"mle present here for %s:%.*s, but no lockres!\\n\"",
            "assert->node_idx",
            "dlm->name",
            "namelen",
            "name"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"assert_master from %u, but current \"\n\t\t\t     \"owner is %u (%.*s), no mle\\n\"",
            "assert->node_idx",
            "res->owner",
            "namelen",
            "name"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "187-192",
          "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_unlink_mle",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_unlink_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "319-326",
          "snippet": "void __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_one_mle",
          "args": [
            "mle"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_one_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "328-337",
          "snippet": "void dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s:%.*s: got assert master from %u \"\n\t\t\t     \"that will mess up this node, refs=%d, extra=%d, \"\n\t\t\t     \"inuse=%d\\n\"",
            "dlm->name",
            "namelen",
            "name",
            "assert->node_idx",
            "rr",
            "extra_ref",
            "mle->inuse"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mle->mle_refs.refcount"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_change_lockres_owner",
          "args": [
            "dlm",
            "res",
            "mle->master"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_change_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1140-1148",
          "snippet": "static inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->state & DLM_LOCK_RES_DIRTY"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"finishing off migration of lockres %.*s, \"\n\t\t\t     \t\t\"from %u to %u\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "dlm->node_num",
            "mle->new_master"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mle->woken",
            "1"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "mle->response_map",
            "O2NM_MAX_NODES",
            "nn+1"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"got assert from %u, but \"\n\t\t\t\t     \"new master is %u, and old master \"\n\t\t\t\t     \"was %u (%.*s)\\n\"",
            "assert->node_idx",
            "mle->new_master",
            "mle->master",
            "namelen",
            "name"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"got assert from %u, but lock \"\n\t\t\t\t     \"with no owner should be \"\n\t\t\t\t     \"in-progress! (%.*s)\\n\"",
            "assert->node_idx",
            "namelen",
            "name"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"got assert_master from \"\n\t\t\t\t     \"node %u, but %u is the owner! \"\n\t\t\t\t     \"(%.*s)\\n\"",
            "assert->node_idx",
            "res->owner",
            "namelen",
            "name"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"owner %u re-asserting on \"\n\t\t\t\t\t     \"lock %.*s\\n\"",
            "assert->node_idx",
            "namelen",
            "name"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"DIE! Mastery assert from %u, \"\n\t\t\t\t     \"but current owner is %u! (%.*s)\\n\"",
            "assert->node_idx",
            "res->owner",
            "namelen",
            "name"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%u asserting but %.*s is \"\n\t\t\t     \"RECOVERING!\\n\"",
            "assert->node_idx",
            "namelen",
            "name"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres",
          "args": [
            "dlm",
            "name",
            "namelen",
            "hash"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "221-244",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: got unrelated assert\"\n\t\t\t\t     \" from %u for migration, ignoring\\n\"",
            "dlm->name",
            "namelen",
            "name",
            "assert->node_idx"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: got cleanup assert\"\n\t\t\t\t     \" from %u for migration\\n\"",
            "dlm->name",
            "namelen",
            "name",
            "assert->node_idx"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%u is the lowest node, \"\n\t\t\t\t     \"%u is asserting. (%.*s)  %u must \"\n\t\t\t\t     \"have begun after %u won.\\n\"",
            "bit",
            "assert->node_idx",
            "namelen",
            "name",
            "bit",
            "assert->node_idx"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"master %u was found, %u should \"\n\t\t\t\t     \"back off\\n\"",
            "assert->node_idx",
            "bit"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"no bits set in the maybe_map, but %u \"\n\t\t\t     \"is asserting! (%.*s)\\n\"",
            "assert->node_idx",
            "namelen",
            "name"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"just got an assert_master from %u, but no \"\n\t\t     \"MLE for it! (%.*s)\\n\"",
            "assert->node_idx",
            "namelen",
            "name"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_find_mle",
          "args": [
            "dlm",
            "&mle",
            "name",
            "namelen"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "339-359",
          "snippet": "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\n\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"assert_master with flags: %u\\n\"",
            "flags"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "assert->flags"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "name",
            "namelen"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_assert_master_worker(struct dlm_work_item *item, void *data);\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_assert_master_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_assert_master *assert = (struct dlm_assert_master *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tchar *name;\n\tunsigned int namelen, hash;\n\tu32 flags;\n\tint master_request = 0, have_lockres_ref = 0;\n\tint ret = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tname = assert->name;\n\tnamelen = assert->namelen;\n\thash = dlm_lockid_hash(name, namelen);\n\tflags = be32_to_cpu(assert->flags);\n\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tmlog(ML_ERROR, \"Invalid name length!\");\n\t\tgoto done;\n\t}\n\n\tspin_lock(&dlm->spinlock);\n\n\tif (flags)\n\t\tmlog(0, \"assert_master with flags: %u\\n\", flags);\n\n\t/* find the MLE */\n\tspin_lock(&dlm->master_lock);\n\tif (!dlm_find_mle(dlm, &mle, name, namelen)) {\n\t\t/* not an error, could be master just re-asserting */\n\t\tmlog(0, \"just got an assert_master from %u, but no \"\n\t\t     \"MLE for it! (%.*s)\\n\", assert->node_idx,\n\t\t     namelen, name);\n\t} else {\n\t\tint bit = find_next_bit (mle->maybe_map, O2NM_MAX_NODES, 0);\n\t\tif (bit >= O2NM_MAX_NODES) {\n\t\t\t/* not necessarily an error, though less likely.\n\t\t\t * could be master just re-asserting. */\n\t\t\tmlog(0, \"no bits set in the maybe_map, but %u \"\n\t\t\t     \"is asserting! (%.*s)\\n\", assert->node_idx,\n\t\t\t     namelen, name);\n\t\t} else if (bit != assert->node_idx) {\n\t\t\tif (flags & DLM_ASSERT_MASTER_MLE_CLEANUP) {\n\t\t\t\tmlog(0, \"master %u was found, %u should \"\n\t\t\t\t     \"back off\\n\", assert->node_idx, bit);\n\t\t\t} else {\n\t\t\t\t/* with the fix for bug 569, a higher node\n\t\t\t\t * number winning the mastery will respond\n\t\t\t\t * YES to mastery requests, but this node\n\t\t\t\t * had no way of knowing.  let it pass. */\n\t\t\t\tmlog(0, \"%u is the lowest node, \"\n\t\t\t\t     \"%u is asserting. (%.*s)  %u must \"\n\t\t\t\t     \"have begun after %u won.\\n\", bit,\n\t\t\t\t     assert->node_idx, namelen, name, bit,\n\t\t\t\t     assert->node_idx);\n\t\t\t}\n\t\t}\n\t\tif (mle->type == DLM_MLE_MIGRATION) {\n\t\t\tif (flags & DLM_ASSERT_MASTER_MLE_CLEANUP) {\n\t\t\t\tmlog(0, \"%s:%.*s: got cleanup assert\"\n\t\t\t\t     \" from %u for migration\\n\",\n\t\t\t\t     dlm->name, namelen, name,\n\t\t\t\t     assert->node_idx);\n\t\t\t} else if (!(flags & DLM_ASSERT_MASTER_FINISH_MIGRATION)) {\n\t\t\t\tmlog(0, \"%s:%.*s: got unrelated assert\"\n\t\t\t\t     \" from %u for migration, ignoring\\n\",\n\t\t\t\t     dlm->name, namelen, name,\n\t\t\t\t     assert->node_idx);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n\n\t/* ok everything checks out with the MLE\n\t * now check to see if there is a lockres */\n\tres = __dlm_lookup_lockres(dlm, name, namelen, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_RECOVERING)  {\n\t\t\tmlog(ML_ERROR, \"%u asserting but %.*s is \"\n\t\t\t     \"RECOVERING!\\n\", assert->node_idx, namelen, name);\n\t\t\tgoto kill;\n\t\t}\n\t\tif (!mle) {\n\t\t\tif (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN &&\n\t\t\t    res->owner != assert->node_idx) {\n\t\t\t\tmlog(ML_ERROR, \"DIE! Mastery assert from %u, \"\n\t\t\t\t     \"but current owner is %u! (%.*s)\\n\",\n\t\t\t\t     assert->node_idx, res->owner, namelen,\n\t\t\t\t     name);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else if (mle->type != DLM_MLE_MIGRATION) {\n\t\t\tif (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t\t/* owner is just re-asserting */\n\t\t\t\tif (res->owner == assert->node_idx) {\n\t\t\t\t\tmlog(0, \"owner %u re-asserting on \"\n\t\t\t\t\t     \"lock %.*s\\n\", assert->node_idx,\n\t\t\t\t\t     namelen, name);\n\t\t\t\t\tgoto ok;\n\t\t\t\t}\n\t\t\t\tmlog(ML_ERROR, \"got assert_master from \"\n\t\t\t\t     \"node %u, but %u is the owner! \"\n\t\t\t\t     \"(%.*s)\\n\", assert->node_idx,\n\t\t\t\t     res->owner, namelen, name);\n\t\t\t\tgoto kill;\n\t\t\t}\n\t\t\tif (!(res->state & DLM_LOCK_RES_IN_PROGRESS)) {\n\t\t\t\tmlog(ML_ERROR, \"got assert from %u, but lock \"\n\t\t\t\t     \"with no owner should be \"\n\t\t\t\t     \"in-progress! (%.*s)\\n\",\n\t\t\t\t     assert->node_idx,\n\t\t\t\t     namelen, name);\n\t\t\t\tgoto kill;\n\t\t\t}\n\t\t} else /* mle->type == DLM_MLE_MIGRATION */ {\n\t\t\t/* should only be getting an assert from new master */\n\t\t\tif (assert->node_idx != mle->new_master) {\n\t\t\t\tmlog(ML_ERROR, \"got assert from %u, but \"\n\t\t\t\t     \"new master is %u, and old master \"\n\t\t\t\t     \"was %u (%.*s)\\n\",\n\t\t\t\t     assert->node_idx, mle->new_master,\n\t\t\t\t     mle->master, namelen, name);\n\t\t\t\tgoto kill;\n\t\t\t}\n\n\t\t}\nok:\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\t// mlog(0, \"woo!  got an assert_master from node %u!\\n\",\n\t// \t     assert->node_idx);\n\tif (mle) {\n\t\tint extra_ref = 0;\n\t\tint nn = -1;\n\t\tint rr, err = 0;\n\n\t\tspin_lock(&mle->spinlock);\n\t\tif (mle->type == DLM_MLE_BLOCK || mle->type == DLM_MLE_MIGRATION)\n\t\t\textra_ref = 1;\n\t\telse {\n\t\t\t/* MASTER mle: if any bits set in the response map\n\t\t\t * then the calling node needs to re-assert to clear\n\t\t\t * up nodes that this node contacted */\n\t\t\twhile ((nn = find_next_bit (mle->response_map, O2NM_MAX_NODES,\n\t\t\t\t\t\t    nn+1)) < O2NM_MAX_NODES) {\n\t\t\t\tif (nn != dlm->node_num && nn != assert->node_idx) {\n\t\t\t\t\tmaster_request = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmle->master = assert->node_idx;\n\t\tatomic_set(&mle->woken, 1);\n\t\twake_up(&mle->wq);\n\t\tspin_unlock(&mle->spinlock);\n\n\t\tif (res) {\n\t\t\tint wake = 0;\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tif (mle->type == DLM_MLE_MIGRATION) {\n\t\t\t\tmlog(0, \"finishing off migration of lockres %.*s, \"\n\t\t\t     \t\t\"from %u to %u\\n\",\n\t\t\t       \t\tres->lockname.len, res->lockname.name,\n\t\t\t       \t\tdlm->node_num, mle->new_master);\n\t\t\t\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\t\t\t\twake = 1;\n\t\t\t\tdlm_change_lockres_owner(dlm, res, mle->new_master);\n\t\t\t\tBUG_ON(res->state & DLM_LOCK_RES_DIRTY);\n\t\t\t} else {\n\t\t\t\tdlm_change_lockres_owner(dlm, res, mle->master);\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\thave_lockres_ref = 1;\n\t\t\tif (wake)\n\t\t\t\twake_up(&res->wq);\n\t\t}\n\n\t\t/* master is known, detach if not already detached.\n\t\t * ensures that only one assert_master call will happen\n\t\t * on this mle. */\n\t\tspin_lock(&dlm->master_lock);\n\n\t\trr = atomic_read(&mle->mle_refs.refcount);\n\t\tif (mle->inuse > 0) {\n\t\t\tif (extra_ref && rr < 3)\n\t\t\t\terr = 1;\n\t\t\telse if (!extra_ref && rr < 2)\n\t\t\t\terr = 1;\n\t\t} else {\n\t\t\tif (extra_ref && rr < 2)\n\t\t\t\terr = 1;\n\t\t\telse if (!extra_ref && rr < 1)\n\t\t\t\terr = 1;\n\t\t}\n\t\tif (err) {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: got assert master from %u \"\n\t\t\t     \"that will mess up this node, refs=%d, extra=%d, \"\n\t\t\t     \"inuse=%d\\n\", dlm->name, namelen, name,\n\t\t\t     assert->node_idx, rr, extra_ref, mle->inuse);\n\t\t\tdlm_print_one_mle(mle);\n\t\t}\n\t\t__dlm_unlink_mle(dlm, mle);\n\t\t__dlm_mle_detach_hb_events(dlm, mle);\n\t\t__dlm_put_mle(mle);\n\t\tif (extra_ref) {\n\t\t\t/* the assert master message now balances the extra\n\t\t \t * ref given by the master / migration request message.\n\t\t \t * if this is the last put, it will be removed\n\t\t \t * from the list. */\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t\tspin_unlock(&dlm->master_lock);\n\t} else if (res) {\n\t\tif (res->owner != assert->node_idx) {\n\t\t\tmlog(0, \"assert_master from %u, but current \"\n\t\t\t     \"owner is %u (%.*s), no mle\\n\", assert->node_idx,\n\t\t\t     res->owner, namelen, name);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n\ndone:\n\tret = 0;\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\t\tspin_unlock(&res->spinlock);\n\t\t*ret_data = (void *)res;\n\t}\n\tdlm_put(dlm);\n\tif (master_request) {\n\t\tmlog(0, \"need to tell master to reassert\\n\");\n\t\t/* positive. negative would shoot down the node. */\n\t\tret |= DLM_ASSERT_RESPONSE_REASSERT;\n\t\tif (!have_lockres_ref) {\n\t\t\tmlog(ML_ERROR, \"strange, got assert from %u, MASTER \"\n\t\t\t     \"mle present here for %s:%.*s, but no lockres!\\n\",\n\t\t\t     assert->node_idx, dlm->name, namelen, name);\n\t\t}\n\t}\n\tif (have_lockres_ref) {\n\t\t/* let the master know we have a reference to the lockres */\n\t\tret |= DLM_ASSERT_RESPONSE_MASTERY_REF;\n\t\tmlog(0, \"%s:%.*s: got assert from %u, need a ref\\n\",\n\t\t     dlm->name, namelen, name, assert->node_idx);\n\t}\n\treturn ret;\n\nkill:\n\t/* kill the caller! */\n\tmlog(ML_ERROR, \"Bad message received from another node.  Dumping state \"\n\t     \"and killing the other node now!  This node is OK and can continue.\\n\");\n\t__dlm_print_one_lock_resource(res);\n\tspin_unlock(&res->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tif (mle)\n\t\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\t*ret_data = (void *)res;\n\tdlm_put(dlm);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "dlm_do_assert_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "1670-1768",
    "snippet": "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags)\n{\n\tstruct dlm_assert_master assert;\n\tint to, tmpret;\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\tint reassert;\n\tconst char *lockname = res->lockname.name;\n\tunsigned int namelen = res->lockname.len;\n\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tspin_lock(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\nagain:\n\treassert = 0;\n\n\t/* note that if this nodemap is empty, it returns 0 */\n\tdlm_node_iter_init(nodemap, &iter);\n\twhile ((to = dlm_node_iter_next(&iter)) >= 0) {\n\t\tint r = 0;\n\t\tstruct dlm_master_list_entry *mle = NULL;\n\n\t\tmlog(0, \"sending assert master to %d (%.*s)\\n\", to,\n\t\t     namelen, lockname);\n\t\tmemset(&assert, 0, sizeof(assert));\n\t\tassert.node_idx = dlm->node_num;\n\t\tassert.namelen = namelen;\n\t\tmemcpy(assert.name, lockname, namelen);\n\t\tassert.flags = cpu_to_be32(flags);\n\n\t\ttmpret = o2net_send_message(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\t    &assert, sizeof(assert), to, &r);\n\t\tif (tmpret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", tmpret,\n\t\t\t     DLM_ASSERT_MASTER_MSG, dlm->key, to);\n\t\t\tif (!dlm_is_host_down(tmpret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", tmpret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* a node died.  finish out the rest of the nodes. */\n\t\t\tmlog(0, \"link to %d went down!\\n\", to);\n\t\t\t/* any nonzero status return will do */\n\t\t\tret = tmpret;\n\t\t\tr = 0;\n\t\t} else if (r < 0) {\n\t\t\t/* ok, something horribly messed.  kill thyself. */\n\t\t\tmlog(ML_ERROR,\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\", namelen, lockname, to, r);\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tspin_lock(&dlm->master_lock);\n\t\t\tif (dlm_find_mle(dlm, &mle, (char *)lockname,\n\t\t\t\t\t namelen)) {\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t}\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT &&\n\t\t    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {\n\t\t\t\tmlog(ML_ERROR, \"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\",\n\t\t\t\t     namelen, lockname, to);\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT) {\n\t\t\tmlog(0, \"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\treassert = 1;\n\t\t}\n\t\tif (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {\n\t\t\tmlog(0, \"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, to);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (reassert)\n\t\tgoto again;\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_set_refmap_bit",
          "args": [
            "dlm",
            "res",
            "to"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_set_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "633-642",
          "snippet": "void dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\"",
            "namelen",
            "lockname",
            "to"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\"",
            "namelen",
            "lockname",
            "to"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\"",
            "namelen",
            "lockname",
            "to"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "229-244",
          "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_one_mle",
          "args": [
            "mle"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_one_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "328-337",
          "snippet": "void dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_mle",
          "args": [
            "dlm",
            "&mle",
            "(char *)lockname",
            "namelen"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "339-359",
          "snippet": "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\n\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\"",
            "namelen",
            "lockname",
            "to",
            "r"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"link to %d went down!\\n\"",
            "to"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "tmpret"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\"",
            "tmpret",
            "DLM_ASSERT_MASTER_MSG",
            "dlm->key",
            "to"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_ASSERT_MASTER_MSG",
            "dlm->key",
            "&assert",
            "sizeof(assert)",
            "to",
            "&r"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "flags"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "assert.name",
            "lockname",
            "namelen"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&assert",
            "0",
            "sizeof(assert)"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"sending assert master to %d (%.*s)\\n\"",
            "to",
            "namelen",
            "lockname"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_next",
          "args": [
            "&iter"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1119-1129",
          "snippet": "static inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_init",
          "args": [
            "nodemap",
            "&iter"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1112-1117",
          "snippet": "static inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "namelen > O2NM_MAX_NAME_LEN"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags)\n{\n\tstruct dlm_assert_master assert;\n\tint to, tmpret;\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\tint reassert;\n\tconst char *lockname = res->lockname.name;\n\tunsigned int namelen = res->lockname.len;\n\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tspin_lock(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\nagain:\n\treassert = 0;\n\n\t/* note that if this nodemap is empty, it returns 0 */\n\tdlm_node_iter_init(nodemap, &iter);\n\twhile ((to = dlm_node_iter_next(&iter)) >= 0) {\n\t\tint r = 0;\n\t\tstruct dlm_master_list_entry *mle = NULL;\n\n\t\tmlog(0, \"sending assert master to %d (%.*s)\\n\", to,\n\t\t     namelen, lockname);\n\t\tmemset(&assert, 0, sizeof(assert));\n\t\tassert.node_idx = dlm->node_num;\n\t\tassert.namelen = namelen;\n\t\tmemcpy(assert.name, lockname, namelen);\n\t\tassert.flags = cpu_to_be32(flags);\n\n\t\ttmpret = o2net_send_message(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\t    &assert, sizeof(assert), to, &r);\n\t\tif (tmpret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", tmpret,\n\t\t\t     DLM_ASSERT_MASTER_MSG, dlm->key, to);\n\t\t\tif (!dlm_is_host_down(tmpret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", tmpret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* a node died.  finish out the rest of the nodes. */\n\t\t\tmlog(0, \"link to %d went down!\\n\", to);\n\t\t\t/* any nonzero status return will do */\n\t\t\tret = tmpret;\n\t\t\tr = 0;\n\t\t} else if (r < 0) {\n\t\t\t/* ok, something horribly messed.  kill thyself. */\n\t\t\tmlog(ML_ERROR,\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\", namelen, lockname, to, r);\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tspin_lock(&dlm->master_lock);\n\t\t\tif (dlm_find_mle(dlm, &mle, (char *)lockname,\n\t\t\t\t\t namelen)) {\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t}\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT &&\n\t\t    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {\n\t\t\t\tmlog(ML_ERROR, \"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\",\n\t\t\t\t     namelen, lockname, to);\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT) {\n\t\t\tmlog(0, \"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\treassert = 1;\n\t\t}\n\t\tif (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {\n\t\t\tmlog(0, \"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, to);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (reassert)\n\t\tgoto again;\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_master_request_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "1416-1658",
    "snippet": "int dlm_master_request_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data)\n{\n\tu8 response = DLM_MASTER_RESP_MAYBE;\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_master_request *request = (struct dlm_master_request *) msg->buf;\n\tstruct dlm_master_list_entry *mle = NULL, *tmpmle = NULL;\n\tchar *name;\n\tunsigned int namelen, hash;\n\tint found, ret;\n\tint set_maybe;\n\tint dispatch_assert = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn DLM_MASTER_RESP_NO;\n\n\tif (!dlm_domain_fully_joined(dlm)) {\n\t\tresponse = DLM_MASTER_RESP_NO;\n\t\tgoto send_response;\n\t}\n\n\tname = request->name;\n\tnamelen = request->namelen;\n\thash = dlm_lockid_hash(name, namelen);\n\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tresponse = DLM_IVBUFLEN;\n\t\tgoto send_response;\n\t}\n\nway_up_top:\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, namelen, hash);\n\tif (res) {\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\t/* take care of the easy cases up front */\n\t\tspin_lock(&res->spinlock);\n\n\t\t/*\n\t\t * Right after dlm spinlock was released, dlm_thread could have\n\t\t * purged the lockres. Check if lockres got unhashed. If so\n\t\t * start over.\n\t\t */\n\t\tif (hlist_unhashed(&res->hash_node)) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\tgoto way_up_top;\n\t\t}\n\n\t\tif (res->state & (DLM_LOCK_RES_RECOVERING|\n\t\t\t\t  DLM_LOCK_RES_MIGRATING)) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tmlog(0, \"returning DLM_MASTER_RESP_ERROR since res is \"\n\t\t\t     \"being recovered/migrated\\n\");\n\t\t\tresponse = DLM_MASTER_RESP_ERROR;\n\t\t\tif (mle)\n\t\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tgoto send_response;\n\t\t}\n\n\t\tif (res->owner == dlm->node_num) {\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, request->node_idx);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tresponse = DLM_MASTER_RESP_YES;\n\t\t\tif (mle)\n\t\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\n\t\t\t/* this node is the owner.\n\t\t\t * there is some extra work that needs to\n\t\t\t * happen now.  the requesting node has\n\t\t\t * caused all nodes up to this one to\n\t\t\t * create mles.  this node now needs to\n\t\t\t * go back and clean those up. */\n\t\t\tdispatch_assert = 1;\n\t\t\tgoto send_response;\n\t\t} else if (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\t// mlog(0, \"node %u is the master\\n\", res->owner);\n\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t\tif (mle)\n\t\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tgoto send_response;\n\t\t}\n\n\t\t/* ok, there is no owner.  either this node is\n\t\t * being blocked, or it is actively trying to\n\t\t * master this lock. */\n\t\tif (!(res->state & DLM_LOCK_RES_IN_PROGRESS)) {\n\t\t\tmlog(ML_ERROR, \"lock with no owner should be \"\n\t\t\t     \"in-progress!\\n\");\n\t\t\tBUG();\n\t\t}\n\n\t\t// mlog(0, \"lockres is in progress...\\n\");\n\t\tspin_lock(&dlm->master_lock);\n\t\tfound = dlm_find_mle(dlm, &tmpmle, name, namelen);\n\t\tif (!found) {\n\t\t\tmlog(ML_ERROR, \"no mle found for this lock!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tset_maybe = 1;\n\t\tspin_lock(&tmpmle->spinlock);\n\t\tif (tmpmle->type == DLM_MLE_BLOCK) {\n\t\t\t// mlog(0, \"this node is waiting for \"\n\t\t\t// \"lockres to be mastered\\n\");\n\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t} else if (tmpmle->type == DLM_MLE_MIGRATION) {\n\t\t\tmlog(0, \"node %u is master, but trying to migrate to \"\n\t\t\t     \"node %u.\\n\", tmpmle->master, tmpmle->new_master);\n\t\t\tif (tmpmle->master == dlm->node_num) {\n\t\t\t\tmlog(ML_ERROR, \"no owner on lockres, but this \"\n\t\t\t\t     \"node is trying to migrate it to %u?!\\n\",\n\t\t\t\t     tmpmle->new_master);\n\t\t\t\tBUG();\n\t\t\t} else {\n\t\t\t\t/* the real master can respond on its own */\n\t\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t\t}\n\t\t} else if (tmpmle->master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tset_maybe = 0;\n\t\t\tif (tmpmle->master == dlm->node_num) {\n\t\t\t\tresponse = DLM_MASTER_RESP_YES;\n\t\t\t\t/* this node will be the owner.\n\t\t\t\t * go back and clean the mles on any\n\t\t\t\t * other nodes */\n\t\t\t\tdispatch_assert = 1;\n\t\t\t\tdlm_lockres_set_refmap_bit(dlm, res,\n\t\t\t\t\t\t\t   request->node_idx);\n\t\t\t} else\n\t\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t} else {\n\t\t\t// mlog(0, \"this node is attempting to \"\n\t\t\t// \"master lockres\\n\");\n\t\t\tresponse = DLM_MASTER_RESP_MAYBE;\n\t\t}\n\t\tif (set_maybe)\n\t\t\tset_bit(request->node_idx, tmpmle->maybe_map);\n\t\tspin_unlock(&tmpmle->spinlock);\n\n\t\tspin_unlock(&dlm->master_lock);\n\t\tspin_unlock(&res->spinlock);\n\n\t\t/* keep the mle attached to heartbeat events */\n\t\tdlm_put_mle(tmpmle);\n\t\tif (mle)\n\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\tgoto send_response;\n\t}\n\n\t/*\n\t * lockres doesn't exist on this node\n\t * if there is an MLE_BLOCK, return NO\n\t * if there is an MLE_MASTER, return MAYBE\n\t * otherwise, add an MLE_BLOCK, return NO\n\t */\n\tspin_lock(&dlm->master_lock);\n\tfound = dlm_find_mle(dlm, &tmpmle, name, namelen);\n\tif (!found) {\n\t\t/* this lockid has never been seen on this node yet */\n\t\t// mlog(0, \"no mle found\\n\");\n\t\tif (!mle) {\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\tmle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\t\t\tif (!mle) {\n\t\t\t\tresponse = DLM_MASTER_RESP_ERROR;\n\t\t\t\tmlog_errno(-ENOMEM);\n\t\t\t\tgoto send_response;\n\t\t\t}\n\t\t\tgoto way_up_top;\n\t\t}\n\n\t\t// mlog(0, \"this is second time thru, already allocated, \"\n\t\t// \"add the block.\\n\");\n\t\tdlm_init_mle(mle, DLM_MLE_BLOCK, dlm, NULL, name, namelen);\n\t\tset_bit(request->node_idx, mle->maybe_map);\n\t\t__dlm_insert_mle(dlm, mle);\n\t\tresponse = DLM_MASTER_RESP_NO;\n\t} else {\n\t\t// mlog(0, \"mle was found\\n\");\n\t\tset_maybe = 1;\n\t\tspin_lock(&tmpmle->spinlock);\n\t\tif (tmpmle->master == dlm->node_num) {\n\t\t\tmlog(ML_ERROR, \"no lockres, but an mle with this node as master!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tif (tmpmle->type == DLM_MLE_BLOCK)\n\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\telse if (tmpmle->type == DLM_MLE_MIGRATION) {\n\t\t\tmlog(0, \"migration mle was found (%u->%u)\\n\",\n\t\t\t     tmpmle->master, tmpmle->new_master);\n\t\t\t/* real master can respond on its own */\n\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t} else\n\t\t\tresponse = DLM_MASTER_RESP_MAYBE;\n\t\tif (set_maybe)\n\t\t\tset_bit(request->node_idx, tmpmle->maybe_map);\n\t\tspin_unlock(&tmpmle->spinlock);\n\t}\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (found) {\n\t\t/* keep the mle attached to heartbeat events */\n\t\tdlm_put_mle(tmpmle);\n\t}\nsend_response:\n\t/*\n\t * __dlm_lookup_lockres() grabbed a reference to this lockres.\n\t * The reference is released by dlm_assert_master_worker() under\n\t * the call to dlm_dispatch_assert_master().  If\n\t * dlm_assert_master_worker() isn't called, we drop it here.\n\t */\n\tif (dispatch_assert) {\n\t\tif (response != DLM_MASTER_RESP_YES)\n\t\t\tmlog(ML_ERROR, \"invalid response %d\\n\", response);\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"bad lockres while trying to assert!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tmlog(0, \"%u is the owner of %.*s, cleaning everyone else\\n\",\n\t\t\t     dlm->node_num, res->lockname.len, res->lockname.name);\n\t\tspin_lock(&res->spinlock);\n\t\tret = dlm_dispatch_assert_master(dlm, res, 0, request->node_idx,\n\t\t\t\t\t\t DLM_ASSERT_MASTER_MLE_CLEANUP);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"failed to dispatch assert master work\\n\");\n\t\t\tresponse = DLM_MASTER_RESP_ERROR;\n\t\t\tdlm_lockres_put(res);\n\t\t} else\n\t\t\t__dlm_lockres_grab_inflight_worker(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t} else {\n\t\tif (res)\n\t\t\tdlm_lockres_put(res);\n\t}\n\n\tdlm_put(dlm);\n\treturn response;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_assert_master_worker(struct dlm_work_item *item, void *data);",
      "static void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);",
      "static struct kmem_cache *dlm_mle_cache;",
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
      "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_grab_inflight_worker",
          "args": [
            "dlm",
            "res"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_grab_inflight_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "688-696",
          "snippet": "void __dlm_lockres_grab_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tres->inflight_assert_workers++;\n\tmlog(0, \"%s:%.*s: inflight assert worker++: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_grab_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tres->inflight_assert_workers++;\n\tmlog(0, \"%s:%.*s: inflight assert worker++: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"failed to dispatch assert master work\\n\""
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dispatch_assert_master",
          "args": [
            "dlm",
            "res",
            "0",
            "request->node_idx",
            "DLM_ASSERT_MASTER_MLE_CLEANUP"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dispatch_assert_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2069-2098",
          "snippet": "int dlm_dispatch_assert_master(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res,\n\t\t\t       int ignore_higher, u8 request_from, u32 flags)\n{\n\tstruct dlm_work_item *item;\n\titem = kzalloc(sizeof(*item), GFP_ATOMIC);\n\tif (!item)\n\t\treturn -ENOMEM;\n\n\n\t/* queue up work for dlm_assert_master_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tdlm_init_work_item(dlm, item, dlm_assert_master_worker, NULL);\n\titem->u.am.lockres = res; /* already have a ref */\n\t/* can optionally ignore node numbers higher than this node */\n\titem->u.am.ignore_higher = ignore_higher;\n\titem->u.am.request_from = request_from;\n\titem->u.am.flags = flags;\n\n\tif (ignore_higher)\n\t\tmlog(0, \"IGNORE HIGHER: %.*s\\n\", res->lockname.len,\n\t\t     res->lockname.name);\n\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_dispatch_assert_master(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res,\n\t\t\t       int ignore_higher, u8 request_from, u32 flags)\n{\n\tstruct dlm_work_item *item;\n\titem = kzalloc(sizeof(*item), GFP_ATOMIC);\n\tif (!item)\n\t\treturn -ENOMEM;\n\n\n\t/* queue up work for dlm_assert_master_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tdlm_init_work_item(dlm, item, dlm_assert_master_worker, NULL);\n\titem->u.am.lockres = res; /* already have a ref */\n\t/* can optionally ignore node numbers higher than this node */\n\titem->u.am.ignore_higher = ignore_higher;\n\titem->u.am.request_from = request_from;\n\titem->u.am.flags = flags;\n\n\tif (ignore_higher)\n\t\tmlog(0, \"IGNORE HIGHER: %.*s\\n\", res->lockname.len,\n\t\t     res->lockname.name);\n\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%u is the owner of %.*s, cleaning everyone else\\n\"",
            "dlm->node_num",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"invalid response %d\\n\"",
            "response"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "request->node_idx",
            "tmpmle->maybe_map"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"migration mle was found (%u->%u)\\n\"",
            "tmpmle->master",
            "tmpmle->new_master"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_insert_mle",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_insert_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "328-336",
          "snippet": "void __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\tbucket = dlm_master_hash(dlm, mle->mnamehash);\n\thlist_add_head(&mle->master_hash_node, bucket);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\tbucket = dlm_master_hash(dlm, mle->mnamehash);\n\thlist_add_head(&mle->master_hash_node, bucket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_mle",
          "args": [
            "mle",
            "DLM_MLE_BLOCK",
            "dlm",
            "NULL",
            "name",
            "namelen"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "265-317",
          "snippet": "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tmle->dlm = dlm;\n\tmle->type = type;\n\tINIT_HLIST_NODE(&mle->master_hash_node);\n\tINIT_LIST_HEAD(&mle->hb_events);\n\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\tspin_lock_init(&mle->spinlock);\n\tinit_waitqueue_head(&mle->wq);\n\tatomic_set(&mle->woken, 0);\n\tkref_init(&mle->mle_refs);\n\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\tmle->master = O2NM_MAX_NODES;\n\tmle->new_master = O2NM_MAX_NODES;\n\tmle->inuse = 0;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION);\n\n\tif (mle->type == DLM_MLE_MASTER) {\n\t\tBUG_ON(!res);\n\t\tmle->mleres = res;\n\t\tmemcpy(mle->mname, res->lockname.name, res->lockname.len);\n\t\tmle->mnamelen = res->lockname.len;\n\t\tmle->mnamehash = res->lockname.hash;\n\t} else {\n\t\tBUG_ON(!name);\n\t\tmle->mleres = NULL;\n\t\tmemcpy(mle->mname, name, namelen);\n\t\tmle->mnamelen = namelen;\n\t\tmle->mnamehash = dlm_lockid_hash(name, namelen);\n\t}\n\n\tatomic_inc(&dlm->mle_tot_count[mle->type]);\n\tatomic_inc(&dlm->mle_cur_count[mle->type]);\n\n\t/* copy off the node_map and register hb callbacks on our copy */\n\tmemcpy(mle->node_map, dlm->domain_map, sizeof(mle->node_map));\n\tmemcpy(mle->vote_map, dlm->domain_map, sizeof(mle->vote_map));\n\tclear_bit(dlm->node_num, mle->vote_map);\n\tclear_bit(dlm->node_num, mle->node_map);\n\n\t/* attach the mle to the domain node up/down events */\n\t__dlm_mle_attach_hb_events(dlm, mle);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tmle->dlm = dlm;\n\tmle->type = type;\n\tINIT_HLIST_NODE(&mle->master_hash_node);\n\tINIT_LIST_HEAD(&mle->hb_events);\n\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\tspin_lock_init(&mle->spinlock);\n\tinit_waitqueue_head(&mle->wq);\n\tatomic_set(&mle->woken, 0);\n\tkref_init(&mle->mle_refs);\n\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\tmle->master = O2NM_MAX_NODES;\n\tmle->new_master = O2NM_MAX_NODES;\n\tmle->inuse = 0;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION);\n\n\tif (mle->type == DLM_MLE_MASTER) {\n\t\tBUG_ON(!res);\n\t\tmle->mleres = res;\n\t\tmemcpy(mle->mname, res->lockname.name, res->lockname.len);\n\t\tmle->mnamelen = res->lockname.len;\n\t\tmle->mnamehash = res->lockname.hash;\n\t} else {\n\t\tBUG_ON(!name);\n\t\tmle->mleres = NULL;\n\t\tmemcpy(mle->mname, name, namelen);\n\t\tmle->mnamelen = namelen;\n\t\tmle->mnamehash = dlm_lockid_hash(name, namelen);\n\t}\n\n\tatomic_inc(&dlm->mle_tot_count[mle->type]);\n\tatomic_inc(&dlm->mle_cur_count[mle->type]);\n\n\t/* copy off the node_map and register hb callbacks on our copy */\n\tmemcpy(mle->node_map, dlm->domain_map, sizeof(mle->node_map));\n\tmemcpy(mle->vote_map, dlm->domain_map, sizeof(mle->vote_map));\n\tclear_bit(dlm->node_num, mle->vote_map);\n\tclear_bit(dlm->node_num, mle->node_map);\n\n\t/* attach the mle to the domain node up/down events */\n\t__dlm_mle_attach_hb_events(dlm, mle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "dlm_mle_cache",
            "GFP_NOFS"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_mle",
          "args": [
            "dlm",
            "&tmpmle",
            "name",
            "namelen"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "339-359",
          "snippet": "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\n\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_mle_cache",
            "mle"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_set_refmap_bit",
          "args": [
            "dlm",
            "res",
            "request->node_idx"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_set_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "633-642",
          "snippet": "void dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_mle_cache",
            "mle"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_mle_cache",
            "mle"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_mle_cache",
            "mle"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&res->hash_node"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres",
          "args": [
            "dlm",
            "name",
            "namelen",
            "hash"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "221-244",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "name",
            "namelen"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_domain_fully_joined",
          "args": [
            "dlm"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_domain_fully_joined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "380-390",
          "snippet": "int dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_assert_master_worker(struct dlm_work_item *item, void *data);\nstatic void dlm_deref_lockres_worker(struct dlm_work_item *item, void *data);\nstatic struct kmem_cache *dlm_mle_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_master_request_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data)\n{\n\tu8 response = DLM_MASTER_RESP_MAYBE;\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_master_request *request = (struct dlm_master_request *) msg->buf;\n\tstruct dlm_master_list_entry *mle = NULL, *tmpmle = NULL;\n\tchar *name;\n\tunsigned int namelen, hash;\n\tint found, ret;\n\tint set_maybe;\n\tint dispatch_assert = 0;\n\n\tif (!dlm_grab(dlm))\n\t\treturn DLM_MASTER_RESP_NO;\n\n\tif (!dlm_domain_fully_joined(dlm)) {\n\t\tresponse = DLM_MASTER_RESP_NO;\n\t\tgoto send_response;\n\t}\n\n\tname = request->name;\n\tnamelen = request->namelen;\n\thash = dlm_lockid_hash(name, namelen);\n\n\tif (namelen > DLM_LOCKID_NAME_MAX) {\n\t\tresponse = DLM_IVBUFLEN;\n\t\tgoto send_response;\n\t}\n\nway_up_top:\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, namelen, hash);\n\tif (res) {\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\t/* take care of the easy cases up front */\n\t\tspin_lock(&res->spinlock);\n\n\t\t/*\n\t\t * Right after dlm spinlock was released, dlm_thread could have\n\t\t * purged the lockres. Check if lockres got unhashed. If so\n\t\t * start over.\n\t\t */\n\t\tif (hlist_unhashed(&res->hash_node)) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\tgoto way_up_top;\n\t\t}\n\n\t\tif (res->state & (DLM_LOCK_RES_RECOVERING|\n\t\t\t\t  DLM_LOCK_RES_MIGRATING)) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tmlog(0, \"returning DLM_MASTER_RESP_ERROR since res is \"\n\t\t\t     \"being recovered/migrated\\n\");\n\t\t\tresponse = DLM_MASTER_RESP_ERROR;\n\t\t\tif (mle)\n\t\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tgoto send_response;\n\t\t}\n\n\t\tif (res->owner == dlm->node_num) {\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, request->node_idx);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tresponse = DLM_MASTER_RESP_YES;\n\t\t\tif (mle)\n\t\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\n\t\t\t/* this node is the owner.\n\t\t\t * there is some extra work that needs to\n\t\t\t * happen now.  the requesting node has\n\t\t\t * caused all nodes up to this one to\n\t\t\t * create mles.  this node now needs to\n\t\t\t * go back and clean those up. */\n\t\t\tdispatch_assert = 1;\n\t\t\tgoto send_response;\n\t\t} else if (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\t// mlog(0, \"node %u is the master\\n\", res->owner);\n\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t\tif (mle)\n\t\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\t\tgoto send_response;\n\t\t}\n\n\t\t/* ok, there is no owner.  either this node is\n\t\t * being blocked, or it is actively trying to\n\t\t * master this lock. */\n\t\tif (!(res->state & DLM_LOCK_RES_IN_PROGRESS)) {\n\t\t\tmlog(ML_ERROR, \"lock with no owner should be \"\n\t\t\t     \"in-progress!\\n\");\n\t\t\tBUG();\n\t\t}\n\n\t\t// mlog(0, \"lockres is in progress...\\n\");\n\t\tspin_lock(&dlm->master_lock);\n\t\tfound = dlm_find_mle(dlm, &tmpmle, name, namelen);\n\t\tif (!found) {\n\t\t\tmlog(ML_ERROR, \"no mle found for this lock!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tset_maybe = 1;\n\t\tspin_lock(&tmpmle->spinlock);\n\t\tif (tmpmle->type == DLM_MLE_BLOCK) {\n\t\t\t// mlog(0, \"this node is waiting for \"\n\t\t\t// \"lockres to be mastered\\n\");\n\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t} else if (tmpmle->type == DLM_MLE_MIGRATION) {\n\t\t\tmlog(0, \"node %u is master, but trying to migrate to \"\n\t\t\t     \"node %u.\\n\", tmpmle->master, tmpmle->new_master);\n\t\t\tif (tmpmle->master == dlm->node_num) {\n\t\t\t\tmlog(ML_ERROR, \"no owner on lockres, but this \"\n\t\t\t\t     \"node is trying to migrate it to %u?!\\n\",\n\t\t\t\t     tmpmle->new_master);\n\t\t\t\tBUG();\n\t\t\t} else {\n\t\t\t\t/* the real master can respond on its own */\n\t\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t\t}\n\t\t} else if (tmpmle->master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tset_maybe = 0;\n\t\t\tif (tmpmle->master == dlm->node_num) {\n\t\t\t\tresponse = DLM_MASTER_RESP_YES;\n\t\t\t\t/* this node will be the owner.\n\t\t\t\t * go back and clean the mles on any\n\t\t\t\t * other nodes */\n\t\t\t\tdispatch_assert = 1;\n\t\t\t\tdlm_lockres_set_refmap_bit(dlm, res,\n\t\t\t\t\t\t\t   request->node_idx);\n\t\t\t} else\n\t\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t} else {\n\t\t\t// mlog(0, \"this node is attempting to \"\n\t\t\t// \"master lockres\\n\");\n\t\t\tresponse = DLM_MASTER_RESP_MAYBE;\n\t\t}\n\t\tif (set_maybe)\n\t\t\tset_bit(request->node_idx, tmpmle->maybe_map);\n\t\tspin_unlock(&tmpmle->spinlock);\n\n\t\tspin_unlock(&dlm->master_lock);\n\t\tspin_unlock(&res->spinlock);\n\n\t\t/* keep the mle attached to heartbeat events */\n\t\tdlm_put_mle(tmpmle);\n\t\tif (mle)\n\t\t\tkmem_cache_free(dlm_mle_cache, mle);\n\t\tgoto send_response;\n\t}\n\n\t/*\n\t * lockres doesn't exist on this node\n\t * if there is an MLE_BLOCK, return NO\n\t * if there is an MLE_MASTER, return MAYBE\n\t * otherwise, add an MLE_BLOCK, return NO\n\t */\n\tspin_lock(&dlm->master_lock);\n\tfound = dlm_find_mle(dlm, &tmpmle, name, namelen);\n\tif (!found) {\n\t\t/* this lockid has never been seen on this node yet */\n\t\t// mlog(0, \"no mle found\\n\");\n\t\tif (!mle) {\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\tmle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\t\t\tif (!mle) {\n\t\t\t\tresponse = DLM_MASTER_RESP_ERROR;\n\t\t\t\tmlog_errno(-ENOMEM);\n\t\t\t\tgoto send_response;\n\t\t\t}\n\t\t\tgoto way_up_top;\n\t\t}\n\n\t\t// mlog(0, \"this is second time thru, already allocated, \"\n\t\t// \"add the block.\\n\");\n\t\tdlm_init_mle(mle, DLM_MLE_BLOCK, dlm, NULL, name, namelen);\n\t\tset_bit(request->node_idx, mle->maybe_map);\n\t\t__dlm_insert_mle(dlm, mle);\n\t\tresponse = DLM_MASTER_RESP_NO;\n\t} else {\n\t\t// mlog(0, \"mle was found\\n\");\n\t\tset_maybe = 1;\n\t\tspin_lock(&tmpmle->spinlock);\n\t\tif (tmpmle->master == dlm->node_num) {\n\t\t\tmlog(ML_ERROR, \"no lockres, but an mle with this node as master!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tif (tmpmle->type == DLM_MLE_BLOCK)\n\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\telse if (tmpmle->type == DLM_MLE_MIGRATION) {\n\t\t\tmlog(0, \"migration mle was found (%u->%u)\\n\",\n\t\t\t     tmpmle->master, tmpmle->new_master);\n\t\t\t/* real master can respond on its own */\n\t\t\tresponse = DLM_MASTER_RESP_NO;\n\t\t} else\n\t\t\tresponse = DLM_MASTER_RESP_MAYBE;\n\t\tif (set_maybe)\n\t\t\tset_bit(request->node_idx, tmpmle->maybe_map);\n\t\tspin_unlock(&tmpmle->spinlock);\n\t}\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (found) {\n\t\t/* keep the mle attached to heartbeat events */\n\t\tdlm_put_mle(tmpmle);\n\t}\nsend_response:\n\t/*\n\t * __dlm_lookup_lockres() grabbed a reference to this lockres.\n\t * The reference is released by dlm_assert_master_worker() under\n\t * the call to dlm_dispatch_assert_master().  If\n\t * dlm_assert_master_worker() isn't called, we drop it here.\n\t */\n\tif (dispatch_assert) {\n\t\tif (response != DLM_MASTER_RESP_YES)\n\t\t\tmlog(ML_ERROR, \"invalid response %d\\n\", response);\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"bad lockres while trying to assert!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tmlog(0, \"%u is the owner of %.*s, cleaning everyone else\\n\",\n\t\t\t     dlm->node_num, res->lockname.len, res->lockname.name);\n\t\tspin_lock(&res->spinlock);\n\t\tret = dlm_dispatch_assert_master(dlm, res, 0, request->node_idx,\n\t\t\t\t\t\t DLM_ASSERT_MASTER_MLE_CLEANUP);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"failed to dispatch assert master work\\n\");\n\t\t\tresponse = DLM_MASTER_RESP_ERROR;\n\t\t\tdlm_lockres_put(res);\n\t\t} else\n\t\t\t__dlm_lockres_grab_inflight_worker(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t} else {\n\t\tif (res)\n\t\t\tdlm_lockres_put(res);\n\t}\n\n\tdlm_put(dlm);\n\treturn response;\n}"
  },
  {
    "function_name": "dlm_do_master_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "1322-1405",
    "snippet": "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to)\n{\n\tstruct dlm_ctxt *dlm = mle->dlm;\n\tstruct dlm_master_request request;\n\tint ret, response=0, resend;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.node_idx = dlm->node_num;\n\n\tBUG_ON(mle->type == DLM_MLE_MIGRATION);\n\n\trequest.namelen = (u8)mle->mnamelen;\n\tmemcpy(request.name, mle->mname, request.namelen);\n\nagain:\n\tret = o2net_send_message(DLM_MASTER_REQUEST_MSG, dlm->key, &request,\n\t\t\t\t sizeof(request), to, &response);\n\tif (ret < 0)  {\n\t\tif (ret == -ESRCH) {\n\t\t\t/* should never happen */\n\t\t\tmlog(ML_ERROR, \"TCP stack not ready!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -EINVAL) {\n\t\t\tmlog(ML_ERROR, \"bad args passed to o2net!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -ENOMEM) {\n\t\t\tmlog(ML_ERROR, \"out of memory while trying to send \"\n\t\t\t     \"network message!  retrying\\n\");\n\t\t\t/* this is totally crude */\n\t\t\tmsleep(50);\n\t\t\tgoto again;\n\t\t} else if (!dlm_is_host_down(ret)) {\n\t\t\t/* not a network error. bad. */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"unhandled error!\");\n\t\t\tBUG();\n\t\t}\n\t\t/* all other errors should be network errors,\n\t\t * and likely indicate node death */\n\t\tmlog(ML_ERROR, \"link to %d went down!\\n\", to);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tresend = 0;\n\tspin_lock(&mle->spinlock);\n\tswitch (response) {\n\t\tcase DLM_MASTER_RESP_YES:\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tmlog(0, \"node %u is the master, response=YES\\n\", to);\n\t\t\tmlog(0, \"%s:%.*s: master node %u now knows I have a \"\n\t\t\t     \"reference\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, to);\n\t\t\tmle->master = to;\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_NO:\n\t\t\tmlog(0, \"node %u not master, response=NO\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_MAYBE:\n\t\t\tmlog(0, \"node %u not master, response=MAYBE\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tset_bit(to, mle->maybe_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_ERROR:\n\t\t\tmlog(0, \"node %u hit an error, resending\\n\", to);\n\t\t\tresend = 1;\n\t\t\tresponse = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR, \"bad response! %u\\n\", response);\n\t\t\tBUG();\n\t}\n\tspin_unlock(&mle->spinlock);\n\tif (resend) {\n\t\t/* this is also totally crude */\n\t\tmsleep(50);\n\t\tgoto again;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "50"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bad response! %u\\n\"",
            "response"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "to",
            "mle->maybe_map"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: master node %u now knows I have a \"\n\t\t\t     \"reference\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "to"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"unhandled error!\""
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "50"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_MASTER_REQUEST_MSG",
            "dlm->key",
            "&request",
            "sizeof(request)",
            "to",
            "&response"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "request.name",
            "mle->mname",
            "request.namelen"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mle->type == DLM_MLE_MIGRATION"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&request",
            "0",
            "sizeof(request)"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to)\n{\n\tstruct dlm_ctxt *dlm = mle->dlm;\n\tstruct dlm_master_request request;\n\tint ret, response=0, resend;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.node_idx = dlm->node_num;\n\n\tBUG_ON(mle->type == DLM_MLE_MIGRATION);\n\n\trequest.namelen = (u8)mle->mnamelen;\n\tmemcpy(request.name, mle->mname, request.namelen);\n\nagain:\n\tret = o2net_send_message(DLM_MASTER_REQUEST_MSG, dlm->key, &request,\n\t\t\t\t sizeof(request), to, &response);\n\tif (ret < 0)  {\n\t\tif (ret == -ESRCH) {\n\t\t\t/* should never happen */\n\t\t\tmlog(ML_ERROR, \"TCP stack not ready!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -EINVAL) {\n\t\t\tmlog(ML_ERROR, \"bad args passed to o2net!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -ENOMEM) {\n\t\t\tmlog(ML_ERROR, \"out of memory while trying to send \"\n\t\t\t     \"network message!  retrying\\n\");\n\t\t\t/* this is totally crude */\n\t\t\tmsleep(50);\n\t\t\tgoto again;\n\t\t} else if (!dlm_is_host_down(ret)) {\n\t\t\t/* not a network error. bad. */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"unhandled error!\");\n\t\t\tBUG();\n\t\t}\n\t\t/* all other errors should be network errors,\n\t\t * and likely indicate node death */\n\t\tmlog(ML_ERROR, \"link to %d went down!\\n\", to);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tresend = 0;\n\tspin_lock(&mle->spinlock);\n\tswitch (response) {\n\t\tcase DLM_MASTER_RESP_YES:\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tmlog(0, \"node %u is the master, response=YES\\n\", to);\n\t\t\tmlog(0, \"%s:%.*s: master node %u now knows I have a \"\n\t\t\t     \"reference\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, to);\n\t\t\tmle->master = to;\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_NO:\n\t\t\tmlog(0, \"node %u not master, response=NO\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_MAYBE:\n\t\t\tmlog(0, \"node %u not master, response=MAYBE\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tset_bit(to, mle->maybe_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_ERROR:\n\t\t\tmlog(0, \"node %u hit an error, resending\\n\", to);\n\t\t\tresend = 1;\n\t\t\tresponse = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR, \"bad response! %u\\n\", response);\n\t\t\tBUG();\n\t}\n\tspin_unlock(&mle->spinlock);\n\tif (resend) {\n\t\t/* this is also totally crude */\n\t\tmsleep(50);\n\t\tgoto again;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_restart_lock_mastery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "1222-1309",
    "snippet": "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked)\n{\n\tstruct dlm_bitmap_diff_iter bdi;\n\tenum dlm_node_state_change sc;\n\tint node;\n\tint ret = 0;\n\n\tmlog(0, \"something happened such that the \"\n\t     \"master process may need to be restarted!\\n\");\n\n\tassert_spin_locked(&mle->spinlock);\n\n\tdlm_bitmap_diff_iter_init(&bdi, mle->vote_map, mle->node_map);\n\tnode = dlm_bitmap_diff_iter_next(&bdi, &sc);\n\twhile (node >= 0) {\n\t\tif (sc == NODE_UP) {\n\t\t\t/* a node came up.  clear any old vote from\n\t\t\t * the response map and set it in the vote map\n\t\t\t * then restart the mastery. */\n\t\t\tmlog(ML_NOTICE, \"node %d up while restarting\\n\", node);\n\n\t\t\t/* redo the master request, but only for the new node */\n\t\t\tmlog(0, \"sending request to new node\\n\");\n\t\t\tclear_bit(node, mle->response_map);\n\t\t\tset_bit(node, mle->vote_map);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"node down! %d\\n\", node);\n\t\t\tif (blocked) {\n\t\t\t\tint lowest = find_next_bit(mle->maybe_map,\n\t\t\t\t\t\t       O2NM_MAX_NODES, 0);\n\n\t\t\t\t/* act like it was never there */\n\t\t\t\tclear_bit(node, mle->maybe_map);\n\n\t\t\t       \tif (node == lowest) {\n\t\t\t\t\tmlog(0, \"expected master %u died\"\n\t\t\t\t\t    \" while this node was blocked \"\n\t\t\t\t\t    \"waiting on it!\\n\", node);\n\t\t\t\t\tlowest = find_next_bit(mle->maybe_map,\n\t\t\t\t\t\t       \tO2NM_MAX_NODES,\n\t\t\t\t\t\t       \tlowest+1);\n\t\t\t\t\tif (lowest < O2NM_MAX_NODES) {\n\t\t\t\t\t\tmlog(0, \"%s:%.*s:still \"\n\t\t\t\t\t\t     \"blocked. waiting on %u \"\n\t\t\t\t\t\t     \"now\\n\", dlm->name,\n\t\t\t\t\t\t     res->lockname.len,\n\t\t\t\t\t\t     res->lockname.name,\n\t\t\t\t\t\t     lowest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* mle is an MLE_BLOCK, but\n\t\t\t\t\t\t * there is now nothing left to\n\t\t\t\t\t\t * block on.  we need to return\n\t\t\t\t\t\t * all the way back out and try\n\t\t\t\t\t\t * again with an MLE_MASTER.\n\t\t\t\t\t\t * dlm_do_local_recovery_cleanup\n\t\t\t\t\t\t * has already run, so the mle\n\t\t\t\t\t\t * refcount is ok */\n\t\t\t\t\t\tmlog(0, \"%s:%.*s: no \"\n\t\t\t\t\t\t     \"longer blocking. try to \"\n\t\t\t\t\t\t     \"master this here\\n\",\n\t\t\t\t\t\t     dlm->name,\n\t\t\t\t\t\t     res->lockname.len,\n\t\t\t\t\t\t     res->lockname.name);\n\t\t\t\t\t\tmle->type = DLM_MLE_MASTER;\n\t\t\t\t\t\tmle->mleres = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* now blank out everything, as if we had never\n\t\t\t * contacted anyone */\n\t\t\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\t\t\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\t\t\t/* reset the vote_map to the current node_map */\n\t\t\tmemcpy(mle->vote_map, mle->node_map,\n\t\t\t       sizeof(mle->node_map));\n\t\t\t/* put myself into the maybe map */\n\t\t\tif (mle->type != DLM_MLE_BLOCK)\n\t\t\t\tset_bit(dlm->node_num, mle->maybe_map);\n\t\t}\n\t\tret = -EAGAIN;\n\t\tnode = dlm_bitmap_diff_iter_next(&bdi, &sc);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
      "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_bitmap_diff_iter_next",
          "args": [
            "&bdi",
            "&sc"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_bitmap_diff_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1196-1219",
          "snippet": "static int dlm_bitmap_diff_iter_next(struct dlm_bitmap_diff_iter *iter,\n\t\t\t\t     enum dlm_node_state_change *state)\n{\n\tint bit;\n\n\tif (iter->curnode >= O2NM_MAX_NODES)\n\t\treturn -ENOENT;\n\n\tbit = find_next_bit(iter->diff_bm, O2NM_MAX_NODES,\n\t\t\t    iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\n\t/* if it was there in the original then this node died */\n\tif (test_bit(bit, iter->orig_bm))\n\t\t*state = NODE_DOWN;\n\telse\n\t\t*state = NODE_UP;\n\n\titer->curnode = bit;\n\treturn bit;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_bitmap_diff_iter_next(struct dlm_bitmap_diff_iter *iter,\n\t\t\t\t     enum dlm_node_state_change *state)\n{\n\tint bit;\n\n\tif (iter->curnode >= O2NM_MAX_NODES)\n\t\treturn -ENOENT;\n\n\tbit = find_next_bit(iter->diff_bm, O2NM_MAX_NODES,\n\t\t\t    iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\n\t/* if it was there in the original then this node died */\n\tif (test_bit(bit, iter->orig_bm))\n\t\t*state = NODE_DOWN;\n\telse\n\t\t*state = NODE_UP;\n\n\titer->curnode = bit;\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "dlm->node_num",
            "mle->maybe_map"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mle->vote_map",
            "mle->node_map",
            "sizeof(mle->node_map)"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mle->response_map",
            "0",
            "sizeof(mle->response_map)"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mle->maybe_map",
            "0",
            "sizeof(mle->maybe_map)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: no \"\n\t\t\t\t\t\t     \"longer blocking. try to \"\n\t\t\t\t\t\t     \"master this here\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s:still \"\n\t\t\t\t\t\t     \"blocked. waiting on %u \"\n\t\t\t\t\t\t     \"now\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "lowest"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "mle->maybe_map",
            "O2NM_MAX_NODES",
            "lowest+1"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"expected master %u died\"\n\t\t\t\t\t    \" while this node was blocked \"\n\t\t\t\t\t    \"waiting on it!\\n\"",
            "node"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "node",
            "mle->maybe_map"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"sending request to new node\\n\""
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_bitmap_diff_iter_init",
          "args": [
            "&bdi",
            "mle->vote_map",
            "mle->node_map"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_bitmap_diff_iter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1178-1194",
          "snippet": "static void dlm_bitmap_diff_iter_init(struct dlm_bitmap_diff_iter *iter,\n\t\t\t\t      unsigned long *orig_bm,\n\t\t\t\t      unsigned long *cur_bm)\n{\n\tunsigned long p1, p2;\n\tint i;\n\n\titer->curnode = -1;\n\titer->orig_bm = orig_bm;\n\titer->cur_bm = cur_bm;\n\n\tfor (i = 0; i < BITS_TO_LONGS(O2NM_MAX_NODES); i++) {\n       \t\tp1 = *(iter->orig_bm + i);\n\t       \tp2 = *(iter->cur_bm + i);\n\t\titer->diff_bm[i] = (p1 & ~p2) | (p2 & ~p1);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_bitmap_diff_iter_init(struct dlm_bitmap_diff_iter *iter,\n\t\t\t\t      unsigned long *orig_bm,\n\t\t\t\t      unsigned long *cur_bm)\n{\n\tunsigned long p1, p2;\n\tint i;\n\n\titer->curnode = -1;\n\titer->orig_bm = orig_bm;\n\titer->cur_bm = cur_bm;\n\n\tfor (i = 0; i < BITS_TO_LONGS(O2NM_MAX_NODES); i++) {\n       \t\tp1 = *(iter->orig_bm + i);\n\t       \tp2 = *(iter->cur_bm + i);\n\t\titer->diff_bm[i] = (p1 & ~p2) | (p2 & ~p1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&mle->spinlock"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked)\n{\n\tstruct dlm_bitmap_diff_iter bdi;\n\tenum dlm_node_state_change sc;\n\tint node;\n\tint ret = 0;\n\n\tmlog(0, \"something happened such that the \"\n\t     \"master process may need to be restarted!\\n\");\n\n\tassert_spin_locked(&mle->spinlock);\n\n\tdlm_bitmap_diff_iter_init(&bdi, mle->vote_map, mle->node_map);\n\tnode = dlm_bitmap_diff_iter_next(&bdi, &sc);\n\twhile (node >= 0) {\n\t\tif (sc == NODE_UP) {\n\t\t\t/* a node came up.  clear any old vote from\n\t\t\t * the response map and set it in the vote map\n\t\t\t * then restart the mastery. */\n\t\t\tmlog(ML_NOTICE, \"node %d up while restarting\\n\", node);\n\n\t\t\t/* redo the master request, but only for the new node */\n\t\t\tmlog(0, \"sending request to new node\\n\");\n\t\t\tclear_bit(node, mle->response_map);\n\t\t\tset_bit(node, mle->vote_map);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"node down! %d\\n\", node);\n\t\t\tif (blocked) {\n\t\t\t\tint lowest = find_next_bit(mle->maybe_map,\n\t\t\t\t\t\t       O2NM_MAX_NODES, 0);\n\n\t\t\t\t/* act like it was never there */\n\t\t\t\tclear_bit(node, mle->maybe_map);\n\n\t\t\t       \tif (node == lowest) {\n\t\t\t\t\tmlog(0, \"expected master %u died\"\n\t\t\t\t\t    \" while this node was blocked \"\n\t\t\t\t\t    \"waiting on it!\\n\", node);\n\t\t\t\t\tlowest = find_next_bit(mle->maybe_map,\n\t\t\t\t\t\t       \tO2NM_MAX_NODES,\n\t\t\t\t\t\t       \tlowest+1);\n\t\t\t\t\tif (lowest < O2NM_MAX_NODES) {\n\t\t\t\t\t\tmlog(0, \"%s:%.*s:still \"\n\t\t\t\t\t\t     \"blocked. waiting on %u \"\n\t\t\t\t\t\t     \"now\\n\", dlm->name,\n\t\t\t\t\t\t     res->lockname.len,\n\t\t\t\t\t\t     res->lockname.name,\n\t\t\t\t\t\t     lowest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* mle is an MLE_BLOCK, but\n\t\t\t\t\t\t * there is now nothing left to\n\t\t\t\t\t\t * block on.  we need to return\n\t\t\t\t\t\t * all the way back out and try\n\t\t\t\t\t\t * again with an MLE_MASTER.\n\t\t\t\t\t\t * dlm_do_local_recovery_cleanup\n\t\t\t\t\t\t * has already run, so the mle\n\t\t\t\t\t\t * refcount is ok */\n\t\t\t\t\t\tmlog(0, \"%s:%.*s: no \"\n\t\t\t\t\t\t     \"longer blocking. try to \"\n\t\t\t\t\t\t     \"master this here\\n\",\n\t\t\t\t\t\t     dlm->name,\n\t\t\t\t\t\t     res->lockname.len,\n\t\t\t\t\t\t     res->lockname.name);\n\t\t\t\t\t\tmle->type = DLM_MLE_MASTER;\n\t\t\t\t\t\tmle->mleres = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* now blank out everything, as if we had never\n\t\t\t * contacted anyone */\n\t\t\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\t\t\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\t\t\t/* reset the vote_map to the current node_map */\n\t\t\tmemcpy(mle->vote_map, mle->node_map,\n\t\t\t       sizeof(mle->node_map));\n\t\t\t/* put myself into the maybe map */\n\t\t\tif (mle->type != DLM_MLE_BLOCK)\n\t\t\t\tset_bit(dlm->node_num, mle->maybe_map);\n\t\t}\n\t\tret = -EAGAIN;\n\t\tnode = dlm_bitmap_diff_iter_next(&bdi, &sc);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_bitmap_diff_iter_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "1196-1219",
    "snippet": "static int dlm_bitmap_diff_iter_next(struct dlm_bitmap_diff_iter *iter,\n\t\t\t\t     enum dlm_node_state_change *state)\n{\n\tint bit;\n\n\tif (iter->curnode >= O2NM_MAX_NODES)\n\t\treturn -ENOENT;\n\n\tbit = find_next_bit(iter->diff_bm, O2NM_MAX_NODES,\n\t\t\t    iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\n\t/* if it was there in the original then this node died */\n\tif (test_bit(bit, iter->orig_bm))\n\t\t*state = NODE_DOWN;\n\telse\n\t\t*state = NODE_UP;\n\n\titer->curnode = bit;\n\treturn bit;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "bit",
            "iter->orig_bm"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "iter->diff_bm",
            "O2NM_MAX_NODES",
            "iter->curnode+1"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_bitmap_diff_iter_next(struct dlm_bitmap_diff_iter *iter,\n\t\t\t\t     enum dlm_node_state_change *state)\n{\n\tint bit;\n\n\tif (iter->curnode >= O2NM_MAX_NODES)\n\t\treturn -ENOENT;\n\n\tbit = find_next_bit(iter->diff_bm, O2NM_MAX_NODES,\n\t\t\t    iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\n\t/* if it was there in the original then this node died */\n\tif (test_bit(bit, iter->orig_bm))\n\t\t*state = NODE_DOWN;\n\telse\n\t\t*state = NODE_UP;\n\n\titer->curnode = bit;\n\treturn bit;\n}"
  },
  {
    "function_name": "dlm_bitmap_diff_iter_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "1178-1194",
    "snippet": "static void dlm_bitmap_diff_iter_init(struct dlm_bitmap_diff_iter *iter,\n\t\t\t\t      unsigned long *orig_bm,\n\t\t\t\t      unsigned long *cur_bm)\n{\n\tunsigned long p1, p2;\n\tint i;\n\n\titer->curnode = -1;\n\titer->orig_bm = orig_bm;\n\titer->cur_bm = cur_bm;\n\n\tfor (i = 0; i < BITS_TO_LONGS(O2NM_MAX_NODES); i++) {\n       \t\tp1 = *(iter->orig_bm + i);\n\t       \tp2 = *(iter->cur_bm + i);\n\t\titer->diff_bm[i] = (p1 & ~p2) | (p2 & ~p1);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "O2NM_MAX_NODES"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_bitmap_diff_iter_init(struct dlm_bitmap_diff_iter *iter,\n\t\t\t\t      unsigned long *orig_bm,\n\t\t\t\t      unsigned long *cur_bm)\n{\n\tunsigned long p1, p2;\n\tint i;\n\n\titer->curnode = -1;\n\titer->orig_bm = orig_bm;\n\titer->cur_bm = cur_bm;\n\n\tfor (i = 0; i < BITS_TO_LONGS(O2NM_MAX_NODES); i++) {\n       \t\tp1 = *(iter->orig_bm + i);\n\t       \tp2 = *(iter->cur_bm + i);\n\t\titer->diff_bm[i] = (p1 & ~p2) | (p2 & ~p1);\n\t}\n}"
  },
  {
    "function_name": "dlm_wait_for_lock_mastery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "1010-1161",
    "snippet": "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked)\n{\n\tu8 m;\n\tint ret, bit;\n\tint map_changed, voting_done;\n\tint assert, sleep;\n\nrecheck:\n\tret = 0;\n\tassert = 0;\n\n\t/* check if another node has already become the owner */\n\tspin_lock(&res->spinlock);\n\tif (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"%s:%.*s: owner is suddenly %u\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, res->owner);\n\t\tspin_unlock(&res->spinlock);\n\t\t/* this will cause the master to re-assert across\n\t\t * the whole cluster, freeing up mles */\n\t\tif (res->owner != dlm->node_num) {\n\t\t\tret = dlm_do_master_request(res, mle, res->owner);\n\t\t\tif (ret < 0) {\n\t\t\t\t/* give recovery a chance to run */\n\t\t\t\tmlog(ML_ERROR, \"link to %u went down?: %d\\n\", res->owner, ret);\n\t\t\t\tmsleep(500);\n\t\t\t\tgoto recheck;\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tspin_lock(&mle->spinlock);\n\tm = mle->master;\n\tmap_changed = (memcmp(mle->vote_map, mle->node_map,\n\t\t\t      sizeof(mle->vote_map)) != 0);\n\tvoting_done = (memcmp(mle->vote_map, mle->response_map,\n\t\t\t     sizeof(mle->vote_map)) == 0);\n\n\t/* restart if we hit any errors */\n\tif (map_changed) {\n\t\tint b;\n\t\tmlog(0, \"%s: %.*s: node map changed, restarting\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tret = dlm_restart_lock_mastery(dlm, res, mle, *blocked);\n\t\tb = (mle->type == DLM_MLE_BLOCK);\n\t\tif ((*blocked && !b) || (!*blocked && b)) {\n\t\t\tmlog(0, \"%s:%.*s: status change: old=%d new=%d\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     *blocked, b);\n\t\t\t*blocked = b;\n\t\t}\n\t\tspin_unlock(&mle->spinlock);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t\tmlog(0, \"%s:%.*s: restart lock mastery succeeded, \"\n\t\t     \"rechecking now\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name);\n\t\tgoto recheck;\n\t} else {\n\t\tif (!voting_done) {\n\t\t\tmlog(0, \"map not changed and voting not done \"\n\t\t\t     \"for %s:%.*s\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t}\n\t}\n\n\tif (m != O2NM_MAX_NODES) {\n\t\t/* another node has done an assert!\n\t\t * all done! */\n\t\tsleep = 0;\n\t} else {\n\t\tsleep = 1;\n\t\t/* have all nodes responded? */\n\t\tif (voting_done && !*blocked) {\n\t\t\tbit = find_next_bit(mle->maybe_map, O2NM_MAX_NODES, 0);\n\t\t\tif (dlm->node_num <= bit) {\n\t\t\t\t/* my node number is lowest.\n\t\t\t \t * now tell other nodes that I am\n\t\t\t\t * mastering this. */\n\t\t\t\tmle->master = dlm->node_num;\n\t\t\t\t/* ref was grabbed in get_lock_resource\n\t\t\t\t * will be dropped in dlmlock_master */\n\t\t\t\tassert = 1;\n\t\t\t\tsleep = 0;\n\t\t\t}\n\t\t\t/* if voting is done, but we have not received\n\t\t\t * an assert master yet, we must sleep */\n\t\t}\n\t}\n\n\tspin_unlock(&mle->spinlock);\n\n\t/* sleep if we haven't finished voting yet */\n\tif (sleep) {\n\t\tunsigned long timeo = msecs_to_jiffies(DLM_MASTERY_TIMEOUT_MS);\n\n\t\t/*\n\t\tif (atomic_read(&mle->mle_refs.refcount) < 2)\n\t\t\tmlog(ML_ERROR, \"mle (%p) refs=%d, name=%.*s\\n\", mle,\n\t\t\tatomic_read(&mle->mle_refs.refcount),\n\t\t\tres->lockname.len, res->lockname.name);\n\t\t*/\n\t\tatomic_set(&mle->woken, 0);\n\t\t(void)wait_event_timeout(mle->wq,\n\t\t\t\t\t (atomic_read(&mle->woken) == 1),\n\t\t\t\t\t timeo);\n\t\tif (res->owner == O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s:%.*s: waiting again\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\tgoto recheck;\n\t\t}\n\t\tmlog(0, \"done waiting, master is %u\\n\", res->owner);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tret = 0;   /* done */\n\tif (assert) {\n\t\tm = dlm->node_num;\n\t\tmlog(0, \"about to master %.*s here, this=%u\\n\",\n\t\t     res->lockname.len, res->lockname.name, m);\n\t\tret = dlm_do_assert_master(dlm, res, mle->vote_map, 0);\n\t\tif (ret) {\n\t\t\t/* This is a failure in the network path,\n\t\t\t * not in the response to the assert_master\n\t\t\t * (any nonzero response is a BUG on this node).\n\t\t\t * Most likely a socket just got disconnected\n\t\t\t * due to node death. */\n\t\t\tmlog_errno(ret);\n\t\t}\n\t\t/* no longer need to restart lock mastery.\n\t\t * all living nodes have been contacted. */\n\t\tret = 0;\n\t}\n\n\t/* set the lockres owner */\n\tspin_lock(&res->spinlock);\n\t/* mastery reference obtained either during\n\t * assert_master_handler or in get_lock_resource */\n\tdlm_change_lockres_owner(dlm, res, m);\n\tspin_unlock(&res->spinlock);\n\nleave:\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_MASTERY_TIMEOUT_MS   5000"
    ],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
      "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_change_lockres_owner",
          "args": [
            "dlm",
            "res",
            "m"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_change_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1140-1148",
          "snippet": "static inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_do_assert_master",
          "args": [
            "dlm",
            "res",
            "mle->vote_map",
            "0"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_assert_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1670-1768",
          "snippet": "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags)\n{\n\tstruct dlm_assert_master assert;\n\tint to, tmpret;\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\tint reassert;\n\tconst char *lockname = res->lockname.name;\n\tunsigned int namelen = res->lockname.len;\n\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tspin_lock(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\nagain:\n\treassert = 0;\n\n\t/* note that if this nodemap is empty, it returns 0 */\n\tdlm_node_iter_init(nodemap, &iter);\n\twhile ((to = dlm_node_iter_next(&iter)) >= 0) {\n\t\tint r = 0;\n\t\tstruct dlm_master_list_entry *mle = NULL;\n\n\t\tmlog(0, \"sending assert master to %d (%.*s)\\n\", to,\n\t\t     namelen, lockname);\n\t\tmemset(&assert, 0, sizeof(assert));\n\t\tassert.node_idx = dlm->node_num;\n\t\tassert.namelen = namelen;\n\t\tmemcpy(assert.name, lockname, namelen);\n\t\tassert.flags = cpu_to_be32(flags);\n\n\t\ttmpret = o2net_send_message(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\t    &assert, sizeof(assert), to, &r);\n\t\tif (tmpret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", tmpret,\n\t\t\t     DLM_ASSERT_MASTER_MSG, dlm->key, to);\n\t\t\tif (!dlm_is_host_down(tmpret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", tmpret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* a node died.  finish out the rest of the nodes. */\n\t\t\tmlog(0, \"link to %d went down!\\n\", to);\n\t\t\t/* any nonzero status return will do */\n\t\t\tret = tmpret;\n\t\t\tr = 0;\n\t\t} else if (r < 0) {\n\t\t\t/* ok, something horribly messed.  kill thyself. */\n\t\t\tmlog(ML_ERROR,\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\", namelen, lockname, to, r);\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tspin_lock(&dlm->master_lock);\n\t\t\tif (dlm_find_mle(dlm, &mle, (char *)lockname,\n\t\t\t\t\t namelen)) {\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t}\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT &&\n\t\t    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {\n\t\t\t\tmlog(ML_ERROR, \"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\",\n\t\t\t\t     namelen, lockname, to);\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT) {\n\t\t\tmlog(0, \"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\treassert = 1;\n\t\t}\n\t\tif (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {\n\t\t\tmlog(0, \"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, to);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (reassert)\n\t\tgoto again;\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags)\n{\n\tstruct dlm_assert_master assert;\n\tint to, tmpret;\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\tint reassert;\n\tconst char *lockname = res->lockname.name;\n\tunsigned int namelen = res->lockname.len;\n\n\tBUG_ON(namelen > O2NM_MAX_NAME_LEN);\n\n\tspin_lock(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\nagain:\n\treassert = 0;\n\n\t/* note that if this nodemap is empty, it returns 0 */\n\tdlm_node_iter_init(nodemap, &iter);\n\twhile ((to = dlm_node_iter_next(&iter)) >= 0) {\n\t\tint r = 0;\n\t\tstruct dlm_master_list_entry *mle = NULL;\n\n\t\tmlog(0, \"sending assert master to %d (%.*s)\\n\", to,\n\t\t     namelen, lockname);\n\t\tmemset(&assert, 0, sizeof(assert));\n\t\tassert.node_idx = dlm->node_num;\n\t\tassert.namelen = namelen;\n\t\tmemcpy(assert.name, lockname, namelen);\n\t\tassert.flags = cpu_to_be32(flags);\n\n\t\ttmpret = o2net_send_message(DLM_ASSERT_MASTER_MSG, dlm->key,\n\t\t\t\t\t    &assert, sizeof(assert), to, &r);\n\t\tif (tmpret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", tmpret,\n\t\t\t     DLM_ASSERT_MASTER_MSG, dlm->key, to);\n\t\t\tif (!dlm_is_host_down(tmpret)) {\n\t\t\t\tmlog(ML_ERROR, \"unhandled error=%d!\\n\", tmpret);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* a node died.  finish out the rest of the nodes. */\n\t\t\tmlog(0, \"link to %d went down!\\n\", to);\n\t\t\t/* any nonzero status return will do */\n\t\t\tret = tmpret;\n\t\t\tr = 0;\n\t\t} else if (r < 0) {\n\t\t\t/* ok, something horribly messed.  kill thyself. */\n\t\t\tmlog(ML_ERROR,\"during assert master of %.*s to %u, \"\n\t\t\t     \"got %d.\\n\", namelen, lockname, to, r);\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tspin_lock(&dlm->master_lock);\n\t\t\tif (dlm_find_mle(dlm, &mle, (char *)lockname,\n\t\t\t\t\t namelen)) {\n\t\t\t\tdlm_print_one_mle(mle);\n\t\t\t\t__dlm_put_mle(mle);\n\t\t\t}\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tBUG();\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT &&\n\t\t    !(r & DLM_ASSERT_RESPONSE_MASTERY_REF)) {\n\t\t\t\tmlog(ML_ERROR, \"%.*s: very strange, \"\n\t\t\t\t     \"master MLE but no lockres on %u\\n\",\n\t\t\t\t     namelen, lockname, to);\n\t\t}\n\n\t\tif (r & DLM_ASSERT_RESPONSE_REASSERT) {\n\t\t\tmlog(0, \"%.*s: node %u create mles on other \"\n\t\t\t     \"nodes and requests a re-assert\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\treassert = 1;\n\t\t}\n\t\tif (r & DLM_ASSERT_RESPONSE_MASTERY_REF) {\n\t\t\tmlog(0, \"%.*s: node %u has a reference to this \"\n\t\t\t     \"lockres, set the bit in the refmap\\n\",\n\t\t\t     namelen, lockname, to);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, to);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n\tif (reassert)\n\t\tgoto again;\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_SETREF_INPROG;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"about to master %.*s here, this=%u\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "m"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"done waiting, master is %u\\n\"",
            "res->owner"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: waiting again\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "mle->wq",
            "(atomic_read(&mle->woken) == 1)",
            "timeo"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mle->woken"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mle->woken",
            "0"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "DLM_MASTERY_TIMEOUT_MS"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "mle->maybe_map",
            "O2NM_MAX_NODES",
            "0"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"map not changed and voting not done \"\n\t\t\t     \"for %s:%.*s\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: restart lock mastery succeeded, \"\n\t\t     \"rechecking now\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: status change: old=%d new=%d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "*blocked",
            "b"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_restart_lock_mastery",
          "args": [
            "dlm",
            "res",
            "mle",
            "*blocked"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_restart_lock_mastery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1222-1309",
          "snippet": "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked)\n{\n\tstruct dlm_bitmap_diff_iter bdi;\n\tenum dlm_node_state_change sc;\n\tint node;\n\tint ret = 0;\n\n\tmlog(0, \"something happened such that the \"\n\t     \"master process may need to be restarted!\\n\");\n\n\tassert_spin_locked(&mle->spinlock);\n\n\tdlm_bitmap_diff_iter_init(&bdi, mle->vote_map, mle->node_map);\n\tnode = dlm_bitmap_diff_iter_next(&bdi, &sc);\n\twhile (node >= 0) {\n\t\tif (sc == NODE_UP) {\n\t\t\t/* a node came up.  clear any old vote from\n\t\t\t * the response map and set it in the vote map\n\t\t\t * then restart the mastery. */\n\t\t\tmlog(ML_NOTICE, \"node %d up while restarting\\n\", node);\n\n\t\t\t/* redo the master request, but only for the new node */\n\t\t\tmlog(0, \"sending request to new node\\n\");\n\t\t\tclear_bit(node, mle->response_map);\n\t\t\tset_bit(node, mle->vote_map);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"node down! %d\\n\", node);\n\t\t\tif (blocked) {\n\t\t\t\tint lowest = find_next_bit(mle->maybe_map,\n\t\t\t\t\t\t       O2NM_MAX_NODES, 0);\n\n\t\t\t\t/* act like it was never there */\n\t\t\t\tclear_bit(node, mle->maybe_map);\n\n\t\t\t       \tif (node == lowest) {\n\t\t\t\t\tmlog(0, \"expected master %u died\"\n\t\t\t\t\t    \" while this node was blocked \"\n\t\t\t\t\t    \"waiting on it!\\n\", node);\n\t\t\t\t\tlowest = find_next_bit(mle->maybe_map,\n\t\t\t\t\t\t       \tO2NM_MAX_NODES,\n\t\t\t\t\t\t       \tlowest+1);\n\t\t\t\t\tif (lowest < O2NM_MAX_NODES) {\n\t\t\t\t\t\tmlog(0, \"%s:%.*s:still \"\n\t\t\t\t\t\t     \"blocked. waiting on %u \"\n\t\t\t\t\t\t     \"now\\n\", dlm->name,\n\t\t\t\t\t\t     res->lockname.len,\n\t\t\t\t\t\t     res->lockname.name,\n\t\t\t\t\t\t     lowest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* mle is an MLE_BLOCK, but\n\t\t\t\t\t\t * there is now nothing left to\n\t\t\t\t\t\t * block on.  we need to return\n\t\t\t\t\t\t * all the way back out and try\n\t\t\t\t\t\t * again with an MLE_MASTER.\n\t\t\t\t\t\t * dlm_do_local_recovery_cleanup\n\t\t\t\t\t\t * has already run, so the mle\n\t\t\t\t\t\t * refcount is ok */\n\t\t\t\t\t\tmlog(0, \"%s:%.*s: no \"\n\t\t\t\t\t\t     \"longer blocking. try to \"\n\t\t\t\t\t\t     \"master this here\\n\",\n\t\t\t\t\t\t     dlm->name,\n\t\t\t\t\t\t     res->lockname.len,\n\t\t\t\t\t\t     res->lockname.name);\n\t\t\t\t\t\tmle->type = DLM_MLE_MASTER;\n\t\t\t\t\t\tmle->mleres = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* now blank out everything, as if we had never\n\t\t\t * contacted anyone */\n\t\t\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\t\t\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\t\t\t/* reset the vote_map to the current node_map */\n\t\t\tmemcpy(mle->vote_map, mle->node_map,\n\t\t\t       sizeof(mle->node_map));\n\t\t\t/* put myself into the maybe map */\n\t\t\tif (mle->type != DLM_MLE_BLOCK)\n\t\t\t\tset_bit(dlm->node_num, mle->maybe_map);\n\t\t}\n\t\tret = -EAGAIN;\n\t\tnode = dlm_bitmap_diff_iter_next(&bdi, &sc);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
            "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked)\n{\n\tstruct dlm_bitmap_diff_iter bdi;\n\tenum dlm_node_state_change sc;\n\tint node;\n\tint ret = 0;\n\n\tmlog(0, \"something happened such that the \"\n\t     \"master process may need to be restarted!\\n\");\n\n\tassert_spin_locked(&mle->spinlock);\n\n\tdlm_bitmap_diff_iter_init(&bdi, mle->vote_map, mle->node_map);\n\tnode = dlm_bitmap_diff_iter_next(&bdi, &sc);\n\twhile (node >= 0) {\n\t\tif (sc == NODE_UP) {\n\t\t\t/* a node came up.  clear any old vote from\n\t\t\t * the response map and set it in the vote map\n\t\t\t * then restart the mastery. */\n\t\t\tmlog(ML_NOTICE, \"node %d up while restarting\\n\", node);\n\n\t\t\t/* redo the master request, but only for the new node */\n\t\t\tmlog(0, \"sending request to new node\\n\");\n\t\t\tclear_bit(node, mle->response_map);\n\t\t\tset_bit(node, mle->vote_map);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"node down! %d\\n\", node);\n\t\t\tif (blocked) {\n\t\t\t\tint lowest = find_next_bit(mle->maybe_map,\n\t\t\t\t\t\t       O2NM_MAX_NODES, 0);\n\n\t\t\t\t/* act like it was never there */\n\t\t\t\tclear_bit(node, mle->maybe_map);\n\n\t\t\t       \tif (node == lowest) {\n\t\t\t\t\tmlog(0, \"expected master %u died\"\n\t\t\t\t\t    \" while this node was blocked \"\n\t\t\t\t\t    \"waiting on it!\\n\", node);\n\t\t\t\t\tlowest = find_next_bit(mle->maybe_map,\n\t\t\t\t\t\t       \tO2NM_MAX_NODES,\n\t\t\t\t\t\t       \tlowest+1);\n\t\t\t\t\tif (lowest < O2NM_MAX_NODES) {\n\t\t\t\t\t\tmlog(0, \"%s:%.*s:still \"\n\t\t\t\t\t\t     \"blocked. waiting on %u \"\n\t\t\t\t\t\t     \"now\\n\", dlm->name,\n\t\t\t\t\t\t     res->lockname.len,\n\t\t\t\t\t\t     res->lockname.name,\n\t\t\t\t\t\t     lowest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* mle is an MLE_BLOCK, but\n\t\t\t\t\t\t * there is now nothing left to\n\t\t\t\t\t\t * block on.  we need to return\n\t\t\t\t\t\t * all the way back out and try\n\t\t\t\t\t\t * again with an MLE_MASTER.\n\t\t\t\t\t\t * dlm_do_local_recovery_cleanup\n\t\t\t\t\t\t * has already run, so the mle\n\t\t\t\t\t\t * refcount is ok */\n\t\t\t\t\t\tmlog(0, \"%s:%.*s: no \"\n\t\t\t\t\t\t     \"longer blocking. try to \"\n\t\t\t\t\t\t     \"master this here\\n\",\n\t\t\t\t\t\t     dlm->name,\n\t\t\t\t\t\t     res->lockname.len,\n\t\t\t\t\t\t     res->lockname.name);\n\t\t\t\t\t\tmle->type = DLM_MLE_MASTER;\n\t\t\t\t\t\tmle->mleres = res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* now blank out everything, as if we had never\n\t\t\t * contacted anyone */\n\t\t\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\t\t\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\t\t\t/* reset the vote_map to the current node_map */\n\t\t\tmemcpy(mle->vote_map, mle->node_map,\n\t\t\t       sizeof(mle->node_map));\n\t\t\t/* put myself into the maybe map */\n\t\t\tif (mle->type != DLM_MLE_BLOCK)\n\t\t\t\tset_bit(dlm->node_num, mle->maybe_map);\n\t\t}\n\t\tret = -EAGAIN;\n\t\tnode = dlm_bitmap_diff_iter_next(&bdi, &sc);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: %.*s: node map changed, restarting\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mle->vote_map",
            "mle->response_map",
            "sizeof(mle->vote_map)"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mle->vote_map",
            "mle->node_map",
            "sizeof(mle->vote_map)"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "500"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"link to %u went down?: %d\\n\"",
            "res->owner",
            "ret"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_do_master_request",
          "args": [
            "res",
            "mle",
            "res->owner"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_master_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1322-1405",
          "snippet": "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to)\n{\n\tstruct dlm_ctxt *dlm = mle->dlm;\n\tstruct dlm_master_request request;\n\tint ret, response=0, resend;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.node_idx = dlm->node_num;\n\n\tBUG_ON(mle->type == DLM_MLE_MIGRATION);\n\n\trequest.namelen = (u8)mle->mnamelen;\n\tmemcpy(request.name, mle->mname, request.namelen);\n\nagain:\n\tret = o2net_send_message(DLM_MASTER_REQUEST_MSG, dlm->key, &request,\n\t\t\t\t sizeof(request), to, &response);\n\tif (ret < 0)  {\n\t\tif (ret == -ESRCH) {\n\t\t\t/* should never happen */\n\t\t\tmlog(ML_ERROR, \"TCP stack not ready!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -EINVAL) {\n\t\t\tmlog(ML_ERROR, \"bad args passed to o2net!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -ENOMEM) {\n\t\t\tmlog(ML_ERROR, \"out of memory while trying to send \"\n\t\t\t     \"network message!  retrying\\n\");\n\t\t\t/* this is totally crude */\n\t\t\tmsleep(50);\n\t\t\tgoto again;\n\t\t} else if (!dlm_is_host_down(ret)) {\n\t\t\t/* not a network error. bad. */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"unhandled error!\");\n\t\t\tBUG();\n\t\t}\n\t\t/* all other errors should be network errors,\n\t\t * and likely indicate node death */\n\t\tmlog(ML_ERROR, \"link to %d went down!\\n\", to);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tresend = 0;\n\tspin_lock(&mle->spinlock);\n\tswitch (response) {\n\t\tcase DLM_MASTER_RESP_YES:\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tmlog(0, \"node %u is the master, response=YES\\n\", to);\n\t\t\tmlog(0, \"%s:%.*s: master node %u now knows I have a \"\n\t\t\t     \"reference\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, to);\n\t\t\tmle->master = to;\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_NO:\n\t\t\tmlog(0, \"node %u not master, response=NO\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_MAYBE:\n\t\t\tmlog(0, \"node %u not master, response=MAYBE\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tset_bit(to, mle->maybe_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_ERROR:\n\t\t\tmlog(0, \"node %u hit an error, resending\\n\", to);\n\t\t\tresend = 1;\n\t\t\tresponse = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR, \"bad response! %u\\n\", response);\n\t\t\tBUG();\n\t}\n\tspin_unlock(&mle->spinlock);\n\tif (resend) {\n\t\t/* this is also totally crude */\n\t\tmsleep(50);\n\t\tgoto again;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to)\n{\n\tstruct dlm_ctxt *dlm = mle->dlm;\n\tstruct dlm_master_request request;\n\tint ret, response=0, resend;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.node_idx = dlm->node_num;\n\n\tBUG_ON(mle->type == DLM_MLE_MIGRATION);\n\n\trequest.namelen = (u8)mle->mnamelen;\n\tmemcpy(request.name, mle->mname, request.namelen);\n\nagain:\n\tret = o2net_send_message(DLM_MASTER_REQUEST_MSG, dlm->key, &request,\n\t\t\t\t sizeof(request), to, &response);\n\tif (ret < 0)  {\n\t\tif (ret == -ESRCH) {\n\t\t\t/* should never happen */\n\t\t\tmlog(ML_ERROR, \"TCP stack not ready!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -EINVAL) {\n\t\t\tmlog(ML_ERROR, \"bad args passed to o2net!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -ENOMEM) {\n\t\t\tmlog(ML_ERROR, \"out of memory while trying to send \"\n\t\t\t     \"network message!  retrying\\n\");\n\t\t\t/* this is totally crude */\n\t\t\tmsleep(50);\n\t\t\tgoto again;\n\t\t} else if (!dlm_is_host_down(ret)) {\n\t\t\t/* not a network error. bad. */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"unhandled error!\");\n\t\t\tBUG();\n\t\t}\n\t\t/* all other errors should be network errors,\n\t\t * and likely indicate node death */\n\t\tmlog(ML_ERROR, \"link to %d went down!\\n\", to);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tresend = 0;\n\tspin_lock(&mle->spinlock);\n\tswitch (response) {\n\t\tcase DLM_MASTER_RESP_YES:\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tmlog(0, \"node %u is the master, response=YES\\n\", to);\n\t\t\tmlog(0, \"%s:%.*s: master node %u now knows I have a \"\n\t\t\t     \"reference\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, to);\n\t\t\tmle->master = to;\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_NO:\n\t\t\tmlog(0, \"node %u not master, response=NO\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_MAYBE:\n\t\t\tmlog(0, \"node %u not master, response=MAYBE\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tset_bit(to, mle->maybe_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_ERROR:\n\t\t\tmlog(0, \"node %u hit an error, resending\\n\", to);\n\t\t\tresend = 1;\n\t\t\tresponse = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR, \"bad response! %u\\n\", response);\n\t\t\tBUG();\n\t}\n\tspin_unlock(&mle->spinlock);\n\tif (resend) {\n\t\t/* this is also totally crude */\n\t\tmsleep(50);\n\t\tgoto again;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: owner is suddenly %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->owner"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_MASTERY_TIMEOUT_MS   5000\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked)\n{\n\tu8 m;\n\tint ret, bit;\n\tint map_changed, voting_done;\n\tint assert, sleep;\n\nrecheck:\n\tret = 0;\n\tassert = 0;\n\n\t/* check if another node has already become the owner */\n\tspin_lock(&res->spinlock);\n\tif (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"%s:%.*s: owner is suddenly %u\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, res->owner);\n\t\tspin_unlock(&res->spinlock);\n\t\t/* this will cause the master to re-assert across\n\t\t * the whole cluster, freeing up mles */\n\t\tif (res->owner != dlm->node_num) {\n\t\t\tret = dlm_do_master_request(res, mle, res->owner);\n\t\t\tif (ret < 0) {\n\t\t\t\t/* give recovery a chance to run */\n\t\t\t\tmlog(ML_ERROR, \"link to %u went down?: %d\\n\", res->owner, ret);\n\t\t\t\tmsleep(500);\n\t\t\t\tgoto recheck;\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tspin_lock(&mle->spinlock);\n\tm = mle->master;\n\tmap_changed = (memcmp(mle->vote_map, mle->node_map,\n\t\t\t      sizeof(mle->vote_map)) != 0);\n\tvoting_done = (memcmp(mle->vote_map, mle->response_map,\n\t\t\t     sizeof(mle->vote_map)) == 0);\n\n\t/* restart if we hit any errors */\n\tif (map_changed) {\n\t\tint b;\n\t\tmlog(0, \"%s: %.*s: node map changed, restarting\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tret = dlm_restart_lock_mastery(dlm, res, mle, *blocked);\n\t\tb = (mle->type == DLM_MLE_BLOCK);\n\t\tif ((*blocked && !b) || (!*blocked && b)) {\n\t\t\tmlog(0, \"%s:%.*s: status change: old=%d new=%d\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     *blocked, b);\n\t\t\t*blocked = b;\n\t\t}\n\t\tspin_unlock(&mle->spinlock);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t\tmlog(0, \"%s:%.*s: restart lock mastery succeeded, \"\n\t\t     \"rechecking now\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name);\n\t\tgoto recheck;\n\t} else {\n\t\tif (!voting_done) {\n\t\t\tmlog(0, \"map not changed and voting not done \"\n\t\t\t     \"for %s:%.*s\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t}\n\t}\n\n\tif (m != O2NM_MAX_NODES) {\n\t\t/* another node has done an assert!\n\t\t * all done! */\n\t\tsleep = 0;\n\t} else {\n\t\tsleep = 1;\n\t\t/* have all nodes responded? */\n\t\tif (voting_done && !*blocked) {\n\t\t\tbit = find_next_bit(mle->maybe_map, O2NM_MAX_NODES, 0);\n\t\t\tif (dlm->node_num <= bit) {\n\t\t\t\t/* my node number is lowest.\n\t\t\t \t * now tell other nodes that I am\n\t\t\t\t * mastering this. */\n\t\t\t\tmle->master = dlm->node_num;\n\t\t\t\t/* ref was grabbed in get_lock_resource\n\t\t\t\t * will be dropped in dlmlock_master */\n\t\t\t\tassert = 1;\n\t\t\t\tsleep = 0;\n\t\t\t}\n\t\t\t/* if voting is done, but we have not received\n\t\t\t * an assert master yet, we must sleep */\n\t\t}\n\t}\n\n\tspin_unlock(&mle->spinlock);\n\n\t/* sleep if we haven't finished voting yet */\n\tif (sleep) {\n\t\tunsigned long timeo = msecs_to_jiffies(DLM_MASTERY_TIMEOUT_MS);\n\n\t\t/*\n\t\tif (atomic_read(&mle->mle_refs.refcount) < 2)\n\t\t\tmlog(ML_ERROR, \"mle (%p) refs=%d, name=%.*s\\n\", mle,\n\t\t\tatomic_read(&mle->mle_refs.refcount),\n\t\t\tres->lockname.len, res->lockname.name);\n\t\t*/\n\t\tatomic_set(&mle->woken, 0);\n\t\t(void)wait_event_timeout(mle->wq,\n\t\t\t\t\t (atomic_read(&mle->woken) == 1),\n\t\t\t\t\t timeo);\n\t\tif (res->owner == O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s:%.*s: waiting again\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\tgoto recheck;\n\t\t}\n\t\tmlog(0, \"done waiting, master is %u\\n\", res->owner);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tret = 0;   /* done */\n\tif (assert) {\n\t\tm = dlm->node_num;\n\t\tmlog(0, \"about to master %.*s here, this=%u\\n\",\n\t\t     res->lockname.len, res->lockname.name, m);\n\t\tret = dlm_do_assert_master(dlm, res, mle->vote_map, 0);\n\t\tif (ret) {\n\t\t\t/* This is a failure in the network path,\n\t\t\t * not in the response to the assert_master\n\t\t\t * (any nonzero response is a BUG on this node).\n\t\t\t * Most likely a socket just got disconnected\n\t\t\t * due to node death. */\n\t\t\tmlog_errno(ret);\n\t\t}\n\t\t/* no longer need to restart lock mastery.\n\t\t * all living nodes have been contacted. */\n\t\tret = 0;\n\t}\n\n\t/* set the lockres owner */\n\tspin_lock(&res->spinlock);\n\t/* mastery reference obtained either during\n\t * assert_master_handler or in get_lock_resource */\n\tdlm_change_lockres_owner(dlm, res, m);\n\tspin_unlock(&res->spinlock);\n\nleave:\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_get_lock_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "733-1005",
    "snippet": "struct dlm_lock_resource * dlm_get_lock_resource(struct dlm_ctxt *dlm,\n\t\t\t\t\t  const char *lockid,\n\t\t\t\t\t  int namelen,\n\t\t\t\t\t  int flags)\n{\n\tstruct dlm_lock_resource *tmpres=NULL, *res=NULL;\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_master_list_entry *alloc_mle = NULL;\n\tint blocked = 0;\n\tint ret, nodenum;\n\tstruct dlm_node_iter iter;\n\tunsigned int hash;\n\tint tries = 0;\n\tint bit, wait_on_recovery = 0;\n\n\tBUG_ON(!lockid);\n\n\thash = dlm_lockid_hash(lockid, namelen);\n\n\tmlog(0, \"get lockres %s (len %d)\\n\", lockid, namelen);\n\nlookup:\n\tspin_lock(&dlm->spinlock);\n\ttmpres = __dlm_lookup_lockres_full(dlm, lockid, namelen, hash);\n\tif (tmpres) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_lock(&tmpres->spinlock);\n\t\t/* Wait on the thread that is mastering the resource */\n\t\tif (tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t__dlm_wait_on_lockres(tmpres);\n\t\t\tBUG_ON(tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t\tspin_unlock(&tmpres->spinlock);\n\t\t\tdlm_lockres_put(tmpres);\n\t\t\ttmpres = NULL;\n\t\t\tgoto lookup;\n\t\t}\n\n\t\t/* Wait on the resource purge to complete before continuing */\n\t\tif (tmpres->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tBUG_ON(tmpres->owner == dlm->node_num);\n\t\t\t__dlm_wait_on_lockres_flags(tmpres,\n\t\t\t\t\t\t    DLM_LOCK_RES_DROPPING_REF);\n\t\t\tspin_unlock(&tmpres->spinlock);\n\t\t\tdlm_lockres_put(tmpres);\n\t\t\ttmpres = NULL;\n\t\t\tgoto lookup;\n\t\t}\n\n\t\t/* Grab inflight ref to pin the resource */\n\t\tdlm_lockres_grab_inflight_ref(dlm, tmpres);\n\n\t\tspin_unlock(&tmpres->spinlock);\n\t\tif (res)\n\t\t\tdlm_lockres_put(res);\n\t\tres = tmpres;\n\t\tgoto leave;\n\t}\n\n\tif (!res) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tmlog(0, \"allocating a new resource\\n\");\n\t\t/* nothing found and we need to allocate one. */\n\t\talloc_mle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\t\tif (!alloc_mle)\n\t\t\tgoto leave;\n\t\tres = dlm_new_lockres(dlm, lockid, namelen);\n\t\tif (!res)\n\t\t\tgoto leave;\n\t\tgoto lookup;\n\t}\n\n\tmlog(0, \"no lockres found, allocated our own: %p\\n\", res);\n\n\tif (flags & LKM_LOCAL) {\n\t\t/* caller knows it's safe to assume it's not mastered elsewhere\n\t\t * DONE!  return right away */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_change_lockres_owner(dlm, res, dlm->node_num);\n\t\t__dlm_insert_lockres(dlm, res);\n\t\tdlm_lockres_grab_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t\t/* lockres still marked IN_PROGRESS */\n\t\tgoto wake_waiters;\n\t}\n\n\t/* check master list to see if another node has started mastering it */\n\tspin_lock(&dlm->master_lock);\n\n\t/* if we found a block, wait for lock to be mastered by another node */\n\tblocked = dlm_find_mle(dlm, &mle, (char *)lockid, namelen);\n\tif (blocked) {\n\t\tint mig;\n\t\tif (mle->type == DLM_MLE_MASTER) {\n\t\t\tmlog(ML_ERROR, \"master entry for nonexistent lock!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tmig = (mle->type == DLM_MLE_MIGRATION);\n\t\t/* if there is a migration in progress, let the migration\n\t\t * finish before continuing.  we can wait for the absence\n\t\t * of the MIGRATION mle: either the migrate finished or\n\t\t * one of the nodes died and the mle was cleaned up.\n\t\t * if there is a BLOCK here, but it already has a master\n\t\t * set, we are too late.  the master does not have a ref\n\t\t * for us in the refmap.  detach the mle and drop it.\n\t\t * either way, go back to the top and start over. */\n\t\tif (mig || mle->master != O2NM_MAX_NODES) {\n\t\t\tBUG_ON(mig && mle->master == dlm->node_num);\n\t\t\t/* we arrived too late.  the master does not\n\t\t\t * have a ref for us. retry. */\n\t\t\tmlog(0, \"%s:%.*s: late on %s\\n\",\n\t\t\t     dlm->name, namelen, lockid,\n\t\t\t     mig ?  \"MIGRATION\" : \"BLOCK\");\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t/* master is known, detach */\n\t\t\tif (!mig)\n\t\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\tdlm_put_mle(mle);\n\t\t\tmle = NULL;\n\t\t\t/* this is lame, but we can't wait on either\n\t\t\t * the mle or lockres waitqueue here */\n\t\t\tif (mig)\n\t\t\t\tmsleep(100);\n\t\t\tgoto lookup;\n\t\t}\n\t} else {\n\t\t/* go ahead and try to master lock on this node */\n\t\tmle = alloc_mle;\n\t\t/* make sure this does not get freed below */\n\t\talloc_mle = NULL;\n\t\tdlm_init_mle(mle, DLM_MLE_MASTER, dlm, res, NULL, 0);\n\t\tset_bit(dlm->node_num, mle->maybe_map);\n\t\t__dlm_insert_mle(dlm, mle);\n\n\t\t/* still holding the dlm spinlock, check the recovery map\n\t\t * to see if there are any nodes that still need to be\n\t\t * considered.  these will not appear in the mle nodemap\n\t\t * but they might own this lockres.  wait on them. */\n\t\tbit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit < O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\",\n\t\t\t     dlm->name, namelen, (char *)lockid, bit);\n\t\t\twait_on_recovery = 1;\n\t\t}\n\t}\n\n\t/* at this point there is either a DLM_MLE_BLOCK or a\n\t * DLM_MLE_MASTER on the master list, so it's safe to add the\n\t * lockres to the hashtable.  anyone who finds the lock will\n\t * still have to wait on the IN_PROGRESS. */\n\n\t/* finally add the lockres to its hash bucket */\n\t__dlm_insert_lockres(dlm, res);\n\n\t/* since this lockres is new it doesn't not require the spinlock */\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n\n\t/* get an extra ref on the mle in case this is a BLOCK\n\t * if so, the creator of the BLOCK may try to put the last\n\t * ref at this time in the assert master handler, so we\n\t * need an extra one to keep from a bad ptr deref. */\n\tdlm_get_mle_inuse(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\nredo_request:\n\twhile (wait_on_recovery) {\n\t\t/* any cluster changes that occurred after dropping the\n\t\t * dlm spinlock would be detectable be a change on the mle,\n\t\t * so we only need to clear out the recovery map once. */\n\t\tif (dlm_is_recovery_lock(lockid, namelen)) {\n\t\t\tmlog(0, \"%s: Recovery map is not empty, but must \"\n\t\t\t     \"master $RECOVERY lock now\\n\", dlm->name);\n\t\t\tif (!dlm_pre_master_reco_lockres(dlm, res))\n\t\t\t\twait_on_recovery = 0;\n\t\t\telse {\n\t\t\t\tmlog(0, \"%s: waiting 500ms for heartbeat state \"\n\t\t\t\t    \"change\\n\", dlm->name);\n\t\t\t\tmsleep(500);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_kick_recovery_thread(dlm);\n\t\tmsleep(1000);\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tspin_lock(&dlm->spinlock);\n\t\tbit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit < O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\",\n\t\t\t     dlm->name, namelen, (char *)lockid, bit);\n\t\t\twait_on_recovery = 1;\n\t\t} else\n\t\t\twait_on_recovery = 0;\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tif (wait_on_recovery)\n\t\t\tdlm_wait_for_node_recovery(dlm, bit, 10000);\n\t}\n\n\t/* must wait for lock to be mastered elsewhere */\n\tif (blocked)\n\t\tgoto wait;\n\n\tret = -EINVAL;\n\tdlm_node_iter_init(mle->vote_map, &iter);\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = dlm_do_master_request(res, mle, nodenum);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\tif (mle->master != O2NM_MAX_NODES) {\n\t\t\t/* found a master ! */\n\t\t\tif (mle->master <= nodenum)\n\t\t\t\tbreak;\n\t\t\t/* if our master request has not reached the master\n\t\t\t * yet, keep going until it does.  this is how the\n\t\t\t * master will know that asserts are needed back to\n\t\t\t * the lower nodes. */\n\t\t\tmlog(0, \"%s: res %.*s, Requests only up to %u but \"\n\t\t\t     \"master is %u, keep going\\n\", dlm->name, namelen,\n\t\t\t     lockid, nodenum, mle->master);\n\t\t}\n\t}\n\nwait:\n\t/* keep going until the response map includes all nodes */\n\tret = dlm_wait_for_lock_mastery(dlm, res, mle, &blocked);\n\tif (ret < 0) {\n\t\twait_on_recovery = 1;\n\t\tmlog(0, \"%s: res %.*s, Node map changed, redo the master \"\n\t\t     \"request now, blocked=%d\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name, blocked);\n\t\tif (++tries > 20) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Spinning on \"\n\t\t\t     \"dlm_wait_for_lock_mastery, blocked = %d\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, blocked);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_print_one_mle(mle);\n\t\t\ttries = 0;\n\t\t}\n\t\tgoto redo_request;\n\t}\n\n\tmlog(0, \"%s: res %.*s, Mastered by %u\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name, res->owner);\n\t/* make sure we never continue without this */\n\tBUG_ON(res->owner == O2NM_MAX_NODES);\n\n\t/* master is known, detach if not already detached */\n\tdlm_mle_detach_hb_events(dlm, mle);\n\tdlm_put_mle(mle);\n\t/* put the extra ref */\n\tdlm_put_mle_inuse(mle);\n\nwake_waiters:\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\nleave:\n\t/* need to free the unused mle */\n\tif (alloc_mle)\n\t\tkmem_cache_free(dlm_mle_cache, alloc_mle);\n\n\treturn res;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
      "static struct kmem_cache *dlm_mle_cache;",
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
      "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_mle_cache",
            "alloc_mle"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_mle_inuse",
          "args": [
            "mle"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle_inuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "214-226",
          "snippet": "static void dlm_put_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tmle->inuse--;\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tmle->inuse--;\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "195-201",
          "snippet": "static inline void dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->owner == O2NM_MAX_NODES"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Mastered by %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->owner"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_mle",
          "args": [
            "mle"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_one_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "328-337",
          "snippet": "void dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, Spinning on \"\n\t\t\t     \"dlm_wait_for_lock_mastery, blocked = %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "blocked"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Node map changed, redo the master \"\n\t\t     \"request now, blocked=%d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "blocked"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_wait_for_lock_mastery",
          "args": [
            "dlm",
            "res",
            "mle",
            "&blocked"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_for_lock_mastery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1010-1161",
          "snippet": "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked)\n{\n\tu8 m;\n\tint ret, bit;\n\tint map_changed, voting_done;\n\tint assert, sleep;\n\nrecheck:\n\tret = 0;\n\tassert = 0;\n\n\t/* check if another node has already become the owner */\n\tspin_lock(&res->spinlock);\n\tif (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"%s:%.*s: owner is suddenly %u\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, res->owner);\n\t\tspin_unlock(&res->spinlock);\n\t\t/* this will cause the master to re-assert across\n\t\t * the whole cluster, freeing up mles */\n\t\tif (res->owner != dlm->node_num) {\n\t\t\tret = dlm_do_master_request(res, mle, res->owner);\n\t\t\tif (ret < 0) {\n\t\t\t\t/* give recovery a chance to run */\n\t\t\t\tmlog(ML_ERROR, \"link to %u went down?: %d\\n\", res->owner, ret);\n\t\t\t\tmsleep(500);\n\t\t\t\tgoto recheck;\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tspin_lock(&mle->spinlock);\n\tm = mle->master;\n\tmap_changed = (memcmp(mle->vote_map, mle->node_map,\n\t\t\t      sizeof(mle->vote_map)) != 0);\n\tvoting_done = (memcmp(mle->vote_map, mle->response_map,\n\t\t\t     sizeof(mle->vote_map)) == 0);\n\n\t/* restart if we hit any errors */\n\tif (map_changed) {\n\t\tint b;\n\t\tmlog(0, \"%s: %.*s: node map changed, restarting\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tret = dlm_restart_lock_mastery(dlm, res, mle, *blocked);\n\t\tb = (mle->type == DLM_MLE_BLOCK);\n\t\tif ((*blocked && !b) || (!*blocked && b)) {\n\t\t\tmlog(0, \"%s:%.*s: status change: old=%d new=%d\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     *blocked, b);\n\t\t\t*blocked = b;\n\t\t}\n\t\tspin_unlock(&mle->spinlock);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t\tmlog(0, \"%s:%.*s: restart lock mastery succeeded, \"\n\t\t     \"rechecking now\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name);\n\t\tgoto recheck;\n\t} else {\n\t\tif (!voting_done) {\n\t\t\tmlog(0, \"map not changed and voting not done \"\n\t\t\t     \"for %s:%.*s\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t}\n\t}\n\n\tif (m != O2NM_MAX_NODES) {\n\t\t/* another node has done an assert!\n\t\t * all done! */\n\t\tsleep = 0;\n\t} else {\n\t\tsleep = 1;\n\t\t/* have all nodes responded? */\n\t\tif (voting_done && !*blocked) {\n\t\t\tbit = find_next_bit(mle->maybe_map, O2NM_MAX_NODES, 0);\n\t\t\tif (dlm->node_num <= bit) {\n\t\t\t\t/* my node number is lowest.\n\t\t\t \t * now tell other nodes that I am\n\t\t\t\t * mastering this. */\n\t\t\t\tmle->master = dlm->node_num;\n\t\t\t\t/* ref was grabbed in get_lock_resource\n\t\t\t\t * will be dropped in dlmlock_master */\n\t\t\t\tassert = 1;\n\t\t\t\tsleep = 0;\n\t\t\t}\n\t\t\t/* if voting is done, but we have not received\n\t\t\t * an assert master yet, we must sleep */\n\t\t}\n\t}\n\n\tspin_unlock(&mle->spinlock);\n\n\t/* sleep if we haven't finished voting yet */\n\tif (sleep) {\n\t\tunsigned long timeo = msecs_to_jiffies(DLM_MASTERY_TIMEOUT_MS);\n\n\t\t/*\n\t\tif (atomic_read(&mle->mle_refs.refcount) < 2)\n\t\t\tmlog(ML_ERROR, \"mle (%p) refs=%d, name=%.*s\\n\", mle,\n\t\t\tatomic_read(&mle->mle_refs.refcount),\n\t\t\tres->lockname.len, res->lockname.name);\n\t\t*/\n\t\tatomic_set(&mle->woken, 0);\n\t\t(void)wait_event_timeout(mle->wq,\n\t\t\t\t\t (atomic_read(&mle->woken) == 1),\n\t\t\t\t\t timeo);\n\t\tif (res->owner == O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s:%.*s: waiting again\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\tgoto recheck;\n\t\t}\n\t\tmlog(0, \"done waiting, master is %u\\n\", res->owner);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tret = 0;   /* done */\n\tif (assert) {\n\t\tm = dlm->node_num;\n\t\tmlog(0, \"about to master %.*s here, this=%u\\n\",\n\t\t     res->lockname.len, res->lockname.name, m);\n\t\tret = dlm_do_assert_master(dlm, res, mle->vote_map, 0);\n\t\tif (ret) {\n\t\t\t/* This is a failure in the network path,\n\t\t\t * not in the response to the assert_master\n\t\t\t * (any nonzero response is a BUG on this node).\n\t\t\t * Most likely a socket just got disconnected\n\t\t\t * due to node death. */\n\t\t\tmlog_errno(ret);\n\t\t}\n\t\t/* no longer need to restart lock mastery.\n\t\t * all living nodes have been contacted. */\n\t\tret = 0;\n\t}\n\n\t/* set the lockres owner */\n\tspin_lock(&res->spinlock);\n\t/* mastery reference obtained either during\n\t * assert_master_handler or in get_lock_resource */\n\tdlm_change_lockres_owner(dlm, res, m);\n\tspin_unlock(&res->spinlock);\n\nleave:\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_MASTERY_TIMEOUT_MS   5000"
          ],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
            "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_MASTERY_TIMEOUT_MS   5000\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked)\n{\n\tu8 m;\n\tint ret, bit;\n\tint map_changed, voting_done;\n\tint assert, sleep;\n\nrecheck:\n\tret = 0;\n\tassert = 0;\n\n\t/* check if another node has already become the owner */\n\tspin_lock(&res->spinlock);\n\tif (res->owner != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\tmlog(0, \"%s:%.*s: owner is suddenly %u\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, res->owner);\n\t\tspin_unlock(&res->spinlock);\n\t\t/* this will cause the master to re-assert across\n\t\t * the whole cluster, freeing up mles */\n\t\tif (res->owner != dlm->node_num) {\n\t\t\tret = dlm_do_master_request(res, mle, res->owner);\n\t\t\tif (ret < 0) {\n\t\t\t\t/* give recovery a chance to run */\n\t\t\t\tmlog(ML_ERROR, \"link to %u went down?: %d\\n\", res->owner, ret);\n\t\t\t\tmsleep(500);\n\t\t\t\tgoto recheck;\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tspin_lock(&mle->spinlock);\n\tm = mle->master;\n\tmap_changed = (memcmp(mle->vote_map, mle->node_map,\n\t\t\t      sizeof(mle->vote_map)) != 0);\n\tvoting_done = (memcmp(mle->vote_map, mle->response_map,\n\t\t\t     sizeof(mle->vote_map)) == 0);\n\n\t/* restart if we hit any errors */\n\tif (map_changed) {\n\t\tint b;\n\t\tmlog(0, \"%s: %.*s: node map changed, restarting\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tret = dlm_restart_lock_mastery(dlm, res, mle, *blocked);\n\t\tb = (mle->type == DLM_MLE_BLOCK);\n\t\tif ((*blocked && !b) || (!*blocked && b)) {\n\t\t\tmlog(0, \"%s:%.*s: status change: old=%d new=%d\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     *blocked, b);\n\t\t\t*blocked = b;\n\t\t}\n\t\tspin_unlock(&mle->spinlock);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto leave;\n\t\t}\n\t\tmlog(0, \"%s:%.*s: restart lock mastery succeeded, \"\n\t\t     \"rechecking now\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name);\n\t\tgoto recheck;\n\t} else {\n\t\tif (!voting_done) {\n\t\t\tmlog(0, \"map not changed and voting not done \"\n\t\t\t     \"for %s:%.*s\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name);\n\t\t}\n\t}\n\n\tif (m != O2NM_MAX_NODES) {\n\t\t/* another node has done an assert!\n\t\t * all done! */\n\t\tsleep = 0;\n\t} else {\n\t\tsleep = 1;\n\t\t/* have all nodes responded? */\n\t\tif (voting_done && !*blocked) {\n\t\t\tbit = find_next_bit(mle->maybe_map, O2NM_MAX_NODES, 0);\n\t\t\tif (dlm->node_num <= bit) {\n\t\t\t\t/* my node number is lowest.\n\t\t\t \t * now tell other nodes that I am\n\t\t\t\t * mastering this. */\n\t\t\t\tmle->master = dlm->node_num;\n\t\t\t\t/* ref was grabbed in get_lock_resource\n\t\t\t\t * will be dropped in dlmlock_master */\n\t\t\t\tassert = 1;\n\t\t\t\tsleep = 0;\n\t\t\t}\n\t\t\t/* if voting is done, but we have not received\n\t\t\t * an assert master yet, we must sleep */\n\t\t}\n\t}\n\n\tspin_unlock(&mle->spinlock);\n\n\t/* sleep if we haven't finished voting yet */\n\tif (sleep) {\n\t\tunsigned long timeo = msecs_to_jiffies(DLM_MASTERY_TIMEOUT_MS);\n\n\t\t/*\n\t\tif (atomic_read(&mle->mle_refs.refcount) < 2)\n\t\t\tmlog(ML_ERROR, \"mle (%p) refs=%d, name=%.*s\\n\", mle,\n\t\t\tatomic_read(&mle->mle_refs.refcount),\n\t\t\tres->lockname.len, res->lockname.name);\n\t\t*/\n\t\tatomic_set(&mle->woken, 0);\n\t\t(void)wait_event_timeout(mle->wq,\n\t\t\t\t\t (atomic_read(&mle->woken) == 1),\n\t\t\t\t\t timeo);\n\t\tif (res->owner == O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s:%.*s: waiting again\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\tgoto recheck;\n\t\t}\n\t\tmlog(0, \"done waiting, master is %u\\n\", res->owner);\n\t\tret = 0;\n\t\tgoto leave;\n\t}\n\n\tret = 0;   /* done */\n\tif (assert) {\n\t\tm = dlm->node_num;\n\t\tmlog(0, \"about to master %.*s here, this=%u\\n\",\n\t\t     res->lockname.len, res->lockname.name, m);\n\t\tret = dlm_do_assert_master(dlm, res, mle->vote_map, 0);\n\t\tif (ret) {\n\t\t\t/* This is a failure in the network path,\n\t\t\t * not in the response to the assert_master\n\t\t\t * (any nonzero response is a BUG on this node).\n\t\t\t * Most likely a socket just got disconnected\n\t\t\t * due to node death. */\n\t\t\tmlog_errno(ret);\n\t\t}\n\t\t/* no longer need to restart lock mastery.\n\t\t * all living nodes have been contacted. */\n\t\tret = 0;\n\t}\n\n\t/* set the lockres owner */\n\tspin_lock(&res->spinlock);\n\t/* mastery reference obtained either during\n\t * assert_master_handler or in get_lock_resource */\n\tdlm_change_lockres_owner(dlm, res, m);\n\tspin_unlock(&res->spinlock);\n\nleave:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Requests only up to %u but \"\n\t\t\t     \"master is %u, keep going\\n\"",
            "dlm->name",
            "namelen",
            "lockid",
            "nodenum",
            "mle->master"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_do_master_request",
          "args": [
            "res",
            "mle",
            "nodenum"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_master_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "1322-1405",
          "snippet": "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to)\n{\n\tstruct dlm_ctxt *dlm = mle->dlm;\n\tstruct dlm_master_request request;\n\tint ret, response=0, resend;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.node_idx = dlm->node_num;\n\n\tBUG_ON(mle->type == DLM_MLE_MIGRATION);\n\n\trequest.namelen = (u8)mle->mnamelen;\n\tmemcpy(request.name, mle->mname, request.namelen);\n\nagain:\n\tret = o2net_send_message(DLM_MASTER_REQUEST_MSG, dlm->key, &request,\n\t\t\t\t sizeof(request), to, &response);\n\tif (ret < 0)  {\n\t\tif (ret == -ESRCH) {\n\t\t\t/* should never happen */\n\t\t\tmlog(ML_ERROR, \"TCP stack not ready!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -EINVAL) {\n\t\t\tmlog(ML_ERROR, \"bad args passed to o2net!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -ENOMEM) {\n\t\t\tmlog(ML_ERROR, \"out of memory while trying to send \"\n\t\t\t     \"network message!  retrying\\n\");\n\t\t\t/* this is totally crude */\n\t\t\tmsleep(50);\n\t\t\tgoto again;\n\t\t} else if (!dlm_is_host_down(ret)) {\n\t\t\t/* not a network error. bad. */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"unhandled error!\");\n\t\t\tBUG();\n\t\t}\n\t\t/* all other errors should be network errors,\n\t\t * and likely indicate node death */\n\t\tmlog(ML_ERROR, \"link to %d went down!\\n\", to);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tresend = 0;\n\tspin_lock(&mle->spinlock);\n\tswitch (response) {\n\t\tcase DLM_MASTER_RESP_YES:\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tmlog(0, \"node %u is the master, response=YES\\n\", to);\n\t\t\tmlog(0, \"%s:%.*s: master node %u now knows I have a \"\n\t\t\t     \"reference\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, to);\n\t\t\tmle->master = to;\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_NO:\n\t\t\tmlog(0, \"node %u not master, response=NO\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_MAYBE:\n\t\t\tmlog(0, \"node %u not master, response=MAYBE\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tset_bit(to, mle->maybe_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_ERROR:\n\t\t\tmlog(0, \"node %u hit an error, resending\\n\", to);\n\t\t\tresend = 1;\n\t\t\tresponse = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR, \"bad response! %u\\n\", response);\n\t\t\tBUG();\n\t}\n\tspin_unlock(&mle->spinlock);\n\tif (resend) {\n\t\t/* this is also totally crude */\n\t\tmsleep(50);\n\t\tgoto again;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to)\n{\n\tstruct dlm_ctxt *dlm = mle->dlm;\n\tstruct dlm_master_request request;\n\tint ret, response=0, resend;\n\n\tmemset(&request, 0, sizeof(request));\n\trequest.node_idx = dlm->node_num;\n\n\tBUG_ON(mle->type == DLM_MLE_MIGRATION);\n\n\trequest.namelen = (u8)mle->mnamelen;\n\tmemcpy(request.name, mle->mname, request.namelen);\n\nagain:\n\tret = o2net_send_message(DLM_MASTER_REQUEST_MSG, dlm->key, &request,\n\t\t\t\t sizeof(request), to, &response);\n\tif (ret < 0)  {\n\t\tif (ret == -ESRCH) {\n\t\t\t/* should never happen */\n\t\t\tmlog(ML_ERROR, \"TCP stack not ready!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -EINVAL) {\n\t\t\tmlog(ML_ERROR, \"bad args passed to o2net!\\n\");\n\t\t\tBUG();\n\t\t} else if (ret == -ENOMEM) {\n\t\t\tmlog(ML_ERROR, \"out of memory while trying to send \"\n\t\t\t     \"network message!  retrying\\n\");\n\t\t\t/* this is totally crude */\n\t\t\tmsleep(50);\n\t\t\tgoto again;\n\t\t} else if (!dlm_is_host_down(ret)) {\n\t\t\t/* not a network error. bad. */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"unhandled error!\");\n\t\t\tBUG();\n\t\t}\n\t\t/* all other errors should be network errors,\n\t\t * and likely indicate node death */\n\t\tmlog(ML_ERROR, \"link to %d went down!\\n\", to);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tresend = 0;\n\tspin_lock(&mle->spinlock);\n\tswitch (response) {\n\t\tcase DLM_MASTER_RESP_YES:\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tmlog(0, \"node %u is the master, response=YES\\n\", to);\n\t\t\tmlog(0, \"%s:%.*s: master node %u now knows I have a \"\n\t\t\t     \"reference\\n\", dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, to);\n\t\t\tmle->master = to;\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_NO:\n\t\t\tmlog(0, \"node %u not master, response=NO\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_MAYBE:\n\t\t\tmlog(0, \"node %u not master, response=MAYBE\\n\", to);\n\t\t\tset_bit(to, mle->response_map);\n\t\t\tset_bit(to, mle->maybe_map);\n\t\t\tbreak;\n\t\tcase DLM_MASTER_RESP_ERROR:\n\t\t\tmlog(0, \"node %u hit an error, resending\\n\", to);\n\t\t\tresend = 1;\n\t\t\tresponse = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlog(ML_ERROR, \"bad response! %u\\n\", response);\n\t\t\tBUG();\n\t}\n\tspin_unlock(&mle->spinlock);\n\tif (resend) {\n\t\t/* this is also totally crude */\n\t\tmsleep(50);\n\t\tgoto again;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_next",
          "args": [
            "&iter"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1119-1129",
          "snippet": "static inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_init",
          "args": [
            "mle->vote_map",
            "&iter"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1112-1117",
          "snippet": "static inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_for_node_recovery",
          "args": [
            "dlm",
            "bit",
            "10000"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_for_node_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "379-394",
          "snippet": "void dlm_wait_for_node_recovery(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_recovered(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the recovery of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_recovered(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_recovered(dlm, node));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_wait_for_node_recovery(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_recovered(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the recovery of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_recovered(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_recovered(dlm, node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\"",
            "dlm->name",
            "namelen",
            "(char *)lockid",
            "bit"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "dlm->recovery_map",
            "O2NM_MAX_NODES",
            "0"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_for_recovery",
          "args": [
            "dlm"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_for_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "412-422",
          "snippet": "void dlm_wait_for_recovery(struct dlm_ctxt *dlm)\n{\n\tif (dlm_in_recovery(dlm)) {\n\t\tmlog(0, \"%s: reco thread %d in recovery: \"\n\t\t     \"state=%d, master=%u, dead=%u\\n\",\n\t\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t\t     dlm->reco.state, dlm->reco.new_master,\n\t\t     dlm->reco.dead_node);\n\t}\n\twait_event(dlm->reco.event, !dlm_in_recovery(dlm));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nvoid dlm_wait_for_recovery(struct dlm_ctxt *dlm)\n{\n\tif (dlm_in_recovery(dlm)) {\n\t\tmlog(0, \"%s: reco thread %d in recovery: \"\n\t\t     \"state=%d, master=%u, dead=%u\\n\",\n\t\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t\t     dlm->reco.state, dlm->reco.new_master,\n\t\t     dlm->reco.dead_node);\n\t}\n\twait_event(dlm->reco.event, !dlm_in_recovery(dlm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_kick_recovery_thread",
          "args": [
            "dlm"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_recovery_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "191-200",
          "snippet": "void dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_recovery_thread(void *data);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
            "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nvoid dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "500"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: waiting 500ms for heartbeat state \"\n\t\t\t\t    \"change\\n\"",
            "dlm->name"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_pre_master_reco_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_pre_master_reco_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2186-2230",
          "snippet": "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\tu8 master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t/* do not send to self */\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, &master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t/* host is down, so answer for that node would be\n\t\t\t * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */\n\t\t\tret = 0;\n\t\t}\n\n\t\tif (master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t/* check to see if this master is in the recovery map */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (test_bit(master, dlm->recovery_map)) {\n\t\t\t\tmlog(ML_NOTICE, \"%s: node %u has not seen \"\n\t\t\t\t     \"node %u go down yet, and thinks the \"\n\t\t\t\t     \"dead node is mastering the recovery \"\n\t\t\t\t     \"lock.  must wait.\\n\", dlm->name,\n\t\t\t\t     nodenum, master);\n\t\t\t\tret = -EAGAIN;\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"%s: reco lock master is %u\\n\", dlm->name,\n\t\t\t     master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\tu8 master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t/* do not send to self */\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, &master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t/* host is down, so answer for that node would be\n\t\t\t * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */\n\t\t\tret = 0;\n\t\t}\n\n\t\tif (master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t/* check to see if this master is in the recovery map */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (test_bit(master, dlm->recovery_map)) {\n\t\t\t\tmlog(ML_NOTICE, \"%s: node %u has not seen \"\n\t\t\t\t     \"node %u go down yet, and thinks the \"\n\t\t\t\t     \"dead node is mastering the recovery \"\n\t\t\t\t     \"lock.  must wait.\\n\", dlm->name,\n\t\t\t\t     nodenum, master);\n\t\t\t\tret = -EAGAIN;\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"%s: reco lock master is %u\\n\", dlm->name,\n\t\t\t     master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_recovery_lock",
          "args": [
            "lockid",
            "namelen"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_recovery_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "97-103",
          "snippet": "static inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_RECOVERY_LOCK_NAME_LEN   9",
            "#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_RECOVERY_LOCK_NAME_LEN   9\n#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\"\n\nstatic inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_mle_inuse",
          "args": [
            "mle"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_mle_inuse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "203-212",
          "snippet": "static void dlm_get_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tmle->inuse++;\n\tkref_get(&mle->mle_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_get_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tmle->inuse++;\n\tkref_get(&mle->mle_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_grab_inflight_ref",
          "args": [
            "dlm",
            "res"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_grab_inflight_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "655-663",
          "snippet": "static void __dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tres->inflight_locks++;\n\n\tmlog(0, \"%s: res %.*s, inflight++: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void __dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tres->inflight_locks++;\n\n\tmlog(0, \"%s: res %.*s, inflight++: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_insert_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_insert_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "169-186",
          "snippet": "void __dlm_insert_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct hlist_head *bucket;\n\tstruct qstr *q;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tq = &res->lockname;\n\tbucket = dlm_lockres_hash(dlm, q->hash);\n\n\t/* get a reference for our hashtable */\n\tdlm_lockres_get(res);\n\n\thlist_add_head(&res->hash_node, bucket);\n\n\tmlog(0, \"%s: Hash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid __dlm_insert_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct hlist_head *bucket;\n\tstruct qstr *q;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tq = &res->lockname;\n\tbucket = dlm_lockres_hash(dlm, q->hash);\n\n\t/* get a reference for our hashtable */\n\tdlm_lockres_get(res);\n\n\thlist_add_head(&res->hash_node, bucket);\n\n\tmlog(0, \"%s: Hash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\"",
            "dlm->name",
            "namelen",
            "(char *)lockid",
            "bit"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_insert_mle",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_insert_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "328-336",
          "snippet": "void __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\tbucket = dlm_master_hash(dlm, mle->mnamehash);\n\thlist_add_head(&mle->master_hash_node, bucket);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\tbucket = dlm_master_hash(dlm, mle->mnamehash);\n\thlist_add_head(&mle->master_hash_node, bucket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "dlm->node_num",
            "mle->maybe_map"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_mle",
          "args": [
            "mle",
            "DLM_MLE_MASTER",
            "dlm",
            "res",
            "NULL",
            "0"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "265-317",
          "snippet": "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tmle->dlm = dlm;\n\tmle->type = type;\n\tINIT_HLIST_NODE(&mle->master_hash_node);\n\tINIT_LIST_HEAD(&mle->hb_events);\n\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\tspin_lock_init(&mle->spinlock);\n\tinit_waitqueue_head(&mle->wq);\n\tatomic_set(&mle->woken, 0);\n\tkref_init(&mle->mle_refs);\n\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\tmle->master = O2NM_MAX_NODES;\n\tmle->new_master = O2NM_MAX_NODES;\n\tmle->inuse = 0;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION);\n\n\tif (mle->type == DLM_MLE_MASTER) {\n\t\tBUG_ON(!res);\n\t\tmle->mleres = res;\n\t\tmemcpy(mle->mname, res->lockname.name, res->lockname.len);\n\t\tmle->mnamelen = res->lockname.len;\n\t\tmle->mnamehash = res->lockname.hash;\n\t} else {\n\t\tBUG_ON(!name);\n\t\tmle->mleres = NULL;\n\t\tmemcpy(mle->mname, name, namelen);\n\t\tmle->mnamelen = namelen;\n\t\tmle->mnamehash = dlm_lockid_hash(name, namelen);\n\t}\n\n\tatomic_inc(&dlm->mle_tot_count[mle->type]);\n\tatomic_inc(&dlm->mle_cur_count[mle->type]);\n\n\t/* copy off the node_map and register hb callbacks on our copy */\n\tmemcpy(mle->node_map, dlm->domain_map, sizeof(mle->node_map));\n\tmemcpy(mle->vote_map, dlm->domain_map, sizeof(mle->vote_map));\n\tclear_bit(dlm->node_num, mle->vote_map);\n\tclear_bit(dlm->node_num, mle->node_map);\n\n\t/* attach the mle to the domain node up/down events */\n\t__dlm_mle_attach_hb_events(dlm, mle);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tmle->dlm = dlm;\n\tmle->type = type;\n\tINIT_HLIST_NODE(&mle->master_hash_node);\n\tINIT_LIST_HEAD(&mle->hb_events);\n\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\tspin_lock_init(&mle->spinlock);\n\tinit_waitqueue_head(&mle->wq);\n\tatomic_set(&mle->woken, 0);\n\tkref_init(&mle->mle_refs);\n\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\tmle->master = O2NM_MAX_NODES;\n\tmle->new_master = O2NM_MAX_NODES;\n\tmle->inuse = 0;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION);\n\n\tif (mle->type == DLM_MLE_MASTER) {\n\t\tBUG_ON(!res);\n\t\tmle->mleres = res;\n\t\tmemcpy(mle->mname, res->lockname.name, res->lockname.len);\n\t\tmle->mnamelen = res->lockname.len;\n\t\tmle->mnamehash = res->lockname.hash;\n\t} else {\n\t\tBUG_ON(!name);\n\t\tmle->mleres = NULL;\n\t\tmemcpy(mle->mname, name, namelen);\n\t\tmle->mnamelen = namelen;\n\t\tmle->mnamehash = dlm_lockid_hash(name, namelen);\n\t}\n\n\tatomic_inc(&dlm->mle_tot_count[mle->type]);\n\tatomic_inc(&dlm->mle_cur_count[mle->type]);\n\n\t/* copy off the node_map and register hb callbacks on our copy */\n\tmemcpy(mle->node_map, dlm->domain_map, sizeof(mle->node_map));\n\tmemcpy(mle->vote_map, dlm->domain_map, sizeof(mle->vote_map));\n\tclear_bit(dlm->node_num, mle->vote_map);\n\tclear_bit(dlm->node_num, mle->node_map);\n\n\t/* attach the mle to the domain node up/down events */\n\t__dlm_mle_attach_hb_events(dlm, mle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: late on %s\\n\"",
            "dlm->name",
            "namelen",
            "lockid",
            "mig ?  \"MIGRATION\" : \"BLOCK\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mig && mle->master == dlm->node_num"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"master entry for nonexistent lock!\\n\""
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_mle",
          "args": [
            "dlm",
            "&mle",
            "(char *)lockid",
            "namelen"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "339-359",
          "snippet": "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\n\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_grab_inflight_ref",
          "args": [
            "dlm",
            "res"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_grab_inflight_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "665-670",
          "snippet": "void dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_change_lockres_owner",
          "args": [
            "dlm",
            "res",
            "dlm->node_num"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_change_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1140-1148",
          "snippet": "static inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_new_lockres",
          "args": [
            "dlm",
            "lockid",
            "namelen"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "610-631",
          "snippet": "struct dlm_lock_resource *dlm_new_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t   const char *name,\n\t\t\t\t   unsigned int namelen)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tres = kmem_cache_zalloc(dlm_lockres_cache, GFP_NOFS);\n\tif (!res)\n\t\tgoto error;\n\n\tres->lockname.name = kmem_cache_zalloc(dlm_lockname_cache, GFP_NOFS);\n\tif (!res->lockname.name)\n\t\tgoto error;\n\n\tdlm_init_lockres(dlm, res, name, namelen);\n\treturn res;\n\nerror:\n\tif (res)\n\t\tkmem_cache_free(dlm_lockres_cache, res);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lockres_cache;",
            "static struct kmem_cache *dlm_lockname_cache;",
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstruct dlm_lock_resource *dlm_new_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t   const char *name,\n\t\t\t\t   unsigned int namelen)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tres = kmem_cache_zalloc(dlm_lockres_cache, GFP_NOFS);\n\tif (!res)\n\t\tgoto error;\n\n\tres->lockname.name = kmem_cache_zalloc(dlm_lockname_cache, GFP_NOFS);\n\tif (!res->lockname.name)\n\t\tgoto error;\n\n\tdlm_init_lockres(dlm, res, name, namelen);\n\treturn res;\n\nerror:\n\tif (res)\n\t\tkmem_cache_free(dlm_lockres_cache, res);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "dlm_mle_cache",
            "GFP_NOFS"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres_flags",
          "args": [
            "tmpres",
            "DLM_LOCK_RES_DROPPING_REF"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "61-78",
          "snippet": "void __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tmpres->owner == dlm->node_num"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres",
          "args": [
            "tmpres"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1020-1025",
          "snippet": "static inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres_full",
          "args": [
            "dlm",
            "lockid",
            "namelen",
            "hash"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "188-213",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres_full(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned int len,\n\t\t\t\t\t\t     unsigned int hash)\n{\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tbucket = dlm_lockres_hash(dlm, hash);\n\n\thlist_for_each_entry(res, bucket, hash_node) {\n\t\tif (res->lockname.name[0] != name[0])\n\t\t\tcontinue;\n\t\tif (unlikely(res->lockname.len != len))\n\t\t\tcontinue;\n\t\tif (memcmp(res->lockname.name + 1, name + 1, len - 1))\n\t\t\tcontinue;\n\t\tdlm_lockres_get(res);\n\t\treturn res;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"get lockres %s (len %d)\\n\"",
            "lockid",
            "namelen"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "lockid",
            "namelen"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockid"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic struct kmem_cache *dlm_mle_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstruct dlm_lock_resource * dlm_get_lock_resource(struct dlm_ctxt *dlm,\n\t\t\t\t\t  const char *lockid,\n\t\t\t\t\t  int namelen,\n\t\t\t\t\t  int flags)\n{\n\tstruct dlm_lock_resource *tmpres=NULL, *res=NULL;\n\tstruct dlm_master_list_entry *mle = NULL;\n\tstruct dlm_master_list_entry *alloc_mle = NULL;\n\tint blocked = 0;\n\tint ret, nodenum;\n\tstruct dlm_node_iter iter;\n\tunsigned int hash;\n\tint tries = 0;\n\tint bit, wait_on_recovery = 0;\n\n\tBUG_ON(!lockid);\n\n\thash = dlm_lockid_hash(lockid, namelen);\n\n\tmlog(0, \"get lockres %s (len %d)\\n\", lockid, namelen);\n\nlookup:\n\tspin_lock(&dlm->spinlock);\n\ttmpres = __dlm_lookup_lockres_full(dlm, lockid, namelen, hash);\n\tif (tmpres) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tspin_lock(&tmpres->spinlock);\n\t\t/* Wait on the thread that is mastering the resource */\n\t\tif (tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t__dlm_wait_on_lockres(tmpres);\n\t\t\tBUG_ON(tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t\tspin_unlock(&tmpres->spinlock);\n\t\t\tdlm_lockres_put(tmpres);\n\t\t\ttmpres = NULL;\n\t\t\tgoto lookup;\n\t\t}\n\n\t\t/* Wait on the resource purge to complete before continuing */\n\t\tif (tmpres->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tBUG_ON(tmpres->owner == dlm->node_num);\n\t\t\t__dlm_wait_on_lockres_flags(tmpres,\n\t\t\t\t\t\t    DLM_LOCK_RES_DROPPING_REF);\n\t\t\tspin_unlock(&tmpres->spinlock);\n\t\t\tdlm_lockres_put(tmpres);\n\t\t\ttmpres = NULL;\n\t\t\tgoto lookup;\n\t\t}\n\n\t\t/* Grab inflight ref to pin the resource */\n\t\tdlm_lockres_grab_inflight_ref(dlm, tmpres);\n\n\t\tspin_unlock(&tmpres->spinlock);\n\t\tif (res)\n\t\t\tdlm_lockres_put(res);\n\t\tres = tmpres;\n\t\tgoto leave;\n\t}\n\n\tif (!res) {\n\t\tspin_unlock(&dlm->spinlock);\n\t\tmlog(0, \"allocating a new resource\\n\");\n\t\t/* nothing found and we need to allocate one. */\n\t\talloc_mle = kmem_cache_alloc(dlm_mle_cache, GFP_NOFS);\n\t\tif (!alloc_mle)\n\t\t\tgoto leave;\n\t\tres = dlm_new_lockres(dlm, lockid, namelen);\n\t\tif (!res)\n\t\t\tgoto leave;\n\t\tgoto lookup;\n\t}\n\n\tmlog(0, \"no lockres found, allocated our own: %p\\n\", res);\n\n\tif (flags & LKM_LOCAL) {\n\t\t/* caller knows it's safe to assume it's not mastered elsewhere\n\t\t * DONE!  return right away */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_change_lockres_owner(dlm, res, dlm->node_num);\n\t\t__dlm_insert_lockres(dlm, res);\n\t\tdlm_lockres_grab_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t\t/* lockres still marked IN_PROGRESS */\n\t\tgoto wake_waiters;\n\t}\n\n\t/* check master list to see if another node has started mastering it */\n\tspin_lock(&dlm->master_lock);\n\n\t/* if we found a block, wait for lock to be mastered by another node */\n\tblocked = dlm_find_mle(dlm, &mle, (char *)lockid, namelen);\n\tif (blocked) {\n\t\tint mig;\n\t\tif (mle->type == DLM_MLE_MASTER) {\n\t\t\tmlog(ML_ERROR, \"master entry for nonexistent lock!\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tmig = (mle->type == DLM_MLE_MIGRATION);\n\t\t/* if there is a migration in progress, let the migration\n\t\t * finish before continuing.  we can wait for the absence\n\t\t * of the MIGRATION mle: either the migrate finished or\n\t\t * one of the nodes died and the mle was cleaned up.\n\t\t * if there is a BLOCK here, but it already has a master\n\t\t * set, we are too late.  the master does not have a ref\n\t\t * for us in the refmap.  detach the mle and drop it.\n\t\t * either way, go back to the top and start over. */\n\t\tif (mig || mle->master != O2NM_MAX_NODES) {\n\t\t\tBUG_ON(mig && mle->master == dlm->node_num);\n\t\t\t/* we arrived too late.  the master does not\n\t\t\t * have a ref for us. retry. */\n\t\t\tmlog(0, \"%s:%.*s: late on %s\\n\",\n\t\t\t     dlm->name, namelen, lockid,\n\t\t\t     mig ?  \"MIGRATION\" : \"BLOCK\");\n\t\t\tspin_unlock(&dlm->master_lock);\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t/* master is known, detach */\n\t\t\tif (!mig)\n\t\t\t\tdlm_mle_detach_hb_events(dlm, mle);\n\t\t\tdlm_put_mle(mle);\n\t\t\tmle = NULL;\n\t\t\t/* this is lame, but we can't wait on either\n\t\t\t * the mle or lockres waitqueue here */\n\t\t\tif (mig)\n\t\t\t\tmsleep(100);\n\t\t\tgoto lookup;\n\t\t}\n\t} else {\n\t\t/* go ahead and try to master lock on this node */\n\t\tmle = alloc_mle;\n\t\t/* make sure this does not get freed below */\n\t\talloc_mle = NULL;\n\t\tdlm_init_mle(mle, DLM_MLE_MASTER, dlm, res, NULL, 0);\n\t\tset_bit(dlm->node_num, mle->maybe_map);\n\t\t__dlm_insert_mle(dlm, mle);\n\n\t\t/* still holding the dlm spinlock, check the recovery map\n\t\t * to see if there are any nodes that still need to be\n\t\t * considered.  these will not appear in the mle nodemap\n\t\t * but they might own this lockres.  wait on them. */\n\t\tbit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit < O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\",\n\t\t\t     dlm->name, namelen, (char *)lockid, bit);\n\t\t\twait_on_recovery = 1;\n\t\t}\n\t}\n\n\t/* at this point there is either a DLM_MLE_BLOCK or a\n\t * DLM_MLE_MASTER on the master list, so it's safe to add the\n\t * lockres to the hashtable.  anyone who finds the lock will\n\t * still have to wait on the IN_PROGRESS. */\n\n\t/* finally add the lockres to its hash bucket */\n\t__dlm_insert_lockres(dlm, res);\n\n\t/* since this lockres is new it doesn't not require the spinlock */\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n\n\t/* get an extra ref on the mle in case this is a BLOCK\n\t * if so, the creator of the BLOCK may try to put the last\n\t * ref at this time in the assert master handler, so we\n\t * need an extra one to keep from a bad ptr deref. */\n\tdlm_get_mle_inuse(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\nredo_request:\n\twhile (wait_on_recovery) {\n\t\t/* any cluster changes that occurred after dropping the\n\t\t * dlm spinlock would be detectable be a change on the mle,\n\t\t * so we only need to clear out the recovery map once. */\n\t\tif (dlm_is_recovery_lock(lockid, namelen)) {\n\t\t\tmlog(0, \"%s: Recovery map is not empty, but must \"\n\t\t\t     \"master $RECOVERY lock now\\n\", dlm->name);\n\t\t\tif (!dlm_pre_master_reco_lockres(dlm, res))\n\t\t\t\twait_on_recovery = 0;\n\t\t\telse {\n\t\t\t\tmlog(0, \"%s: waiting 500ms for heartbeat state \"\n\t\t\t\t    \"change\\n\", dlm->name);\n\t\t\t\tmsleep(500);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tdlm_kick_recovery_thread(dlm);\n\t\tmsleep(1000);\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tspin_lock(&dlm->spinlock);\n\t\tbit = find_next_bit(dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit < O2NM_MAX_NODES) {\n\t\t\tmlog(0, \"%s: res %.*s, At least one node (%d) \"\n\t\t\t     \"to recover before lock mastery can begin\\n\",\n\t\t\t     dlm->name, namelen, (char *)lockid, bit);\n\t\t\twait_on_recovery = 1;\n\t\t} else\n\t\t\twait_on_recovery = 0;\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\tif (wait_on_recovery)\n\t\t\tdlm_wait_for_node_recovery(dlm, bit, 10000);\n\t}\n\n\t/* must wait for lock to be mastered elsewhere */\n\tif (blocked)\n\t\tgoto wait;\n\n\tret = -EINVAL;\n\tdlm_node_iter_init(mle->vote_map, &iter);\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = dlm_do_master_request(res, mle, nodenum);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\tif (mle->master != O2NM_MAX_NODES) {\n\t\t\t/* found a master ! */\n\t\t\tif (mle->master <= nodenum)\n\t\t\t\tbreak;\n\t\t\t/* if our master request has not reached the master\n\t\t\t * yet, keep going until it does.  this is how the\n\t\t\t * master will know that asserts are needed back to\n\t\t\t * the lower nodes. */\n\t\t\tmlog(0, \"%s: res %.*s, Requests only up to %u but \"\n\t\t\t     \"master is %u, keep going\\n\", dlm->name, namelen,\n\t\t\t     lockid, nodenum, mle->master);\n\t\t}\n\t}\n\nwait:\n\t/* keep going until the response map includes all nodes */\n\tret = dlm_wait_for_lock_mastery(dlm, res, mle, &blocked);\n\tif (ret < 0) {\n\t\twait_on_recovery = 1;\n\t\tmlog(0, \"%s: res %.*s, Node map changed, redo the master \"\n\t\t     \"request now, blocked=%d\\n\", dlm->name, res->lockname.len,\n\t\t     res->lockname.name, blocked);\n\t\tif (++tries > 20) {\n\t\t\tmlog(ML_ERROR, \"%s: res %.*s, Spinning on \"\n\t\t\t     \"dlm_wait_for_lock_mastery, blocked = %d\\n\",\n\t\t\t     dlm->name, res->lockname.len,\n\t\t\t     res->lockname.name, blocked);\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_print_one_mle(mle);\n\t\t\ttries = 0;\n\t\t}\n\t\tgoto redo_request;\n\t}\n\n\tmlog(0, \"%s: res %.*s, Mastered by %u\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name, res->owner);\n\t/* make sure we never continue without this */\n\tBUG_ON(res->owner == O2NM_MAX_NODES);\n\n\t/* master is known, detach if not already detached */\n\tdlm_mle_detach_hb_events(dlm, mle);\n\tdlm_put_mle(mle);\n\t/* put the extra ref */\n\tdlm_put_mle_inuse(mle);\n\nwake_waiters:\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\nleave:\n\t/* need to free the unused mle */\n\tif (alloc_mle)\n\t\tkmem_cache_free(dlm_mle_cache, alloc_mle);\n\n\treturn res;\n}"
  },
  {
    "function_name": "dlm_lockres_drop_inflight_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "709-715",
    "snippet": "static void dlm_lockres_drop_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tspin_lock(&res->spinlock);\n\t__dlm_lockres_drop_inflight_worker(dlm, res);\n\tspin_unlock(&res->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_drop_inflight_worker",
          "args": [
            "dlm",
            "res"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_drop_inflight_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "698-707",
          "snippet": "static void __dlm_lockres_drop_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON(res->inflight_assert_workers == 0);\n\tres->inflight_assert_workers--;\n\tmlog(0, \"%s:%.*s: inflight assert worker--: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void __dlm_lockres_drop_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON(res->inflight_assert_workers == 0);\n\tres->inflight_assert_workers--;\n\tmlog(0, \"%s:%.*s: inflight assert worker--: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_lockres_drop_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tspin_lock(&res->spinlock);\n\t__dlm_lockres_drop_inflight_worker(dlm, res);\n\tspin_unlock(&res->spinlock);\n}"
  },
  {
    "function_name": "__dlm_lockres_drop_inflight_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "698-707",
    "snippet": "static void __dlm_lockres_drop_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON(res->inflight_assert_workers == 0);\n\tres->inflight_assert_workers--;\n\tmlog(0, \"%s:%.*s: inflight assert worker--: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: inflight assert worker--: now %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->inflight_assert_workers"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->inflight_assert_workers == 0"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void __dlm_lockres_drop_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tBUG_ON(res->inflight_assert_workers == 0);\n\tres->inflight_assert_workers--;\n\tmlog(0, \"%s:%.*s: inflight assert worker--: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}"
  },
  {
    "function_name": "__dlm_lockres_grab_inflight_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "688-696",
    "snippet": "void __dlm_lockres_grab_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tres->inflight_assert_workers++;\n\tmlog(0, \"%s:%.*s: inflight assert worker++: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: inflight assert worker++: now %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->inflight_assert_workers"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_grab_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tres->inflight_assert_workers++;\n\tmlog(0, \"%s:%.*s: inflight assert worker++: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}"
  },
  {
    "function_name": "dlm_lockres_drop_inflight_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "672-686",
    "snippet": "void dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->inflight_locks == 0);\n\n\tres->inflight_locks--;\n\n\tmlog(0, \"%s: res %.*s, inflight--: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n\n\twake_up(&res->wq);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, inflight--: now %u, %ps()\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->inflight_locks",
            "__builtin_return_address(0)"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->inflight_locks == 0"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->inflight_locks == 0);\n\n\tres->inflight_locks--;\n\n\tmlog(0, \"%s: res %.*s, inflight--: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n\n\twake_up(&res->wq);\n}"
  },
  {
    "function_name": "dlm_lockres_grab_inflight_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "665-670",
    "snippet": "void dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_lockres_grab_inflight_ref",
          "args": [
            "dlm",
            "res"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_grab_inflight_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "655-663",
          "snippet": "static void __dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tres->inflight_locks++;\n\n\tmlog(0, \"%s: res %.*s, inflight++: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void __dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tres->inflight_locks++;\n\n\tmlog(0, \"%s: res %.*s, inflight++: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n}"
  },
  {
    "function_name": "__dlm_lockres_grab_inflight_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "655-663",
    "snippet": "static void __dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tres->inflight_locks++;\n\n\tmlog(0, \"%s: res %.*s, inflight++: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, inflight++: now %u, %ps()\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->inflight_locks",
            "__builtin_return_address(0)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void __dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tres->inflight_locks++;\n\n\tmlog(0, \"%s: res %.*s, inflight++: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n}"
  },
  {
    "function_name": "dlm_lockres_clear_refmap_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "644-653",
    "snippet": "void dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "bit",
            "res->refmap"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"res %.*s, clr node %u, %ps()\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "bit",
            "__builtin_return_address(0)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}"
  },
  {
    "function_name": "dlm_lockres_set_refmap_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "633-642",
    "snippet": "void dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit",
            "res->refmap"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"res %.*s, set node %u, %ps()\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "bit",
            "__builtin_return_address(0)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}"
  },
  {
    "function_name": "dlm_new_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "610-631",
    "snippet": "struct dlm_lock_resource *dlm_new_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t   const char *name,\n\t\t\t\t   unsigned int namelen)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tres = kmem_cache_zalloc(dlm_lockres_cache, GFP_NOFS);\n\tif (!res)\n\t\tgoto error;\n\n\tres->lockname.name = kmem_cache_zalloc(dlm_lockname_cache, GFP_NOFS);\n\tif (!res->lockname.name)\n\t\tgoto error;\n\n\tdlm_init_lockres(dlm, res, name, namelen);\n\treturn res;\n\nerror:\n\tif (res)\n\t\tkmem_cache_free(dlm_lockres_cache, res);\n\treturn NULL;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_lockres_cache;",
      "static struct kmem_cache *dlm_lockname_cache;",
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_lockres_cache",
            "res"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_init_lockres",
          "args": [
            "dlm",
            "res",
            "name",
            "namelen"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "555-608",
          "snippet": "static void dlm_init_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res,\n\t\t\t     const char *name, unsigned int namelen)\n{\n\tchar *qname;\n\n\t/* If we memset here, we lose our reference to the kmalloc'd\n\t * res->lockname.name, so be sure to init every field\n\t * correctly! */\n\n\tqname = (char *) res->lockname.name;\n\tmemcpy(qname, name, namelen);\n\n\tres->lockname.len = namelen;\n\tres->lockname.hash = dlm_lockid_hash(name, namelen);\n\n\tinit_waitqueue_head(&res->wq);\n\tspin_lock_init(&res->spinlock);\n\tINIT_HLIST_NODE(&res->hash_node);\n\tINIT_LIST_HEAD(&res->granted);\n\tINIT_LIST_HEAD(&res->converting);\n\tINIT_LIST_HEAD(&res->blocked);\n\tINIT_LIST_HEAD(&res->dirty);\n\tINIT_LIST_HEAD(&res->recovering);\n\tINIT_LIST_HEAD(&res->purge);\n\tINIT_LIST_HEAD(&res->tracking);\n\tatomic_set(&res->asts_reserved, 0);\n\tres->migration_pending = 0;\n\tres->inflight_locks = 0;\n\tres->inflight_assert_workers = 0;\n\n\tres->dlm = dlm;\n\n\tkref_init(&res->refs);\n\n\tatomic_inc(&dlm->res_tot_count);\n\tatomic_inc(&dlm->res_cur_count);\n\n\t/* just for consistency */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tspin_unlock(&res->spinlock);\n\n\tres->state = DLM_LOCK_RES_IN_PROGRESS;\n\n\tres->last_used = 0;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_add_tail(&res->tracking, &dlm->tracking_list);\n\tspin_unlock(&dlm->spinlock);\n\n\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\tmemset(res->refmap, 0, sizeof(res->refmap));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
            "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_init_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res,\n\t\t\t     const char *name, unsigned int namelen)\n{\n\tchar *qname;\n\n\t/* If we memset here, we lose our reference to the kmalloc'd\n\t * res->lockname.name, so be sure to init every field\n\t * correctly! */\n\n\tqname = (char *) res->lockname.name;\n\tmemcpy(qname, name, namelen);\n\n\tres->lockname.len = namelen;\n\tres->lockname.hash = dlm_lockid_hash(name, namelen);\n\n\tinit_waitqueue_head(&res->wq);\n\tspin_lock_init(&res->spinlock);\n\tINIT_HLIST_NODE(&res->hash_node);\n\tINIT_LIST_HEAD(&res->granted);\n\tINIT_LIST_HEAD(&res->converting);\n\tINIT_LIST_HEAD(&res->blocked);\n\tINIT_LIST_HEAD(&res->dirty);\n\tINIT_LIST_HEAD(&res->recovering);\n\tINIT_LIST_HEAD(&res->purge);\n\tINIT_LIST_HEAD(&res->tracking);\n\tatomic_set(&res->asts_reserved, 0);\n\tres->migration_pending = 0;\n\tres->inflight_locks = 0;\n\tres->inflight_assert_workers = 0;\n\n\tres->dlm = dlm;\n\n\tkref_init(&res->refs);\n\n\tatomic_inc(&dlm->res_tot_count);\n\tatomic_inc(&dlm->res_cur_count);\n\n\t/* just for consistency */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tspin_unlock(&res->spinlock);\n\n\tres->state = DLM_LOCK_RES_IN_PROGRESS;\n\n\tres->last_used = 0;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_add_tail(&res->tracking, &dlm->tracking_list);\n\tspin_unlock(&dlm->spinlock);\n\n\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\tmemset(res->refmap, 0, sizeof(res->refmap));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "dlm_lockname_cache",
            "GFP_NOFS"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "dlm_lockres_cache",
            "GFP_NOFS"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstruct dlm_lock_resource *dlm_new_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t   const char *name,\n\t\t\t\t   unsigned int namelen)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tres = kmem_cache_zalloc(dlm_lockres_cache, GFP_NOFS);\n\tif (!res)\n\t\tgoto error;\n\n\tres->lockname.name = kmem_cache_zalloc(dlm_lockname_cache, GFP_NOFS);\n\tif (!res->lockname.name)\n\t\tgoto error;\n\n\tdlm_init_lockres(dlm, res, name, namelen);\n\treturn res;\n\nerror:\n\tif (res)\n\t\tkmem_cache_free(dlm_lockres_cache, res);\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_init_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "555-608",
    "snippet": "static void dlm_init_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res,\n\t\t\t     const char *name, unsigned int namelen)\n{\n\tchar *qname;\n\n\t/* If we memset here, we lose our reference to the kmalloc'd\n\t * res->lockname.name, so be sure to init every field\n\t * correctly! */\n\n\tqname = (char *) res->lockname.name;\n\tmemcpy(qname, name, namelen);\n\n\tres->lockname.len = namelen;\n\tres->lockname.hash = dlm_lockid_hash(name, namelen);\n\n\tinit_waitqueue_head(&res->wq);\n\tspin_lock_init(&res->spinlock);\n\tINIT_HLIST_NODE(&res->hash_node);\n\tINIT_LIST_HEAD(&res->granted);\n\tINIT_LIST_HEAD(&res->converting);\n\tINIT_LIST_HEAD(&res->blocked);\n\tINIT_LIST_HEAD(&res->dirty);\n\tINIT_LIST_HEAD(&res->recovering);\n\tINIT_LIST_HEAD(&res->purge);\n\tINIT_LIST_HEAD(&res->tracking);\n\tatomic_set(&res->asts_reserved, 0);\n\tres->migration_pending = 0;\n\tres->inflight_locks = 0;\n\tres->inflight_assert_workers = 0;\n\n\tres->dlm = dlm;\n\n\tkref_init(&res->refs);\n\n\tatomic_inc(&dlm->res_tot_count);\n\tatomic_inc(&dlm->res_cur_count);\n\n\t/* just for consistency */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tspin_unlock(&res->spinlock);\n\n\tres->state = DLM_LOCK_RES_IN_PROGRESS;\n\n\tres->last_used = 0;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_add_tail(&res->tracking, &dlm->tracking_list);\n\tspin_unlock(&dlm->spinlock);\n\n\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\tmemset(res->refmap, 0, sizeof(res->refmap));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
      "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "res->refmap",
            "0",
            "sizeof(res->refmap)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "res->lvb",
            "0",
            "DLM_LVB_LEN"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&res->tracking",
            "&dlm->tracking_list"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_lockres_owner",
          "args": [
            "dlm",
            "res",
            "DLM_LOCK_RES_OWNER_UNKNOWN"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1131-1138",
          "snippet": "static inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dlm->res_cur_count"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dlm->res_tot_count"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&res->refs"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&res->asts_reserved",
            "0"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->tracking"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->purge"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->recovering"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->dirty"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->blocked"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->converting"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&res->granted"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&res->hash_node"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&res->spinlock"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&res->wq"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "name",
            "namelen"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qname",
            "name",
            "namelen"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_init_lockres(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res,\n\t\t\t     const char *name, unsigned int namelen)\n{\n\tchar *qname;\n\n\t/* If we memset here, we lose our reference to the kmalloc'd\n\t * res->lockname.name, so be sure to init every field\n\t * correctly! */\n\n\tqname = (char *) res->lockname.name;\n\tmemcpy(qname, name, namelen);\n\n\tres->lockname.len = namelen;\n\tres->lockname.hash = dlm_lockid_hash(name, namelen);\n\n\tinit_waitqueue_head(&res->wq);\n\tspin_lock_init(&res->spinlock);\n\tINIT_HLIST_NODE(&res->hash_node);\n\tINIT_LIST_HEAD(&res->granted);\n\tINIT_LIST_HEAD(&res->converting);\n\tINIT_LIST_HEAD(&res->blocked);\n\tINIT_LIST_HEAD(&res->dirty);\n\tINIT_LIST_HEAD(&res->recovering);\n\tINIT_LIST_HEAD(&res->purge);\n\tINIT_LIST_HEAD(&res->tracking);\n\tatomic_set(&res->asts_reserved, 0);\n\tres->migration_pending = 0;\n\tres->inflight_locks = 0;\n\tres->inflight_assert_workers = 0;\n\n\tres->dlm = dlm;\n\n\tkref_init(&res->refs);\n\n\tatomic_inc(&dlm->res_tot_count);\n\tatomic_inc(&dlm->res_cur_count);\n\n\t/* just for consistency */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, DLM_LOCK_RES_OWNER_UNKNOWN);\n\tspin_unlock(&res->spinlock);\n\n\tres->state = DLM_LOCK_RES_IN_PROGRESS;\n\n\tres->last_used = 0;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_add_tail(&res->tracking, &dlm->tracking_list);\n\tspin_unlock(&dlm->spinlock);\n\n\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\tmemset(res->refmap, 0, sizeof(res->refmap));\n}"
  },
  {
    "function_name": "dlm_lockres_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "550-553",
    "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&res->refs",
            "dlm_lockres_release"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
  },
  {
    "function_name": "dlm_lockres_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "486-548",
    "snippet": "static void dlm_lockres_release(struct kref *kref)\n{\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_ctxt *dlm;\n\n\tres = container_of(kref, struct dlm_lock_resource, refs);\n\tdlm = res->dlm;\n\n\t/* This should not happen -- all lockres' have a name\n\t * associated with them at init time. */\n\tBUG_ON(!res->lockname.name);\n\n\tmlog(0, \"destroying lockres %.*s\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tspin_lock(&dlm->track_lock);\n\tif (!list_empty(&res->tracking))\n\t\tlist_del_init(&res->tracking);\n\telse {\n\t\tmlog(ML_ERROR, \"Resource %.*s not on the Tracking list\\n\",\n\t\t     res->lockname.len, res->lockname.name);\n\t\tdlm_print_one_lock_resource(res);\n\t}\n\tspin_unlock(&dlm->track_lock);\n\n\tatomic_dec(&dlm->res_cur_count);\n\n\tif (!hlist_unhashed(&res->hash_node) ||\n\t    !list_empty(&res->granted) ||\n\t    !list_empty(&res->converting) ||\n\t    !list_empty(&res->blocked) ||\n\t    !list_empty(&res->dirty) ||\n\t    !list_empty(&res->recovering) ||\n\t    !list_empty(&res->purge)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Going to BUG for resource %.*s.\"\n\t\t     \"  We're on a list! [%c%c%c%c%c%c%c]\\n\",\n\t\t     res->lockname.len, res->lockname.name,\n\t\t     !hlist_unhashed(&res->hash_node) ? 'H' : ' ',\n\t\t     !list_empty(&res->granted) ? 'G' : ' ',\n\t\t     !list_empty(&res->converting) ? 'C' : ' ',\n\t\t     !list_empty(&res->blocked) ? 'B' : ' ',\n\t\t     !list_empty(&res->dirty) ? 'D' : ' ',\n\t\t     !list_empty(&res->recovering) ? 'R' : ' ',\n\t\t     !list_empty(&res->purge) ? 'P' : ' ');\n\n\t\tdlm_print_one_lock_resource(res);\n\t}\n\n\t/* By the time we're ready to blow this guy away, we shouldn't\n\t * be on any lists. */\n\tBUG_ON(!hlist_unhashed(&res->hash_node));\n\tBUG_ON(!list_empty(&res->granted));\n\tBUG_ON(!list_empty(&res->converting));\n\tBUG_ON(!list_empty(&res->blocked));\n\tBUG_ON(!list_empty(&res->dirty));\n\tBUG_ON(!list_empty(&res->recovering));\n\tBUG_ON(!list_empty(&res->purge));\n\n\tkmem_cache_free(dlm_lockname_cache, (void *)res->lockname.name);\n\n\tkmem_cache_free(dlm_lockres_cache, res);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_lockres_cache;",
      "static struct kmem_cache *dlm_lockname_cache;",
      "static void dlm_mle_release(struct kref *kref);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);",
      "static int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_lockres_cache",
            "res"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_lockname_cache",
            "(void *)res->lockname.name"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&res->purge)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->purge"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&res->recovering)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&res->dirty)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&res->blocked)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&res->converting)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&res->granted)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_unhashed(&res->hash_node)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&res->hash_node"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Going to BUG for resource %.*s.\"\n\t\t     \"  We're on a list! [%c%c%c%c%c%c%c]\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "!hlist_unhashed(&res->hash_node) ? 'H' : ' '",
            "!list_empty(&res->granted) ? 'G' : ' '",
            "!list_empty(&res->converting) ? 'C' : ' '",
            "!list_empty(&res->blocked) ? 'B' : ' '",
            "!list_empty(&res->dirty) ? 'D' : ' '",
            "!list_empty(&res->recovering) ? 'R' : ' '",
            "!list_empty(&res->purge) ? 'P' : ' '"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&res->hash_node"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&res->hash_node"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&dlm->res_cur_count"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->track_lock"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Resource %.*s not on the Tracking list\\n\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&res->tracking"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->track_lock"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!res->lockname.name"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structdlm_lock_resource",
            "refs"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\nstatic void dlm_mle_release(struct kref *kref);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_wait_for_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_master_list_entry *mle,\n\t\t\t\t     int *blocked);\nstatic int dlm_restart_lock_mastery(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t\t    int blocked);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_lockres_release(struct kref *kref)\n{\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_ctxt *dlm;\n\n\tres = container_of(kref, struct dlm_lock_resource, refs);\n\tdlm = res->dlm;\n\n\t/* This should not happen -- all lockres' have a name\n\t * associated with them at init time. */\n\tBUG_ON(!res->lockname.name);\n\n\tmlog(0, \"destroying lockres %.*s\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tspin_lock(&dlm->track_lock);\n\tif (!list_empty(&res->tracking))\n\t\tlist_del_init(&res->tracking);\n\telse {\n\t\tmlog(ML_ERROR, \"Resource %.*s not on the Tracking list\\n\",\n\t\t     res->lockname.len, res->lockname.name);\n\t\tdlm_print_one_lock_resource(res);\n\t}\n\tspin_unlock(&dlm->track_lock);\n\n\tatomic_dec(&dlm->res_cur_count);\n\n\tif (!hlist_unhashed(&res->hash_node) ||\n\t    !list_empty(&res->granted) ||\n\t    !list_empty(&res->converting) ||\n\t    !list_empty(&res->blocked) ||\n\t    !list_empty(&res->dirty) ||\n\t    !list_empty(&res->recovering) ||\n\t    !list_empty(&res->purge)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Going to BUG for resource %.*s.\"\n\t\t     \"  We're on a list! [%c%c%c%c%c%c%c]\\n\",\n\t\t     res->lockname.len, res->lockname.name,\n\t\t     !hlist_unhashed(&res->hash_node) ? 'H' : ' ',\n\t\t     !list_empty(&res->granted) ? 'G' : ' ',\n\t\t     !list_empty(&res->converting) ? 'C' : ' ',\n\t\t     !list_empty(&res->blocked) ? 'B' : ' ',\n\t\t     !list_empty(&res->dirty) ? 'D' : ' ',\n\t\t     !list_empty(&res->recovering) ? 'R' : ' ',\n\t\t     !list_empty(&res->purge) ? 'P' : ' ');\n\n\t\tdlm_print_one_lock_resource(res);\n\t}\n\n\t/* By the time we're ready to blow this guy away, we shouldn't\n\t * be on any lists. */\n\tBUG_ON(!hlist_unhashed(&res->hash_node));\n\tBUG_ON(!list_empty(&res->granted));\n\tBUG_ON(!list_empty(&res->converting));\n\tBUG_ON(!list_empty(&res->blocked));\n\tBUG_ON(!list_empty(&res->dirty));\n\tBUG_ON(!list_empty(&res->recovering));\n\tBUG_ON(!list_empty(&res->purge));\n\n\tkmem_cache_free(dlm_lockname_cache, (void *)res->lockname.name);\n\n\tkmem_cache_free(dlm_lockres_cache, res);\n}"
  },
  {
    "function_name": "dlm_destroy_master_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "473-484",
    "snippet": "void dlm_destroy_master_caches(void)\n{\n\tif (dlm_lockname_cache) {\n\t\tkmem_cache_destroy(dlm_lockname_cache);\n\t\tdlm_lockname_cache = NULL;\n\t}\n\n\tif (dlm_lockres_cache) {\n\t\tkmem_cache_destroy(dlm_lockres_cache);\n\t\tdlm_lockres_cache = NULL;\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_lockres_cache;",
      "static struct kmem_cache *dlm_lockname_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "dlm_lockres_cache"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "dlm_lockname_cache"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\n\nvoid dlm_destroy_master_caches(void)\n{\n\tif (dlm_lockname_cache) {\n\t\tkmem_cache_destroy(dlm_lockname_cache);\n\t\tdlm_lockname_cache = NULL;\n\t}\n\n\tif (dlm_lockres_cache) {\n\t\tkmem_cache_destroy(dlm_lockres_cache);\n\t\tdlm_lockres_cache = NULL;\n\t}\n}"
  },
  {
    "function_name": "dlm_init_master_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "453-471",
    "snippet": "int dlm_init_master_caches(void)\n{\n\tdlm_lockres_cache = kmem_cache_create(\"o2dlm_lockres\",\n\t\t\t\t\t      sizeof(struct dlm_lock_resource),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!dlm_lockres_cache)\n\t\tgoto bail;\n\n\tdlm_lockname_cache = kmem_cache_create(\"o2dlm_lockname\",\n\t\t\t\t\t       DLM_LOCKID_NAME_MAX, 0,\n\t\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL);\n\tif (!dlm_lockname_cache)\n\t\tgoto bail;\n\n\treturn 0;\nbail:\n\tdlm_destroy_master_caches();\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_lockres_cache;",
      "static struct kmem_cache *dlm_lockname_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_destroy_master_caches",
          "args": [],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_master_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "473-484",
          "snippet": "void dlm_destroy_master_caches(void)\n{\n\tif (dlm_lockname_cache) {\n\t\tkmem_cache_destroy(dlm_lockname_cache);\n\t\tdlm_lockname_cache = NULL;\n\t}\n\n\tif (dlm_lockres_cache) {\n\t\tkmem_cache_destroy(dlm_lockres_cache);\n\t\tdlm_lockres_cache = NULL;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lockres_cache;",
            "static struct kmem_cache *dlm_lockname_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\n\nvoid dlm_destroy_master_caches(void)\n{\n\tif (dlm_lockname_cache) {\n\t\tkmem_cache_destroy(dlm_lockname_cache);\n\t\tdlm_lockname_cache = NULL;\n\t}\n\n\tif (dlm_lockres_cache) {\n\t\tkmem_cache_destroy(dlm_lockres_cache);\n\t\tdlm_lockres_cache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"o2dlm_lockname\"",
            "DLM_LOCKID_NAME_MAX",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"o2dlm_lockres\"",
            "sizeof(struct dlm_lock_resource)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\n\nint dlm_init_master_caches(void)\n{\n\tdlm_lockres_cache = kmem_cache_create(\"o2dlm_lockres\",\n\t\t\t\t\t      sizeof(struct dlm_lock_resource),\n\t\t\t\t\t      0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!dlm_lockres_cache)\n\t\tgoto bail;\n\n\tdlm_lockname_cache = kmem_cache_create(\"o2dlm_lockname\",\n\t\t\t\t\t       DLM_LOCKID_NAME_MAX, 0,\n\t\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL);\n\tif (!dlm_lockname_cache)\n\t\tgoto bail;\n\n\treturn 0;\nbail:\n\tdlm_destroy_master_caches();\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "dlm_mle_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "421-446",
    "snippet": "static void dlm_mle_release(struct kref *kref)\n{\n\tstruct dlm_master_list_entry *mle;\n\tstruct dlm_ctxt *dlm;\n\n\tmle = container_of(kref, struct dlm_master_list_entry, mle_refs);\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tmlog(0, \"Releasing mle for %.*s, type %d\\n\", mle->mnamelen, mle->mname,\n\t     mle->type);\n\n\t/* remove from list if not already */\n\t__dlm_unlink_mle(dlm, mle);\n\n\t/* detach the mle from the domain node up/down events */\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\tatomic_dec(&dlm->mle_cur_count[mle->type]);\n\n\t/* NOTE: kfree under spinlock here.\n\t * if this is bad, we can move this to a freelist. */\n\tkmem_cache_free(dlm_mle_cache, mle);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_mle_cache;",
      "static void dlm_mle_release(struct kref *kref);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dlm_mle_cache",
            "mle"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&dlm->mle_cur_count[mle->type]"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "187-192",
          "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_unlink_mle",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_unlink_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "319-326",
          "snippet": "void __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Releasing mle for %.*s, type %d\\n\"",
            "mle->mnamelen",
            "mle->mname",
            "mle->type"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structdlm_master_list_entry",
            "mle_refs"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_mle_cache;\nstatic void dlm_mle_release(struct kref *kref);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\n\nstatic void dlm_mle_release(struct kref *kref)\n{\n\tstruct dlm_master_list_entry *mle;\n\tstruct dlm_ctxt *dlm;\n\n\tmle = container_of(kref, struct dlm_master_list_entry, mle_refs);\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tmlog(0, \"Releasing mle for %.*s, type %d\\n\", mle->mnamelen, mle->mname,\n\t     mle->type);\n\n\t/* remove from list if not already */\n\t__dlm_unlink_mle(dlm, mle);\n\n\t/* detach the mle from the domain node up/down events */\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\n\tatomic_dec(&dlm->mle_cur_count[mle->type]);\n\n\t/* NOTE: kfree under spinlock here.\n\t * if this is bad, we can move this to a freelist. */\n\tkmem_cache_free(dlm_mle_cache, mle);\n}"
  },
  {
    "function_name": "dlm_destroy_mle_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "415-419",
    "snippet": "void dlm_destroy_mle_cache(void)\n{\n\tif (dlm_mle_cache)\n\t\tkmem_cache_destroy(dlm_mle_cache);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_mle_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "dlm_mle_cache"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_mle_cache;\n\nvoid dlm_destroy_mle_cache(void)\n{\n\tif (dlm_mle_cache)\n\t\tkmem_cache_destroy(dlm_mle_cache);\n}"
  },
  {
    "function_name": "dlm_init_mle_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "404-413",
    "snippet": "int dlm_init_mle_cache(void)\n{\n\tdlm_mle_cache = kmem_cache_create(\"o2dlm_mle\",\n\t\t\t\t\t  sizeof(struct dlm_master_list_entry),\n\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t  NULL);\n\tif (dlm_mle_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dlm_mle_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"o2dlm_mle\"",
            "sizeof(struct dlm_master_list_entry)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_mle_cache;\n\nint dlm_init_mle_cache(void)\n{\n\tdlm_mle_cache = kmem_cache_create(\"o2dlm_mle\",\n\t\t\t\t\t  sizeof(struct dlm_master_list_entry),\n\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t  NULL);\n\tif (dlm_mle_cache == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_mle_node_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "389-401",
    "snippet": "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node, int idx)\n{\n\tspin_lock(&mle->spinlock);\n\n\tif (test_bit(idx, mle->node_map))\n\t\tmlog(0, \"node %u already in node map!\\n\", idx);\n\telse\n\t\tset_bit(idx, mle->node_map);\n\n\tspin_unlock(&mle->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
      "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "idx",
            "mle->node_map"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u already in node map!\\n\"",
            "idx"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "idx",
            "mle->node_map"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node, int idx)\n{\n\tspin_lock(&mle->spinlock);\n\n\tif (test_bit(idx, mle->node_map))\n\t\tmlog(0, \"node %u already in node map!\\n\", idx);\n\telse\n\t\tset_bit(idx, mle->node_map);\n\n\tspin_unlock(&mle->spinlock);\n}"
  },
  {
    "function_name": "dlm_mle_node_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "375-387",
    "snippet": "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node, int idx)\n{\n\tspin_lock(&mle->spinlock);\n\n\tif (!test_bit(idx, mle->node_map))\n\t\tmlog(0, \"node %u already removed from nodemap!\\n\", idx);\n\telse\n\t\tclear_bit(idx, mle->node_map);\n\n\tspin_unlock(&mle->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
      "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "idx",
            "mle->node_map"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u already removed from nodemap!\\n\"",
            "idx"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "idx",
            "mle->node_map"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mle->spinlock"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node, int idx)\n{\n\tspin_lock(&mle->spinlock);\n\n\tif (!test_bit(idx, mle->node_map))\n\t\tmlog(0, \"node %u already removed from nodemap!\\n\", idx);\n\telse\n\t\tclear_bit(idx, mle->node_map);\n\n\tspin_unlock(&mle->spinlock);\n}"
  },
  {
    "function_name": "dlm_hb_event_notify_attached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "361-373",
    "snippet": "void dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up)\n{\n\tstruct dlm_master_list_entry *mle;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry(mle, &dlm->mle_hb_events, hb_events) {\n\t\tif (node_up)\n\t\t\tdlm_mle_node_up(dlm, mle, NULL, idx);\n\t\telse\n\t\t\tdlm_mle_node_down(dlm, mle, NULL, idx);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
      "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_mle_node_down",
          "args": [
            "dlm",
            "mle",
            "NULL",
            "idx"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_mle_node_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "375-387",
          "snippet": "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node, int idx)\n{\n\tspin_lock(&mle->spinlock);\n\n\tif (!test_bit(idx, mle->node_map))\n\t\tmlog(0, \"node %u already removed from nodemap!\\n\", idx);\n\telse\n\t\tclear_bit(idx, mle->node_map);\n\n\tspin_unlock(&mle->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
            "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node, int idx)\n{\n\tspin_lock(&mle->spinlock);\n\n\tif (!test_bit(idx, mle->node_map))\n\t\tmlog(0, \"node %u already removed from nodemap!\\n\", idx);\n\telse\n\t\tclear_bit(idx, mle->node_map);\n\n\tspin_unlock(&mle->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_mle_node_up",
          "args": [
            "dlm",
            "mle",
            "NULL",
            "idx"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_mle_node_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "389-401",
          "snippet": "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node, int idx)\n{\n\tspin_lock(&mle->spinlock);\n\n\tif (test_bit(idx, mle->node_map))\n\t\tmlog(0, \"node %u already in node map!\\n\", idx);\n\telse\n\t\tset_bit(idx, mle->node_map);\n\n\tspin_unlock(&mle->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
            "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node, int idx)\n{\n\tspin_lock(&mle->spinlock);\n\n\tif (test_bit(idx, mle->node_map))\n\t\tmlog(0, \"node %u already in node map!\\n\", idx);\n\telse\n\t\tset_bit(idx, mle->node_map);\n\n\tspin_unlock(&mle->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mle",
            "&dlm->mle_hb_events",
            "hb_events"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up)\n{\n\tstruct dlm_master_list_entry *mle;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry(mle, &dlm->mle_hb_events, hb_events) {\n\t\tif (node_up)\n\t\t\tdlm_mle_node_up(dlm, mle, NULL, idx);\n\t\telse\n\t\t\tdlm_mle_node_down(dlm, mle, NULL, idx);\n\t}\n}"
  },
  {
    "function_name": "dlm_find_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "339-359",
    "snippet": "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_get_mle",
          "args": [
            "tmpmle"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "260-263",
          "snippet": "static inline void dlm_get_mle(struct dlm_master_list_entry *mle)\n{\n\tkref_get(&mle->mle_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void dlm_get_mle(struct dlm_master_list_entry *mle)\n{\n\tkref_get(&mle->mle_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_mle_equal",
          "args": [
            "dlm",
            "tmpmle",
            "name",
            "namelen"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_mle_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "70-83",
          "snippet": "static inline int dlm_mle_equal(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_master_list_entry *mle,\n\t\t\t\tconst char *name,\n\t\t\t\tunsigned int namelen)\n{\n\tif (dlm != mle->dlm)\n\t\treturn 0;\n\n\tif (namelen != mle->mnamelen ||\n\t    memcmp(name, mle->mname, namelen) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\n\nstatic inline int dlm_mle_equal(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_master_list_entry *mle,\n\t\t\t\tconst char *name,\n\t\t\t\tunsigned int namelen)\n{\n\tif (dlm != mle->dlm)\n\t\treturn 0;\n\n\tif (namelen != mle->mnamelen ||\n\t    memcmp(name, mle->mname, namelen) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "tmpmle",
            "bucket",
            "master_hash_node"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_master_hash",
          "args": [
            "dlm",
            "hash"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_master_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "195-200",
          "snippet": "static inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "name",
            "namelen"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\n\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen)\n{\n\tstruct dlm_master_list_entry *tmpmle;\n\tstruct hlist_head *bucket;\n\tunsigned int hash;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\thash = dlm_lockid_hash(name, namelen);\n\tbucket = dlm_master_hash(dlm, hash);\n\thlist_for_each_entry(tmpmle, bucket, master_hash_node) {\n\t\tif (!dlm_mle_equal(dlm, tmpmle, name, namelen))\n\t\t\tcontinue;\n\t\tdlm_get_mle(tmpmle);\n\t\t*mle = tmpmle;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__dlm_insert_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "328-336",
    "snippet": "void __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\tbucket = dlm_master_hash(dlm, mle->mnamehash);\n\thlist_add_head(&mle->master_hash_node, bucket);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&mle->master_hash_node",
            "bucket"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_master_hash",
          "args": [
            "dlm",
            "mle->mnamehash"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_master_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "195-200",
          "snippet": "static inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_insert_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tstruct hlist_head *bucket;\n\n\tassert_spin_locked(&dlm->master_lock);\n\n\tbucket = dlm_master_hash(dlm, mle->mnamehash);\n\thlist_add_head(&mle->master_hash_node, bucket);\n}"
  },
  {
    "function_name": "__dlm_unlink_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "319-326",
    "snippet": "void __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&mle->master_hash_node"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&mle->master_hash_node"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid __dlm_unlink_mle(struct dlm_ctxt *dlm, struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\n\tif (!hlist_unhashed(&mle->master_hash_node))\n\t\thlist_del_init(&mle->master_hash_node);\n}"
  },
  {
    "function_name": "dlm_init_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "265-317",
    "snippet": "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tmle->dlm = dlm;\n\tmle->type = type;\n\tINIT_HLIST_NODE(&mle->master_hash_node);\n\tINIT_LIST_HEAD(&mle->hb_events);\n\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\tspin_lock_init(&mle->spinlock);\n\tinit_waitqueue_head(&mle->wq);\n\tatomic_set(&mle->woken, 0);\n\tkref_init(&mle->mle_refs);\n\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\tmle->master = O2NM_MAX_NODES;\n\tmle->new_master = O2NM_MAX_NODES;\n\tmle->inuse = 0;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION);\n\n\tif (mle->type == DLM_MLE_MASTER) {\n\t\tBUG_ON(!res);\n\t\tmle->mleres = res;\n\t\tmemcpy(mle->mname, res->lockname.name, res->lockname.len);\n\t\tmle->mnamelen = res->lockname.len;\n\t\tmle->mnamehash = res->lockname.hash;\n\t} else {\n\t\tBUG_ON(!name);\n\t\tmle->mleres = NULL;\n\t\tmemcpy(mle->mname, name, namelen);\n\t\tmle->mnamelen = namelen;\n\t\tmle->mnamehash = dlm_lockid_hash(name, namelen);\n\t}\n\n\tatomic_inc(&dlm->mle_tot_count[mle->type]);\n\tatomic_inc(&dlm->mle_cur_count[mle->type]);\n\n\t/* copy off the node_map and register hb callbacks on our copy */\n\tmemcpy(mle->node_map, dlm->domain_map, sizeof(mle->node_map));\n\tmemcpy(mle->vote_map, dlm->domain_map, sizeof(mle->vote_map));\n\tclear_bit(dlm->node_num, mle->vote_map);\n\tclear_bit(dlm->node_num, mle->node_map);\n\n\t/* attach the mle to the domain node up/down events */\n\t__dlm_mle_attach_hb_events(dlm, mle);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
      "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
      "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
      "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
      "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
      "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_mle_attach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_attach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "178-184",
          "snippet": "static inline void __dlm_mle_attach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_add_tail(&mle->hb_events, &dlm->mle_hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_attach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_add_tail(&mle->hb_events, &dlm->mle_hb_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "dlm->node_num",
            "mle->node_map"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mle->vote_map",
            "dlm->domain_map",
            "sizeof(mle->vote_map)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mle->node_map",
            "dlm->domain_map",
            "sizeof(mle->node_map)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dlm->mle_cur_count[mle->type]"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dlm->mle_tot_count[mle->type]"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "name",
            "namelen"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mle->mname",
            "name",
            "namelen"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!name"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mle->mname",
            "res->lockname.name",
            "res->lockname.len"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!res"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mle->response_map",
            "0",
            "sizeof(mle->response_map)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&mle->mle_refs"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mle->woken",
            "0"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&mle->wq"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mle->spinlock"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mle->maybe_map",
            "0",
            "sizeof(mle->maybe_map)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mle->hb_events"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&mle->master_hash_node"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tmle->dlm = dlm;\n\tmle->type = type;\n\tINIT_HLIST_NODE(&mle->master_hash_node);\n\tINIT_LIST_HEAD(&mle->hb_events);\n\tmemset(mle->maybe_map, 0, sizeof(mle->maybe_map));\n\tspin_lock_init(&mle->spinlock);\n\tinit_waitqueue_head(&mle->wq);\n\tatomic_set(&mle->woken, 0);\n\tkref_init(&mle->mle_refs);\n\tmemset(mle->response_map, 0, sizeof(mle->response_map));\n\tmle->master = O2NM_MAX_NODES;\n\tmle->new_master = O2NM_MAX_NODES;\n\tmle->inuse = 0;\n\n\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t       mle->type != DLM_MLE_MASTER &&\n\t       mle->type != DLM_MLE_MIGRATION);\n\n\tif (mle->type == DLM_MLE_MASTER) {\n\t\tBUG_ON(!res);\n\t\tmle->mleres = res;\n\t\tmemcpy(mle->mname, res->lockname.name, res->lockname.len);\n\t\tmle->mnamelen = res->lockname.len;\n\t\tmle->mnamehash = res->lockname.hash;\n\t} else {\n\t\tBUG_ON(!name);\n\t\tmle->mleres = NULL;\n\t\tmemcpy(mle->mname, name, namelen);\n\t\tmle->mnamelen = namelen;\n\t\tmle->mnamehash = dlm_lockid_hash(name, namelen);\n\t}\n\n\tatomic_inc(&dlm->mle_tot_count[mle->type]);\n\tatomic_inc(&dlm->mle_cur_count[mle->type]);\n\n\t/* copy off the node_map and register hb callbacks on our copy */\n\tmemcpy(mle->node_map, dlm->domain_map, sizeof(mle->node_map));\n\tmemcpy(mle->vote_map, dlm->domain_map, sizeof(mle->vote_map));\n\tclear_bit(dlm->node_num, mle->vote_map);\n\tclear_bit(dlm->node_num, mle->node_map);\n\n\t/* attach the mle to the domain node up/down events */\n\t__dlm_mle_attach_hb_events(dlm, mle);\n}"
  },
  {
    "function_name": "dlm_get_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "260-263",
    "snippet": "static inline void dlm_get_mle(struct dlm_master_list_entry *mle)\n{\n\tkref_get(&mle->mle_refs);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&mle->mle_refs"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void dlm_get_mle(struct dlm_master_list_entry *mle)\n{\n\tkref_get(&mle->mle_refs);\n}"
  },
  {
    "function_name": "dlm_put_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "248-258",
    "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "229-244",
          "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "__dlm_put_mle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "229-244",
    "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&mle->mle_refs",
            "dlm_mle_release"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_mle",
          "args": [
            "mle"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_one_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "328-337",
          "snippet": "void dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid dlm_print_one_mle(struct dlm_master_list_entry *mle)\n{\n\tchar *buf;\n\n\tbuf = (char *) get_zeroed_page(GFP_NOFS);\n\tif (buf) {\n\t\tdump_mle(mle, buf, PAGE_SIZE - 1);\n\t\tfree_page((unsigned long)buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bad mle: %p\\n\"",
            "mle"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mle->mle_refs.refcount"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
  },
  {
    "function_name": "dlm_put_mle_inuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "214-226",
    "snippet": "static void dlm_put_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tmle->inuse--;\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_put_mle",
          "args": [
            "mle"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "229-244",
          "snippet": "static void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tif (!atomic_read(&mle->mle_refs.refcount)) {\n\t\t/* this may or may not crash, but who cares.\n\t\t * it's a BUG. */\n\t\tmlog(ML_ERROR, \"bad mle: %p\\n\", mle);\n\t\tdlm_print_one_mle(mle);\n\t\tBUG();\n\t} else\n\t\tkref_put(&mle->mle_refs, dlm_mle_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\tmle->inuse--;\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n\n}"
  },
  {
    "function_name": "dlm_get_mle_inuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "203-212",
    "snippet": "static void dlm_get_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tmle->inuse++;\n\tkref_get(&mle->mle_refs);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&mle->mle_refs"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->master_lock"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_get_mle_inuse(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&dlm->master_lock);\n\tmle->inuse++;\n\tkref_get(&mle->mle_refs);\n}"
  },
  {
    "function_name": "dlm_mle_detach_hb_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "195-201",
    "snippet": "static inline void dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_mle_detach_hb_events",
          "args": [
            "dlm",
            "mle"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_mle_detach_hb_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "187-192",
          "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_master_list_entry *mle)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_mle_detach_hb_events(dlm, mle);\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "__dlm_mle_detach_hb_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "187-192",
    "snippet": "static inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mle->hb_events"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mle->hb_events"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_detach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tif (!list_empty(&mle->hb_events))\n\t\tlist_del_init(&mle->hb_events);\n}"
  },
  {
    "function_name": "__dlm_mle_attach_hb_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "178-184",
    "snippet": "static inline void __dlm_mle_attach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_add_tail(&mle->hb_events, &dlm->mle_hb_events);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mle->hb_events",
            "&dlm->mle_hb_events"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic inline void __dlm_mle_attach_hb_events(struct dlm_ctxt *dlm,\n\t\t\t\t\t      struct dlm_master_list_entry *mle)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_add_tail(&mle->hb_events, &dlm->mle_hb_events);\n}"
  },
  {
    "function_name": "dlm_is_host_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "132-154",
    "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_mle_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
    "lines": "70-83",
    "snippet": "static inline int dlm_mle_equal(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_master_list_entry *mle,\n\t\t\t\tconst char *name,\n\t\t\t\tunsigned int namelen)\n{\n\tif (dlm != mle->dlm)\n\t\treturn 0;\n\n\tif (namelen != mle->mnamelen ||\n\t    memcmp(name, mle->mname, namelen) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdebug.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
      "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
      "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "mle->mname",
            "namelen"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\n\nstatic inline int dlm_mle_equal(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_master_list_entry *mle,\n\t\t\t\tconst char *name,\n\t\t\t\tunsigned int namelen)\n{\n\tif (dlm != mle->dlm)\n\t\treturn 0;\n\n\tif (namelen != mle->mnamelen ||\n\t    memcmp(name, mle->mname, namelen) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
  }
]