[
  {
    "function_name": "xit_em86_binfmt(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_em86.c",
    "lines": "110-113",
    "snippet": "tatic void __exit exit_em86_binfmt(void)\n{\n\tunregister_binfmt(&em86_format);\n}",
    "includes": [
      "include <linux/errno.h>",
      "include <linux/file.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/elf.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/stat.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct linux_binfmt em86_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_em86,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nregister_binfmt(",
          "args": [
            "em86_format)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/errno.h>\ninclude <linux/file.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/elf.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/stat.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct linux_binfmt em86_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_em86,\n};\n\ntatic void __exit exit_em86_binfmt(void)\n{\n\tunregister_binfmt(&em86_format);\n}"
  },
  {
    "function_name": "nit_em86_binfmt(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_em86.c",
    "lines": "104-108",
    "snippet": "tatic int __init init_em86_binfmt(void)\n{\n\tregister_binfmt(&em86_format);\n\treturn 0;\n}",
    "includes": [
      "include <linux/errno.h>",
      "include <linux/file.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/elf.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/stat.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct linux_binfmt em86_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_em86,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egister_binfmt(",
          "args": [
            "em86_format)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/errno.h>\ninclude <linux/file.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/elf.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/stat.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct linux_binfmt em86_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_em86,\n};\n\ntatic int __init init_em86_binfmt(void)\n{\n\tregister_binfmt(&em86_format);\n\treturn 0;\n}"
  },
  {
    "function_name": "oad_em86(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_em86.c",
    "lines": "25-97",
    "snippet": "tatic int load_em86(struct linux_binprm *bprm)\n{\n\tchar *interp, *i_name, *i_arg;\n\tstruct file * file;\n\tint retval;\n\tstruct elfhdr\telf_ex;\n\n\t/* Make sure this is a Linux/Intel ELF executable... */\n\telf_ex = *((struct elfhdr *)bprm->buf);\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\treturn  -ENOEXEC;\n\n\t/* First of all, some simple consistency checks */\n\tif ((elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) ||\n\t\t(!((elf_ex.e_machine == EM_386) || (elf_ex.e_machine == EM_486))) ||\n\t\t!bprm->file->f_op->mmap) {\n\t\t\treturn -ENOEXEC;\n\t}\n\n\t/* Need to be able to load the file after exec */\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\treturn -ENOENT;\n\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\t/* Unlike in the script case, we don't have to do any hairy\n\t * parsing to find our interpreter... it's hardcoded!\n\t */\n\tinterp = EM86_INTERP;\n\ti_name = EM86_I_NAME;\n\ti_arg = NULL;\t\t/* We reserve the right to add an arg later */\n\n\t/*\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of emulated file (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tremove_arg_zero(bprm);\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval < 0)\treturn retval;\n\tbprm->argc++;\n\n\t/*\n\t * OK, now restart the process with the interpreter's inode.\n\t * Note that we use open_exec() as the name is now in kernel\n\t * space, and we don't need to copy it.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn search_binary_handler(bprm);\n}",
    "includes": [
      "include <linux/errno.h>",
      "include <linux/file.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/elf.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/stat.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "earch_binary_handler(",
          "args": [
            "prm)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repare_binprm(",
          "args": [
            "prm)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "ile)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "ile)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pen_exec(",
          "args": [
            "nterp)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_strings_kernel(",
          "args": [
            ",",
            "i_name,",
            "prm)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_strings_kernel(",
          "args": [
            ",",
            "i_arg,",
            "prm)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_strings_kernel(",
          "args": [
            ",",
            "bprm->filename,",
            "prm)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emove_arg_zero(",
          "args": [
            "prm)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "prm->file)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llow_write_access(",
          "args": [
            "prm->file)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcmp(",
          "args": [
            "lf_ex.e_ident,",
            "LFMAG,",
            "ELFMAG)"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/errno.h>\ninclude <linux/file.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/elf.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/stat.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int load_em86(struct linux_binprm *bprm)\n{\n\tchar *interp, *i_name, *i_arg;\n\tstruct file * file;\n\tint retval;\n\tstruct elfhdr\telf_ex;\n\n\t/* Make sure this is a Linux/Intel ELF executable... */\n\telf_ex = *((struct elfhdr *)bprm->buf);\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\treturn  -ENOEXEC;\n\n\t/* First of all, some simple consistency checks */\n\tif ((elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) ||\n\t\t(!((elf_ex.e_machine == EM_386) || (elf_ex.e_machine == EM_486))) ||\n\t\t!bprm->file->f_op->mmap) {\n\t\t\treturn -ENOEXEC;\n\t}\n\n\t/* Need to be able to load the file after exec */\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\treturn -ENOENT;\n\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\t/* Unlike in the script case, we don't have to do any hairy\n\t * parsing to find our interpreter... it's hardcoded!\n\t */\n\tinterp = EM86_INTERP;\n\ti_name = EM86_I_NAME;\n\ti_arg = NULL;\t\t/* We reserve the right to add an arg later */\n\n\t/*\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of emulated file (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tremove_arg_zero(bprm);\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval < 0)\treturn retval;\n\tbprm->argc++;\n\n\t/*\n\t * OK, now restart the process with the interpreter's inode.\n\t * Note that we use open_exec() as the name is now in kernel\n\t * space, and we don't need to copy it.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn search_binary_handler(bprm);\n}"
  }
]