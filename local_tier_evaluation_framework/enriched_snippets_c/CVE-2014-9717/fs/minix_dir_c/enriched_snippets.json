[
  {
    "function_name": "minix_inode_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "455-473",
    "snippet": "ino_t minix_inode_by_name(struct dentry *dentry)\n{\n\tstruct page *page;\n\tstruct minix_dir_entry *de = minix_find_entry(dentry, &page);\n\tino_t res = 0;\n\n\tif (de) {\n\t\tstruct address_space *mapping = page->mapping;\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\tres = ((minix3_dirent *) de)->inode;\n\t\telse\n\t\t\tres = de->inode;\n\t\tdir_put_page(page);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_put_page",
          "args": [
            "page"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "28-32",
          "snippet": "static inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_find_entry",
          "args": [
            "dentry",
            "&page"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "minix_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "155-202",
          "snippet": "minix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nminix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nino_t minix_inode_by_name(struct dentry *dentry)\n{\n\tstruct page *page;\n\tstruct minix_dir_entry *de = minix_find_entry(dentry, &page);\n\tino_t res = 0;\n\n\tif (de) {\n\t\tstruct address_space *mapping = page->mapping;\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\tres = ((minix3_dirent *) de)->inode;\n\t\telse\n\t\t\tres = de->inode;\n\t\tdir_put_page(page);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "minix_dotdot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "442-453",
    "snippet": "struct minix_dir_entry * minix_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = dir_get_page(dir, 0);\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tstruct minix_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = minix_next_entry(page_address(page), sbi);\n\t\t*p = page;\n\t}\n\treturn de;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minix_next_entry",
          "args": [
            "page_address(page)",
            "sbi"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "minix_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "80-83",
          "snippet": "static inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "dir->i_sb"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_get_page",
          "args": [
            "dir",
            "0"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "dir_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "71-78",
          "snippet": "static struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstruct minix_dir_entry * minix_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = dir_get_page(dir, 0);\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tstruct minix_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = minix_next_entry(page_address(page), sbi);\n\t\t*p = page;\n\t}\n\treturn de;\n}"
  },
  {
    "function_name": "minix_set_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "416-440",
    "snippet": "void minix_set_link(struct minix_dir_entry *de, struct page *page,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *)de-(char*)page_address(page);\n\tint err;\n\n\tlock_page(page);\n\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = inode->i_ino;\n\t\telse\n\t\t\tde->inode = inode->i_ino;\n\t\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_put_page",
          "args": [
            "page"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "28-32",
          "snippet": "static inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_commit_chunk",
          "args": [
            "page",
            "pos",
            "sbi->s_dirsize"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "dir_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "53-69",
          "snippet": "static int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_prepare_chunk",
          "args": [
            "page",
            "pos",
            "sbi->s_dirsize"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "minix_prepare_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "394-397",
          "snippet": "int minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nint minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "dir->i_sb"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nvoid minix_set_link(struct minix_dir_entry *de, struct page *page,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *)de-(char*)page_address(page);\n\tint err;\n\n\tlock_page(page);\n\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = inode->i_ino;\n\t\telse\n\t\t\tde->inode = inode->i_ino;\n\t\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}"
  },
  {
    "function_name": "minix_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "365-413",
    "snippet": "int minix_empty_dir(struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *name;\n\t__u32 inumber;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *p, *kaddr, *limit;\n\n\t\tpage = dir_get_page(inode, i);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(inode, i) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\n\t\t\tif (inumber != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (!name[1]) {\n\t\t\t\t\tif (inumber != inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\telse if (name[2])\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_put_page",
          "args": [
            "page"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "28-32",
          "snippet": "static inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_next_entry",
          "args": [
            "p",
            "sbi"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "minix_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "80-83",
          "snippet": "static inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_last_byte",
          "args": [
            "inode",
            "i"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "minix_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "38-46",
          "snippet": "static unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_get_page",
          "args": [
            "inode",
            "i"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "dir_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "71-78",
          "snippet": "static struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "inode"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "48-51",
          "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_empty_dir(struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *name;\n\t__u32 inumber;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *p, *kaddr, *limit;\n\n\t\tpage = dir_get_page(inode, i);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(inode, i) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\n\t\t\tif (inumber != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (!name[1]) {\n\t\t\t\t\tif (inumber != inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\telse if (name[2])\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "minix_make_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "319-360",
    "snippet": "int minix_make_empty(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *kaddr;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\terr = minix_prepare_chunk(page, 0, 2 * sbi->s_dirsize);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr, 0, PAGE_CACHE_SIZE);\n\n\tif (sbi->s_version == MINIX_V3) {\n\t\tminix3_dirent *de3 = (minix3_dirent *)kaddr;\n\n\t\tde3->inode = inode->i_ino;\n\t\tstrcpy(de3->name, \".\");\n\t\tde3 = minix_next_entry(de3, sbi);\n\t\tde3->inode = dir->i_ino;\n\t\tstrcpy(de3->name, \"..\");\n\t} else {\n\t\tminix_dirent *de = (minix_dirent *)kaddr;\n\n\t\tde->inode = inode->i_ino;\n\t\tstrcpy(de->name, \".\");\n\t\tde = minix_next_entry(de, sbi);\n\t\tde->inode = dir->i_ino;\n\t\tstrcpy(de->name, \"..\");\n\t}\n\tkunmap_atomic(kaddr);\n\n\terr = dir_commit_chunk(page, 0, 2 * sbi->s_dirsize);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_commit_chunk",
          "args": [
            "page",
            "0",
            "2 * sbi->s_dirsize"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "dir_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "53-69",
          "snippet": "static int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->name",
            "\"..\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_next_entry",
          "args": [
            "de",
            "sbi"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "minix_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "80-83",
          "snippet": "static inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de->name",
            "\".\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de3->name",
            "\"..\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "de3->name",
            "\".\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_prepare_chunk",
          "args": [
            "page",
            "0",
            "2 * sbi->s_dirsize"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "minix_prepare_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "394-397",
          "snippet": "int minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nint minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "inode->i_mapping",
            "0"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_make_empty(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *kaddr;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\terr = minix_prepare_chunk(page, 0, 2 * sbi->s_dirsize);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr, 0, PAGE_CACHE_SIZE);\n\n\tif (sbi->s_version == MINIX_V3) {\n\t\tminix3_dirent *de3 = (minix3_dirent *)kaddr;\n\n\t\tde3->inode = inode->i_ino;\n\t\tstrcpy(de3->name, \".\");\n\t\tde3 = minix_next_entry(de3, sbi);\n\t\tde3->inode = dir->i_ino;\n\t\tstrcpy(de3->name, \"..\");\n\t} else {\n\t\tminix_dirent *de = (minix_dirent *)kaddr;\n\n\t\tde->inode = inode->i_ino;\n\t\tstrcpy(de->name, \".\");\n\t\tde = minix_next_entry(de, sbi);\n\t\tde->inode = dir->i_ino;\n\t\tstrcpy(de->name, \"..\");\n\t}\n\tkunmap_atomic(kaddr);\n\n\terr = dir_commit_chunk(page, 0, 2 * sbi->s_dirsize);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "minix_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "293-317",
    "snippet": "int minix_delete_entry(struct minix_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tloff_t pos = page_offset(page) + (char*)de - kaddr;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tunsigned len = sbi->s_dirsize;\n\tint err;\n\n\tlock_page(page);\n\terr = minix_prepare_chunk(page, pos, len);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = 0;\n\t\telse\n\t\t\tde->inode = 0;\n\t\terr = dir_commit_chunk(page, pos, len);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_put_page",
          "args": [
            "page"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "28-32",
          "snippet": "static inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_commit_chunk",
          "args": [
            "page",
            "pos",
            "len"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "dir_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "53-69",
          "snippet": "static int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_prepare_chunk",
          "args": [
            "page",
            "pos",
            "len"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "minix_prepare_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "394-397",
          "snippet": "int minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nint minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_delete_entry(struct minix_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tloff_t pos = page_offset(page) + (char*)de - kaddr;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tunsigned len = sbi->s_dirsize;\n\tint err;\n\n\tlock_page(page);\n\terr = minix_prepare_chunk(page, pos, len);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = 0;\n\t\telse\n\t\t\tde->inode = 0;\n\t\terr = dir_commit_chunk(page, pos, len);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "minix_add_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "204-291",
    "snippet": "int minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t/*\n\t * We take care of directory expansion in the same loop\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_CACHE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_put_page",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "28-32",
          "snippet": "static inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_commit_chunk",
          "args": [
            "page",
            "pos",
            "sbi->s_dirsize"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "dir_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "53-69",
          "snippet": "static int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "namx + namelen",
            "0",
            "sbi->s_dirsize - namelen - 2"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "namx + namelen",
            "0",
            "sbi->s_dirsize - namelen - 4"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "namx",
            "name",
            "namelen"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_prepare_chunk",
          "args": [
            "page",
            "pos",
            "sbi->s_dirsize"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "minix_prepare_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "394-397",
          "snippet": "int minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nint minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namecompare",
          "args": [
            "namelen",
            "sbi->s_namelen",
            "name",
            "namx"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "namecompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "139-145",
          "snippet": "static inline int namecompare(int len, int maxlen,\n\tconst char * name, const char * buffer)\n{\n\tif (len < maxlen && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline int namecompare(int len, int maxlen,\n\tconst char * name, const char * buffer)\n{\n\tif (len < maxlen && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_next_entry",
          "args": [
            "p",
            "sbi"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "minix_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "80-83",
          "snippet": "static inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_last_byte",
          "args": [
            "dir",
            "n"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "minix_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "38-46",
          "snippet": "static unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_get_page",
          "args": [
            "dir",
            "n"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "dir_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "71-78",
          "snippet": "static struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "dir"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "48-51",
          "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "sb"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t/*\n\t * We take care of directory expansion in the same loop\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_CACHE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
  },
  {
    "function_name": "minix_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "155-202",
    "snippet": "minix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_put_page",
          "args": [
            "page"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "28-32",
          "snippet": "static inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "namecompare",
          "args": [
            "namelen",
            "sbi->s_namelen",
            "name",
            "namx"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "namecompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "139-145",
          "snippet": "static inline int namecompare(int len, int maxlen,\n\tconst char * name, const char * buffer)\n{\n\tif (len < maxlen && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline int namecompare(int len, int maxlen,\n\tconst char * name, const char * buffer)\n{\n\tif (len < maxlen && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_next_entry",
          "args": [
            "p",
            "sbi"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "minix_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "80-83",
          "snippet": "static inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_last_byte",
          "args": [
            "dir",
            "n"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "minix_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "38-46",
          "snippet": "static unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_get_page",
          "args": [
            "dir",
            "n"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "dir_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "71-78",
          "snippet": "static struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "dir"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "48-51",
          "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "sb"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nminix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}"
  },
  {
    "function_name": "namecompare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "139-145",
    "snippet": "static inline int namecompare(int len, int maxlen,\n\tconst char * name, const char * buffer)\n{\n\tif (len < maxlen && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "buffer",
            "len"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline int namecompare(int len, int maxlen,\n\tconst char * name, const char * buffer)\n{\n\tif (len < maxlen && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}"
  },
  {
    "function_name": "minix_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "85-137",
    "snippet": "static int minix_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tunsigned chunk_size = sbi->s_dirsize;\n\tunsigned long npages = dir_pages(inode);\n\tunsigned long pos = ctx->pos;\n\tunsigned offset;\n\tunsigned long n;\n\n\tctx->pos = pos = ALIGN(pos, chunk_size);\n\tif (pos >= inode->i_size)\n\t\treturn 0;\n\n\toffset = pos & ~PAGE_CACHE_MASK;\n\tn = pos >> PAGE_CACHE_SHIFT;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *p, *kaddr, *limit;\n\t\tstruct page *page = dir_get_page(inode, n);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\t\tkaddr = (char *)page_address(page);\n\t\tp = kaddr+offset;\n\t\tlimit = kaddr + minix_last_byte(inode, n) - chunk_size;\n\t\tfor ( ; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tconst char *name;\n\t\t\t__u32 inumber;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t \t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (inumber) {\n\t\t\t\tunsigned l = strnlen(name, sbi->s_namelen);\n\t\t\t\tif (!dir_emit(ctx, name, l,\n\t\t\t\t\t      inumber, DT_UNKNOWN)) {\n\t\t\t\t\tdir_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += chunk_size;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int minix_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_put_page",
          "args": [
            "page"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "28-32",
          "snippet": "static inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "l",
            "inumber",
            "DT_UNKNOWN"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "name",
            "sbi->s_namelen"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_next_entry",
          "args": [
            "p",
            "sbi"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "minix_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "80-83",
          "snippet": "static inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_last_byte",
          "args": [
            "inode",
            "n"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "minix_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "38-46",
          "snippet": "static unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_get_page",
          "args": [
            "inode",
            "n"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "dir_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "71-78",
          "snippet": "static struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "pos",
            "chunk_size"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "48-51",
          "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "sb"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic int minix_readdir(struct file *, struct dir_context *);\n\nstatic int minix_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tunsigned chunk_size = sbi->s_dirsize;\n\tunsigned long npages = dir_pages(inode);\n\tunsigned long pos = ctx->pos;\n\tunsigned offset;\n\tunsigned long n;\n\n\tctx->pos = pos = ALIGN(pos, chunk_size);\n\tif (pos >= inode->i_size)\n\t\treturn 0;\n\n\toffset = pos & ~PAGE_CACHE_MASK;\n\tn = pos >> PAGE_CACHE_SHIFT;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *p, *kaddr, *limit;\n\t\tstruct page *page = dir_get_page(inode, n);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\t\tkaddr = (char *)page_address(page);\n\t\tp = kaddr+offset;\n\t\tlimit = kaddr + minix_last_byte(inode, n) - chunk_size;\n\t\tfor ( ; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tconst char *name;\n\t\t\t__u32 inumber;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t \t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (inumber) {\n\t\t\t\tunsigned l = strnlen(name, sbi->s_namelen);\n\t\t\t\tif (!dir_emit(ctx, name, l,\n\t\t\t\t\t      inumber, DT_UNKNOWN)) {\n\t\t\t\t\tdir_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += chunk_size;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "minix_next_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "80-83",
    "snippet": "static inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)\n{\n\treturn (void*)((char*)de + sbi->s_dirsize);\n}"
  },
  {
    "function_name": "dir_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "71-78",
    "snippet": "static struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "n",
            "NULL"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic struct page * dir_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\tif (!IS_ERR(page))\n\t\tkmap(page);\n\treturn page;\n}"
  },
  {
    "function_name": "dir_commit_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "53-69",
    "snippet": "static int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_page",
          "args": [
            "page",
            "1"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dir",
            "pos+len"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "NULL",
            "mapping",
            "pos",
            "len",
            "len",
            "page",
            "NULL"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2031-2064",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic int dir_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\tblock_write_end(NULL, mapping, pos, len, len, page, NULL);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "dir_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "48-51",
    "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;\n}"
  },
  {
    "function_name": "minix_last_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "38-46",
    "snippet": "static unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic unsigned\nminix_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tunsigned last_byte = PAGE_CACHE_SIZE;\n\n\tif (page_nr == (inode->i_size >> PAGE_CACHE_SHIFT))\n\t\tlast_byte = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\treturn last_byte;\n}"
  },
  {
    "function_name": "dir_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
    "lines": "28-32",
    "snippet": "static inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include <linux/swap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic inline void dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
  }
]