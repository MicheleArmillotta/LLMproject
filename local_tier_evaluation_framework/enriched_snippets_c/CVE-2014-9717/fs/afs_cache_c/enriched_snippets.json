[
  {
    "function_name": "afs_vnode_cache_now_uncached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "370-402",
    "snippet": "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tstruct pagevec pvec;\n\tpgoff_t first;\n\tint loop, nr_pages;\n\n\t_enter(\"{%x,%x,%Lx}\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version);\n\n\tpagevec_init(&pvec, 0);\n\tfirst = 0;\n\n\tfor (;;) {\n\t\t/* grab a bunch of pages to clean */\n\t\tnr_pages = pagevec_lookup(&pvec, vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  first,\n\t\t\t\t\t  PAGEVEC_SIZE - pagevec_count(&pvec));\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (loop = 0; loop < nr_pages; loop++)\n\t\t\tClearPageFsCache(pvec.pages[loop]);\n\n\t\tfirst = pvec.pages[nr_pages - 1]->index + 1;\n\n\t\tpvec.nr = nr_pages;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageFsCache",
          "args": [
            "pvec.pages[loop]"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "vnode->vfs_inode.i_mapping",
            "first",
            "PAGEVEC_SIZE - pagevec_count(&pvec)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x,%x,%Lx}\"",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "vnode->status.data_version"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tstruct pagevec pvec;\n\tpgoff_t first;\n\tint loop, nr_pages;\n\n\t_enter(\"{%x,%x,%Lx}\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version);\n\n\tpagevec_init(&pvec, 0);\n\tfirst = 0;\n\n\tfor (;;) {\n\t\t/* grab a bunch of pages to clean */\n\t\tnr_pages = pagevec_lookup(&pvec, vnode->vfs_inode.i_mapping,\n\t\t\t\t\t  first,\n\t\t\t\t\t  PAGEVEC_SIZE - pagevec_count(&pvec));\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\n\t\tfor (loop = 0; loop < nr_pages; loop++)\n\t\t\tClearPageFsCache(pvec.pages[loop]);\n\n\t\tfirst = pvec.pages[nr_pages - 1]->index + 1;\n\n\t\tpvec.nr = nr_pages;\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_vnode_cache_check_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "314-361",
    "snippet": "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen != buflen) {\n\t\t_leave(\" = OBSOLETE [len %hx != %hx]\", dlen, buflen);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer,\n\t\t   &vnode->fid.unique,\n\t\t   sizeof(vnode->fid.unique)\n\t\t   ) != 0) {\n\t\tunsigned unique;\n\n\t\tmemcpy(&unique, buffer, sizeof(unique));\n\n\t\t_leave(\" = OBSOLETE [uniq %x != %x]\",\n\t\t       unique, vnode->fid.unique);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer + sizeof(vnode->fid.unique),\n\t\t   &vnode->status.data_version,\n\t\t   sizeof(vnode->status.data_version)\n\t\t   ) != 0) {\n\t\tafs_dataversion_t version;\n\n\t\tmemcpy(&version, buffer + sizeof(vnode->fid.unique),\n\t\t       sizeof(version));\n\n\t\t_leave(\" = OBSOLETE [vers %llx != %llx]\",\n\t\t       version, vnode->status.data_version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = SUCCESS\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
      "static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);",
      "static uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
      "static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);",
      "static uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);",
      "static uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
      "static void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);",
      "static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);",
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = SUCCESS\""
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = OBSOLETE [vers %llx != %llx]\"",
            "version",
            "vnode->status.data_version"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&version",
            "buffer + sizeof(vnode->fid.unique)",
            "sizeof(version)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer + sizeof(vnode->fid.unique)",
            "&vnode->status.data_version",
            "sizeof(vnode->status.data_version)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&unique",
            "buffer",
            "sizeof(unique)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buffer",
            "&vnode->fid.unique",
            "sizeof(vnode->fid.unique)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x,%x,%llx},%p,%u\"",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "vnode->status.data_version",
            "buffer",
            "buflen"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);\nstatic uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);\nstatic uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);\nstatic uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen != buflen) {\n\t\t_leave(\" = OBSOLETE [len %hx != %hx]\", dlen, buflen);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer,\n\t\t   &vnode->fid.unique,\n\t\t   sizeof(vnode->fid.unique)\n\t\t   ) != 0) {\n\t\tunsigned unique;\n\n\t\tmemcpy(&unique, buffer, sizeof(unique));\n\n\t\t_leave(\" = OBSOLETE [uniq %x != %x]\",\n\t\t       unique, vnode->fid.unique);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer + sizeof(vnode->fid.unique),\n\t\t   &vnode->status.data_version,\n\t\t   sizeof(vnode->status.data_version)\n\t\t   ) != 0) {\n\t\tafs_dataversion_t version;\n\n\t\tmemcpy(&version, buffer + sizeof(vnode->fid.unique),\n\t\t       sizeof(version));\n\n\t\t_leave(\" = OBSOLETE [vers %llx != %llx]\",\n\t\t       version, vnode->status.data_version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = SUCCESS\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
  },
  {
    "function_name": "afs_vnode_cache_get_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "288-309",
    "snippet": "static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t bufmax)\n{\n\tconst struct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%Lx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, bufmax);\n\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, &vnode->fid.unique, sizeof(vnode->fid.unique));\n\tbuffer += sizeof(vnode->fid.unique);\n\tmemcpy(buffer, &vnode->status.data_version,\n\t       sizeof(vnode->status.data_version));\n\n\t_leave(\" = %u\", dlen);\n\treturn dlen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %u\"",
            "dlen"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&vnode->status.data_version",
            "sizeof(vnode->status.data_version)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&vnode->fid.unique",
            "sizeof(vnode->fid.unique)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x,%x,%Lx},%p,%u\"",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "vnode->status.data_version",
            "buffer",
            "bufmax"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t bufmax)\n{\n\tconst struct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%Lx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, bufmax);\n\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, &vnode->fid.unique, sizeof(vnode->fid.unique));\n\tbuffer += sizeof(vnode->fid.unique);\n\tmemcpy(buffer, &vnode->status.data_version,\n\t       sizeof(vnode->status.data_version));\n\n\t_leave(\" = %u\", dlen);\n\treturn dlen;\n}"
  },
  {
    "function_name": "afs_vnode_cache_get_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "273-283",
    "snippet": "static void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size)\n{\n\tconst struct afs_vnode *vnode = cookie_netfs_data;\n\n\t_enter(\"{%x,%x,%llx},\",\n\t       vnode->fid.vnode, vnode->fid.unique,\n\t       vnode->status.data_version);\n\n\t*size = vnode->status.size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);",
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x,%x,%llx},\"",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "vnode->status.data_version"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size)\n{\n\tconst struct afs_vnode *vnode = cookie_netfs_data;\n\n\t_enter(\"{%x,%x,%llx},\",\n\t       vnode->fid.vnode, vnode->fid.unique,\n\t       vnode->status.data_version);\n\n\t*size = vnode->status.size;\n}"
  },
  {
    "function_name": "afs_vnode_cache_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "250-268",
    "snippet": "static uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t bufmax)\n{\n\tconst struct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t klen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, bufmax);\n\n\tklen = sizeof(vnode->fid.vnode);\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, &vnode->fid.vnode, sizeof(vnode->fid.vnode));\n\n\t_leave(\" = %u\", klen);\n\treturn klen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %u\"",
            "klen"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&vnode->fid.vnode",
            "sizeof(vnode->fid.vnode)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x,%x,%llx},%p,%u\"",
            "vnode->fid.vnode",
            "vnode->fid.unique",
            "vnode->status.data_version",
            "buffer",
            "bufmax"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t bufmax)\n{\n\tconst struct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t klen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, bufmax);\n\n\tklen = sizeof(vnode->fid.vnode);\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, &vnode->fid.vnode, sizeof(vnode->fid.vnode));\n\n\t_leave(\" = %u\", klen);\n\treturn klen;\n}"
  },
  {
    "function_name": "afs_volume_cache_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "227-244",
    "snippet": "static uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t bufmax)\n{\n\tconst struct afs_volume *volume = cookie_netfs_data;\n\tuint16_t klen;\n\n\t_enter(\"{%u},%p,%u\", volume->type, buffer, bufmax);\n\n\tklen = sizeof(volume->type);\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, &volume->type, sizeof(volume->type));\n\n\t_leave(\" = %u\", klen);\n\treturn klen;\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %u\"",
            "klen"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&volume->type",
            "sizeof(volume->type)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},%p,%u\"",
            "volume->type",
            "buffer",
            "bufmax"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t bufmax)\n{\n\tconst struct afs_volume *volume = cookie_netfs_data;\n\tuint16_t klen;\n\n\t_enter(\"{%u},%p,%u\", volume->type, buffer, bufmax);\n\n\tklen = sizeof(volume->type);\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, &volume->type, sizeof(volume->type));\n\n\t_leave(\" = %u\", klen);\n\treturn klen;\n\n}"
  },
  {
    "function_name": "afs_vlocation_cache_check_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "177-221",
    "snippet": "static\nenum fscache_checkaux afs_vlocation_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t    const void *buffer,\n\t\t\t\t\t\t    uint16_t buflen)\n{\n\tconst struct afs_cache_vlocation *cvldb;\n\tstruct afs_vlocation *vlocation = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%s},%p,%u\", vlocation->vldb.name, buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(struct afs_cache_vlocation);\n\tdlen -= offsetof(struct afs_cache_vlocation, nservers);\n\tif (dlen != buflen)\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tcvldb = container_of(buffer, struct afs_cache_vlocation, nservers);\n\n\t/* if what's on disk is more valid than what's in memory, then use the\n\t * VL record from the cache */\n\tif (!vlocation->valid || vlocation->vldb.rtime == cvldb->rtime) {\n\t\tmemcpy((uint8_t *)&vlocation->vldb.nservers, buffer, dlen);\n\t\tvlocation->valid = 1;\n\t\t_leave(\" = SUCCESS [c->m]\");\n\t\treturn FSCACHE_CHECKAUX_OKAY;\n\t}\n\n\t/* need to update the cache if the cached info differs */\n\tif (memcmp(&vlocation->vldb, buffer, dlen) != 0) {\n\t\t/* delete if the volume IDs for this name differ */\n\t\tif (memcmp(&vlocation->vldb.vid, &cvldb->vid,\n\t\t\t   sizeof(cvldb->vid)) != 0\n\t\t    ) {\n\t\t\t_leave(\" = OBSOLETE\");\n\t\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t\t}\n\n\t\t_leave(\" = UPDATE\");\n\t\treturn FSCACHE_CHECKAUX_NEEDS_UPDATE;\n\t}\n\n\t_leave(\" = OKAY\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
      "static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);",
      "static uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
      "static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);",
      "static uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);",
      "static uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
      "static void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);",
      "static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);",
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = OKAY\""
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&vlocation->vldb.vid",
            "&cvldb->vid",
            "sizeof(cvldb->vid)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&vlocation->vldb",
            "buffer",
            "dlen"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(uint8_t *)&vlocation->vldb.nservers",
            "buffer",
            "dlen"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "buffer",
            "structafs_cache_vlocation",
            "nservers"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s},%p,%u\"",
            "vlocation->vldb.name",
            "buffer",
            "buflen"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);\nstatic uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);\nstatic uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);\nstatic uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic\nenum fscache_checkaux afs_vlocation_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t    const void *buffer,\n\t\t\t\t\t\t    uint16_t buflen)\n{\n\tconst struct afs_cache_vlocation *cvldb;\n\tstruct afs_vlocation *vlocation = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%s},%p,%u\", vlocation->vldb.name, buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(struct afs_cache_vlocation);\n\tdlen -= offsetof(struct afs_cache_vlocation, nservers);\n\tif (dlen != buflen)\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\n\tcvldb = container_of(buffer, struct afs_cache_vlocation, nservers);\n\n\t/* if what's on disk is more valid than what's in memory, then use the\n\t * VL record from the cache */\n\tif (!vlocation->valid || vlocation->vldb.rtime == cvldb->rtime) {\n\t\tmemcpy((uint8_t *)&vlocation->vldb.nservers, buffer, dlen);\n\t\tvlocation->valid = 1;\n\t\t_leave(\" = SUCCESS [c->m]\");\n\t\treturn FSCACHE_CHECKAUX_OKAY;\n\t}\n\n\t/* need to update the cache if the cached info differs */\n\tif (memcmp(&vlocation->vldb, buffer, dlen) != 0) {\n\t\t/* delete if the volume IDs for this name differ */\n\t\tif (memcmp(&vlocation->vldb.vid, &cvldb->vid,\n\t\t\t   sizeof(cvldb->vid)) != 0\n\t\t    ) {\n\t\t\t_leave(\" = OBSOLETE\");\n\t\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t\t}\n\n\t\t_leave(\" = UPDATE\");\n\t\treturn FSCACHE_CHECKAUX_NEEDS_UPDATE;\n\t}\n\n\t_leave(\" = OKAY\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
  },
  {
    "function_name": "afs_vlocation_cache_get_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "155-172",
    "snippet": "static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax)\n{\n\tconst struct afs_vlocation *vlocation = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%s},%p,%u\", vlocation->vldb.name, buffer, bufmax);\n\n\tdlen = sizeof(struct afs_cache_vlocation);\n\tdlen -= offsetof(struct afs_cache_vlocation, nservers);\n\tif (dlen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, (uint8_t *)&vlocation->vldb.nservers, dlen);\n\n\t_leave(\" = %u\", dlen);\n\treturn dlen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %u\"",
            "dlen"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "(uint8_t *)&vlocation->vldb.nservers",
            "dlen"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s},%p,%u\"",
            "vlocation->vldb.name",
            "buffer",
            "bufmax"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax)\n{\n\tconst struct afs_vlocation *vlocation = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%s},%p,%u\", vlocation->vldb.name, buffer, bufmax);\n\n\tdlen = sizeof(struct afs_cache_vlocation);\n\tdlen -= offsetof(struct afs_cache_vlocation, nservers);\n\tif (dlen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, (uint8_t *)&vlocation->vldb.nservers, dlen);\n\n\t_leave(\" = %u\", dlen);\n\treturn dlen;\n}"
  },
  {
    "function_name": "afs_vlocation_cache_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "134-150",
    "snippet": "static uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax)\n{\n\tconst struct afs_vlocation *vlocation = cookie_netfs_data;\n\tuint16_t klen;\n\n\t_enter(\"{%s},%p,%u\", vlocation->vldb.name, buffer, bufmax);\n\n\tklen = strnlen(vlocation->vldb.name, sizeof(vlocation->vldb.name));\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, vlocation->vldb.name, klen);\n\n\t_leave(\" = %u\", klen);\n\treturn klen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %u\"",
            "klen"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "vlocation->vldb.name",
            "klen"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "vlocation->vldb.name",
            "sizeof(vlocation->vldb.name)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s},%p,%u\"",
            "vlocation->vldb.name",
            "buffer",
            "bufmax"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax)\n{\n\tconst struct afs_vlocation *vlocation = cookie_netfs_data;\n\tuint16_t klen;\n\n\t_enter(\"{%s},%p,%u\", vlocation->vldb.name, buffer, bufmax);\n\n\tklen = strnlen(vlocation->vldb.name, sizeof(vlocation->vldb.name));\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, vlocation->vldb.name, klen);\n\n\t_leave(\" = %u\", klen);\n\treturn klen;\n}"
  },
  {
    "function_name": "afs_cell_cache_check_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "122-128",
    "snippet": "static enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen)\n{\n\t_leave(\" = OKAY\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
      "static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);",
      "static uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
      "static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);",
      "static uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);",
      "static uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
      "static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
      "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);",
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = OKAY\""
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);\nstatic uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);\nstatic uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen)\n{\n\t_leave(\" = OKAY\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
  },
  {
    "function_name": "afs_cell_cache_get_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "103-117",
    "snippet": "static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t bufmax)\n{\n\tconst struct afs_cell *cell = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"%p,%p,%u\", cell, buffer, bufmax);\n\n\tdlen = cell->vl_naddrs * sizeof(cell->vl_addrs[0]);\n\tdlen = min(dlen, bufmax);\n\tdlen &= ~(sizeof(cell->vl_addrs[0]) - 1);\n\n\tmemcpy(buffer, cell->vl_addrs, dlen);\n\treturn dlen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "cell->vl_addrs",
            "dlen"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "dlen",
            "bufmax"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p,%u\"",
            "cell",
            "buffer",
            "bufmax"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t bufmax)\n{\n\tconst struct afs_cell *cell = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"%p,%p,%u\", cell, buffer, bufmax);\n\n\tdlen = cell->vl_naddrs * sizeof(cell->vl_addrs[0]);\n\tdlen = min(dlen, bufmax);\n\tdlen &= ~(sizeof(cell->vl_addrs[0]) - 1);\n\n\tmemcpy(buffer, cell->vl_addrs, dlen);\n\treturn dlen;\n}"
  },
  {
    "function_name": "afs_cell_cache_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
    "lines": "84-98",
    "snippet": "static uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t bufmax)\n{\n\tconst struct afs_cell *cell = cookie_netfs_data;\n\tuint16_t klen;\n\n\t_enter(\"%p,%p,%u\", cell, buffer, bufmax);\n\n\tklen = strlen(cell->name);\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, cell->name, klen);\n\treturn klen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "cell->name",
            "klen"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cell->name"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p,%u\"",
            "cell",
            "buffer",
            "bufmax"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t bufmax)\n{\n\tconst struct afs_cell *cell = cookie_netfs_data;\n\tuint16_t klen;\n\n\t_enter(\"%p,%p,%u\", cell, buffer, bufmax);\n\n\tklen = strlen(cell->name);\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, cell->name, klen);\n\treturn klen;\n}"
  }
]