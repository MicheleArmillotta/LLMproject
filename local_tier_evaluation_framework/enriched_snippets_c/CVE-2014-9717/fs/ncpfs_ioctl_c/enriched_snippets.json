[
  {
    "function_name": "ncp_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
    "lines": "911-918",
    "snippet": "long ncp_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\n\targ = (unsigned long) compat_ptr(arg);\n\tret = ncp_ioctl(file, cmd, arg);\n\treturn ret;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_ioctl",
          "args": [
            "file",
            "cmd",
            "arg"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
          "lines": "810-908",
          "snippet": "long ncp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tkuid_t uid = current_uid();\n\tint need_drop_write = 0;\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase NCP_IOC_SETCHARSETS:\n\tcase NCP_IOC_CONN_LOGGED_IN:\n\tcase NCP_IOC_SETROOT:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!uid_eq(server->m.mounted_uid, uid)) {\n\t\tswitch (cmd) {\n\t\t/*\n\t\t * Only mount owner can issue these ioctls.  Information\n\t\t * necessary to authenticate to other NDS servers are\n\t\t * stored here.\n\t\t */\n\t\tcase NCP_IOC_GETOBJECTNAME:\n\t\tcase NCP_IOC_SETOBJECTNAME:\n\t\tcase NCP_IOC_GETPRIVATEDATA:\n\t\tcase NCP_IOC_SETPRIVATEDATA:\n#ifdef CONFIG_COMPAT\n\t\tcase NCP_IOC_GETOBJECTNAME_32:\n\t\tcase NCP_IOC_SETOBJECTNAME_32:\n\t\tcase NCP_IOC_GETPRIVATEDATA_32:\n\t\tcase NCP_IOC_SETPRIVATEDATA_32:\n#endif\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t/*\n\t\t * These require write access on the inode if user id\n\t\t * does not match.  Note that they do not write to the\n\t\t * file...  But old code did mnt_want_write, so I keep\n\t\t * it as is.  Of course not for mountpoint owner, as\n\t\t * that breaks read-only mounts altogether as ncpmount\n\t\t * needs working NCP_IOC_NCPREQUEST and\n\t\t * NCP_IOC_GET_FS_INFO.  Some of these codes (setdentryttl,\n\t\t * signinit, setsignwanted) should be probably restricted\n\t\t * to owner only, or even more to CAP_SYS_ADMIN).\n\t\t */\n\t\tcase NCP_IOC_GET_FS_INFO:\n\t\tcase NCP_IOC_GET_FS_INFO_V2:\n\t\tcase NCP_IOC_NCPREQUEST:\n\t\tcase NCP_IOC_SETDENTRYTTL:\n\t\tcase NCP_IOC_SIGN_INIT:\n\t\tcase NCP_IOC_LOCKUNLOCK:\n\t\tcase NCP_IOC_SET_SIGN_WANTED:\n#ifdef CONFIG_COMPAT\n\t\tcase NCP_IOC_GET_FS_INFO_V2_32:\n\t\tcase NCP_IOC_NCPREQUEST_32:\n#endif\n\t\t\tret = mnt_want_write_file(filp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tneed_drop_write = 1;\n\t\t\tret = inode_permission(inode, MAY_WRITE);\n\t\t\tif (ret)\n\t\t\t\tgoto outDropWrite;\n\t\t\tbreak;\n\t\t/*\n\t\t * Read access required.\n\t\t */\n\t\tcase NCP_IOC_GETMOUNTUID16:\n\t\tcase NCP_IOC_GETMOUNTUID32:\n\t\tcase NCP_IOC_GETMOUNTUID64:\n\t\tcase NCP_IOC_GETROOT:\n\t\tcase NCP_IOC_SIGN_WANTED:\n\t\t\tret = inode_permission(inode, MAY_READ);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t/*\n\t\t * Anybody can read these.\n\t\t */\n\t\tcase NCP_IOC_GETCHARSETS:\n\t\tcase NCP_IOC_GETDENTRYTTL:\n\t\tdefault:\n\t\t/* Three codes below are protected by CAP_SYS_ADMIN above. */\n\t\tcase NCP_IOC_SETCHARSETS:\n\t\tcase NCP_IOC_CONN_LOGGED_IN:\n\t\tcase NCP_IOC_SETROOT:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = __ncp_ioctl(inode, cmd, arg);\noutDropWrite:\n\tif (need_drop_write)\n\t\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define NCP_IOC_GETMOUNTUID64\t\t_IOW('n', 2, u64)",
            "#define NCP_IOC_GETMOUNTUID32\t\t_IOW('n', 2, u32)",
            "#define NCP_IOC_GETMOUNTUID16\t\t_IOW('n', 2, u16)",
            "#define NCP_IOC_SETPRIVATEDATA_32\t_IOR('n', 10, struct compat_ncp_privatedata_ioctl)",
            "#define NCP_IOC_GETPRIVATEDATA_32\t_IOWR('n', 10, struct compat_ncp_privatedata_ioctl)",
            "#define NCP_IOC_SETOBJECTNAME_32\t_IOR('n', 9, struct compat_ncp_objectname_ioctl)",
            "#define NCP_IOC_GETOBJECTNAME_32\t_IOWR('n', 9, struct compat_ncp_objectname_ioctl)",
            "#define NCP_IOC_NCPREQUEST_32\t\t_IOR('n', 1, struct compat_ncp_ioctl_request)",
            "#define NCP_IOC_GET_FS_INFO_V2_32\t_IOWR('n', 4, struct compat_ncp_fs_info_v2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\n#define NCP_IOC_GETMOUNTUID64\t\t_IOW('n', 2, u64)\n#define NCP_IOC_GETMOUNTUID32\t\t_IOW('n', 2, u32)\n#define NCP_IOC_GETMOUNTUID16\t\t_IOW('n', 2, u16)\n#define NCP_IOC_SETPRIVATEDATA_32\t_IOR('n', 10, struct compat_ncp_privatedata_ioctl)\n#define NCP_IOC_GETPRIVATEDATA_32\t_IOWR('n', 10, struct compat_ncp_privatedata_ioctl)\n#define NCP_IOC_SETOBJECTNAME_32\t_IOR('n', 9, struct compat_ncp_objectname_ioctl)\n#define NCP_IOC_GETOBJECTNAME_32\t_IOWR('n', 9, struct compat_ncp_objectname_ioctl)\n#define NCP_IOC_NCPREQUEST_32\t\t_IOR('n', 1, struct compat_ncp_ioctl_request)\n#define NCP_IOC_GET_FS_INFO_V2_32\t_IOWR('n', 4, struct compat_ncp_fs_info_v2)\n\nlong ncp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tkuid_t uid = current_uid();\n\tint need_drop_write = 0;\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase NCP_IOC_SETCHARSETS:\n\tcase NCP_IOC_CONN_LOGGED_IN:\n\tcase NCP_IOC_SETROOT:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!uid_eq(server->m.mounted_uid, uid)) {\n\t\tswitch (cmd) {\n\t\t/*\n\t\t * Only mount owner can issue these ioctls.  Information\n\t\t * necessary to authenticate to other NDS servers are\n\t\t * stored here.\n\t\t */\n\t\tcase NCP_IOC_GETOBJECTNAME:\n\t\tcase NCP_IOC_SETOBJECTNAME:\n\t\tcase NCP_IOC_GETPRIVATEDATA:\n\t\tcase NCP_IOC_SETPRIVATEDATA:\n#ifdef CONFIG_COMPAT\n\t\tcase NCP_IOC_GETOBJECTNAME_32:\n\t\tcase NCP_IOC_SETOBJECTNAME_32:\n\t\tcase NCP_IOC_GETPRIVATEDATA_32:\n\t\tcase NCP_IOC_SETPRIVATEDATA_32:\n#endif\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t/*\n\t\t * These require write access on the inode if user id\n\t\t * does not match.  Note that they do not write to the\n\t\t * file...  But old code did mnt_want_write, so I keep\n\t\t * it as is.  Of course not for mountpoint owner, as\n\t\t * that breaks read-only mounts altogether as ncpmount\n\t\t * needs working NCP_IOC_NCPREQUEST and\n\t\t * NCP_IOC_GET_FS_INFO.  Some of these codes (setdentryttl,\n\t\t * signinit, setsignwanted) should be probably restricted\n\t\t * to owner only, or even more to CAP_SYS_ADMIN).\n\t\t */\n\t\tcase NCP_IOC_GET_FS_INFO:\n\t\tcase NCP_IOC_GET_FS_INFO_V2:\n\t\tcase NCP_IOC_NCPREQUEST:\n\t\tcase NCP_IOC_SETDENTRYTTL:\n\t\tcase NCP_IOC_SIGN_INIT:\n\t\tcase NCP_IOC_LOCKUNLOCK:\n\t\tcase NCP_IOC_SET_SIGN_WANTED:\n#ifdef CONFIG_COMPAT\n\t\tcase NCP_IOC_GET_FS_INFO_V2_32:\n\t\tcase NCP_IOC_NCPREQUEST_32:\n#endif\n\t\t\tret = mnt_want_write_file(filp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tneed_drop_write = 1;\n\t\t\tret = inode_permission(inode, MAY_WRITE);\n\t\t\tif (ret)\n\t\t\t\tgoto outDropWrite;\n\t\t\tbreak;\n\t\t/*\n\t\t * Read access required.\n\t\t */\n\t\tcase NCP_IOC_GETMOUNTUID16:\n\t\tcase NCP_IOC_GETMOUNTUID32:\n\t\tcase NCP_IOC_GETMOUNTUID64:\n\t\tcase NCP_IOC_GETROOT:\n\t\tcase NCP_IOC_SIGN_WANTED:\n\t\t\tret = inode_permission(inode, MAY_READ);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t/*\n\t\t * Anybody can read these.\n\t\t */\n\t\tcase NCP_IOC_GETCHARSETS:\n\t\tcase NCP_IOC_GETDENTRYTTL:\n\t\tdefault:\n\t\t/* Three codes below are protected by CAP_SYS_ADMIN above. */\n\t\tcase NCP_IOC_SETCHARSETS:\n\t\tcase NCP_IOC_CONN_LOGGED_IN:\n\t\tcase NCP_IOC_SETROOT:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = __ncp_ioctl(inode, cmd, arg);\noutDropWrite:\n\tif (need_drop_write)\n\t\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nlong ncp_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\n\targ = (unsigned long) compat_ptr(arg);\n\tret = ncp_ioctl(file, cmd, arg);\n\treturn ret;\n}"
  },
  {
    "function_name": "ncp_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
    "lines": "810-908",
    "snippet": "long ncp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tkuid_t uid = current_uid();\n\tint need_drop_write = 0;\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase NCP_IOC_SETCHARSETS:\n\tcase NCP_IOC_CONN_LOGGED_IN:\n\tcase NCP_IOC_SETROOT:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!uid_eq(server->m.mounted_uid, uid)) {\n\t\tswitch (cmd) {\n\t\t/*\n\t\t * Only mount owner can issue these ioctls.  Information\n\t\t * necessary to authenticate to other NDS servers are\n\t\t * stored here.\n\t\t */\n\t\tcase NCP_IOC_GETOBJECTNAME:\n\t\tcase NCP_IOC_SETOBJECTNAME:\n\t\tcase NCP_IOC_GETPRIVATEDATA:\n\t\tcase NCP_IOC_SETPRIVATEDATA:\n#ifdef CONFIG_COMPAT\n\t\tcase NCP_IOC_GETOBJECTNAME_32:\n\t\tcase NCP_IOC_SETOBJECTNAME_32:\n\t\tcase NCP_IOC_GETPRIVATEDATA_32:\n\t\tcase NCP_IOC_SETPRIVATEDATA_32:\n#endif\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t/*\n\t\t * These require write access on the inode if user id\n\t\t * does not match.  Note that they do not write to the\n\t\t * file...  But old code did mnt_want_write, so I keep\n\t\t * it as is.  Of course not for mountpoint owner, as\n\t\t * that breaks read-only mounts altogether as ncpmount\n\t\t * needs working NCP_IOC_NCPREQUEST and\n\t\t * NCP_IOC_GET_FS_INFO.  Some of these codes (setdentryttl,\n\t\t * signinit, setsignwanted) should be probably restricted\n\t\t * to owner only, or even more to CAP_SYS_ADMIN).\n\t\t */\n\t\tcase NCP_IOC_GET_FS_INFO:\n\t\tcase NCP_IOC_GET_FS_INFO_V2:\n\t\tcase NCP_IOC_NCPREQUEST:\n\t\tcase NCP_IOC_SETDENTRYTTL:\n\t\tcase NCP_IOC_SIGN_INIT:\n\t\tcase NCP_IOC_LOCKUNLOCK:\n\t\tcase NCP_IOC_SET_SIGN_WANTED:\n#ifdef CONFIG_COMPAT\n\t\tcase NCP_IOC_GET_FS_INFO_V2_32:\n\t\tcase NCP_IOC_NCPREQUEST_32:\n#endif\n\t\t\tret = mnt_want_write_file(filp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tneed_drop_write = 1;\n\t\t\tret = inode_permission(inode, MAY_WRITE);\n\t\t\tif (ret)\n\t\t\t\tgoto outDropWrite;\n\t\t\tbreak;\n\t\t/*\n\t\t * Read access required.\n\t\t */\n\t\tcase NCP_IOC_GETMOUNTUID16:\n\t\tcase NCP_IOC_GETMOUNTUID32:\n\t\tcase NCP_IOC_GETMOUNTUID64:\n\t\tcase NCP_IOC_GETROOT:\n\t\tcase NCP_IOC_SIGN_WANTED:\n\t\t\tret = inode_permission(inode, MAY_READ);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t/*\n\t\t * Anybody can read these.\n\t\t */\n\t\tcase NCP_IOC_GETCHARSETS:\n\t\tcase NCP_IOC_GETDENTRYTTL:\n\t\tdefault:\n\t\t/* Three codes below are protected by CAP_SYS_ADMIN above. */\n\t\tcase NCP_IOC_SETCHARSETS:\n\t\tcase NCP_IOC_CONN_LOGGED_IN:\n\t\tcase NCP_IOC_SETROOT:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = __ncp_ioctl(inode, cmd, arg);\noutDropWrite:\n\tif (need_drop_write)\n\t\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define NCP_IOC_GETMOUNTUID64\t\t_IOW('n', 2, u64)",
      "#define NCP_IOC_GETMOUNTUID32\t\t_IOW('n', 2, u32)",
      "#define NCP_IOC_GETMOUNTUID16\t\t_IOW('n', 2, u16)",
      "#define NCP_IOC_SETPRIVATEDATA_32\t_IOR('n', 10, struct compat_ncp_privatedata_ioctl)",
      "#define NCP_IOC_GETPRIVATEDATA_32\t_IOWR('n', 10, struct compat_ncp_privatedata_ioctl)",
      "#define NCP_IOC_SETOBJECTNAME_32\t_IOR('n', 9, struct compat_ncp_objectname_ioctl)",
      "#define NCP_IOC_GETOBJECTNAME_32\t_IOWR('n', 9, struct compat_ncp_objectname_ioctl)",
      "#define NCP_IOC_NCPREQUEST_32\t\t_IOR('n', 1, struct compat_ncp_ioctl_request)",
      "#define NCP_IOC_GET_FS_INFO_V2_32\t_IOWR('n', 4, struct compat_ncp_fs_info_v2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ncp_ioctl",
          "args": [
            "inode",
            "cmd",
            "arg"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "__ncp_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
          "lines": "257-808",
          "snippet": "static long __ncp_ioctl(struct inode *inode, unsigned int cmd, unsigned long arg)\n{\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tint result;\n\tstruct ncp_ioctl_request request;\n\tchar* bouncebuffer;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_NCPREQUEST_32:\n#endif\n\tcase NCP_IOC_NCPREQUEST:\n#ifdef CONFIG_COMPAT\n\t\tif (cmd == NCP_IOC_NCPREQUEST_32) {\n\t\t\tstruct compat_ncp_ioctl_request request32;\n\t\t\tif (copy_from_user(&request32, argp, sizeof(request32)))\n\t\t\t\treturn -EFAULT;\n\t\t\trequest.function = request32.function;\n\t\t\trequest.size = request32.size;\n\t\t\trequest.data = compat_ptr(request32.data);\n\t\t} else\n#endif\n\t\tif (copy_from_user(&request, argp, sizeof(request)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((request.function > 255)\n\t\t    || (request.size >\n\t\t  NCP_PACKET_SIZE - sizeof(struct ncp_request_header))) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbouncebuffer = vmalloc(NCP_PACKET_SIZE_INTERNAL);\n\t\tif (!bouncebuffer)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(bouncebuffer, request.data, request.size)) {\n\t\t\tvfree(bouncebuffer);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tncp_lock_server(server);\n\n\t\t/* FIXME: We hack around in the server's structures\n\t\t   here to be able to use ncp_request */\n\n\t\tserver->has_subfunction = 0;\n\t\tserver->current_size = request.size;\n\t\tmemcpy(server->packet, bouncebuffer, request.size);\n\n\t\tresult = ncp_request2(server, request.function,\n\t\t\tbouncebuffer, NCP_PACKET_SIZE_INTERNAL);\n\t\tif (result < 0)\n\t\t\tresult = -EIO;\n\t\telse\n\t\t\tresult = server->reply_size;\n\t\tncp_unlock_server(server);\n\t\tncp_dbg(1, \"copy %d bytes\\n\", result);\n\t\tif (result >= 0)\n\t\t\tif (copy_to_user(request.data, bouncebuffer, result))\n\t\t\t\tresult = -EFAULT;\n\t\tvfree(bouncebuffer);\n\t\treturn result;\n\n\tcase NCP_IOC_CONN_LOGGED_IN:\n\n\t\tif (!(server->m.int_flags & NCP_IMOUNT_LOGGEDIN_POSSIBLE))\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&server->root_setup_lock);\n\t\tif (server->root_setuped)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tresult = ncp_conn_logged_in(inode->i_sb);\n\t\t\tif (result == 0)\n\t\t\t\tserver->root_setuped = 1;\n\t\t}\n\t\tmutex_unlock(&server->root_setup_lock);\n\t\treturn result;\n\n\tcase NCP_IOC_GET_FS_INFO:\n\t\treturn ncp_get_fs_info(server, inode, argp);\n\n\tcase NCP_IOC_GET_FS_INFO_V2:\n\t\treturn ncp_get_fs_info_v2(server, inode, argp);\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GET_FS_INFO_V2_32:\n\t\treturn ncp_get_compat_fs_info_v2(server, inode, argp);\n#endif\n\t/* we have too many combinations of CONFIG_COMPAT,\n\t * CONFIG_64BIT and CONFIG_UID16, so just handle\n\t * any of the possible ioctls */\n\tcase NCP_IOC_GETMOUNTUID16:\n\t\t{\n\t\t\tu16 uid;\n\n\t\t\tSET_UID(uid, from_kuid_munged(current_user_ns(), server->m.mounted_uid));\n\t\t\tif (put_user(uid, (u16 __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\tcase NCP_IOC_GETMOUNTUID32:\n\t{\n\t\tuid_t uid = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\t\tif (put_user(uid, (u32 __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase NCP_IOC_GETMOUNTUID64:\n\t{\n\t\tuid_t uid = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\t\tif (put_user(uid, (u64 __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase NCP_IOC_GETROOT:\n\t\t{\n\t\t\tstruct ncp_setroot_ioctl sr;\n\n\t\t\tresult = -EACCES;\n\t\t\tmutex_lock(&server->root_setup_lock);\n\t\t\tif (server->m.mounted_vol[0]) {\n\t\t\t\tstruct dentry* dentry = inode->i_sb->s_root;\n\n\t\t\t\tif (dentry) {\n\t\t\t\t\tstruct inode* s_inode = dentry->d_inode;\n\n\t\t\t\t\tif (s_inode) {\n\t\t\t\t\t\tsr.volNumber = NCP_FINFO(s_inode)->volNumber;\n\t\t\t\t\t\tsr.dirEntNum = NCP_FINFO(s_inode)->dirEntNum;\n\t\t\t\t\t\tsr.namespace = server->name_space[sr.volNumber];\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t\tncp_dbg(1, \"s_root->d_inode==NULL\\n\");\n\t\t\t\t} else\n\t\t\t\t\tncp_dbg(1, \"s_root==NULL\\n\");\n\t\t\t} else {\n\t\t\t\tsr.volNumber = -1;\n\t\t\t\tsr.namespace = 0;\n\t\t\t\tsr.dirEntNum = 0;\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&server->root_setup_lock);\n\t\t\tif (!result && copy_to_user(argp, &sr, sizeof(sr)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n\n\tcase NCP_IOC_SETROOT:\n\t\t{\n\t\t\tstruct ncp_setroot_ioctl sr;\n\t\t\t__u32 vnum;\n\t\t\t__le32 de;\n\t\t\t__le32 dosde;\n\t\t\tstruct dentry* dentry;\n\n\t\t\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&server->root_setup_lock);\n\t\t\tif (server->root_setuped)\n\t\t\t\tresult = -EBUSY;\n\t\t\telse {\n\t\t\t\tif (sr.volNumber < 0) {\n\t\t\t\t\tserver->m.mounted_vol[0] = 0;\n\t\t\t\t\tvnum = NCP_NUMBER_OF_VOLUMES;\n\t\t\t\t\tde = 0;\n\t\t\t\t\tdosde = 0;\n\t\t\t\t\tresult = 0;\n\t\t\t\t} else if (sr.volNumber >= NCP_NUMBER_OF_VOLUMES) {\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\t} else if (ncp_mount_subdir(server, sr.volNumber,\n\t\t\t\t\t\t\tsr.namespace, sr.dirEntNum,\n\t\t\t\t\t\t\t&vnum, &de, &dosde)) {\n\t\t\t\t\tresult = -ENOENT;\n\t\t\t\t} else\n\t\t\t\t\tresult = 0;\n\n\t\t\t\tif (result == 0) {\n\t\t\t\t\tdentry = inode->i_sb->s_root;\n\t\t\t\t\tif (dentry) {\n\t\t\t\t\t\tstruct inode* s_inode = dentry->d_inode;\n\n\t\t\t\t\t\tif (s_inode) {\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->volNumber = vnum;\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->dirEntNum = de;\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->DosDirNum = dosde;\n\t\t\t\t\t\t\tserver->root_setuped = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tncp_dbg(1, \"s_root->d_inode==NULL\\n\");\n\t\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncp_dbg(1, \"s_root==NULL\\n\");\n\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&server->root_setup_lock);\n\n\t\t\treturn result;\n\t\t}\n\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tcase NCP_IOC_SIGN_INIT:\n\t\t{\n\t\t\tstruct ncp_sign_init sign;\n\n\t\t\tif (argp)\n\t\t\t\tif (copy_from_user(&sign, argp, sizeof(sign)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\tncp_lock_server(server);\n\t\t\tmutex_lock(&server->rcv.creq_mutex);\n\t\t\tif (argp) {\n\t\t\t\tif (server->sign_wanted) {\n\t\t\t\t\tmemcpy(server->sign_root,sign.sign_root,8);\n\t\t\t\t\tmemcpy(server->sign_last,sign.sign_last,16);\n\t\t\t\t\tserver->sign_active = 1;\n\t\t\t\t}\n\t\t\t\t/* ignore when signatures not wanted */\n\t\t\t} else {\n\t\t\t\tserver->sign_active = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\t\tncp_unlock_server(server);\n\t\t\treturn 0;\n\t\t}\n\n        case NCP_IOC_SIGN_WANTED:\n\t\t{\n\t\t\tint state;\n\n\t\t\tncp_lock_server(server);\n\t\t\tstate = server->sign_wanted;\n\t\t\tncp_unlock_server(server);\n\t\t\tif (put_user(state, (int __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\tcase NCP_IOC_SET_SIGN_WANTED:\n\t\t{\n\t\t\tint newstate;\n\n\t\t\t/* get only low 8 bits... */\n\t\t\tif (get_user(newstate, (unsigned char __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\tresult = 0;\n\t\t\tncp_lock_server(server);\n\t\t\tif (server->sign_active) {\n\t\t\t\t/* cannot turn signatures OFF when active */\n\t\t\t\tif (!newstate)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t} else {\n\t\t\t\tserver->sign_wanted = newstate != 0;\n\t\t\t}\n\t\t\tncp_unlock_server(server);\n\t\t\treturn result;\n\t\t}\n\n#endif /* CONFIG_NCPFS_PACKET_SIGNING */\n\n#ifdef CONFIG_NCPFS_IOCTL_LOCKING\n\tcase NCP_IOC_LOCKUNLOCK:\n\t\t{\n\t\t\tstruct ncp_lock_ioctl\t rqdata;\n\n\t\t\tif (copy_from_user(&rqdata, argp, sizeof(rqdata)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rqdata.origin != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\t/* check for cmd */\n\t\t\tswitch (rqdata.cmd) {\n\t\t\t\tcase NCP_LOCK_EX:\n\t\t\t\tcase NCP_LOCK_SH:\n\t\t\t\t\t\tif (rqdata.timeout == 0)\n\t\t\t\t\t\t\trqdata.timeout = NCP_LOCK_DEFAULT_TIMEOUT;\n\t\t\t\t\t\telse if (rqdata.timeout > NCP_LOCK_MAX_TIMEOUT)\n\t\t\t\t\t\t\trqdata.timeout = NCP_LOCK_MAX_TIMEOUT;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase NCP_LOCK_LOG:\n\t\t\t\t\t\trqdata.timeout = NCP_LOCK_DEFAULT_TIMEOUT;\t/* has no effect */\n\t\t\t\tcase NCP_LOCK_CLEAR:\n\t\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* locking needs both read and write access */\n\t\t\tif ((result = ncp_make_open(inode, O_RDWR)) != 0)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = -EISDIR;\n\t\t\tif (!S_ISREG(inode->i_mode))\n\t\t\t\tgoto outrel;\n\t\t\tif (rqdata.cmd == NCP_LOCK_CLEAR)\n\t\t\t{\n\t\t\t\tresult = ncp_ClearPhysicalRecord(NCP_SERVER(inode),\n\t\t\t\t\t\t\tNCP_FINFO(inode)->file_handle,\n\t\t\t\t\t\t\trqdata.offset,\n\t\t\t\t\t\t\trqdata.length);\n\t\t\t\tif (result > 0) result = 0;\t/* no such lock */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lockcmd;\n\n\t\t\t\tswitch (rqdata.cmd)\n\t\t\t\t{\n\t\t\t\t\tcase NCP_LOCK_EX:  lockcmd=1; break;\n\t\t\t\t\tcase NCP_LOCK_SH:  lockcmd=3; break;\n\t\t\t\t\tdefault:\t   lockcmd=0; break;\n\t\t\t\t}\n\t\t\t\tresult = ncp_LogPhysicalRecord(NCP_SERVER(inode),\n\t\t\t\t\t\t\tNCP_FINFO(inode)->file_handle,\n\t\t\t\t\t\t\tlockcmd,\n\t\t\t\t\t\t\trqdata.offset,\n\t\t\t\t\t\t\trqdata.length,\n\t\t\t\t\t\t\trqdata.timeout);\n\t\t\t\tif (result > 0) result = -EAGAIN;\n\t\t\t}\noutrel:\n\t\t\tncp_inode_close(inode);\n\t\t\treturn result;\n\t\t}\n#endif\t/* CONFIG_NCPFS_IOCTL_LOCKING */\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GETOBJECTNAME_32:\n\t\t{\n\t\t\tstruct compat_ncp_objectname_ioctl user;\n\t\t\tsize_t outl;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\tuser.auth_type = server->auth.auth_type;\n\t\t\toutl = user.object_name_len;\n\t\t\tuser.object_name_len = server->auth.object_name_len;\n\t\t\tif (outl > user.object_name_len)\n\t\t\t\toutl = user.object_name_len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(compat_ptr(user.object_name),\n\t\t\t\t\t\t server->auth.object_name,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (!result && copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n#endif\n\n\tcase NCP_IOC_GETOBJECTNAME:\n\t\t{\n\t\t\tstruct ncp_objectname_ioctl user;\n\t\t\tsize_t outl;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\tuser.auth_type = server->auth.auth_type;\n\t\t\toutl = user.object_name_len;\n\t\t\tuser.object_name_len = server->auth.object_name_len;\n\t\t\tif (outl > user.object_name_len)\n\t\t\t\toutl = user.object_name_len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(user.object_name,\n\t\t\t\t\t\t server->auth.object_name,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (!result && copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_SETOBJECTNAME_32:\n#endif\n\tcase NCP_IOC_SETOBJECTNAME:\n\t\t{\n\t\t\tstruct ncp_objectname_ioctl user;\n\t\t\tvoid* newname;\n\t\t\tvoid* oldname;\n\t\t\tsize_t oldnamelen;\n\t\t\tvoid* oldprivate;\n\t\t\tsize_t oldprivatelen;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_SETOBJECTNAME_32) {\n\t\t\t\tstruct compat_ncp_objectname_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.auth_type = user32.auth_type;\n\t\t\t\tuser.object_name_len = user32.object_name_len;\n\t\t\t\tuser.object_name = compat_ptr(user32.object_name);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (user.object_name_len > NCP_OBJECT_NAME_MAX_LEN)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (user.object_name_len) {\n\t\t\t\tnewname = memdup_user(user.object_name,\n\t\t\t\t\t\t      user.object_name_len);\n\t\t\t\tif (IS_ERR(newname))\n\t\t\t\t\treturn PTR_ERR(newname);\n\t\t\t} else {\n\t\t\t\tnewname = NULL;\n\t\t\t}\n\t\t\tdown_write(&server->auth_rwsem);\n\t\t\toldname = server->auth.object_name;\n\t\t\toldnamelen = server->auth.object_name_len;\n\t\t\toldprivate = server->priv.data;\n\t\t\toldprivatelen = server->priv.len;\n\t\t\tserver->auth.auth_type = user.auth_type;\n\t\t\tserver->auth.object_name_len = user.object_name_len;\n\t\t\tserver->auth.object_name = newname;\n\t\t\tserver->priv.len = 0;\n\t\t\tserver->priv.data = NULL;\n\t\t\tup_write(&server->auth_rwsem);\n\t\t\tkfree(oldprivate);\n\t\t\tkfree(oldname);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GETPRIVATEDATA_32:\n#endif\n\tcase NCP_IOC_GETPRIVATEDATA:\n\t\t{\n\t\t\tstruct ncp_privatedata_ioctl user;\n\t\t\tsize_t outl;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_GETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.len = user32.len;\n\t\t\t\tuser.data = compat_ptr(user32.data);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\toutl = user.len;\n\t\t\tuser.len = server->priv.len;\n\t\t\tif (outl > user.len) outl = user.len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(user.data,\n\t\t\t\t\t\t server->priv.data,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (result)\n\t\t\t\treturn result;\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_GETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tuser32.len = user.len;\n\t\t\t\tuser32.data = (unsigned long) user.data;\n\t\t\t\tif (copy_to_user(argp, &user32, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n#endif\n\t\t\tif (copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_SETPRIVATEDATA_32:\n#endif\n\tcase NCP_IOC_SETPRIVATEDATA:\n\t\t{\n\t\t\tstruct ncp_privatedata_ioctl user;\n\t\t\tvoid* new;\n\t\t\tvoid* old;\n\t\t\tsize_t oldlen;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_SETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.len = user32.len;\n\t\t\t\tuser.data = compat_ptr(user32.data);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (user.len > NCP_PRIVATE_DATA_MAX_LEN)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (user.len) {\n\t\t\t\tnew = memdup_user(user.data, user.len);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\treturn PTR_ERR(new);\n\t\t\t} else {\n\t\t\t\tnew = NULL;\n\t\t\t}\n\t\t\tdown_write(&server->auth_rwsem);\n\t\t\told = server->priv.data;\n\t\t\toldlen = server->priv.len;\n\t\t\tserver->priv.len = user.len;\n\t\t\tserver->priv.data = new;\n\t\t\tup_write(&server->auth_rwsem);\n\t\t\tkfree(old);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_NCPFS_NLS\n\tcase NCP_IOC_SETCHARSETS:\n\t\treturn ncp_set_charsets(server, argp);\n\n\tcase NCP_IOC_GETCHARSETS:\n\t\treturn ncp_get_charsets(server, argp);\n\n#endif /* CONFIG_NCPFS_NLS */\n\n\tcase NCP_IOC_SETDENTRYTTL:\n\t\t{\n\t\t\tu_int32_t user;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* 20 secs at most... */\n\t\t\tif (user > 20000)\n\t\t\t\treturn -EINVAL;\n\t\t\tuser = (user * HZ) / 1000;\n\t\t\tatomic_set(&server->dentry_ttl, user);\n\t\t\treturn 0;\n\t\t}\n\n\tcase NCP_IOC_GETDENTRYTTL:\n\t\t{\n\t\t\tu_int32_t user = (atomic_read(&server->dentry_ttl) * 1000) / HZ;\n\t\t\tif (copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define NCP_IOC_GETMOUNTUID64\t\t_IOW('n', 2, u64)",
            "#define NCP_IOC_GETMOUNTUID32\t\t_IOW('n', 2, u32)",
            "#define NCP_IOC_GETMOUNTUID16\t\t_IOW('n', 2, u16)",
            "#define NCP_IOC_SETPRIVATEDATA_32\t_IOR('n', 10, struct compat_ncp_privatedata_ioctl)",
            "#define NCP_IOC_GETPRIVATEDATA_32\t_IOWR('n', 10, struct compat_ncp_privatedata_ioctl)",
            "#define NCP_IOC_SETOBJECTNAME_32\t_IOR('n', 9, struct compat_ncp_objectname_ioctl)",
            "#define NCP_IOC_GETOBJECTNAME_32\t_IOWR('n', 9, struct compat_ncp_objectname_ioctl)",
            "#define NCP_IOC_NCPREQUEST_32\t\t_IOR('n', 1, struct compat_ncp_ioctl_request)",
            "#define NCP_IOC_GET_FS_INFO_V2_32\t_IOWR('n', 4, struct compat_ncp_fs_info_v2)",
            "#define NCP_PACKET_SIZE_INTERNAL 65536",
            "#define NCP_PRIVATE_DATA_MAX_LEN 8192",
            "#define NCP_OBJECT_NAME_MAX_LEN\t4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\n#define NCP_IOC_GETMOUNTUID64\t\t_IOW('n', 2, u64)\n#define NCP_IOC_GETMOUNTUID32\t\t_IOW('n', 2, u32)\n#define NCP_IOC_GETMOUNTUID16\t\t_IOW('n', 2, u16)\n#define NCP_IOC_SETPRIVATEDATA_32\t_IOR('n', 10, struct compat_ncp_privatedata_ioctl)\n#define NCP_IOC_GETPRIVATEDATA_32\t_IOWR('n', 10, struct compat_ncp_privatedata_ioctl)\n#define NCP_IOC_SETOBJECTNAME_32\t_IOR('n', 9, struct compat_ncp_objectname_ioctl)\n#define NCP_IOC_GETOBJECTNAME_32\t_IOWR('n', 9, struct compat_ncp_objectname_ioctl)\n#define NCP_IOC_NCPREQUEST_32\t\t_IOR('n', 1, struct compat_ncp_ioctl_request)\n#define NCP_IOC_GET_FS_INFO_V2_32\t_IOWR('n', 4, struct compat_ncp_fs_info_v2)\n#define NCP_PACKET_SIZE_INTERNAL 65536\n#define NCP_PRIVATE_DATA_MAX_LEN 8192\n#define NCP_OBJECT_NAME_MAX_LEN\t4096\n\nstatic long __ncp_ioctl(struct inode *inode, unsigned int cmd, unsigned long arg)\n{\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tint result;\n\tstruct ncp_ioctl_request request;\n\tchar* bouncebuffer;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_NCPREQUEST_32:\n#endif\n\tcase NCP_IOC_NCPREQUEST:\n#ifdef CONFIG_COMPAT\n\t\tif (cmd == NCP_IOC_NCPREQUEST_32) {\n\t\t\tstruct compat_ncp_ioctl_request request32;\n\t\t\tif (copy_from_user(&request32, argp, sizeof(request32)))\n\t\t\t\treturn -EFAULT;\n\t\t\trequest.function = request32.function;\n\t\t\trequest.size = request32.size;\n\t\t\trequest.data = compat_ptr(request32.data);\n\t\t} else\n#endif\n\t\tif (copy_from_user(&request, argp, sizeof(request)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((request.function > 255)\n\t\t    || (request.size >\n\t\t  NCP_PACKET_SIZE - sizeof(struct ncp_request_header))) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbouncebuffer = vmalloc(NCP_PACKET_SIZE_INTERNAL);\n\t\tif (!bouncebuffer)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(bouncebuffer, request.data, request.size)) {\n\t\t\tvfree(bouncebuffer);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tncp_lock_server(server);\n\n\t\t/* FIXME: We hack around in the server's structures\n\t\t   here to be able to use ncp_request */\n\n\t\tserver->has_subfunction = 0;\n\t\tserver->current_size = request.size;\n\t\tmemcpy(server->packet, bouncebuffer, request.size);\n\n\t\tresult = ncp_request2(server, request.function,\n\t\t\tbouncebuffer, NCP_PACKET_SIZE_INTERNAL);\n\t\tif (result < 0)\n\t\t\tresult = -EIO;\n\t\telse\n\t\t\tresult = server->reply_size;\n\t\tncp_unlock_server(server);\n\t\tncp_dbg(1, \"copy %d bytes\\n\", result);\n\t\tif (result >= 0)\n\t\t\tif (copy_to_user(request.data, bouncebuffer, result))\n\t\t\t\tresult = -EFAULT;\n\t\tvfree(bouncebuffer);\n\t\treturn result;\n\n\tcase NCP_IOC_CONN_LOGGED_IN:\n\n\t\tif (!(server->m.int_flags & NCP_IMOUNT_LOGGEDIN_POSSIBLE))\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&server->root_setup_lock);\n\t\tif (server->root_setuped)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tresult = ncp_conn_logged_in(inode->i_sb);\n\t\t\tif (result == 0)\n\t\t\t\tserver->root_setuped = 1;\n\t\t}\n\t\tmutex_unlock(&server->root_setup_lock);\n\t\treturn result;\n\n\tcase NCP_IOC_GET_FS_INFO:\n\t\treturn ncp_get_fs_info(server, inode, argp);\n\n\tcase NCP_IOC_GET_FS_INFO_V2:\n\t\treturn ncp_get_fs_info_v2(server, inode, argp);\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GET_FS_INFO_V2_32:\n\t\treturn ncp_get_compat_fs_info_v2(server, inode, argp);\n#endif\n\t/* we have too many combinations of CONFIG_COMPAT,\n\t * CONFIG_64BIT and CONFIG_UID16, so just handle\n\t * any of the possible ioctls */\n\tcase NCP_IOC_GETMOUNTUID16:\n\t\t{\n\t\t\tu16 uid;\n\n\t\t\tSET_UID(uid, from_kuid_munged(current_user_ns(), server->m.mounted_uid));\n\t\t\tif (put_user(uid, (u16 __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\tcase NCP_IOC_GETMOUNTUID32:\n\t{\n\t\tuid_t uid = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\t\tif (put_user(uid, (u32 __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase NCP_IOC_GETMOUNTUID64:\n\t{\n\t\tuid_t uid = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\t\tif (put_user(uid, (u64 __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase NCP_IOC_GETROOT:\n\t\t{\n\t\t\tstruct ncp_setroot_ioctl sr;\n\n\t\t\tresult = -EACCES;\n\t\t\tmutex_lock(&server->root_setup_lock);\n\t\t\tif (server->m.mounted_vol[0]) {\n\t\t\t\tstruct dentry* dentry = inode->i_sb->s_root;\n\n\t\t\t\tif (dentry) {\n\t\t\t\t\tstruct inode* s_inode = dentry->d_inode;\n\n\t\t\t\t\tif (s_inode) {\n\t\t\t\t\t\tsr.volNumber = NCP_FINFO(s_inode)->volNumber;\n\t\t\t\t\t\tsr.dirEntNum = NCP_FINFO(s_inode)->dirEntNum;\n\t\t\t\t\t\tsr.namespace = server->name_space[sr.volNumber];\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t\tncp_dbg(1, \"s_root->d_inode==NULL\\n\");\n\t\t\t\t} else\n\t\t\t\t\tncp_dbg(1, \"s_root==NULL\\n\");\n\t\t\t} else {\n\t\t\t\tsr.volNumber = -1;\n\t\t\t\tsr.namespace = 0;\n\t\t\t\tsr.dirEntNum = 0;\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&server->root_setup_lock);\n\t\t\tif (!result && copy_to_user(argp, &sr, sizeof(sr)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n\n\tcase NCP_IOC_SETROOT:\n\t\t{\n\t\t\tstruct ncp_setroot_ioctl sr;\n\t\t\t__u32 vnum;\n\t\t\t__le32 de;\n\t\t\t__le32 dosde;\n\t\t\tstruct dentry* dentry;\n\n\t\t\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&server->root_setup_lock);\n\t\t\tif (server->root_setuped)\n\t\t\t\tresult = -EBUSY;\n\t\t\telse {\n\t\t\t\tif (sr.volNumber < 0) {\n\t\t\t\t\tserver->m.mounted_vol[0] = 0;\n\t\t\t\t\tvnum = NCP_NUMBER_OF_VOLUMES;\n\t\t\t\t\tde = 0;\n\t\t\t\t\tdosde = 0;\n\t\t\t\t\tresult = 0;\n\t\t\t\t} else if (sr.volNumber >= NCP_NUMBER_OF_VOLUMES) {\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\t} else if (ncp_mount_subdir(server, sr.volNumber,\n\t\t\t\t\t\t\tsr.namespace, sr.dirEntNum,\n\t\t\t\t\t\t\t&vnum, &de, &dosde)) {\n\t\t\t\t\tresult = -ENOENT;\n\t\t\t\t} else\n\t\t\t\t\tresult = 0;\n\n\t\t\t\tif (result == 0) {\n\t\t\t\t\tdentry = inode->i_sb->s_root;\n\t\t\t\t\tif (dentry) {\n\t\t\t\t\t\tstruct inode* s_inode = dentry->d_inode;\n\n\t\t\t\t\t\tif (s_inode) {\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->volNumber = vnum;\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->dirEntNum = de;\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->DosDirNum = dosde;\n\t\t\t\t\t\t\tserver->root_setuped = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tncp_dbg(1, \"s_root->d_inode==NULL\\n\");\n\t\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncp_dbg(1, \"s_root==NULL\\n\");\n\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&server->root_setup_lock);\n\n\t\t\treturn result;\n\t\t}\n\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tcase NCP_IOC_SIGN_INIT:\n\t\t{\n\t\t\tstruct ncp_sign_init sign;\n\n\t\t\tif (argp)\n\t\t\t\tif (copy_from_user(&sign, argp, sizeof(sign)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\tncp_lock_server(server);\n\t\t\tmutex_lock(&server->rcv.creq_mutex);\n\t\t\tif (argp) {\n\t\t\t\tif (server->sign_wanted) {\n\t\t\t\t\tmemcpy(server->sign_root,sign.sign_root,8);\n\t\t\t\t\tmemcpy(server->sign_last,sign.sign_last,16);\n\t\t\t\t\tserver->sign_active = 1;\n\t\t\t\t}\n\t\t\t\t/* ignore when signatures not wanted */\n\t\t\t} else {\n\t\t\t\tserver->sign_active = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\t\tncp_unlock_server(server);\n\t\t\treturn 0;\n\t\t}\n\n        case NCP_IOC_SIGN_WANTED:\n\t\t{\n\t\t\tint state;\n\n\t\t\tncp_lock_server(server);\n\t\t\tstate = server->sign_wanted;\n\t\t\tncp_unlock_server(server);\n\t\t\tif (put_user(state, (int __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\tcase NCP_IOC_SET_SIGN_WANTED:\n\t\t{\n\t\t\tint newstate;\n\n\t\t\t/* get only low 8 bits... */\n\t\t\tif (get_user(newstate, (unsigned char __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\tresult = 0;\n\t\t\tncp_lock_server(server);\n\t\t\tif (server->sign_active) {\n\t\t\t\t/* cannot turn signatures OFF when active */\n\t\t\t\tif (!newstate)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t} else {\n\t\t\t\tserver->sign_wanted = newstate != 0;\n\t\t\t}\n\t\t\tncp_unlock_server(server);\n\t\t\treturn result;\n\t\t}\n\n#endif /* CONFIG_NCPFS_PACKET_SIGNING */\n\n#ifdef CONFIG_NCPFS_IOCTL_LOCKING\n\tcase NCP_IOC_LOCKUNLOCK:\n\t\t{\n\t\t\tstruct ncp_lock_ioctl\t rqdata;\n\n\t\t\tif (copy_from_user(&rqdata, argp, sizeof(rqdata)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rqdata.origin != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\t/* check for cmd */\n\t\t\tswitch (rqdata.cmd) {\n\t\t\t\tcase NCP_LOCK_EX:\n\t\t\t\tcase NCP_LOCK_SH:\n\t\t\t\t\t\tif (rqdata.timeout == 0)\n\t\t\t\t\t\t\trqdata.timeout = NCP_LOCK_DEFAULT_TIMEOUT;\n\t\t\t\t\t\telse if (rqdata.timeout > NCP_LOCK_MAX_TIMEOUT)\n\t\t\t\t\t\t\trqdata.timeout = NCP_LOCK_MAX_TIMEOUT;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase NCP_LOCK_LOG:\n\t\t\t\t\t\trqdata.timeout = NCP_LOCK_DEFAULT_TIMEOUT;\t/* has no effect */\n\t\t\t\tcase NCP_LOCK_CLEAR:\n\t\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* locking needs both read and write access */\n\t\t\tif ((result = ncp_make_open(inode, O_RDWR)) != 0)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = -EISDIR;\n\t\t\tif (!S_ISREG(inode->i_mode))\n\t\t\t\tgoto outrel;\n\t\t\tif (rqdata.cmd == NCP_LOCK_CLEAR)\n\t\t\t{\n\t\t\t\tresult = ncp_ClearPhysicalRecord(NCP_SERVER(inode),\n\t\t\t\t\t\t\tNCP_FINFO(inode)->file_handle,\n\t\t\t\t\t\t\trqdata.offset,\n\t\t\t\t\t\t\trqdata.length);\n\t\t\t\tif (result > 0) result = 0;\t/* no such lock */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lockcmd;\n\n\t\t\t\tswitch (rqdata.cmd)\n\t\t\t\t{\n\t\t\t\t\tcase NCP_LOCK_EX:  lockcmd=1; break;\n\t\t\t\t\tcase NCP_LOCK_SH:  lockcmd=3; break;\n\t\t\t\t\tdefault:\t   lockcmd=0; break;\n\t\t\t\t}\n\t\t\t\tresult = ncp_LogPhysicalRecord(NCP_SERVER(inode),\n\t\t\t\t\t\t\tNCP_FINFO(inode)->file_handle,\n\t\t\t\t\t\t\tlockcmd,\n\t\t\t\t\t\t\trqdata.offset,\n\t\t\t\t\t\t\trqdata.length,\n\t\t\t\t\t\t\trqdata.timeout);\n\t\t\t\tif (result > 0) result = -EAGAIN;\n\t\t\t}\noutrel:\n\t\t\tncp_inode_close(inode);\n\t\t\treturn result;\n\t\t}\n#endif\t/* CONFIG_NCPFS_IOCTL_LOCKING */\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GETOBJECTNAME_32:\n\t\t{\n\t\t\tstruct compat_ncp_objectname_ioctl user;\n\t\t\tsize_t outl;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\tuser.auth_type = server->auth.auth_type;\n\t\t\toutl = user.object_name_len;\n\t\t\tuser.object_name_len = server->auth.object_name_len;\n\t\t\tif (outl > user.object_name_len)\n\t\t\t\toutl = user.object_name_len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(compat_ptr(user.object_name),\n\t\t\t\t\t\t server->auth.object_name,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (!result && copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n#endif\n\n\tcase NCP_IOC_GETOBJECTNAME:\n\t\t{\n\t\t\tstruct ncp_objectname_ioctl user;\n\t\t\tsize_t outl;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\tuser.auth_type = server->auth.auth_type;\n\t\t\toutl = user.object_name_len;\n\t\t\tuser.object_name_len = server->auth.object_name_len;\n\t\t\tif (outl > user.object_name_len)\n\t\t\t\toutl = user.object_name_len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(user.object_name,\n\t\t\t\t\t\t server->auth.object_name,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (!result && copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_SETOBJECTNAME_32:\n#endif\n\tcase NCP_IOC_SETOBJECTNAME:\n\t\t{\n\t\t\tstruct ncp_objectname_ioctl user;\n\t\t\tvoid* newname;\n\t\t\tvoid* oldname;\n\t\t\tsize_t oldnamelen;\n\t\t\tvoid* oldprivate;\n\t\t\tsize_t oldprivatelen;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_SETOBJECTNAME_32) {\n\t\t\t\tstruct compat_ncp_objectname_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.auth_type = user32.auth_type;\n\t\t\t\tuser.object_name_len = user32.object_name_len;\n\t\t\t\tuser.object_name = compat_ptr(user32.object_name);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (user.object_name_len > NCP_OBJECT_NAME_MAX_LEN)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (user.object_name_len) {\n\t\t\t\tnewname = memdup_user(user.object_name,\n\t\t\t\t\t\t      user.object_name_len);\n\t\t\t\tif (IS_ERR(newname))\n\t\t\t\t\treturn PTR_ERR(newname);\n\t\t\t} else {\n\t\t\t\tnewname = NULL;\n\t\t\t}\n\t\t\tdown_write(&server->auth_rwsem);\n\t\t\toldname = server->auth.object_name;\n\t\t\toldnamelen = server->auth.object_name_len;\n\t\t\toldprivate = server->priv.data;\n\t\t\toldprivatelen = server->priv.len;\n\t\t\tserver->auth.auth_type = user.auth_type;\n\t\t\tserver->auth.object_name_len = user.object_name_len;\n\t\t\tserver->auth.object_name = newname;\n\t\t\tserver->priv.len = 0;\n\t\t\tserver->priv.data = NULL;\n\t\t\tup_write(&server->auth_rwsem);\n\t\t\tkfree(oldprivate);\n\t\t\tkfree(oldname);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GETPRIVATEDATA_32:\n#endif\n\tcase NCP_IOC_GETPRIVATEDATA:\n\t\t{\n\t\t\tstruct ncp_privatedata_ioctl user;\n\t\t\tsize_t outl;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_GETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.len = user32.len;\n\t\t\t\tuser.data = compat_ptr(user32.data);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\toutl = user.len;\n\t\t\tuser.len = server->priv.len;\n\t\t\tif (outl > user.len) outl = user.len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(user.data,\n\t\t\t\t\t\t server->priv.data,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (result)\n\t\t\t\treturn result;\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_GETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tuser32.len = user.len;\n\t\t\t\tuser32.data = (unsigned long) user.data;\n\t\t\t\tif (copy_to_user(argp, &user32, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n#endif\n\t\t\tif (copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_SETPRIVATEDATA_32:\n#endif\n\tcase NCP_IOC_SETPRIVATEDATA:\n\t\t{\n\t\t\tstruct ncp_privatedata_ioctl user;\n\t\t\tvoid* new;\n\t\t\tvoid* old;\n\t\t\tsize_t oldlen;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_SETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.len = user32.len;\n\t\t\t\tuser.data = compat_ptr(user32.data);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (user.len > NCP_PRIVATE_DATA_MAX_LEN)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (user.len) {\n\t\t\t\tnew = memdup_user(user.data, user.len);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\treturn PTR_ERR(new);\n\t\t\t} else {\n\t\t\t\tnew = NULL;\n\t\t\t}\n\t\t\tdown_write(&server->auth_rwsem);\n\t\t\told = server->priv.data;\n\t\t\toldlen = server->priv.len;\n\t\t\tserver->priv.len = user.len;\n\t\t\tserver->priv.data = new;\n\t\t\tup_write(&server->auth_rwsem);\n\t\t\tkfree(old);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_NCPFS_NLS\n\tcase NCP_IOC_SETCHARSETS:\n\t\treturn ncp_set_charsets(server, argp);\n\n\tcase NCP_IOC_GETCHARSETS:\n\t\treturn ncp_get_charsets(server, argp);\n\n#endif /* CONFIG_NCPFS_NLS */\n\n\tcase NCP_IOC_SETDENTRYTTL:\n\t\t{\n\t\t\tu_int32_t user;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* 20 secs at most... */\n\t\t\tif (user > 20000)\n\t\t\t\treturn -EINVAL;\n\t\t\tuser = (user * HZ) / 1000;\n\t\t\tatomic_set(&server->dentry_ttl, user);\n\t\t\treturn 0;\n\t\t}\n\n\tcase NCP_IOC_GETDENTRYTTL:\n\t\t{\n\t\t\tu_int32_t user = (atomic_read(&server->dentry_ttl) * 1000) / HZ;\n\t\t\tif (copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_READ"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "server->m.mounted_uid",
            "uid"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\n#define NCP_IOC_GETMOUNTUID64\t\t_IOW('n', 2, u64)\n#define NCP_IOC_GETMOUNTUID32\t\t_IOW('n', 2, u32)\n#define NCP_IOC_GETMOUNTUID16\t\t_IOW('n', 2, u16)\n#define NCP_IOC_SETPRIVATEDATA_32\t_IOR('n', 10, struct compat_ncp_privatedata_ioctl)\n#define NCP_IOC_GETPRIVATEDATA_32\t_IOWR('n', 10, struct compat_ncp_privatedata_ioctl)\n#define NCP_IOC_SETOBJECTNAME_32\t_IOR('n', 9, struct compat_ncp_objectname_ioctl)\n#define NCP_IOC_GETOBJECTNAME_32\t_IOWR('n', 9, struct compat_ncp_objectname_ioctl)\n#define NCP_IOC_NCPREQUEST_32\t\t_IOR('n', 1, struct compat_ncp_ioctl_request)\n#define NCP_IOC_GET_FS_INFO_V2_32\t_IOWR('n', 4, struct compat_ncp_fs_info_v2)\n\nlong ncp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tkuid_t uid = current_uid();\n\tint need_drop_write = 0;\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase NCP_IOC_SETCHARSETS:\n\tcase NCP_IOC_CONN_LOGGED_IN:\n\tcase NCP_IOC_SETROOT:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!uid_eq(server->m.mounted_uid, uid)) {\n\t\tswitch (cmd) {\n\t\t/*\n\t\t * Only mount owner can issue these ioctls.  Information\n\t\t * necessary to authenticate to other NDS servers are\n\t\t * stored here.\n\t\t */\n\t\tcase NCP_IOC_GETOBJECTNAME:\n\t\tcase NCP_IOC_SETOBJECTNAME:\n\t\tcase NCP_IOC_GETPRIVATEDATA:\n\t\tcase NCP_IOC_SETPRIVATEDATA:\n#ifdef CONFIG_COMPAT\n\t\tcase NCP_IOC_GETOBJECTNAME_32:\n\t\tcase NCP_IOC_SETOBJECTNAME_32:\n\t\tcase NCP_IOC_GETPRIVATEDATA_32:\n\t\tcase NCP_IOC_SETPRIVATEDATA_32:\n#endif\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t/*\n\t\t * These require write access on the inode if user id\n\t\t * does not match.  Note that they do not write to the\n\t\t * file...  But old code did mnt_want_write, so I keep\n\t\t * it as is.  Of course not for mountpoint owner, as\n\t\t * that breaks read-only mounts altogether as ncpmount\n\t\t * needs working NCP_IOC_NCPREQUEST and\n\t\t * NCP_IOC_GET_FS_INFO.  Some of these codes (setdentryttl,\n\t\t * signinit, setsignwanted) should be probably restricted\n\t\t * to owner only, or even more to CAP_SYS_ADMIN).\n\t\t */\n\t\tcase NCP_IOC_GET_FS_INFO:\n\t\tcase NCP_IOC_GET_FS_INFO_V2:\n\t\tcase NCP_IOC_NCPREQUEST:\n\t\tcase NCP_IOC_SETDENTRYTTL:\n\t\tcase NCP_IOC_SIGN_INIT:\n\t\tcase NCP_IOC_LOCKUNLOCK:\n\t\tcase NCP_IOC_SET_SIGN_WANTED:\n#ifdef CONFIG_COMPAT\n\t\tcase NCP_IOC_GET_FS_INFO_V2_32:\n\t\tcase NCP_IOC_NCPREQUEST_32:\n#endif\n\t\t\tret = mnt_want_write_file(filp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tneed_drop_write = 1;\n\t\t\tret = inode_permission(inode, MAY_WRITE);\n\t\t\tif (ret)\n\t\t\t\tgoto outDropWrite;\n\t\t\tbreak;\n\t\t/*\n\t\t * Read access required.\n\t\t */\n\t\tcase NCP_IOC_GETMOUNTUID16:\n\t\tcase NCP_IOC_GETMOUNTUID32:\n\t\tcase NCP_IOC_GETMOUNTUID64:\n\t\tcase NCP_IOC_GETROOT:\n\t\tcase NCP_IOC_SIGN_WANTED:\n\t\t\tret = inode_permission(inode, MAY_READ);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t/*\n\t\t * Anybody can read these.\n\t\t */\n\t\tcase NCP_IOC_GETCHARSETS:\n\t\tcase NCP_IOC_GETDENTRYTTL:\n\t\tdefault:\n\t\t/* Three codes below are protected by CAP_SYS_ADMIN above. */\n\t\tcase NCP_IOC_SETCHARSETS:\n\t\tcase NCP_IOC_CONN_LOGGED_IN:\n\t\tcase NCP_IOC_SETROOT:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = __ncp_ioctl(inode, cmd, arg);\noutDropWrite:\n\tif (need_drop_write)\n\t\tmnt_drop_write_file(filp);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__ncp_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
    "lines": "257-808",
    "snippet": "static long __ncp_ioctl(struct inode *inode, unsigned int cmd, unsigned long arg)\n{\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tint result;\n\tstruct ncp_ioctl_request request;\n\tchar* bouncebuffer;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_NCPREQUEST_32:\n#endif\n\tcase NCP_IOC_NCPREQUEST:\n#ifdef CONFIG_COMPAT\n\t\tif (cmd == NCP_IOC_NCPREQUEST_32) {\n\t\t\tstruct compat_ncp_ioctl_request request32;\n\t\t\tif (copy_from_user(&request32, argp, sizeof(request32)))\n\t\t\t\treturn -EFAULT;\n\t\t\trequest.function = request32.function;\n\t\t\trequest.size = request32.size;\n\t\t\trequest.data = compat_ptr(request32.data);\n\t\t} else\n#endif\n\t\tif (copy_from_user(&request, argp, sizeof(request)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((request.function > 255)\n\t\t    || (request.size >\n\t\t  NCP_PACKET_SIZE - sizeof(struct ncp_request_header))) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbouncebuffer = vmalloc(NCP_PACKET_SIZE_INTERNAL);\n\t\tif (!bouncebuffer)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(bouncebuffer, request.data, request.size)) {\n\t\t\tvfree(bouncebuffer);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tncp_lock_server(server);\n\n\t\t/* FIXME: We hack around in the server's structures\n\t\t   here to be able to use ncp_request */\n\n\t\tserver->has_subfunction = 0;\n\t\tserver->current_size = request.size;\n\t\tmemcpy(server->packet, bouncebuffer, request.size);\n\n\t\tresult = ncp_request2(server, request.function,\n\t\t\tbouncebuffer, NCP_PACKET_SIZE_INTERNAL);\n\t\tif (result < 0)\n\t\t\tresult = -EIO;\n\t\telse\n\t\t\tresult = server->reply_size;\n\t\tncp_unlock_server(server);\n\t\tncp_dbg(1, \"copy %d bytes\\n\", result);\n\t\tif (result >= 0)\n\t\t\tif (copy_to_user(request.data, bouncebuffer, result))\n\t\t\t\tresult = -EFAULT;\n\t\tvfree(bouncebuffer);\n\t\treturn result;\n\n\tcase NCP_IOC_CONN_LOGGED_IN:\n\n\t\tif (!(server->m.int_flags & NCP_IMOUNT_LOGGEDIN_POSSIBLE))\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&server->root_setup_lock);\n\t\tif (server->root_setuped)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tresult = ncp_conn_logged_in(inode->i_sb);\n\t\t\tif (result == 0)\n\t\t\t\tserver->root_setuped = 1;\n\t\t}\n\t\tmutex_unlock(&server->root_setup_lock);\n\t\treturn result;\n\n\tcase NCP_IOC_GET_FS_INFO:\n\t\treturn ncp_get_fs_info(server, inode, argp);\n\n\tcase NCP_IOC_GET_FS_INFO_V2:\n\t\treturn ncp_get_fs_info_v2(server, inode, argp);\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GET_FS_INFO_V2_32:\n\t\treturn ncp_get_compat_fs_info_v2(server, inode, argp);\n#endif\n\t/* we have too many combinations of CONFIG_COMPAT,\n\t * CONFIG_64BIT and CONFIG_UID16, so just handle\n\t * any of the possible ioctls */\n\tcase NCP_IOC_GETMOUNTUID16:\n\t\t{\n\t\t\tu16 uid;\n\n\t\t\tSET_UID(uid, from_kuid_munged(current_user_ns(), server->m.mounted_uid));\n\t\t\tif (put_user(uid, (u16 __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\tcase NCP_IOC_GETMOUNTUID32:\n\t{\n\t\tuid_t uid = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\t\tif (put_user(uid, (u32 __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase NCP_IOC_GETMOUNTUID64:\n\t{\n\t\tuid_t uid = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\t\tif (put_user(uid, (u64 __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase NCP_IOC_GETROOT:\n\t\t{\n\t\t\tstruct ncp_setroot_ioctl sr;\n\n\t\t\tresult = -EACCES;\n\t\t\tmutex_lock(&server->root_setup_lock);\n\t\t\tif (server->m.mounted_vol[0]) {\n\t\t\t\tstruct dentry* dentry = inode->i_sb->s_root;\n\n\t\t\t\tif (dentry) {\n\t\t\t\t\tstruct inode* s_inode = dentry->d_inode;\n\n\t\t\t\t\tif (s_inode) {\n\t\t\t\t\t\tsr.volNumber = NCP_FINFO(s_inode)->volNumber;\n\t\t\t\t\t\tsr.dirEntNum = NCP_FINFO(s_inode)->dirEntNum;\n\t\t\t\t\t\tsr.namespace = server->name_space[sr.volNumber];\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t\tncp_dbg(1, \"s_root->d_inode==NULL\\n\");\n\t\t\t\t} else\n\t\t\t\t\tncp_dbg(1, \"s_root==NULL\\n\");\n\t\t\t} else {\n\t\t\t\tsr.volNumber = -1;\n\t\t\t\tsr.namespace = 0;\n\t\t\t\tsr.dirEntNum = 0;\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&server->root_setup_lock);\n\t\t\tif (!result && copy_to_user(argp, &sr, sizeof(sr)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n\n\tcase NCP_IOC_SETROOT:\n\t\t{\n\t\t\tstruct ncp_setroot_ioctl sr;\n\t\t\t__u32 vnum;\n\t\t\t__le32 de;\n\t\t\t__le32 dosde;\n\t\t\tstruct dentry* dentry;\n\n\t\t\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&server->root_setup_lock);\n\t\t\tif (server->root_setuped)\n\t\t\t\tresult = -EBUSY;\n\t\t\telse {\n\t\t\t\tif (sr.volNumber < 0) {\n\t\t\t\t\tserver->m.mounted_vol[0] = 0;\n\t\t\t\t\tvnum = NCP_NUMBER_OF_VOLUMES;\n\t\t\t\t\tde = 0;\n\t\t\t\t\tdosde = 0;\n\t\t\t\t\tresult = 0;\n\t\t\t\t} else if (sr.volNumber >= NCP_NUMBER_OF_VOLUMES) {\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\t} else if (ncp_mount_subdir(server, sr.volNumber,\n\t\t\t\t\t\t\tsr.namespace, sr.dirEntNum,\n\t\t\t\t\t\t\t&vnum, &de, &dosde)) {\n\t\t\t\t\tresult = -ENOENT;\n\t\t\t\t} else\n\t\t\t\t\tresult = 0;\n\n\t\t\t\tif (result == 0) {\n\t\t\t\t\tdentry = inode->i_sb->s_root;\n\t\t\t\t\tif (dentry) {\n\t\t\t\t\t\tstruct inode* s_inode = dentry->d_inode;\n\n\t\t\t\t\t\tif (s_inode) {\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->volNumber = vnum;\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->dirEntNum = de;\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->DosDirNum = dosde;\n\t\t\t\t\t\t\tserver->root_setuped = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tncp_dbg(1, \"s_root->d_inode==NULL\\n\");\n\t\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncp_dbg(1, \"s_root==NULL\\n\");\n\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&server->root_setup_lock);\n\n\t\t\treturn result;\n\t\t}\n\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tcase NCP_IOC_SIGN_INIT:\n\t\t{\n\t\t\tstruct ncp_sign_init sign;\n\n\t\t\tif (argp)\n\t\t\t\tif (copy_from_user(&sign, argp, sizeof(sign)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\tncp_lock_server(server);\n\t\t\tmutex_lock(&server->rcv.creq_mutex);\n\t\t\tif (argp) {\n\t\t\t\tif (server->sign_wanted) {\n\t\t\t\t\tmemcpy(server->sign_root,sign.sign_root,8);\n\t\t\t\t\tmemcpy(server->sign_last,sign.sign_last,16);\n\t\t\t\t\tserver->sign_active = 1;\n\t\t\t\t}\n\t\t\t\t/* ignore when signatures not wanted */\n\t\t\t} else {\n\t\t\t\tserver->sign_active = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\t\tncp_unlock_server(server);\n\t\t\treturn 0;\n\t\t}\n\n        case NCP_IOC_SIGN_WANTED:\n\t\t{\n\t\t\tint state;\n\n\t\t\tncp_lock_server(server);\n\t\t\tstate = server->sign_wanted;\n\t\t\tncp_unlock_server(server);\n\t\t\tif (put_user(state, (int __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\tcase NCP_IOC_SET_SIGN_WANTED:\n\t\t{\n\t\t\tint newstate;\n\n\t\t\t/* get only low 8 bits... */\n\t\t\tif (get_user(newstate, (unsigned char __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\tresult = 0;\n\t\t\tncp_lock_server(server);\n\t\t\tif (server->sign_active) {\n\t\t\t\t/* cannot turn signatures OFF when active */\n\t\t\t\tif (!newstate)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t} else {\n\t\t\t\tserver->sign_wanted = newstate != 0;\n\t\t\t}\n\t\t\tncp_unlock_server(server);\n\t\t\treturn result;\n\t\t}\n\n#endif /* CONFIG_NCPFS_PACKET_SIGNING */\n\n#ifdef CONFIG_NCPFS_IOCTL_LOCKING\n\tcase NCP_IOC_LOCKUNLOCK:\n\t\t{\n\t\t\tstruct ncp_lock_ioctl\t rqdata;\n\n\t\t\tif (copy_from_user(&rqdata, argp, sizeof(rqdata)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rqdata.origin != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\t/* check for cmd */\n\t\t\tswitch (rqdata.cmd) {\n\t\t\t\tcase NCP_LOCK_EX:\n\t\t\t\tcase NCP_LOCK_SH:\n\t\t\t\t\t\tif (rqdata.timeout == 0)\n\t\t\t\t\t\t\trqdata.timeout = NCP_LOCK_DEFAULT_TIMEOUT;\n\t\t\t\t\t\telse if (rqdata.timeout > NCP_LOCK_MAX_TIMEOUT)\n\t\t\t\t\t\t\trqdata.timeout = NCP_LOCK_MAX_TIMEOUT;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase NCP_LOCK_LOG:\n\t\t\t\t\t\trqdata.timeout = NCP_LOCK_DEFAULT_TIMEOUT;\t/* has no effect */\n\t\t\t\tcase NCP_LOCK_CLEAR:\n\t\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* locking needs both read and write access */\n\t\t\tif ((result = ncp_make_open(inode, O_RDWR)) != 0)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = -EISDIR;\n\t\t\tif (!S_ISREG(inode->i_mode))\n\t\t\t\tgoto outrel;\n\t\t\tif (rqdata.cmd == NCP_LOCK_CLEAR)\n\t\t\t{\n\t\t\t\tresult = ncp_ClearPhysicalRecord(NCP_SERVER(inode),\n\t\t\t\t\t\t\tNCP_FINFO(inode)->file_handle,\n\t\t\t\t\t\t\trqdata.offset,\n\t\t\t\t\t\t\trqdata.length);\n\t\t\t\tif (result > 0) result = 0;\t/* no such lock */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lockcmd;\n\n\t\t\t\tswitch (rqdata.cmd)\n\t\t\t\t{\n\t\t\t\t\tcase NCP_LOCK_EX:  lockcmd=1; break;\n\t\t\t\t\tcase NCP_LOCK_SH:  lockcmd=3; break;\n\t\t\t\t\tdefault:\t   lockcmd=0; break;\n\t\t\t\t}\n\t\t\t\tresult = ncp_LogPhysicalRecord(NCP_SERVER(inode),\n\t\t\t\t\t\t\tNCP_FINFO(inode)->file_handle,\n\t\t\t\t\t\t\tlockcmd,\n\t\t\t\t\t\t\trqdata.offset,\n\t\t\t\t\t\t\trqdata.length,\n\t\t\t\t\t\t\trqdata.timeout);\n\t\t\t\tif (result > 0) result = -EAGAIN;\n\t\t\t}\noutrel:\n\t\t\tncp_inode_close(inode);\n\t\t\treturn result;\n\t\t}\n#endif\t/* CONFIG_NCPFS_IOCTL_LOCKING */\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GETOBJECTNAME_32:\n\t\t{\n\t\t\tstruct compat_ncp_objectname_ioctl user;\n\t\t\tsize_t outl;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\tuser.auth_type = server->auth.auth_type;\n\t\t\toutl = user.object_name_len;\n\t\t\tuser.object_name_len = server->auth.object_name_len;\n\t\t\tif (outl > user.object_name_len)\n\t\t\t\toutl = user.object_name_len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(compat_ptr(user.object_name),\n\t\t\t\t\t\t server->auth.object_name,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (!result && copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n#endif\n\n\tcase NCP_IOC_GETOBJECTNAME:\n\t\t{\n\t\t\tstruct ncp_objectname_ioctl user;\n\t\t\tsize_t outl;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\tuser.auth_type = server->auth.auth_type;\n\t\t\toutl = user.object_name_len;\n\t\t\tuser.object_name_len = server->auth.object_name_len;\n\t\t\tif (outl > user.object_name_len)\n\t\t\t\toutl = user.object_name_len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(user.object_name,\n\t\t\t\t\t\t server->auth.object_name,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (!result && copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_SETOBJECTNAME_32:\n#endif\n\tcase NCP_IOC_SETOBJECTNAME:\n\t\t{\n\t\t\tstruct ncp_objectname_ioctl user;\n\t\t\tvoid* newname;\n\t\t\tvoid* oldname;\n\t\t\tsize_t oldnamelen;\n\t\t\tvoid* oldprivate;\n\t\t\tsize_t oldprivatelen;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_SETOBJECTNAME_32) {\n\t\t\t\tstruct compat_ncp_objectname_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.auth_type = user32.auth_type;\n\t\t\t\tuser.object_name_len = user32.object_name_len;\n\t\t\t\tuser.object_name = compat_ptr(user32.object_name);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (user.object_name_len > NCP_OBJECT_NAME_MAX_LEN)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (user.object_name_len) {\n\t\t\t\tnewname = memdup_user(user.object_name,\n\t\t\t\t\t\t      user.object_name_len);\n\t\t\t\tif (IS_ERR(newname))\n\t\t\t\t\treturn PTR_ERR(newname);\n\t\t\t} else {\n\t\t\t\tnewname = NULL;\n\t\t\t}\n\t\t\tdown_write(&server->auth_rwsem);\n\t\t\toldname = server->auth.object_name;\n\t\t\toldnamelen = server->auth.object_name_len;\n\t\t\toldprivate = server->priv.data;\n\t\t\toldprivatelen = server->priv.len;\n\t\t\tserver->auth.auth_type = user.auth_type;\n\t\t\tserver->auth.object_name_len = user.object_name_len;\n\t\t\tserver->auth.object_name = newname;\n\t\t\tserver->priv.len = 0;\n\t\t\tserver->priv.data = NULL;\n\t\t\tup_write(&server->auth_rwsem);\n\t\t\tkfree(oldprivate);\n\t\t\tkfree(oldname);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GETPRIVATEDATA_32:\n#endif\n\tcase NCP_IOC_GETPRIVATEDATA:\n\t\t{\n\t\t\tstruct ncp_privatedata_ioctl user;\n\t\t\tsize_t outl;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_GETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.len = user32.len;\n\t\t\t\tuser.data = compat_ptr(user32.data);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\toutl = user.len;\n\t\t\tuser.len = server->priv.len;\n\t\t\tif (outl > user.len) outl = user.len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(user.data,\n\t\t\t\t\t\t server->priv.data,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (result)\n\t\t\t\treturn result;\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_GETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tuser32.len = user.len;\n\t\t\t\tuser32.data = (unsigned long) user.data;\n\t\t\t\tif (copy_to_user(argp, &user32, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n#endif\n\t\t\tif (copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_SETPRIVATEDATA_32:\n#endif\n\tcase NCP_IOC_SETPRIVATEDATA:\n\t\t{\n\t\t\tstruct ncp_privatedata_ioctl user;\n\t\t\tvoid* new;\n\t\t\tvoid* old;\n\t\t\tsize_t oldlen;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_SETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.len = user32.len;\n\t\t\t\tuser.data = compat_ptr(user32.data);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (user.len > NCP_PRIVATE_DATA_MAX_LEN)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (user.len) {\n\t\t\t\tnew = memdup_user(user.data, user.len);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\treturn PTR_ERR(new);\n\t\t\t} else {\n\t\t\t\tnew = NULL;\n\t\t\t}\n\t\t\tdown_write(&server->auth_rwsem);\n\t\t\told = server->priv.data;\n\t\t\toldlen = server->priv.len;\n\t\t\tserver->priv.len = user.len;\n\t\t\tserver->priv.data = new;\n\t\t\tup_write(&server->auth_rwsem);\n\t\t\tkfree(old);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_NCPFS_NLS\n\tcase NCP_IOC_SETCHARSETS:\n\t\treturn ncp_set_charsets(server, argp);\n\n\tcase NCP_IOC_GETCHARSETS:\n\t\treturn ncp_get_charsets(server, argp);\n\n#endif /* CONFIG_NCPFS_NLS */\n\n\tcase NCP_IOC_SETDENTRYTTL:\n\t\t{\n\t\t\tu_int32_t user;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* 20 secs at most... */\n\t\t\tif (user > 20000)\n\t\t\t\treturn -EINVAL;\n\t\t\tuser = (user * HZ) / 1000;\n\t\t\tatomic_set(&server->dentry_ttl, user);\n\t\t\treturn 0;\n\t\t}\n\n\tcase NCP_IOC_GETDENTRYTTL:\n\t\t{\n\t\t\tu_int32_t user = (atomic_read(&server->dentry_ttl) * 1000) / HZ;\n\t\t\tif (copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define NCP_IOC_GETMOUNTUID64\t\t_IOW('n', 2, u64)",
      "#define NCP_IOC_GETMOUNTUID32\t\t_IOW('n', 2, u32)",
      "#define NCP_IOC_GETMOUNTUID16\t\t_IOW('n', 2, u16)",
      "#define NCP_IOC_SETPRIVATEDATA_32\t_IOR('n', 10, struct compat_ncp_privatedata_ioctl)",
      "#define NCP_IOC_GETPRIVATEDATA_32\t_IOWR('n', 10, struct compat_ncp_privatedata_ioctl)",
      "#define NCP_IOC_SETOBJECTNAME_32\t_IOR('n', 9, struct compat_ncp_objectname_ioctl)",
      "#define NCP_IOC_GETOBJECTNAME_32\t_IOWR('n', 9, struct compat_ncp_objectname_ioctl)",
      "#define NCP_IOC_NCPREQUEST_32\t\t_IOR('n', 1, struct compat_ncp_ioctl_request)",
      "#define NCP_IOC_GET_FS_INFO_V2_32\t_IOWR('n', 4, struct compat_ncp_fs_info_v2)",
      "#define NCP_PACKET_SIZE_INTERNAL 65536",
      "#define NCP_PRIVATE_DATA_MAX_LEN 8192",
      "#define NCP_OBJECT_NAME_MAX_LEN\t4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&user",
            "sizeof(user)"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&server->dentry_ttl"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&server->dentry_ttl",
            "user"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&user",
            "argp",
            "sizeof(user)"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_get_charsets",
          "args": [
            "server",
            "argp"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_get_charsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
          "lines": "224-254",
          "snippet": "static int\nncp_get_charsets(struct ncp_server* server, struct ncp_nls_ioctl __user *arg)\n{\n\tstruct ncp_nls_ioctl user;\n\tint len;\n\n\tmemset(&user, 0, sizeof(user));\n\tmutex_lock(&server->root_setup_lock);\n\tif (server->nls_vol && server->nls_vol->charset) {\n\t\tlen = strlen(server->nls_vol->charset);\n\t\tif (len > NCP_IOCSNAME_LEN)\n\t\t\tlen = NCP_IOCSNAME_LEN;\n\t\tstrncpy(user.codepage, server->nls_vol->charset, len);\n\t\tuser.codepage[len] = 0;\n\t}\n\n\tif (NCP_IS_FLAG(server, NCP_FLAG_UTF8))\n\t\tstrcpy(user.iocharset, \"utf8\");\n\telse if (server->nls_io && server->nls_io->charset) {\n\t\tlen = strlen(server->nls_io->charset);\n\t\tif (len > NCP_IOCSNAME_LEN)\n\t\t\tlen = NCP_IOCSNAME_LEN;\n\t\tstrncpy(user.iocharset,\tserver->nls_io->charset, len);\n\t\tuser.iocharset[len] = 0;\n\t}\n\tmutex_unlock(&server->root_setup_lock);\n\n\tif (copy_to_user(arg, &user, sizeof(user)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_get_charsets(struct ncp_server* server, struct ncp_nls_ioctl __user *arg)\n{\n\tstruct ncp_nls_ioctl user;\n\tint len;\n\n\tmemset(&user, 0, sizeof(user));\n\tmutex_lock(&server->root_setup_lock);\n\tif (server->nls_vol && server->nls_vol->charset) {\n\t\tlen = strlen(server->nls_vol->charset);\n\t\tif (len > NCP_IOCSNAME_LEN)\n\t\t\tlen = NCP_IOCSNAME_LEN;\n\t\tstrncpy(user.codepage, server->nls_vol->charset, len);\n\t\tuser.codepage[len] = 0;\n\t}\n\n\tif (NCP_IS_FLAG(server, NCP_FLAG_UTF8))\n\t\tstrcpy(user.iocharset, \"utf8\");\n\telse if (server->nls_io && server->nls_io->charset) {\n\t\tlen = strlen(server->nls_io->charset);\n\t\tif (len > NCP_IOCSNAME_LEN)\n\t\t\tlen = NCP_IOCSNAME_LEN;\n\t\tstrncpy(user.iocharset,\tserver->nls_io->charset, len);\n\t\tuser.iocharset[len] = 0;\n\t}\n\tmutex_unlock(&server->root_setup_lock);\n\n\tif (copy_to_user(arg, &user, sizeof(user)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_set_charsets",
          "args": [
            "server",
            "argp"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_set_charsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
          "lines": "159-222",
          "snippet": "static int\nncp_set_charsets(struct ncp_server* server, struct ncp_nls_ioctl __user *arg)\n{\n\tstruct ncp_nls_ioctl user;\n\tstruct nls_table *codepage;\n\tstruct nls_table *iocharset;\n\tstruct nls_table *oldset_io;\n\tstruct nls_table *oldset_cp;\n\tint utf8;\n\tint err;\n\n\tif (copy_from_user(&user, arg, sizeof(user)))\n\t\treturn -EFAULT;\n\n\tcodepage = NULL;\n\tuser.codepage[NCP_IOCSNAME_LEN] = 0;\n\tif (!user.codepage[0] || !strcmp(user.codepage, \"default\"))\n\t\tcodepage = load_nls_default();\n\telse {\n\t\tcodepage = load_nls(user.codepage);\n\t\tif (!codepage) {\n\t\t\treturn -EBADRQC;\n\t\t}\n\t}\n\n\tiocharset = NULL;\n\tuser.iocharset[NCP_IOCSNAME_LEN] = 0;\n\tif (!user.iocharset[0] || !strcmp(user.iocharset, \"default\")) {\n\t\tiocharset = load_nls_default();\n\t\tutf8 = 0;\n\t} else if (!strcmp(user.iocharset, \"utf8\")) {\n\t\tiocharset = load_nls_default();\n\t\tutf8 = 1;\n\t} else {\n\t\tiocharset = load_nls(user.iocharset);\n\t\tif (!iocharset) {\n\t\t\tunload_nls(codepage);\n\t\t\treturn -EBADRQC;\n\t\t}\n\t\tutf8 = 0;\n\t}\n\n\tmutex_lock(&server->root_setup_lock);\n\tif (server->root_setuped) {\n\t\toldset_cp = codepage;\n\t\toldset_io = iocharset;\n\t\terr = -EBUSY;\n\t} else {\n\t\tif (utf8)\n\t\t\tNCP_SET_FLAG(server, NCP_FLAG_UTF8);\n\t\telse\n\t\t\tNCP_CLR_FLAG(server, NCP_FLAG_UTF8);\n\t\toldset_cp = server->nls_vol;\n\t\tserver->nls_vol = codepage;\n\t\toldset_io = server->nls_io;\n\t\tserver->nls_io = iocharset;\n\t\terr = 0;\n\t}\n\tmutex_unlock(&server->root_setup_lock);\n\tunload_nls(oldset_cp);\n\tunload_nls(oldset_io);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_set_charsets(struct ncp_server* server, struct ncp_nls_ioctl __user *arg)\n{\n\tstruct ncp_nls_ioctl user;\n\tstruct nls_table *codepage;\n\tstruct nls_table *iocharset;\n\tstruct nls_table *oldset_io;\n\tstruct nls_table *oldset_cp;\n\tint utf8;\n\tint err;\n\n\tif (copy_from_user(&user, arg, sizeof(user)))\n\t\treturn -EFAULT;\n\n\tcodepage = NULL;\n\tuser.codepage[NCP_IOCSNAME_LEN] = 0;\n\tif (!user.codepage[0] || !strcmp(user.codepage, \"default\"))\n\t\tcodepage = load_nls_default();\n\telse {\n\t\tcodepage = load_nls(user.codepage);\n\t\tif (!codepage) {\n\t\t\treturn -EBADRQC;\n\t\t}\n\t}\n\n\tiocharset = NULL;\n\tuser.iocharset[NCP_IOCSNAME_LEN] = 0;\n\tif (!user.iocharset[0] || !strcmp(user.iocharset, \"default\")) {\n\t\tiocharset = load_nls_default();\n\t\tutf8 = 0;\n\t} else if (!strcmp(user.iocharset, \"utf8\")) {\n\t\tiocharset = load_nls_default();\n\t\tutf8 = 1;\n\t} else {\n\t\tiocharset = load_nls(user.iocharset);\n\t\tif (!iocharset) {\n\t\t\tunload_nls(codepage);\n\t\t\treturn -EBADRQC;\n\t\t}\n\t\tutf8 = 0;\n\t}\n\n\tmutex_lock(&server->root_setup_lock);\n\tif (server->root_setuped) {\n\t\toldset_cp = codepage;\n\t\toldset_io = iocharset;\n\t\terr = -EBUSY;\n\t} else {\n\t\tif (utf8)\n\t\t\tNCP_SET_FLAG(server, NCP_FLAG_UTF8);\n\t\telse\n\t\t\tNCP_CLR_FLAG(server, NCP_FLAG_UTF8);\n\t\toldset_cp = server->nls_vol;\n\t\tserver->nls_vol = codepage;\n\t\toldset_io = server->nls_io;\n\t\tserver->nls_io = iocharset;\n\t\terr = 0;\n\t}\n\tmutex_unlock(&server->root_setup_lock);\n\tunload_nls(oldset_cp);\n\tunload_nls(oldset_io);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "user.data",
            "user.len"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "user32.data"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&user",
            "sizeof(user)"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&user32",
            "sizeof(user32)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user.data",
            "server->priv.data",
            "outl"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "user32.data"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oldname"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oldprivate"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "newname"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newname"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "user.object_name",
            "user.object_name_len"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "user32.object_name"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&user",
            "sizeof(user)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user.object_name",
            "server->auth.object_name",
            "outl"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&user",
            "sizeof(user)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "compat_ptr(user.object_name)",
            "server->auth.object_name",
            "outl"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "user.object_name"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&server->auth_rwsem"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_inode_close",
          "args": [
            "inode"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_inode_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "62-64",
          "snippet": "static inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_LogPhysicalRecord",
          "args": [
            "NCP_SERVER(inode)",
            "NCP_FINFO(inode)->file_handle",
            "lockcmd",
            "rqdata.offset",
            "rqdata.length",
            "rqdata.timeout"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_LogPhysicalRecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "1056-1076",
          "snippet": "int\nncp_LogPhysicalRecord(struct ncp_server *server, const char *file_id,\n\t  __u8 locktype, __u32 offset, __u32 length, __u16 timeout)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, locktype);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be32(server, length);\n\tncp_add_be16(server, timeout);\n\n\tif ((result = ncp_request(server, 0x1A)) != 0)\n\t{\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\tncp_unlock_server(server);\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_LogPhysicalRecord(struct ncp_server *server, const char *file_id,\n\t  __u8 locktype, __u32 offset, __u32 length, __u16 timeout)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, locktype);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be32(server, length);\n\tncp_add_be16(server, timeout);\n\n\tif ((result = ncp_request(server, 0x1A)) != 0)\n\t{\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\tncp_unlock_server(server);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_ClearPhysicalRecord",
          "args": [
            "NCP_SERVER(inode)",
            "NCP_FINFO(inode)->file_handle",
            "rqdata.offset",
            "rqdata.length"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_ClearPhysicalRecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "1078-1097",
          "snippet": "int\nncp_ClearPhysicalRecord(struct ncp_server *server, const char *file_id,\n\t  __u32 offset, __u32 length)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\t/* who knows... lanalyzer says that */\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be32(server, length);\n\n\tif ((result = ncp_request(server, 0x1E)) != 0)\n\t{\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\tncp_unlock_server(server);\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_ClearPhysicalRecord(struct ncp_server *server, const char *file_id,\n\t  __u32 offset, __u32 length)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\t/* who knows... lanalyzer says that */\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be32(server, length);\n\n\tif ((result = ncp_request(server, 0x1E)) != 0)\n\t{\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\tncp_unlock_server(server);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_open",
          "args": [
            "inode",
            "O_RDWR"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
          "lines": "32-98",
          "snippet": "int ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nint ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_unlock_server",
          "args": [
            "server"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_unlock_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "873-881",
          "snippet": "void ncp_unlock_server(struct ncp_server *server)\n{\n\tif (!server->lock) {\n\t\tpr_warn(\"%s: was not locked!\\n\", __func__);\n\t\treturn;\n\t}\n\tserver->lock = 0;\n\tmutex_unlock(&server->mutex);\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_unlock_server(struct ncp_server *server)\n{\n\tif (!server->lock) {\n\t\tpr_warn(\"%s: was not locked!\\n\", __func__);\n\t\treturn;\n\t}\n\tserver->lock = 0;\n\tmutex_unlock(&server->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_lock_server",
          "args": [
            "server"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_lock_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "865-871",
          "snippet": "void ncp_lock_server(struct ncp_server *server)\n{\n\tmutex_lock(&server->mutex);\n\tif (server->lock)\n\t\tpr_warn(\"%s: was locked!\\n\", __func__);\n\tserver->lock = 1;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nvoid ncp_lock_server(struct ncp_server *server)\n{\n\tmutex_lock(&server->mutex);\n\tif (server->lock)\n\t\tpr_warn(\"%s: was locked!\\n\", __func__);\n\tserver->lock = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "newstate",
            "(unsigned char __user *)argp"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "state",
            "(int __user *)argp"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server->sign_last",
            "sign.sign_last",
            "16"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server->sign_root",
            "sign.sign_root",
            "8"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->rcv.creq_mutex"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"s_root==NULL\\n\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"s_root->d_inode==NULL\\n\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_mount_subdir",
          "args": [
            "server",
            "sr.volNumber",
            "sr.namespace",
            "sr.dirEntNum",
            "&vnum",
            "&de",
            "&dosde"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_mount_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "571-589",
          "snippet": "int\nncp_mount_subdir(struct ncp_server *server,\n\t\t __u8 volNumber, __u8 srcNS, __le32 dirEntNum,\n\t\t __u32* volume, __le32* newDirEnt, __le32* newDosEnt)\n{\n\tint dstNS;\n\tint result;\n\n\tncp_update_known_namespace(server, volNumber, &dstNS);\n\tif ((result = ncp_ObtainSpecificDirBase(server, srcNS, dstNS, volNumber, \n\t\t\t\t      dirEntNum, NULL, newDirEnt, newDosEnt)) != 0)\n\t{\n\t\treturn result;\n\t}\n\t*volume = volNumber;\n\tserver->m.mounted_vol[1] = 0;\n\tserver->m.mounted_vol[0] = 'X';\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_mount_subdir(struct ncp_server *server,\n\t\t __u8 volNumber, __u8 srcNS, __le32 dirEntNum,\n\t\t __u32* volume, __le32* newDirEnt, __le32* newDosEnt)\n{\n\tint dstNS;\n\tint result;\n\n\tncp_update_known_namespace(server, volNumber, &dstNS);\n\tif ((result = ncp_ObtainSpecificDirBase(server, srcNS, dstNS, volNumber, \n\t\t\t\t      dirEntNum, NULL, newDirEnt, newDosEnt)) != 0)\n\t{\n\t\treturn result;\n\t}\n\t*volume = volNumber;\n\tserver->m.mounted_vol[1] = 0;\n\tserver->m.mounted_vol[0] = 'X';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&sr",
            "sizeof(sr)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"s_root==NULL\\n\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"s_root->d_inode==NULL\\n\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "uid",
            "(u64 __user *)argp"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "server->m.mounted_uid"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "uid",
            "(u32 __user *)argp"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "server->m.mounted_uid"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "uid",
            "(u16 __user *)argp"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_UID",
          "args": [
            "uid",
            "from_kuid_munged(current_user_ns(), server->m.mounted_uid)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "server->m.mounted_uid"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_get_compat_fs_info_v2",
          "args": [
            "server",
            "inode",
            "argp"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_get_compat_fs_info_v2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
          "lines": "125-148",
          "snippet": "static int\nncp_get_compat_fs_info_v2(struct ncp_server * server, struct inode *inode,\n\t\t   struct compat_ncp_fs_info_v2 __user * arg)\n{\n\tstruct compat_ncp_fs_info_v2 info2;\n\n\tif (copy_from_user(&info2, arg, sizeof(info2)))\n\t\treturn -EFAULT;\n\n\tif (info2.version != NCP_GET_FS_INFO_VERSION_V2) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info2.version);\n\t\treturn -EINVAL;\n\t}\n\tinfo2.mounted_uid   = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\tinfo2.connection    = server->connection;\n\tinfo2.buffer_size   = server->buffer_size;\n\tinfo2.volume_number = NCP_FINFO(inode)->volNumber;\n\tinfo2.directory_id  = NCP_FINFO(inode)->DosDirNum;\n\tinfo2.dummy1 = info2.dummy2 = info2.dummy3 = 0;\n\n\tif (copy_to_user(arg, &info2, sizeof(info2)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_get_compat_fs_info_v2(struct ncp_server * server, struct inode *inode,\n\t\t   struct compat_ncp_fs_info_v2 __user * arg)\n{\n\tstruct compat_ncp_fs_info_v2 info2;\n\n\tif (copy_from_user(&info2, arg, sizeof(info2)))\n\t\treturn -EFAULT;\n\n\tif (info2.version != NCP_GET_FS_INFO_VERSION_V2) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info2.version);\n\t\treturn -EINVAL;\n\t}\n\tinfo2.mounted_uid   = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\tinfo2.connection    = server->connection;\n\tinfo2.buffer_size   = server->buffer_size;\n\tinfo2.volume_number = NCP_FINFO(inode)->volNumber;\n\tinfo2.directory_id  = NCP_FINFO(inode)->DosDirNum;\n\tinfo2.dummy1 = info2.dummy2 = info2.dummy3 = 0;\n\n\tif (copy_to_user(arg, &info2, sizeof(info2)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_get_fs_info_v2",
          "args": [
            "server",
            "inode",
            "argp"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_get_fs_info_v2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
          "lines": "59-82",
          "snippet": "static int\nncp_get_fs_info_v2(struct ncp_server * server, struct inode *inode,\n\t\t   struct ncp_fs_info_v2 __user * arg)\n{\n\tstruct ncp_fs_info_v2 info2;\n\n\tif (copy_from_user(&info2, arg, sizeof(info2)))\n\t\treturn -EFAULT;\n\n\tif (info2.version != NCP_GET_FS_INFO_VERSION_V2) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info2.version);\n\t\treturn -EINVAL;\n\t}\n\tinfo2.mounted_uid   = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\tinfo2.connection    = server->connection;\n\tinfo2.buffer_size   = server->buffer_size;\n\tinfo2.volume_number = NCP_FINFO(inode)->volNumber;\n\tinfo2.directory_id  = NCP_FINFO(inode)->DosDirNum;\n\tinfo2.dummy1 = info2.dummy2 = info2.dummy3 = 0;\n\n\tif (copy_to_user(arg, &info2, sizeof(info2)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highuid.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_get_fs_info_v2(struct ncp_server * server, struct inode *inode,\n\t\t   struct ncp_fs_info_v2 __user * arg)\n{\n\tstruct ncp_fs_info_v2 info2;\n\n\tif (copy_from_user(&info2, arg, sizeof(info2)))\n\t\treturn -EFAULT;\n\n\tif (info2.version != NCP_GET_FS_INFO_VERSION_V2) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info2.version);\n\t\treturn -EINVAL;\n\t}\n\tinfo2.mounted_uid   = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\tinfo2.connection    = server->connection;\n\tinfo2.buffer_size   = server->buffer_size;\n\tinfo2.volume_number = NCP_FINFO(inode)->volNumber;\n\tinfo2.directory_id  = NCP_FINFO(inode)->DosDirNum;\n\tinfo2.dummy1 = info2.dummy2 = info2.dummy3 = 0;\n\n\tif (copy_to_user(arg, &info2, sizeof(info2)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_conn_logged_in",
          "args": [
            "inode->i_sb"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_conn_logged_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "785-828",
          "snippet": "int ncp_conn_logged_in(struct super_block *sb)\n{\n\tstruct ncp_server* server = NCP_SBP(sb);\n\tint result;\n\n\tif (ncp_single_volume(server)) {\n\t\tint len;\n\t\tstruct dentry* dent;\n\t\t__u32 volNumber;\n\t\t__le32 dirEntNum;\n\t\t__le32 DosDirNum;\n\t\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\t\tlen = sizeof(__name);\n\t\tresult = ncp_io2vol(server, __name, &len, server->m.mounted_vol,\n\t\t\t\t    strlen(server->m.mounted_vol), 1);\n\t\tif (result)\n\t\t\tgoto out;\n\t\tresult = -ENOENT;\n\t\tif (ncp_get_volume_root(server, __name, &volNumber, &dirEntNum, &DosDirNum)) {\n\t\t\tncp_vdbg(\"%s not found\\n\", server->m.mounted_vol);\n\t\t\tgoto out;\n\t\t}\n\t\tdent = sb->s_root;\n\t\tif (dent) {\n\t\t\tstruct inode* ino = dent->d_inode;\n\t\t\tif (ino) {\n\t\t\t\tncp_update_known_namespace(server, volNumber, NULL);\n\t\t\t\tNCP_FINFO(ino)->volNumber = volNumber;\n\t\t\t\tNCP_FINFO(ino)->dirEntNum = dirEntNum;\n\t\t\t\tNCP_FINFO(ino)->DosDirNum = DosDirNum;\n\t\t\t\tresult = 0;\n\t\t\t} else {\n\t\t\t\tncp_dbg(1, \"sb->s_root->d_inode == NULL!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tncp_dbg(1, \"sb->s_root == NULL!\\n\");\n\t\t}\n\t} else\n\t\tresult = 0;\n\nout:\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nint ncp_conn_logged_in(struct super_block *sb)\n{\n\tstruct ncp_server* server = NCP_SBP(sb);\n\tint result;\n\n\tif (ncp_single_volume(server)) {\n\t\tint len;\n\t\tstruct dentry* dent;\n\t\t__u32 volNumber;\n\t\t__le32 dirEntNum;\n\t\t__le32 DosDirNum;\n\t\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\t\tlen = sizeof(__name);\n\t\tresult = ncp_io2vol(server, __name, &len, server->m.mounted_vol,\n\t\t\t\t    strlen(server->m.mounted_vol), 1);\n\t\tif (result)\n\t\t\tgoto out;\n\t\tresult = -ENOENT;\n\t\tif (ncp_get_volume_root(server, __name, &volNumber, &dirEntNum, &DosDirNum)) {\n\t\t\tncp_vdbg(\"%s not found\\n\", server->m.mounted_vol);\n\t\t\tgoto out;\n\t\t}\n\t\tdent = sb->s_root;\n\t\tif (dent) {\n\t\t\tstruct inode* ino = dent->d_inode;\n\t\t\tif (ino) {\n\t\t\t\tncp_update_known_namespace(server, volNumber, NULL);\n\t\t\t\tNCP_FINFO(ino)->volNumber = volNumber;\n\t\t\t\tNCP_FINFO(ino)->dirEntNum = dirEntNum;\n\t\t\t\tNCP_FINFO(ino)->DosDirNum = DosDirNum;\n\t\t\t\tresult = 0;\n\t\t\t} else {\n\t\t\t\tncp_dbg(1, \"sb->s_root->d_inode == NULL!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tncp_dbg(1, \"sb->s_root == NULL!\\n\");\n\t\t}\n\t} else\n\t\tresult = 0;\n\nout:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "bouncebuffer"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "request.data",
            "bouncebuffer",
            "result"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"copy %d bytes\\n\"",
            "result"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_request2",
          "args": [
            "server",
            "request.function",
            "bouncebuffer",
            "NCP_PACKET_SIZE_INTERNAL"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_request2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/sock.c",
          "lines": "794-829",
          "snippet": "int ncp_request2(struct ncp_server *server, int function, \n\t\tvoid* rpl, int size)\n{\n\tstruct ncp_request_header *h;\n\tstruct ncp_reply_header* reply = rpl;\n\tint result;\n\n\th = (struct ncp_request_header *) (server->packet);\n\tif (server->has_subfunction != 0) {\n\t\t*(__u16 *) & (h->data[0]) = htons(server->current_size - sizeof(*h) - 2);\n\t}\n\th->type = NCP_REQUEST;\n\t/*\n\t * The server shouldn't know or care what task is making a\n\t * request, so we always use the same task number.\n\t */\n\th->task = 2; /* (current->pid) & 0xff; */\n\th->function = function;\n\n\tresult = ncp_do_request(server, server->current_size, reply, size);\n\tif (result < 0) {\n\t\tncp_dbg(1, \"ncp_request_error: %d\\n\", result);\n\t\tgoto out;\n\t}\n\tserver->completion = reply->completion_code;\n\tserver->conn_status = reply->connection_state;\n\tserver->reply_size = result;\n\tserver->ncp_reply_size = result - sizeof(struct ncp_reply_header);\n\n\tresult = reply->completion_code;\n\n\tif (result != 0)\n\t\tncp_vdbg(\"completion code=%x\\n\", result);\nout:\n\treturn result;\n}",
          "includes": [
            "#include \"ncpsign_kernel.h\"",
            "#include \"ncp_fs.h\"",
            "#include <linux/file.h>",
            "#include <linux/poll.h>",
            "#include <linux/ipx.h>",
            "#include <net/sock.h>",
            "#include <net/scm.h>",
            "#include <linux/slab.h>",
            "#include <linux/signal.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/mm.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/socket.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncpsign_kernel.h\"\n#include \"ncp_fs.h\"\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/ipx.h>\n#include <net/sock.h>\n#include <net/scm.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/netdevice.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nint ncp_request2(struct ncp_server *server, int function, \n\t\tvoid* rpl, int size)\n{\n\tstruct ncp_request_header *h;\n\tstruct ncp_reply_header* reply = rpl;\n\tint result;\n\n\th = (struct ncp_request_header *) (server->packet);\n\tif (server->has_subfunction != 0) {\n\t\t*(__u16 *) & (h->data[0]) = htons(server->current_size - sizeof(*h) - 2);\n\t}\n\th->type = NCP_REQUEST;\n\t/*\n\t * The server shouldn't know or care what task is making a\n\t * request, so we always use the same task number.\n\t */\n\th->task = 2; /* (current->pid) & 0xff; */\n\th->function = function;\n\n\tresult = ncp_do_request(server, server->current_size, reply, size);\n\tif (result < 0) {\n\t\tncp_dbg(1, \"ncp_request_error: %d\\n\", result);\n\t\tgoto out;\n\t}\n\tserver->completion = reply->completion_code;\n\tserver->conn_status = reply->connection_state;\n\tserver->reply_size = result;\n\tserver->ncp_reply_size = result - sizeof(struct ncp_reply_header);\n\n\tresult = reply->completion_code;\n\n\tif (result != 0)\n\t\tncp_vdbg(\"completion code=%x\\n\", result);\nout:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server->packet",
            "bouncebuffer",
            "request.size"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "bouncebuffer"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "NCP_PACKET_SIZE_INTERNAL"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "request32.data"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\n#define NCP_IOC_GETMOUNTUID64\t\t_IOW('n', 2, u64)\n#define NCP_IOC_GETMOUNTUID32\t\t_IOW('n', 2, u32)\n#define NCP_IOC_GETMOUNTUID16\t\t_IOW('n', 2, u16)\n#define NCP_IOC_SETPRIVATEDATA_32\t_IOR('n', 10, struct compat_ncp_privatedata_ioctl)\n#define NCP_IOC_GETPRIVATEDATA_32\t_IOWR('n', 10, struct compat_ncp_privatedata_ioctl)\n#define NCP_IOC_SETOBJECTNAME_32\t_IOR('n', 9, struct compat_ncp_objectname_ioctl)\n#define NCP_IOC_GETOBJECTNAME_32\t_IOWR('n', 9, struct compat_ncp_objectname_ioctl)\n#define NCP_IOC_NCPREQUEST_32\t\t_IOR('n', 1, struct compat_ncp_ioctl_request)\n#define NCP_IOC_GET_FS_INFO_V2_32\t_IOWR('n', 4, struct compat_ncp_fs_info_v2)\n#define NCP_PACKET_SIZE_INTERNAL 65536\n#define NCP_PRIVATE_DATA_MAX_LEN 8192\n#define NCP_OBJECT_NAME_MAX_LEN\t4096\n\nstatic long __ncp_ioctl(struct inode *inode, unsigned int cmd, unsigned long arg)\n{\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tint result;\n\tstruct ncp_ioctl_request request;\n\tchar* bouncebuffer;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_NCPREQUEST_32:\n#endif\n\tcase NCP_IOC_NCPREQUEST:\n#ifdef CONFIG_COMPAT\n\t\tif (cmd == NCP_IOC_NCPREQUEST_32) {\n\t\t\tstruct compat_ncp_ioctl_request request32;\n\t\t\tif (copy_from_user(&request32, argp, sizeof(request32)))\n\t\t\t\treturn -EFAULT;\n\t\t\trequest.function = request32.function;\n\t\t\trequest.size = request32.size;\n\t\t\trequest.data = compat_ptr(request32.data);\n\t\t} else\n#endif\n\t\tif (copy_from_user(&request, argp, sizeof(request)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((request.function > 255)\n\t\t    || (request.size >\n\t\t  NCP_PACKET_SIZE - sizeof(struct ncp_request_header))) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbouncebuffer = vmalloc(NCP_PACKET_SIZE_INTERNAL);\n\t\tif (!bouncebuffer)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(bouncebuffer, request.data, request.size)) {\n\t\t\tvfree(bouncebuffer);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tncp_lock_server(server);\n\n\t\t/* FIXME: We hack around in the server's structures\n\t\t   here to be able to use ncp_request */\n\n\t\tserver->has_subfunction = 0;\n\t\tserver->current_size = request.size;\n\t\tmemcpy(server->packet, bouncebuffer, request.size);\n\n\t\tresult = ncp_request2(server, request.function,\n\t\t\tbouncebuffer, NCP_PACKET_SIZE_INTERNAL);\n\t\tif (result < 0)\n\t\t\tresult = -EIO;\n\t\telse\n\t\t\tresult = server->reply_size;\n\t\tncp_unlock_server(server);\n\t\tncp_dbg(1, \"copy %d bytes\\n\", result);\n\t\tif (result >= 0)\n\t\t\tif (copy_to_user(request.data, bouncebuffer, result))\n\t\t\t\tresult = -EFAULT;\n\t\tvfree(bouncebuffer);\n\t\treturn result;\n\n\tcase NCP_IOC_CONN_LOGGED_IN:\n\n\t\tif (!(server->m.int_flags & NCP_IMOUNT_LOGGEDIN_POSSIBLE))\n\t\t\treturn -EINVAL;\n\t\tmutex_lock(&server->root_setup_lock);\n\t\tif (server->root_setuped)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tresult = ncp_conn_logged_in(inode->i_sb);\n\t\t\tif (result == 0)\n\t\t\t\tserver->root_setuped = 1;\n\t\t}\n\t\tmutex_unlock(&server->root_setup_lock);\n\t\treturn result;\n\n\tcase NCP_IOC_GET_FS_INFO:\n\t\treturn ncp_get_fs_info(server, inode, argp);\n\n\tcase NCP_IOC_GET_FS_INFO_V2:\n\t\treturn ncp_get_fs_info_v2(server, inode, argp);\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GET_FS_INFO_V2_32:\n\t\treturn ncp_get_compat_fs_info_v2(server, inode, argp);\n#endif\n\t/* we have too many combinations of CONFIG_COMPAT,\n\t * CONFIG_64BIT and CONFIG_UID16, so just handle\n\t * any of the possible ioctls */\n\tcase NCP_IOC_GETMOUNTUID16:\n\t\t{\n\t\t\tu16 uid;\n\n\t\t\tSET_UID(uid, from_kuid_munged(current_user_ns(), server->m.mounted_uid));\n\t\t\tif (put_user(uid, (u16 __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\tcase NCP_IOC_GETMOUNTUID32:\n\t{\n\t\tuid_t uid = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\t\tif (put_user(uid, (u32 __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase NCP_IOC_GETMOUNTUID64:\n\t{\n\t\tuid_t uid = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\t\tif (put_user(uid, (u64 __user *)argp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase NCP_IOC_GETROOT:\n\t\t{\n\t\t\tstruct ncp_setroot_ioctl sr;\n\n\t\t\tresult = -EACCES;\n\t\t\tmutex_lock(&server->root_setup_lock);\n\t\t\tif (server->m.mounted_vol[0]) {\n\t\t\t\tstruct dentry* dentry = inode->i_sb->s_root;\n\n\t\t\t\tif (dentry) {\n\t\t\t\t\tstruct inode* s_inode = dentry->d_inode;\n\n\t\t\t\t\tif (s_inode) {\n\t\t\t\t\t\tsr.volNumber = NCP_FINFO(s_inode)->volNumber;\n\t\t\t\t\t\tsr.dirEntNum = NCP_FINFO(s_inode)->dirEntNum;\n\t\t\t\t\t\tsr.namespace = server->name_space[sr.volNumber];\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t\tncp_dbg(1, \"s_root->d_inode==NULL\\n\");\n\t\t\t\t} else\n\t\t\t\t\tncp_dbg(1, \"s_root==NULL\\n\");\n\t\t\t} else {\n\t\t\t\tsr.volNumber = -1;\n\t\t\t\tsr.namespace = 0;\n\t\t\t\tsr.dirEntNum = 0;\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&server->root_setup_lock);\n\t\t\tif (!result && copy_to_user(argp, &sr, sizeof(sr)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n\n\tcase NCP_IOC_SETROOT:\n\t\t{\n\t\t\tstruct ncp_setroot_ioctl sr;\n\t\t\t__u32 vnum;\n\t\t\t__le32 de;\n\t\t\t__le32 dosde;\n\t\t\tstruct dentry* dentry;\n\n\t\t\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\tmutex_lock(&server->root_setup_lock);\n\t\t\tif (server->root_setuped)\n\t\t\t\tresult = -EBUSY;\n\t\t\telse {\n\t\t\t\tif (sr.volNumber < 0) {\n\t\t\t\t\tserver->m.mounted_vol[0] = 0;\n\t\t\t\t\tvnum = NCP_NUMBER_OF_VOLUMES;\n\t\t\t\t\tde = 0;\n\t\t\t\t\tdosde = 0;\n\t\t\t\t\tresult = 0;\n\t\t\t\t} else if (sr.volNumber >= NCP_NUMBER_OF_VOLUMES) {\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\t} else if (ncp_mount_subdir(server, sr.volNumber,\n\t\t\t\t\t\t\tsr.namespace, sr.dirEntNum,\n\t\t\t\t\t\t\t&vnum, &de, &dosde)) {\n\t\t\t\t\tresult = -ENOENT;\n\t\t\t\t} else\n\t\t\t\t\tresult = 0;\n\n\t\t\t\tif (result == 0) {\n\t\t\t\t\tdentry = inode->i_sb->s_root;\n\t\t\t\t\tif (dentry) {\n\t\t\t\t\t\tstruct inode* s_inode = dentry->d_inode;\n\n\t\t\t\t\t\tif (s_inode) {\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->volNumber = vnum;\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->dirEntNum = de;\n\t\t\t\t\t\t\tNCP_FINFO(s_inode)->DosDirNum = dosde;\n\t\t\t\t\t\t\tserver->root_setuped = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tncp_dbg(1, \"s_root->d_inode==NULL\\n\");\n\t\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncp_dbg(1, \"s_root==NULL\\n\");\n\t\t\t\t\t\tresult = -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&server->root_setup_lock);\n\n\t\t\treturn result;\n\t\t}\n\n#ifdef CONFIG_NCPFS_PACKET_SIGNING\n\tcase NCP_IOC_SIGN_INIT:\n\t\t{\n\t\t\tstruct ncp_sign_init sign;\n\n\t\t\tif (argp)\n\t\t\t\tif (copy_from_user(&sign, argp, sizeof(sign)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\tncp_lock_server(server);\n\t\t\tmutex_lock(&server->rcv.creq_mutex);\n\t\t\tif (argp) {\n\t\t\t\tif (server->sign_wanted) {\n\t\t\t\t\tmemcpy(server->sign_root,sign.sign_root,8);\n\t\t\t\t\tmemcpy(server->sign_last,sign.sign_last,16);\n\t\t\t\t\tserver->sign_active = 1;\n\t\t\t\t}\n\t\t\t\t/* ignore when signatures not wanted */\n\t\t\t} else {\n\t\t\t\tserver->sign_active = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&server->rcv.creq_mutex);\n\t\t\tncp_unlock_server(server);\n\t\t\treturn 0;\n\t\t}\n\n        case NCP_IOC_SIGN_WANTED:\n\t\t{\n\t\t\tint state;\n\n\t\t\tncp_lock_server(server);\n\t\t\tstate = server->sign_wanted;\n\t\t\tncp_unlock_server(server);\n\t\t\tif (put_user(state, (int __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\tcase NCP_IOC_SET_SIGN_WANTED:\n\t\t{\n\t\t\tint newstate;\n\n\t\t\t/* get only low 8 bits... */\n\t\t\tif (get_user(newstate, (unsigned char __user *)argp))\n\t\t\t\treturn -EFAULT;\n\t\t\tresult = 0;\n\t\t\tncp_lock_server(server);\n\t\t\tif (server->sign_active) {\n\t\t\t\t/* cannot turn signatures OFF when active */\n\t\t\t\tif (!newstate)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t} else {\n\t\t\t\tserver->sign_wanted = newstate != 0;\n\t\t\t}\n\t\t\tncp_unlock_server(server);\n\t\t\treturn result;\n\t\t}\n\n#endif /* CONFIG_NCPFS_PACKET_SIGNING */\n\n#ifdef CONFIG_NCPFS_IOCTL_LOCKING\n\tcase NCP_IOC_LOCKUNLOCK:\n\t\t{\n\t\t\tstruct ncp_lock_ioctl\t rqdata;\n\n\t\t\tif (copy_from_user(&rqdata, argp, sizeof(rqdata)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rqdata.origin != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\t/* check for cmd */\n\t\t\tswitch (rqdata.cmd) {\n\t\t\t\tcase NCP_LOCK_EX:\n\t\t\t\tcase NCP_LOCK_SH:\n\t\t\t\t\t\tif (rqdata.timeout == 0)\n\t\t\t\t\t\t\trqdata.timeout = NCP_LOCK_DEFAULT_TIMEOUT;\n\t\t\t\t\t\telse if (rqdata.timeout > NCP_LOCK_MAX_TIMEOUT)\n\t\t\t\t\t\t\trqdata.timeout = NCP_LOCK_MAX_TIMEOUT;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase NCP_LOCK_LOG:\n\t\t\t\t\t\trqdata.timeout = NCP_LOCK_DEFAULT_TIMEOUT;\t/* has no effect */\n\t\t\t\tcase NCP_LOCK_CLEAR:\n\t\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* locking needs both read and write access */\n\t\t\tif ((result = ncp_make_open(inode, O_RDWR)) != 0)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = -EISDIR;\n\t\t\tif (!S_ISREG(inode->i_mode))\n\t\t\t\tgoto outrel;\n\t\t\tif (rqdata.cmd == NCP_LOCK_CLEAR)\n\t\t\t{\n\t\t\t\tresult = ncp_ClearPhysicalRecord(NCP_SERVER(inode),\n\t\t\t\t\t\t\tNCP_FINFO(inode)->file_handle,\n\t\t\t\t\t\t\trqdata.offset,\n\t\t\t\t\t\t\trqdata.length);\n\t\t\t\tif (result > 0) result = 0;\t/* no such lock */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lockcmd;\n\n\t\t\t\tswitch (rqdata.cmd)\n\t\t\t\t{\n\t\t\t\t\tcase NCP_LOCK_EX:  lockcmd=1; break;\n\t\t\t\t\tcase NCP_LOCK_SH:  lockcmd=3; break;\n\t\t\t\t\tdefault:\t   lockcmd=0; break;\n\t\t\t\t}\n\t\t\t\tresult = ncp_LogPhysicalRecord(NCP_SERVER(inode),\n\t\t\t\t\t\t\tNCP_FINFO(inode)->file_handle,\n\t\t\t\t\t\t\tlockcmd,\n\t\t\t\t\t\t\trqdata.offset,\n\t\t\t\t\t\t\trqdata.length,\n\t\t\t\t\t\t\trqdata.timeout);\n\t\t\t\tif (result > 0) result = -EAGAIN;\n\t\t\t}\noutrel:\n\t\t\tncp_inode_close(inode);\n\t\t\treturn result;\n\t\t}\n#endif\t/* CONFIG_NCPFS_IOCTL_LOCKING */\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GETOBJECTNAME_32:\n\t\t{\n\t\t\tstruct compat_ncp_objectname_ioctl user;\n\t\t\tsize_t outl;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\tuser.auth_type = server->auth.auth_type;\n\t\t\toutl = user.object_name_len;\n\t\t\tuser.object_name_len = server->auth.object_name_len;\n\t\t\tif (outl > user.object_name_len)\n\t\t\t\toutl = user.object_name_len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(compat_ptr(user.object_name),\n\t\t\t\t\t\t server->auth.object_name,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (!result && copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n#endif\n\n\tcase NCP_IOC_GETOBJECTNAME:\n\t\t{\n\t\t\tstruct ncp_objectname_ioctl user;\n\t\t\tsize_t outl;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\tuser.auth_type = server->auth.auth_type;\n\t\t\toutl = user.object_name_len;\n\t\t\tuser.object_name_len = server->auth.object_name_len;\n\t\t\tif (outl > user.object_name_len)\n\t\t\t\toutl = user.object_name_len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(user.object_name,\n\t\t\t\t\t\t server->auth.object_name,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (!result && copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\tresult = -EFAULT;\n\t\t\treturn result;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_SETOBJECTNAME_32:\n#endif\n\tcase NCP_IOC_SETOBJECTNAME:\n\t\t{\n\t\t\tstruct ncp_objectname_ioctl user;\n\t\t\tvoid* newname;\n\t\t\tvoid* oldname;\n\t\t\tsize_t oldnamelen;\n\t\t\tvoid* oldprivate;\n\t\t\tsize_t oldprivatelen;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_SETOBJECTNAME_32) {\n\t\t\t\tstruct compat_ncp_objectname_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.auth_type = user32.auth_type;\n\t\t\t\tuser.object_name_len = user32.object_name_len;\n\t\t\t\tuser.object_name = compat_ptr(user32.object_name);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (user.object_name_len > NCP_OBJECT_NAME_MAX_LEN)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (user.object_name_len) {\n\t\t\t\tnewname = memdup_user(user.object_name,\n\t\t\t\t\t\t      user.object_name_len);\n\t\t\t\tif (IS_ERR(newname))\n\t\t\t\t\treturn PTR_ERR(newname);\n\t\t\t} else {\n\t\t\t\tnewname = NULL;\n\t\t\t}\n\t\t\tdown_write(&server->auth_rwsem);\n\t\t\toldname = server->auth.object_name;\n\t\t\toldnamelen = server->auth.object_name_len;\n\t\t\toldprivate = server->priv.data;\n\t\t\toldprivatelen = server->priv.len;\n\t\t\tserver->auth.auth_type = user.auth_type;\n\t\t\tserver->auth.object_name_len = user.object_name_len;\n\t\t\tserver->auth.object_name = newname;\n\t\t\tserver->priv.len = 0;\n\t\t\tserver->priv.data = NULL;\n\t\t\tup_write(&server->auth_rwsem);\n\t\t\tkfree(oldprivate);\n\t\t\tkfree(oldname);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_GETPRIVATEDATA_32:\n#endif\n\tcase NCP_IOC_GETPRIVATEDATA:\n\t\t{\n\t\t\tstruct ncp_privatedata_ioctl user;\n\t\t\tsize_t outl;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_GETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.len = user32.len;\n\t\t\t\tuser.data = compat_ptr(user32.data);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tdown_read(&server->auth_rwsem);\n\t\t\toutl = user.len;\n\t\t\tuser.len = server->priv.len;\n\t\t\tif (outl > user.len) outl = user.len;\n\t\t\tresult = 0;\n\t\t\tif (outl) {\n\t\t\t\tif (copy_to_user(user.data,\n\t\t\t\t\t\t server->priv.data,\n\t\t\t\t\t\t outl))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t}\n\t\t\tup_read(&server->auth_rwsem);\n\t\t\tif (result)\n\t\t\t\treturn result;\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_GETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tuser32.len = user.len;\n\t\t\t\tuser32.data = (unsigned long) user.data;\n\t\t\t\tif (copy_to_user(argp, &user32, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n#endif\n\t\t\tif (copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_COMPAT\n\tcase NCP_IOC_SETPRIVATEDATA_32:\n#endif\n\tcase NCP_IOC_SETPRIVATEDATA:\n\t\t{\n\t\t\tstruct ncp_privatedata_ioctl user;\n\t\t\tvoid* new;\n\t\t\tvoid* old;\n\t\t\tsize_t oldlen;\n\n#ifdef CONFIG_COMPAT\n\t\t\tif (cmd == NCP_IOC_SETPRIVATEDATA_32) {\n\t\t\t\tstruct compat_ncp_privatedata_ioctl user32;\n\t\t\t\tif (copy_from_user(&user32, argp, sizeof(user32)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tuser.len = user32.len;\n\t\t\t\tuser.data = compat_ptr(user32.data);\n\t\t\t} else\n#endif\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (user.len > NCP_PRIVATE_DATA_MAX_LEN)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (user.len) {\n\t\t\t\tnew = memdup_user(user.data, user.len);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\treturn PTR_ERR(new);\n\t\t\t} else {\n\t\t\t\tnew = NULL;\n\t\t\t}\n\t\t\tdown_write(&server->auth_rwsem);\n\t\t\told = server->priv.data;\n\t\t\toldlen = server->priv.len;\n\t\t\tserver->priv.len = user.len;\n\t\t\tserver->priv.data = new;\n\t\t\tup_write(&server->auth_rwsem);\n\t\t\tkfree(old);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef CONFIG_NCPFS_NLS\n\tcase NCP_IOC_SETCHARSETS:\n\t\treturn ncp_set_charsets(server, argp);\n\n\tcase NCP_IOC_GETCHARSETS:\n\t\treturn ncp_get_charsets(server, argp);\n\n#endif /* CONFIG_NCPFS_NLS */\n\n\tcase NCP_IOC_SETDENTRYTTL:\n\t\t{\n\t\t\tu_int32_t user;\n\n\t\t\tif (copy_from_user(&user, argp, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* 20 secs at most... */\n\t\t\tif (user > 20000)\n\t\t\t\treturn -EINVAL;\n\t\t\tuser = (user * HZ) / 1000;\n\t\t\tatomic_set(&server->dentry_ttl, user);\n\t\t\treturn 0;\n\t\t}\n\n\tcase NCP_IOC_GETDENTRYTTL:\n\t\t{\n\t\t\tu_int32_t user = (atomic_read(&server->dentry_ttl) * 1000) / HZ;\n\t\t\tif (copy_to_user(argp, &user, sizeof(user)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "ncp_get_charsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
    "lines": "224-254",
    "snippet": "static int\nncp_get_charsets(struct ncp_server* server, struct ncp_nls_ioctl __user *arg)\n{\n\tstruct ncp_nls_ioctl user;\n\tint len;\n\n\tmemset(&user, 0, sizeof(user));\n\tmutex_lock(&server->root_setup_lock);\n\tif (server->nls_vol && server->nls_vol->charset) {\n\t\tlen = strlen(server->nls_vol->charset);\n\t\tif (len > NCP_IOCSNAME_LEN)\n\t\t\tlen = NCP_IOCSNAME_LEN;\n\t\tstrncpy(user.codepage, server->nls_vol->charset, len);\n\t\tuser.codepage[len] = 0;\n\t}\n\n\tif (NCP_IS_FLAG(server, NCP_FLAG_UTF8))\n\t\tstrcpy(user.iocharset, \"utf8\");\n\telse if (server->nls_io && server->nls_io->charset) {\n\t\tlen = strlen(server->nls_io->charset);\n\t\tif (len > NCP_IOCSNAME_LEN)\n\t\t\tlen = NCP_IOCSNAME_LEN;\n\t\tstrncpy(user.iocharset,\tserver->nls_io->charset, len);\n\t\tuser.iocharset[len] = 0;\n\t}\n\tmutex_unlock(&server->root_setup_lock);\n\n\tif (copy_to_user(arg, &user, sizeof(user)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&user",
            "sizeof(user)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "user.iocharset",
            "server->nls_io->charset",
            "len"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "server->nls_io->charset"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "user.iocharset",
            "\"utf8\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_IS_FLAG",
          "args": [
            "server",
            "NCP_FLAG_UTF8"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "user.codepage",
            "server->nls_vol->charset",
            "len"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&user",
            "0",
            "sizeof(user)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_get_charsets(struct ncp_server* server, struct ncp_nls_ioctl __user *arg)\n{\n\tstruct ncp_nls_ioctl user;\n\tint len;\n\n\tmemset(&user, 0, sizeof(user));\n\tmutex_lock(&server->root_setup_lock);\n\tif (server->nls_vol && server->nls_vol->charset) {\n\t\tlen = strlen(server->nls_vol->charset);\n\t\tif (len > NCP_IOCSNAME_LEN)\n\t\t\tlen = NCP_IOCSNAME_LEN;\n\t\tstrncpy(user.codepage, server->nls_vol->charset, len);\n\t\tuser.codepage[len] = 0;\n\t}\n\n\tif (NCP_IS_FLAG(server, NCP_FLAG_UTF8))\n\t\tstrcpy(user.iocharset, \"utf8\");\n\telse if (server->nls_io && server->nls_io->charset) {\n\t\tlen = strlen(server->nls_io->charset);\n\t\tif (len > NCP_IOCSNAME_LEN)\n\t\t\tlen = NCP_IOCSNAME_LEN;\n\t\tstrncpy(user.iocharset,\tserver->nls_io->charset, len);\n\t\tuser.iocharset[len] = 0;\n\t}\n\tmutex_unlock(&server->root_setup_lock);\n\n\tif (copy_to_user(arg, &user, sizeof(user)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_set_charsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
    "lines": "159-222",
    "snippet": "static int\nncp_set_charsets(struct ncp_server* server, struct ncp_nls_ioctl __user *arg)\n{\n\tstruct ncp_nls_ioctl user;\n\tstruct nls_table *codepage;\n\tstruct nls_table *iocharset;\n\tstruct nls_table *oldset_io;\n\tstruct nls_table *oldset_cp;\n\tint utf8;\n\tint err;\n\n\tif (copy_from_user(&user, arg, sizeof(user)))\n\t\treturn -EFAULT;\n\n\tcodepage = NULL;\n\tuser.codepage[NCP_IOCSNAME_LEN] = 0;\n\tif (!user.codepage[0] || !strcmp(user.codepage, \"default\"))\n\t\tcodepage = load_nls_default();\n\telse {\n\t\tcodepage = load_nls(user.codepage);\n\t\tif (!codepage) {\n\t\t\treturn -EBADRQC;\n\t\t}\n\t}\n\n\tiocharset = NULL;\n\tuser.iocharset[NCP_IOCSNAME_LEN] = 0;\n\tif (!user.iocharset[0] || !strcmp(user.iocharset, \"default\")) {\n\t\tiocharset = load_nls_default();\n\t\tutf8 = 0;\n\t} else if (!strcmp(user.iocharset, \"utf8\")) {\n\t\tiocharset = load_nls_default();\n\t\tutf8 = 1;\n\t} else {\n\t\tiocharset = load_nls(user.iocharset);\n\t\tif (!iocharset) {\n\t\t\tunload_nls(codepage);\n\t\t\treturn -EBADRQC;\n\t\t}\n\t\tutf8 = 0;\n\t}\n\n\tmutex_lock(&server->root_setup_lock);\n\tif (server->root_setuped) {\n\t\toldset_cp = codepage;\n\t\toldset_io = iocharset;\n\t\terr = -EBUSY;\n\t} else {\n\t\tif (utf8)\n\t\t\tNCP_SET_FLAG(server, NCP_FLAG_UTF8);\n\t\telse\n\t\t\tNCP_CLR_FLAG(server, NCP_FLAG_UTF8);\n\t\toldset_cp = server->nls_vol;\n\t\tserver->nls_vol = codepage;\n\t\toldset_io = server->nls_io;\n\t\tserver->nls_io = iocharset;\n\t\terr = 0;\n\t}\n\tmutex_unlock(&server->root_setup_lock);\n\tunload_nls(oldset_cp);\n\tunload_nls(oldset_io);\n\n\treturn err;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "oldset_io"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_CLR_FLAG",
          "args": [
            "server",
            "NCP_FLAG_UTF8"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SET_FLAG",
          "args": [
            "server",
            "NCP_FLAG_UTF8"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->root_setup_lock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_nls_default",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "load_nls_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "532-541",
          "snippet": "struct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nls_table default_table;",
            "static struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct nls_table default_table;\nstatic struct nls_table default_table = {\n\t.charset\t= \"default\",\n\t.uni2char\t= uni2char,\n\t.char2uni\t= char2uni,\n\t.charset2lower\t= charset2lower,\n\t.charset2upper\t= charset2upper,\n};\n\nstruct nls_table *load_nls_default(void)\n{\n\tstruct nls_table *default_nls;\n\t\n\tdefault_nls = load_nls(CONFIG_NLS_DEFAULT);\n\tif (default_nls != NULL)\n\t\treturn default_nls;\n\telse\n\t\treturn &default_table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user.iocharset",
            "\"utf8\""
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&user",
            "arg",
            "sizeof(user)"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_set_charsets(struct ncp_server* server, struct ncp_nls_ioctl __user *arg)\n{\n\tstruct ncp_nls_ioctl user;\n\tstruct nls_table *codepage;\n\tstruct nls_table *iocharset;\n\tstruct nls_table *oldset_io;\n\tstruct nls_table *oldset_cp;\n\tint utf8;\n\tint err;\n\n\tif (copy_from_user(&user, arg, sizeof(user)))\n\t\treturn -EFAULT;\n\n\tcodepage = NULL;\n\tuser.codepage[NCP_IOCSNAME_LEN] = 0;\n\tif (!user.codepage[0] || !strcmp(user.codepage, \"default\"))\n\t\tcodepage = load_nls_default();\n\telse {\n\t\tcodepage = load_nls(user.codepage);\n\t\tif (!codepage) {\n\t\t\treturn -EBADRQC;\n\t\t}\n\t}\n\n\tiocharset = NULL;\n\tuser.iocharset[NCP_IOCSNAME_LEN] = 0;\n\tif (!user.iocharset[0] || !strcmp(user.iocharset, \"default\")) {\n\t\tiocharset = load_nls_default();\n\t\tutf8 = 0;\n\t} else if (!strcmp(user.iocharset, \"utf8\")) {\n\t\tiocharset = load_nls_default();\n\t\tutf8 = 1;\n\t} else {\n\t\tiocharset = load_nls(user.iocharset);\n\t\tif (!iocharset) {\n\t\t\tunload_nls(codepage);\n\t\t\treturn -EBADRQC;\n\t\t}\n\t\tutf8 = 0;\n\t}\n\n\tmutex_lock(&server->root_setup_lock);\n\tif (server->root_setuped) {\n\t\toldset_cp = codepage;\n\t\toldset_io = iocharset;\n\t\terr = -EBUSY;\n\t} else {\n\t\tif (utf8)\n\t\t\tNCP_SET_FLAG(server, NCP_FLAG_UTF8);\n\t\telse\n\t\t\tNCP_CLR_FLAG(server, NCP_FLAG_UTF8);\n\t\toldset_cp = server->nls_vol;\n\t\tserver->nls_vol = codepage;\n\t\toldset_io = server->nls_io;\n\t\tserver->nls_io = iocharset;\n\t\terr = 0;\n\t}\n\tmutex_unlock(&server->root_setup_lock);\n\tunload_nls(oldset_cp);\n\tunload_nls(oldset_io);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ncp_get_compat_fs_info_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
    "lines": "125-148",
    "snippet": "static int\nncp_get_compat_fs_info_v2(struct ncp_server * server, struct inode *inode,\n\t\t   struct compat_ncp_fs_info_v2 __user * arg)\n{\n\tstruct compat_ncp_fs_info_v2 info2;\n\n\tif (copy_from_user(&info2, arg, sizeof(info2)))\n\t\treturn -EFAULT;\n\n\tif (info2.version != NCP_GET_FS_INFO_VERSION_V2) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info2.version);\n\t\treturn -EINVAL;\n\t}\n\tinfo2.mounted_uid   = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\tinfo2.connection    = server->connection;\n\tinfo2.buffer_size   = server->buffer_size;\n\tinfo2.volume_number = NCP_FINFO(inode)->volNumber;\n\tinfo2.directory_id  = NCP_FINFO(inode)->DosDirNum;\n\tinfo2.dummy1 = info2.dummy2 = info2.dummy3 = 0;\n\n\tif (copy_to_user(arg, &info2, sizeof(info2)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&info2",
            "sizeof(info2)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "server->m.mounted_uid"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"info.version invalid: %d\\n\"",
            "info2.version"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info2",
            "arg",
            "sizeof(info2)"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_get_compat_fs_info_v2(struct ncp_server * server, struct inode *inode,\n\t\t   struct compat_ncp_fs_info_v2 __user * arg)\n{\n\tstruct compat_ncp_fs_info_v2 info2;\n\n\tif (copy_from_user(&info2, arg, sizeof(info2)))\n\t\treturn -EFAULT;\n\n\tif (info2.version != NCP_GET_FS_INFO_VERSION_V2) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info2.version);\n\t\treturn -EINVAL;\n\t}\n\tinfo2.mounted_uid   = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\tinfo2.connection    = server->connection;\n\tinfo2.buffer_size   = server->buffer_size;\n\tinfo2.volume_number = NCP_FINFO(inode)->volNumber;\n\tinfo2.directory_id  = NCP_FINFO(inode)->DosDirNum;\n\tinfo2.dummy1 = info2.dummy2 = info2.dummy3 = 0;\n\n\tif (copy_to_user(arg, &info2, sizeof(info2)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_get_fs_info_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
    "lines": "59-82",
    "snippet": "static int\nncp_get_fs_info_v2(struct ncp_server * server, struct inode *inode,\n\t\t   struct ncp_fs_info_v2 __user * arg)\n{\n\tstruct ncp_fs_info_v2 info2;\n\n\tif (copy_from_user(&info2, arg, sizeof(info2)))\n\t\treturn -EFAULT;\n\n\tif (info2.version != NCP_GET_FS_INFO_VERSION_V2) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info2.version);\n\t\treturn -EINVAL;\n\t}\n\tinfo2.mounted_uid   = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\tinfo2.connection    = server->connection;\n\tinfo2.buffer_size   = server->buffer_size;\n\tinfo2.volume_number = NCP_FINFO(inode)->volNumber;\n\tinfo2.directory_id  = NCP_FINFO(inode)->DosDirNum;\n\tinfo2.dummy1 = info2.dummy2 = info2.dummy3 = 0;\n\n\tif (copy_to_user(arg, &info2, sizeof(info2)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&info2",
            "sizeof(info2)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "server->m.mounted_uid"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"info.version invalid: %d\\n\"",
            "info2.version"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info2",
            "arg",
            "sizeof(info2)"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_get_fs_info_v2(struct ncp_server * server, struct inode *inode,\n\t\t   struct ncp_fs_info_v2 __user * arg)\n{\n\tstruct ncp_fs_info_v2 info2;\n\n\tif (copy_from_user(&info2, arg, sizeof(info2)))\n\t\treturn -EFAULT;\n\n\tif (info2.version != NCP_GET_FS_INFO_VERSION_V2) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info2.version);\n\t\treturn -EINVAL;\n\t}\n\tinfo2.mounted_uid   = from_kuid_munged(current_user_ns(), server->m.mounted_uid);\n\tinfo2.connection    = server->connection;\n\tinfo2.buffer_size   = server->buffer_size;\n\tinfo2.volume_number = NCP_FINFO(inode)->volNumber;\n\tinfo2.directory_id  = NCP_FINFO(inode)->DosDirNum;\n\tinfo2.dummy1 = info2.dummy2 = info2.dummy3 = 0;\n\n\tif (copy_to_user(arg, &info2, sizeof(info2)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_get_fs_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ioctl.c",
    "lines": "34-57",
    "snippet": "static int\nncp_get_fs_info(struct ncp_server * server, struct inode *inode,\n\t\tstruct ncp_fs_info __user *arg)\n{\n\tstruct ncp_fs_info info;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.version != NCP_GET_FS_INFO_VERSION) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info.version);\n\t\treturn -EINVAL;\n\t}\n\t/* TODO: info.addr = server->m.serv_addr; */\n\tSET_UID(info.mounted_uid, from_kuid_munged(current_user_ns(), server->m.mounted_uid));\n\tinfo.connection\t\t= server->connection;\n\tinfo.buffer_size\t= server->buffer_size;\n\tinfo.volume_number\t= NCP_FINFO(inode)->volNumber;\n\tinfo.directory_id\t= NCP_FINFO(inode)->DosDirNum;\n\n\tif (copy_to_user(arg, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/highuid.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&info",
            "sizeof(info)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_UID",
          "args": [
            "info.mounted_uid",
            "from_kuid_munged(current_user_ns(), server->m.mounted_uid)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "server->m.mounted_uid"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"info.version invalid: %d\\n\"",
            "info.version"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info",
            "arg",
            "sizeof(info)"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/highuid.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/capability.h>\n\nstatic int\nncp_get_fs_info(struct ncp_server * server, struct inode *inode,\n\t\tstruct ncp_fs_info __user *arg)\n{\n\tstruct ncp_fs_info info;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.version != NCP_GET_FS_INFO_VERSION) {\n\t\tncp_dbg(1, \"info.version invalid: %d\\n\", info.version);\n\t\treturn -EINVAL;\n\t}\n\t/* TODO: info.addr = server->m.serv_addr; */\n\tSET_UID(info.mounted_uid, from_kuid_munged(current_user_ns(), server->m.mounted_uid));\n\tinfo.connection\t\t= server->connection;\n\tinfo.buffer_size\t= server->buffer_size;\n\tinfo.volume_number\t= NCP_FINFO(inode)->volNumber;\n\tinfo.directory_id\t= NCP_FINFO(inode)->DosDirNum;\n\n\tif (copy_to_user(arg, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  }
]