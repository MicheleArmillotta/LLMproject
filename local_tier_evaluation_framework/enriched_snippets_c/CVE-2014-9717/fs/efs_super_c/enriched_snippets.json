[
  {
    "function_name": "efs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "332-352",
    "snippet": "static int efs_statfs(struct dentry *dentry, struct kstatfs *buf) {\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct efs_sb_info *sbi = SUPER_INFO(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = EFS_SUPER_MAGIC;\t/* efs magic number */\n\tbuf->f_bsize   = EFS_BLOCKSIZE;\t\t/* blocksize */\n\tbuf->f_blocks  = sbi->total_groups *\t/* total data blocks */\n\t\t\t(sbi->group_size - sbi->inode_blocks);\n\tbuf->f_bfree   = sbi->data_free;\t/* free data blocks */\n\tbuf->f_bavail  = sbi->data_free;\t/* free blocks for non-root */\n\tbuf->f_files   = sbi->total_groups *\t/* total inodes */\n\t\t\tsbi->inode_blocks *\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\tbuf->f_ffree   = sbi->inode_free;\t/* free inodes */\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = EFS_MAXNAMELEN;\t/* max filename length */\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int efs_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SUPER_INFO",
          "args": [
            "sb"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "SUPER_INFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/efs.h",
          "lines": "122-125",
          "snippet": "static inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n\nstatic inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int efs_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int efs_statfs(struct dentry *dentry, struct kstatfs *buf) {\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct efs_sb_info *sbi = SUPER_INFO(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = EFS_SUPER_MAGIC;\t/* efs magic number */\n\tbuf->f_bsize   = EFS_BLOCKSIZE;\t\t/* blocksize */\n\tbuf->f_blocks  = sbi->total_groups *\t/* total data blocks */\n\t\t\t(sbi->group_size - sbi->inode_blocks);\n\tbuf->f_bfree   = sbi->data_free;\t/* free data blocks */\n\tbuf->f_bavail  = sbi->data_free;\t/* free blocks for non-root */\n\tbuf->f_files   = sbi->total_groups *\t/* total inodes */\n\t\t\tsbi->inode_blocks *\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\tbuf->f_ffree   = sbi->inode_free;\t/* free inodes */\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = EFS_MAXNAMELEN;\t/* max filename length */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "efs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "255-330",
    "snippet": "static int efs_fill_super(struct super_block *s, void *d, int silent)\n{\n\tstruct efs_sb_info *sb;\n\tstruct buffer_head *bh;\n\tstruct inode *root;\n\n \tsb = kzalloc(sizeof(struct efs_sb_info), GFP_KERNEL);\n\tif (!sb)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sb;\n \n\ts->s_magic\t\t= EFS_SUPER_MAGIC;\n\tif (!sb_set_blocksize(s, EFS_BLOCKSIZE)) {\n\t\tpr_err(\"device does not support %d byte blocks\\n\",\n\t\t\tEFS_BLOCKSIZE);\n\t\treturn -EINVAL;\n\t}\n  \n\t/* read the vh (volume header) block */\n\tbh = sb_bread(s, 0);\n\n\tif (!bh) {\n\t\tpr_err(\"cannot read volume header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * if this returns zero then we didn't find any partition table.\n\t * this isn't (yet) an error - just assume for the moment that\n\t * the device is valid and go on to search for a superblock.\n\t */\n\tsb->fs_start = efs_validate_vh((struct volume_header *) bh->b_data);\n\tbrelse(bh);\n\n\tif (sb->fs_start == -1) {\n\t\treturn -EINVAL;\n\t}\n\n\tbh = sb_bread(s, sb->fs_start + EFS_SUPER);\n\tif (!bh) {\n\t\tpr_err(\"cannot read superblock\\n\");\n\t\treturn -EINVAL;\n\t}\n\t\t\n\tif (efs_validate_super(sb, (struct efs_super *) bh->b_data)) {\n#ifdef DEBUG\n\t\tpr_warn(\"invalid superblock at block %u\\n\",\n\t\t\tsb->fs_start + EFS_SUPER);\n#endif\n\t\tbrelse(bh);\n\t\treturn -EINVAL;\n\t}\n\tbrelse(bh);\n\n\tif (!(s->s_flags & MS_RDONLY)) {\n#ifdef DEBUG\n\t\tpr_info(\"forcing read-only mode\\n\");\n#endif\n\t\ts->s_flags |= MS_RDONLY;\n\t}\n\ts->s_op   = &efs_superblock_operations;\n\ts->s_export_op = &efs_export_ops;\n\troot = efs_iget(s, EFS_ROOTINODE);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"get root inode failed\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\ts->s_root = d_make_root(root);\n\tif (!(s->s_root)) {\n\t\tpr_err(\"get root dentry failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int efs_fill_super(struct super_block *s, void *d, int silent);",
      "static const struct super_operations efs_superblock_operations = {\n\t.alloc_inode\t= efs_alloc_inode,\n\t.destroy_inode\t= efs_destroy_inode,\n\t.statfs\t\t= efs_statfs,\n\t.remount_fs\t= efs_remount,\n};",
      "static const struct export_operations efs_export_ops = {\n\t.fh_to_dentry\t= efs_fh_to_dentry,\n\t.fh_to_parent\t= efs_fh_to_parent,\n\t.get_parent\t= efs_get_parent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"get root dentry failed\\n\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"get root inode failed\\n\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efs_iget",
          "args": [
            "s",
            "EFS_ROOTINODE"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "efs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "47-174",
          "snippet": "struct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};\n\nstruct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"forcing read-only mode\\n\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"invalid superblock at block %u\\n\"",
            "sb->fs_start + EFS_SUPER"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efs_validate_super",
          "args": [
            "sb",
            "(struct efs_super *) bh->b_data"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "efs_validate_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
          "lines": "238-253",
          "snippet": "static int efs_validate_super(struct efs_sb_info *sb, struct efs_super *super) {\n\n\tif (!IS_EFS_MAGIC(be32_to_cpu(super->fs_magic)))\n\t\treturn -1;\n\n\tsb->fs_magic     = be32_to_cpu(super->fs_magic);\n\tsb->total_blocks = be32_to_cpu(super->fs_size);\n\tsb->first_block  = be32_to_cpu(super->fs_firstcg);\n\tsb->group_size   = be32_to_cpu(super->fs_cgfsize);\n\tsb->data_free    = be32_to_cpu(super->fs_tfree);\n\tsb->inode_free   = be32_to_cpu(super->fs_tinode);\n\tsb->inode_blocks = be16_to_cpu(super->fs_cgisize);\n\tsb->total_groups = be16_to_cpu(super->fs_ncg);\n    \n\treturn 0;    \n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <linux/efs_vh.h>",
            "#include \"efs.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int efs_validate_super(struct efs_sb_info *sb, struct efs_super *super) {\n\n\tif (!IS_EFS_MAGIC(be32_to_cpu(super->fs_magic)))\n\t\treturn -1;\n\n\tsb->fs_magic     = be32_to_cpu(super->fs_magic);\n\tsb->total_blocks = be32_to_cpu(super->fs_size);\n\tsb->first_block  = be32_to_cpu(super->fs_firstcg);\n\tsb->group_size   = be32_to_cpu(super->fs_cgfsize);\n\tsb->data_free    = be32_to_cpu(super->fs_tfree);\n\tsb->inode_free   = be32_to_cpu(super->fs_tinode);\n\tsb->inode_blocks = be16_to_cpu(super->fs_cgisize);\n\tsb->total_groups = be16_to_cpu(super->fs_ncg);\n    \n\treturn 0;    \n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cannot read superblock\\n\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "sb->fs_start + EFS_SUPER"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efs_validate_vh",
          "args": [
            "(struct volume_header *) bh->b_data"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cannot read volume header\\n\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "0"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"device does not support %d byte blocks\\n\"",
            "EFS_BLOCKSIZE"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "EFS_BLOCKSIZE"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct efs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int efs_fill_super(struct super_block *s, void *d, int silent);\nstatic const struct super_operations efs_superblock_operations = {\n\t.alloc_inode\t= efs_alloc_inode,\n\t.destroy_inode\t= efs_destroy_inode,\n\t.statfs\t\t= efs_statfs,\n\t.remount_fs\t= efs_remount,\n};\nstatic const struct export_operations efs_export_ops = {\n\t.fh_to_dentry\t= efs_fh_to_dentry,\n\t.fh_to_parent\t= efs_fh_to_parent,\n\t.get_parent\t= efs_get_parent,\n};\n\nstatic int efs_fill_super(struct super_block *s, void *d, int silent)\n{\n\tstruct efs_sb_info *sb;\n\tstruct buffer_head *bh;\n\tstruct inode *root;\n\n \tsb = kzalloc(sizeof(struct efs_sb_info), GFP_KERNEL);\n\tif (!sb)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sb;\n \n\ts->s_magic\t\t= EFS_SUPER_MAGIC;\n\tif (!sb_set_blocksize(s, EFS_BLOCKSIZE)) {\n\t\tpr_err(\"device does not support %d byte blocks\\n\",\n\t\t\tEFS_BLOCKSIZE);\n\t\treturn -EINVAL;\n\t}\n  \n\t/* read the vh (volume header) block */\n\tbh = sb_bread(s, 0);\n\n\tif (!bh) {\n\t\tpr_err(\"cannot read volume header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * if this returns zero then we didn't find any partition table.\n\t * this isn't (yet) an error - just assume for the moment that\n\t * the device is valid and go on to search for a superblock.\n\t */\n\tsb->fs_start = efs_validate_vh((struct volume_header *) bh->b_data);\n\tbrelse(bh);\n\n\tif (sb->fs_start == -1) {\n\t\treturn -EINVAL;\n\t}\n\n\tbh = sb_bread(s, sb->fs_start + EFS_SUPER);\n\tif (!bh) {\n\t\tpr_err(\"cannot read superblock\\n\");\n\t\treturn -EINVAL;\n\t}\n\t\t\n\tif (efs_validate_super(sb, (struct efs_super *) bh->b_data)) {\n#ifdef DEBUG\n\t\tpr_warn(\"invalid superblock at block %u\\n\",\n\t\t\tsb->fs_start + EFS_SUPER);\n#endif\n\t\tbrelse(bh);\n\t\treturn -EINVAL;\n\t}\n\tbrelse(bh);\n\n\tif (!(s->s_flags & MS_RDONLY)) {\n#ifdef DEBUG\n\t\tpr_info(\"forcing read-only mode\\n\");\n#endif\n\t\ts->s_flags |= MS_RDONLY;\n\t}\n\ts->s_op   = &efs_superblock_operations;\n\ts->s_export_op = &efs_export_ops;\n\troot = efs_iget(s, EFS_ROOTINODE);\n\tif (IS_ERR(root)) {\n\t\tpr_err(\"get root inode failed\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\ts->s_root = d_make_root(root);\n\tif (!(s->s_root)) {\n\t\tpr_err(\"get root dentry failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "efs_validate_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "238-253",
    "snippet": "static int efs_validate_super(struct efs_sb_info *sb, struct efs_super *super) {\n\n\tif (!IS_EFS_MAGIC(be32_to_cpu(super->fs_magic)))\n\t\treturn -1;\n\n\tsb->fs_magic     = be32_to_cpu(super->fs_magic);\n\tsb->total_blocks = be32_to_cpu(super->fs_size);\n\tsb->first_block  = be32_to_cpu(super->fs_firstcg);\n\tsb->group_size   = be32_to_cpu(super->fs_cgfsize);\n\tsb->data_free    = be32_to_cpu(super->fs_tfree);\n\tsb->inode_free   = be32_to_cpu(super->fs_tinode);\n\tsb->inode_blocks = be16_to_cpu(super->fs_cgisize);\n\tsb->total_groups = be16_to_cpu(super->fs_ncg);\n    \n\treturn 0;    \n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "super->fs_ncg"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "super->fs_cgisize"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "super->fs_tinode"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "super->fs_tfree"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "super->fs_cgfsize"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "super->fs_firstcg"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "super->fs_size"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "super->fs_magic"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_EFS_MAGIC",
          "args": [
            "be32_to_cpu(super->fs_magic)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "super->fs_magic"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int efs_validate_super(struct efs_sb_info *sb, struct efs_super *super) {\n\n\tif (!IS_EFS_MAGIC(be32_to_cpu(super->fs_magic)))\n\t\treturn -1;\n\n\tsb->fs_magic     = be32_to_cpu(super->fs_magic);\n\tsb->total_blocks = be32_to_cpu(super->fs_size);\n\tsb->first_block  = be32_to_cpu(super->fs_firstcg);\n\tsb->group_size   = be32_to_cpu(super->fs_cgfsize);\n\tsb->data_free    = be32_to_cpu(super->fs_tfree);\n\tsb->inode_free   = be32_to_cpu(super->fs_tinode);\n\tsb->inode_blocks = be16_to_cpu(super->fs_cgisize);\n\tsb->total_groups = be16_to_cpu(super->fs_ncg);\n    \n\treturn 0;    \n}"
  },
  {
    "function_name": "module_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "156-174",
    "snippet": "module_init(init_efs_fs)\nmodule_exit(exit_efs_fs)\n\nstatic efs_block_t efs_validate_vh(struct volume_header *vh) {\n\tint\t\ti;\n\t__be32\t\tcs, *ui;\n\tint\t\tcsum;\n\tefs_block_t\tsblock = 0; /* shuts up gcc */\n\tstruct pt_types\t*pt_entry;\n\tint\t\tpt_type, slice = -1;\n\n\tif (be32_to_cpu(vh->vh_magic) != VHMAGIC) {\n\t\t/*\n\t\t * assume that we're dealing with a partition and allow\n\t\t * read_super() to try and detect a valid superblock\n\t\t * on the next block.\n\t\t */\n\t\treturn 0;\n\t}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nmodule_init(init_efs_fs)\nmodule_exit(exit_efs_fs)\n\nstatic efs_block_t efs_validate_vh(struct volume_header *vh) {\n\tint\t\ti;\n\t__be32\t\tcs, *ui;\n\tint\t\tcsum;\n\tefs_block_t\tsblock = 0; /* shuts up gcc */\n\tstruct pt_types\t*pt_entry;\n\tint\t\tpt_type, slice = -1;\n\n\tif (be32_to_cpu(vh->vh_magic) != VHMAGIC) {\n\t\t/*\n\t\t * assume that we're dealing with a partition and allow\n\t\t * read_super() to try and detect a valid superblock\n\t\t * on the next block.\n\t\t */\n\t\treturn 0;\n\t}"
  },
  {
    "function_name": "exit_efs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "151-154",
    "snippet": "static void __exit exit_efs_fs(void) {\n\tunregister_filesystem(&efs_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type efs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"efs\",\n\t.mount\t\t= efs_mount,\n\t.kill_sb\t= efs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
          "lines": "105-113",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(efs_inode_cachep);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <linux/efs_vh.h>",
            "#include \"efs.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * efs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * efs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(efs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&efs_fs_type"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct file_system_type efs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"efs\",\n\t.mount\t\t= efs_mount,\n\t.kill_sb\t= efs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_efs_fs(void) {\n\tunregister_filesystem(&efs_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_efs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "135-149",
    "snippet": "static int __init init_efs_fs(void) {\n\tint err;\n\tpr_info(EFS_VERSION\" - http://aeschi.ch.eu.org/efs/\\n\");\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&efs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type efs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"efs\",\n\t.mount\t\t= efs_mount,\n\t.kill_sb\t= efs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
          "lines": "105-113",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(efs_inode_cachep);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <linux/efs_vh.h>",
            "#include \"efs.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * efs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * efs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(efs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&efs_fs_type"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
          "lines": "94-103",
          "snippet": "static int __init init_inodecache(void)\n{\n\tefs_inode_cachep = kmem_cache_create(\"efs_inode_cache\",\n\t\t\t\tsizeof(struct efs_inode_info),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (efs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <linux/efs_vh.h>",
            "#include \"efs.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * efs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * efs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tefs_inode_cachep = kmem_cache_create(\"efs_inode_cache\",\n\t\t\t\tsizeof(struct efs_inode_info),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (efs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "EFS_VERSION\" - http://aeschi.ch.eu.org/efs/\\n\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct file_system_type efs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"efs\",\n\t.mount\t\t= efs_mount,\n\t.kill_sb\t= efs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_efs_fs(void) {\n\tint err;\n\tpr_info(EFS_VERSION\" - http://aeschi.ch.eu.org/efs/\\n\");\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&efs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "efs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "115-120",
    "snippet": "static int efs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int efs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "105-113",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(efs_inode_cachep);\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * efs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "efs_inode_cachep"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * efs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(efs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "94-103",
    "snippet": "static int __init init_inodecache(void)\n{\n\tefs_inode_cachep = kmem_cache_create(\"efs_inode_cache\",\n\t\t\t\tsizeof(struct efs_inode_info),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (efs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * efs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"efs_inode_cache\"",
            "sizeof(struct efs_inode_info)",
            "0",
            "SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD",
            "init_once"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * efs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tefs_inode_cachep = kmem_cache_create(\"efs_inode_cache\",\n\t\t\t\tsizeof(struct efs_inode_info),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (efs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "87-92",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct efs_inode_info *ei = (struct efs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct efs_inode_info *ei = (struct efs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "efs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "82-85",
    "snippet": "static void efs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, efs_i_callback);\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "efs_i_callback"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void efs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, efs_i_callback);\n}"
  },
  {
    "function_name": "efs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "76-80",
    "snippet": "static void efs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(efs_inode_cachep, INODE_INFO(inode));\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * efs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "efs_inode_cachep",
            "INODE_INFO(inode)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_INFO",
          "args": [
            "inode"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_INFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/efs.h",
          "lines": "117-120",
          "snippet": "static inline struct efs_inode_info *INODE_INFO(struct inode *inode)\n{\n\treturn container_of(inode, struct efs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n\nstatic inline struct efs_inode_info *INODE_INFO(struct inode *inode)\n{\n\treturn container_of(inode, struct efs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * efs_inode_cachep;\n\nstatic void efs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(efs_inode_cachep, INODE_INFO(inode));\n}"
  },
  {
    "function_name": "efs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "67-74",
    "snippet": "static struct inode *efs_alloc_inode(struct super_block *sb)\n{\n\tstruct efs_inode_info *ei;\n\tei = (struct efs_inode_info *)kmem_cache_alloc(efs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * efs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "efs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * efs_inode_cachep;\n\nstatic struct inode *efs_alloc_inode(struct super_block *sb)\n{\n\tstruct efs_inode_info *ei;\n\tei = (struct efs_inode_info *)kmem_cache_alloc(efs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "efs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "29-34",
    "snippet": "static void efs_kill_sb(struct super_block *s)\n{\n\tstruct efs_sb_info *sbi = SUPER_INFO(s);\n\tkill_block_super(s);\n\tkfree(sbi);\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_block_super",
          "args": [
            "s"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_kill_block_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "629-638",
          "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_sb_info_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUPER_INFO",
          "args": [
            "s"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "SUPER_INFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/efs.h",
          "lines": "122-125",
          "snippet": "static inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n\nstatic inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic void efs_kill_sb(struct super_block *s)\n{\n\tstruct efs_sb_info *sbi = SUPER_INFO(s);\n\tkill_block_super(s);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "efs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/super.c",
    "lines": "23-27",
    "snippet": "static struct dentry *efs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, efs_fill_super);\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include <linux/efs_vh.h>",
      "#include \"efs.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "efs_fill_super"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <linux/efs_vh.h>\n#include \"efs.h\"\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct dentry *efs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, efs_fill_super);\n}"
  }
]