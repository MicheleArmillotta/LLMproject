[
  {
    "function_name": "ext4_ind_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "616-672",
    "snippet": "int ext4_ind_migrate(struct inode *inode)\n{\n\tstruct ext4_extent_header\t*eh;\n\tstruct ext4_super_block\t\t*es = EXT4_SB(inode->i_sb)->s_es;\n\tstruct ext4_inode_info\t\t*ei = EXT4_I(inode);\n\tstruct ext4_extent\t\t*ex;\n\tunsigned int\t\t\ti, len;\n\text4_fsblk_t\t\t\tblk;\n\thandle_t\t\t\t*handle;\n\tint\t\t\t\tret;\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_INCOMPAT_EXTENTS) ||\n\t    (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC))\n\t\treturn -EOPNOTSUPP;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_ext_check_inode(inode);\n\tif (ret)\n\t\tgoto errout;\n\n\teh = ext_inode_hdr(inode);\n\tex  = EXT_FIRST_EXTENT(eh);\n\tif (ext4_blocks_count(es) > EXT4_MAX_BLOCK_FILE_PHYS ||\n\t    eh->eh_depth != 0 || le16_to_cpu(eh->eh_entries) > 1) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\tif (eh->eh_entries == 0)\n\t\tblk = len = 0;\n\telse {\n\t\tlen = le16_to_cpu(ex->ee_len);\n\t\tblk = ext4_ext_pblock(ex);\n\t\tif (len > EXT4_NDIR_BLOCKS) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tfor (i=0; i < len; i++)\n\t\tei->i_data[i] = cpu_to_le32(blk++);\n\text4_mark_inode_dirty(handle, inode);\nerrout:\n\text4_journal_stop(handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "blk++"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ei->i_data",
            "0",
            "sizeof(ei->i_data)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_pblock",
          "args": [
            "ex"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "220-227",
          "snippet": "static inline ext4_fsblk_t ext4_ext_pblock(struct ext4_extent *ex)\n{\n\text4_fsblk_t block;\n\n\tblock = le32_to_cpu(ex->ee_start_lo);\n\tblock |= ((ext4_fsblk_t) le16_to_cpu(ex->ee_start_hi) << 31) << 1;\n\treturn block;\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\nstatic inline ext4_fsblk_t ext4_ext_pblock(struct ext4_extent *ex)\n{\n\text4_fsblk_t block;\n\n\tblock = le32_to_cpu(ex->ee_start_lo);\n\tblock |= ((ext4_fsblk_t) le16_to_cpu(ex->ee_start_hi) << 31) << 1;\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ex->ee_len"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT_FIRST_EXTENT",
          "args": [
            "eh"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_inode_hdr",
          "args": [
            "inode"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "ext_inode_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "176-179",
          "snippet": "static inline struct ext4_extent_header *ext_inode_hdr(struct inode *inode)\n{\n\treturn (struct ext4_extent_header *) EXT4_I(inode)->i_data;\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\nstatic inline struct ext4_extent_header *ext_inode_hdr(struct inode *inode)\n{\n\treturn (struct ext4_extent_header *) EXT4_I(inode)->i_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_check_inode",
          "args": [
            "inode"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_check_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "493-496",
          "snippet": "int ext4_ext_check_inode(struct inode *inode)\n{\n\treturn ext4_ext_check(inode, ext_inode_hdr(inode), ext_depth(inode), 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_check_inode(struct inode *inode)\n{\n\treturn ext4_ext_check(inode, ext_inode_hdr(inode), ext_depth(inode), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_MIGRATE",
            "1"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_INCOMPAT_EXTENTS"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nint ext4_ind_migrate(struct inode *inode)\n{\n\tstruct ext4_extent_header\t*eh;\n\tstruct ext4_super_block\t\t*es = EXT4_SB(inode->i_sb)->s_es;\n\tstruct ext4_inode_info\t\t*ei = EXT4_I(inode);\n\tstruct ext4_extent\t\t*ex;\n\tunsigned int\t\t\ti, len;\n\text4_fsblk_t\t\t\tblk;\n\thandle_t\t\t\t*handle;\n\tint\t\t\t\tret;\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_INCOMPAT_EXTENTS) ||\n\t    (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC))\n\t\treturn -EOPNOTSUPP;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_ext_check_inode(inode);\n\tif (ret)\n\t\tgoto errout;\n\n\teh = ext_inode_hdr(inode);\n\tex  = EXT_FIRST_EXTENT(eh);\n\tif (ext4_blocks_count(es) > EXT4_MAX_BLOCK_FILE_PHYS ||\n\t    eh->eh_depth != 0 || le16_to_cpu(eh->eh_entries) > 1) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\tif (eh->eh_entries == 0)\n\t\tblk = len = 0;\n\telse {\n\t\tlen = le16_to_cpu(ex->ee_len);\n\t\tblk = ext4_ext_pblock(ex);\n\t\tif (len > EXT4_NDIR_BLOCKS) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tfor (i=0; i < len; i++)\n\t\tei->i_data[i] = cpu_to_le32(blk++);\n\text4_mark_inode_dirty(handle, inode);\nerrout:\n\text4_journal_stop(handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_ext_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "435-611",
    "snippet": "int ext4_ext_migrate(struct inode *inode)\n{\n\thandle_t *handle;\n\tint retval = 0, i;\n\t__le32 *i_data;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *tmp_inode = NULL;\n\tstruct migrate_struct lb;\n\tunsigned long max_entries;\n\t__u32 goal;\n\tuid_t owner[2];\n\n\t/*\n\t * If the filesystem does not support extents, or the inode\n\t * already is extent-based, error out.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_INCOMPAT_EXTENTS) ||\n\t    (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (S_ISLNK(inode->i_mode) && inode->i_blocks == 0)\n\t\t/*\n\t\t * don't migrate fast symlink\n\t\t */\n\t\treturn retval;\n\n\t/*\n\t * Worst case we can touch the allocation bitmaps, a bgd\n\t * block, and a block to link in the orphan list.  We do need\n\t * need to worry about credits for modifying the quota inode.\n\t */\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE,\n\t\t4 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\treturn retval;\n\t}\n\tgoal = (((inode->i_ino - 1) / EXT4_INODES_PER_GROUP(inode->i_sb)) *\n\t\tEXT4_INODES_PER_GROUP(inode->i_sb)) + 1;\n\towner[0] = i_uid_read(inode);\n\towner[1] = i_gid_read(inode);\n\ttmp_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,\n\t\t\t\t   S_IFREG, NULL, goal, owner);\n\tif (IS_ERR(tmp_inode)) {\n\t\tretval = PTR_ERR(tmp_inode);\n\t\text4_journal_stop(handle);\n\t\treturn retval;\n\t}\n\ti_size_write(tmp_inode, i_size_read(inode));\n\t/*\n\t * Set the i_nlink to zero so it will be deleted later\n\t * when we drop inode reference.\n\t */\n\tclear_nlink(tmp_inode);\n\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_orphan_add(handle, tmp_inode);\n\text4_journal_stop(handle);\n\n\t/*\n\t * start with one credit accounted for\n\t * superblock modification.\n\t *\n\t * For the tmp_inode we already have committed the\n\t * transaction that created the inode. Later as and\n\t * when we add extents we extent the journal\n\t */\n\t/*\n\t * Even though we take i_mutex we can still cause block\n\t * allocation via mmap write to holes. If we have allocated\n\t * new blocks we fail migrate.  New block allocation will\n\t * clear EXT4_STATE_EXT_MIGRATE flag.  The flag is updated\n\t * with i_data_sem held to prevent racing with block\n\t * allocation.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\text4_set_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle)) {\n\t\t/*\n\t\t * It is impossible to update on-disk structures without\n\t\t * a handle, so just rollback in-core changes and live other\n\t\t * work to orphan_list_cleanup()\n\t\t */\n\t\text4_orphan_del(NULL, tmp_inode);\n\t\tretval = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tei = EXT4_I(inode);\n\ti_data = ei->i_data;\n\tmemset(&lb, 0, sizeof(lb));\n\n\t/* 32 bit block address 4 bytes */\n\tmax_entries = inode->i_sb->s_blocksize >> 2;\n\tfor (i = 0; i < EXT4_NDIR_BLOCKS; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, tmp_inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t} else\n\t\t\tlb.curr_block++;\n\t}\n\tif (i_data[EXT4_IND_BLOCK]) {\n\t\tretval = update_ind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_IND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries;\n\tif (i_data[EXT4_DIND_BLOCK]) {\n\t\tretval = update_dind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_DIND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries * max_entries;\n\tif (i_data[EXT4_TIND_BLOCK]) {\n\t\tretval = update_tind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_TIND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t}\n\t/*\n\t * Build the last extent\n\t */\n\tretval = finish_range(handle, tmp_inode, &lb);\nerr_out:\n\tif (retval)\n\t\t/*\n\t\t * Failure case delete the extent information with the\n\t\t * tmp_inode\n\t\t */\n\t\tfree_ext_block(handle, tmp_inode);\n\telse {\n\t\tretval = ext4_ext_swap_inode_data(handle, inode, tmp_inode);\n\t\tif (retval)\n\t\t\t/*\n\t\t\t * if we fail to swap inode data free the extent\n\t\t\t * details of the tmp inode\n\t\t\t */\n\t\t\tfree_ext_block(handle, tmp_inode);\n\t}\n\n\t/* We mark the tmp_inode dirty via ext4_ext_tree_init. */\n\tif (ext4_journal_extend(handle, 1) != 0)\n\t\text4_journal_restart(handle, 1);\n\n\t/*\n\t * Mark the tmp_inode as of size zero\n\t */\n\ti_size_write(tmp_inode, 0);\n\n\t/*\n\t * set the  i_blocks count to zero\n\t * so that the ext4_evict_inode() does the\n\t * right job\n\t *\n\t * We don't need to take the i_lock because\n\t * the inode is not visible to user space.\n\t */\n\ttmp_inode->i_blocks = 0;\n\n\t/* Reset the extent details */\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_journal_stop(handle);\nout:\n\tunlock_new_inode(tmp_inode);\n\tiput(tmp_inode);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "tmp_inode"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "tmp_inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_tree_init",
          "args": [
            "handle",
            "tmp_inode"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "844-855",
          "snippet": "int ext4_ext_tree_init(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_extent_header *eh;\n\n\teh = ext_inode_hdr(inode);\n\teh->eh_depth = 0;\n\teh->eh_entries = 0;\n\teh->eh_magic = EXT4_EXT_MAGIC;\n\teh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0));\n\text4_mark_inode_dirty(handle, inode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_tree_init(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_extent_header *eh;\n\n\teh = ext_inode_hdr(inode);\n\teh->eh_depth = 0;\n\teh->eh_entries = 0;\n\teh->eh_magic = EXT4_EXT_MAGIC;\n\teh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0));\n\text4_mark_inode_dirty(handle, inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "tmp_inode",
            "0"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_restart",
          "args": [
            "handle",
            "1"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "343-348",
          "snippet": "static inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_extend",
          "args": [
            "handle",
            "1"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "336-341",
          "snippet": "static inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ext_block",
          "args": [
            "handle",
            "tmp_inode"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "free_ext_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "415-433",
          "snippet": "static int free_ext_block(handle_t *handle, struct inode *inode)\n{\n\tint i, retval = 0;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_extent_header *eh = (struct ext4_extent_header *)ei->i_data;\n\tstruct ext4_extent_idx *ix;\n\tif (eh->eh_depth == 0)\n\t\t/*\n\t\t * No extra blocks allocated for extent meta data\n\t\t */\n\t\treturn 0;\n\tix = EXT_FIRST_INDEX(eh);\n\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\tretval = free_ext_idx(handle, inode, ix);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_ext_block(handle_t *handle, struct inode *inode)\n{\n\tint i, retval = 0;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_extent_header *eh = (struct ext4_extent_header *)ei->i_data;\n\tstruct ext4_extent_idx *ix;\n\tif (eh->eh_depth == 0)\n\t\t/*\n\t\t * No extra blocks allocated for extent meta data\n\t\t */\n\t\treturn 0;\n\tix = EXT_FIRST_INDEX(eh);\n\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\tretval = free_ext_idx(handle, inode, ix);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_swap_inode_data",
          "args": [
            "handle",
            "inode",
            "tmp_inode"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_swap_inode_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "316-381",
          "snippet": "static int ext4_ext_swap_inode_data(handle_t *handle, struct inode *inode,\n\t\t\t\t\t\tstruct inode *tmp_inode)\n{\n\tint retval;\n\t__le32\ti_data[3];\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_inode_info *tmp_ei = EXT4_I(tmp_inode);\n\n\t/*\n\t * One credit accounted for writing the\n\t * i_data field of the original inode\n\t */\n\tretval = ext4_journal_extend(handle, 1);\n\tif (retval) {\n\t\tretval = ext4_journal_restart(handle, 1);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t}\n\n\ti_data[0] = ei->i_data[EXT4_IND_BLOCK];\n\ti_data[1] = ei->i_data[EXT4_DIND_BLOCK];\n\ti_data[2] = ei->i_data[EXT4_TIND_BLOCK];\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t/*\n\t * if EXT4_STATE_EXT_MIGRATE is cleared a block allocation\n\t * happened after we started the migrate. We need to\n\t * fail the migrate\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_EXT_MIGRATE)) {\n\t\tretval = -EAGAIN;\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto err_out;\n\t} else\n\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t/*\n\t * We have the extent map build with the tmp inode.\n\t * Now copy the i_data across\n\t */\n\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemcpy(ei->i_data, tmp_ei->i_data, sizeof(ei->i_data));\n\n\t/*\n\t * Update i_blocks with the new blocks that got\n\t * allocated while adding extents for extent index\n\t * blocks.\n\t *\n\t * While converting to extents we need not\n\t * update the orignal inode i_blocks for extent blocks\n\t * via quota APIs. The quota update happened via tmp_inode already.\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += tmp_inode->i_blocks;\n\tspin_unlock(&inode->i_lock);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We mark the inode dirty after, because we decrement the\n\t * i_blocks when freeing the indirect meta-data blocks\n\t */\n\tretval = free_ind_block(handle, inode, i_data);\n\text4_mark_inode_dirty(handle, inode);\n\nerr_out:\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int ext4_ext_swap_inode_data(handle_t *handle, struct inode *inode,\n\t\t\t\t\t\tstruct inode *tmp_inode)\n{\n\tint retval;\n\t__le32\ti_data[3];\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_inode_info *tmp_ei = EXT4_I(tmp_inode);\n\n\t/*\n\t * One credit accounted for writing the\n\t * i_data field of the original inode\n\t */\n\tretval = ext4_journal_extend(handle, 1);\n\tif (retval) {\n\t\tretval = ext4_journal_restart(handle, 1);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t}\n\n\ti_data[0] = ei->i_data[EXT4_IND_BLOCK];\n\ti_data[1] = ei->i_data[EXT4_DIND_BLOCK];\n\ti_data[2] = ei->i_data[EXT4_TIND_BLOCK];\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t/*\n\t * if EXT4_STATE_EXT_MIGRATE is cleared a block allocation\n\t * happened after we started the migrate. We need to\n\t * fail the migrate\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_EXT_MIGRATE)) {\n\t\tretval = -EAGAIN;\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto err_out;\n\t} else\n\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t/*\n\t * We have the extent map build with the tmp inode.\n\t * Now copy the i_data across\n\t */\n\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemcpy(ei->i_data, tmp_ei->i_data, sizeof(ei->i_data));\n\n\t/*\n\t * Update i_blocks with the new blocks that got\n\t * allocated while adding extents for extent index\n\t * blocks.\n\t *\n\t * While converting to extents we need not\n\t * update the orignal inode i_blocks for extent blocks\n\t * via quota APIs. The quota update happened via tmp_inode already.\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += tmp_inode->i_blocks;\n\tspin_unlock(&inode->i_lock);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We mark the inode dirty after, because we decrement the\n\t * i_blocks when freeing the indirect meta-data blocks\n\t */\n\tretval = free_ind_block(handle, inode, i_data);\n\text4_mark_inode_dirty(handle, inode);\n\nerr_out:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_range",
          "args": [
            "handle",
            "tmp_inode",
            "&lb"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "finish_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "28-90",
          "snippet": "static int finish_range(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct migrate_struct *lb)\n\n{\n\tint retval = 0, needed;\n\tstruct ext4_extent newext;\n\tstruct ext4_ext_path *path;\n\tif (lb->first_pblock == 0)\n\t\treturn 0;\n\n\t/* Add the extent to temp inode*/\n\tnewext.ee_block = cpu_to_le32(lb->first_block);\n\tnewext.ee_len   = cpu_to_le16(lb->last_block - lb->first_block + 1);\n\text4_ext_store_pblock(&newext, lb->first_pblock);\n\t/* Locking only for convinience since we are operating on temp inode */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tpath = ext4_find_extent(inode, lb->first_block, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tretval = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/*\n\t * Calculate the credit needed to inserting this extent\n\t * Since we are doing this in loop we may accumalate extra\n\t * credit. But below we try to not accumalate too much\n\t * of them by restarting the journal.\n\t */\n\tneeded = ext4_ext_calc_credits_for_single_extent(inode,\n\t\t    lb->last_block - lb->first_block + 1, path);\n\n\t/*\n\t * Make sure the credit we accumalated is not really high\n\t */\n\tif (needed && ext4_handle_has_enough_credits(handle,\n\t\t\t\t\t\tEXT4_RESERVE_TRANS_BLOCKS)) {\n\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\tretval = ext4_journal_restart(handle, needed);\n\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t} else if (needed) {\n\t\tretval = ext4_journal_extend(handle, needed);\n\t\tif (retval) {\n\t\t\t/*\n\t\t\t * IF not able to extend the journal restart the journal\n\t\t\t */\n\t\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tretval = ext4_journal_restart(handle, needed);\n\t\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = ext4_ext_insert_extent(handle, inode, &path, &newext, 0);\nerr_out:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tlb->first_pblock = 0;\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int finish_range(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct migrate_struct *lb)\n\n{\n\tint retval = 0, needed;\n\tstruct ext4_extent newext;\n\tstruct ext4_ext_path *path;\n\tif (lb->first_pblock == 0)\n\t\treturn 0;\n\n\t/* Add the extent to temp inode*/\n\tnewext.ee_block = cpu_to_le32(lb->first_block);\n\tnewext.ee_len   = cpu_to_le16(lb->last_block - lb->first_block + 1);\n\text4_ext_store_pblock(&newext, lb->first_pblock);\n\t/* Locking only for convinience since we are operating on temp inode */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tpath = ext4_find_extent(inode, lb->first_block, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tretval = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/*\n\t * Calculate the credit needed to inserting this extent\n\t * Since we are doing this in loop we may accumalate extra\n\t * credit. But below we try to not accumalate too much\n\t * of them by restarting the journal.\n\t */\n\tneeded = ext4_ext_calc_credits_for_single_extent(inode,\n\t\t    lb->last_block - lb->first_block + 1, path);\n\n\t/*\n\t * Make sure the credit we accumalated is not really high\n\t */\n\tif (needed && ext4_handle_has_enough_credits(handle,\n\t\t\t\t\t\tEXT4_RESERVE_TRANS_BLOCKS)) {\n\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\tretval = ext4_journal_restart(handle, needed);\n\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t} else if (needed) {\n\t\tretval = ext4_journal_extend(handle, needed);\n\t\tif (retval) {\n\t\t\t/*\n\t\t\t * IF not able to extend the journal restart the journal\n\t\t\t */\n\t\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tretval = ext4_journal_restart(handle, needed);\n\t\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = ext4_ext_insert_extent(handle, inode, &path, &newext, 0);\nerr_out:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tlb->first_pblock = 0;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_tind_extent_range",
          "args": [
            "handle",
            "tmp_inode",
            "le32_to_cpu(i_data[EXT4_TIND_BLOCK])",
            "&lb"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "update_tind_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "176-204",
          "snippet": "static int update_tind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_dind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries * max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_tind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_dind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries * max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "i_data[EXT4_TIND_BLOCK]"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dind_extent_range",
          "args": [
            "handle",
            "tmp_inode",
            "le32_to_cpu(i_data[EXT4_DIND_BLOCK])",
            "&lb"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "update_dind_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "146-174",
          "snippet": "static int update_dind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_ind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_dind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_ind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ind_extent_range",
          "args": [
            "handle",
            "tmp_inode",
            "le32_to_cpu(i_data[EXT4_IND_BLOCK])",
            "&lb"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "update_ind_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "117-144",
          "snippet": "static int update_ind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t   ext4_fsblk_t pblock,\n\t\t\t\t   struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tlb->curr_block++;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_ind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t   ext4_fsblk_t pblock,\n\t\t\t\t   struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tlb->curr_block++;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_extent_range",
          "args": [
            "handle",
            "tmp_inode",
            "le32_to_cpu(i_data[i])",
            "&lb"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "update_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "92-115",
          "snippet": "static int update_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_fsblk_t pblock, struct migrate_struct *lb)\n{\n\tint retval;\n\t/*\n\t * See if we can add on to the existing range (if it exists)\n\t */\n\tif (lb->first_pblock &&\n\t\t(lb->last_pblock+1 == pblock) &&\n\t\t(lb->last_block+1 == lb->curr_block)) {\n\t\tlb->last_pblock = pblock;\n\t\tlb->last_block = lb->curr_block;\n\t\tlb->curr_block++;\n\t\treturn 0;\n\t}\n\t/*\n\t * Start a new range.\n\t */\n\tretval = finish_range(handle, inode, lb);\n\tlb->first_pblock = lb->last_pblock = pblock;\n\tlb->first_block = lb->last_block = lb->curr_block;\n\tlb->curr_block++;\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_fsblk_t pblock, struct migrate_struct *lb)\n{\n\tint retval;\n\t/*\n\t * See if we can add on to the existing range (if it exists)\n\t */\n\tif (lb->first_pblock &&\n\t\t(lb->last_pblock+1 == pblock) &&\n\t\t(lb->last_block+1 == lb->curr_block)) {\n\t\tlb->last_pblock = pblock;\n\t\tlb->last_block = lb->curr_block;\n\t\tlb->curr_block++;\n\t\treturn 0;\n\t}\n\t/*\n\t * Start a new range.\n\t */\n\tretval = finish_range(handle, inode, lb);\n\tlb->first_pblock = lb->last_pblock = pblock;\n\tlb->first_block = lb->last_block = lb->curr_block;\n\tlb->curr_block++;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lb",
            "0",
            "sizeof(lb)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "NULL",
            "tmp_inode"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_MIGRATE",
            "1"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_EXT_MIGRATE"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "tmp_inode"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "tmp_inode"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp_inode"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp_inode"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_new_inode",
          "args": [
            "handle",
            "inode->i_sb->s_root->d_inode",
            "S_IFREG",
            "NULL",
            "goal",
            "owner"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "inode->i_sb"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MAXQUOTAS_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_INCOMPAT_EXTENTS"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nint ext4_ext_migrate(struct inode *inode)\n{\n\thandle_t *handle;\n\tint retval = 0, i;\n\t__le32 *i_data;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *tmp_inode = NULL;\n\tstruct migrate_struct lb;\n\tunsigned long max_entries;\n\t__u32 goal;\n\tuid_t owner[2];\n\n\t/*\n\t * If the filesystem does not support extents, or the inode\n\t * already is extent-based, error out.\n\t */\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_INCOMPAT_EXTENTS) ||\n\t    (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn -EINVAL;\n\n\tif (S_ISLNK(inode->i_mode) && inode->i_blocks == 0)\n\t\t/*\n\t\t * don't migrate fast symlink\n\t\t */\n\t\treturn retval;\n\n\t/*\n\t * Worst case we can touch the allocation bitmaps, a bgd\n\t * block, and a block to link in the orphan list.  We do need\n\t * need to worry about credits for modifying the quota inode.\n\t */\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE,\n\t\t4 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\n\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\treturn retval;\n\t}\n\tgoal = (((inode->i_ino - 1) / EXT4_INODES_PER_GROUP(inode->i_sb)) *\n\t\tEXT4_INODES_PER_GROUP(inode->i_sb)) + 1;\n\towner[0] = i_uid_read(inode);\n\towner[1] = i_gid_read(inode);\n\ttmp_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,\n\t\t\t\t   S_IFREG, NULL, goal, owner);\n\tif (IS_ERR(tmp_inode)) {\n\t\tretval = PTR_ERR(tmp_inode);\n\t\text4_journal_stop(handle);\n\t\treturn retval;\n\t}\n\ti_size_write(tmp_inode, i_size_read(inode));\n\t/*\n\t * Set the i_nlink to zero so it will be deleted later\n\t * when we drop inode reference.\n\t */\n\tclear_nlink(tmp_inode);\n\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_orphan_add(handle, tmp_inode);\n\text4_journal_stop(handle);\n\n\t/*\n\t * start with one credit accounted for\n\t * superblock modification.\n\t *\n\t * For the tmp_inode we already have committed the\n\t * transaction that created the inode. Later as and\n\t * when we add extents we extent the journal\n\t */\n\t/*\n\t * Even though we take i_mutex we can still cause block\n\t * allocation via mmap write to holes. If we have allocated\n\t * new blocks we fail migrate.  New block allocation will\n\t * clear EXT4_STATE_EXT_MIGRATE flag.  The flag is updated\n\t * with i_data_sem held to prevent racing with block\n\t * allocation.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\text4_set_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\n\tif (IS_ERR(handle)) {\n\t\t/*\n\t\t * It is impossible to update on-disk structures without\n\t\t * a handle, so just rollback in-core changes and live other\n\t\t * work to orphan_list_cleanup()\n\t\t */\n\t\text4_orphan_del(NULL, tmp_inode);\n\t\tretval = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tei = EXT4_I(inode);\n\ti_data = ei->i_data;\n\tmemset(&lb, 0, sizeof(lb));\n\n\t/* 32 bit block address 4 bytes */\n\tmax_entries = inode->i_sb->s_blocksize >> 2;\n\tfor (i = 0; i < EXT4_NDIR_BLOCKS; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, tmp_inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t} else\n\t\t\tlb.curr_block++;\n\t}\n\tif (i_data[EXT4_IND_BLOCK]) {\n\t\tretval = update_ind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_IND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries;\n\tif (i_data[EXT4_DIND_BLOCK]) {\n\t\tretval = update_dind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_DIND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t} else\n\t\tlb.curr_block += max_entries * max_entries;\n\tif (i_data[EXT4_TIND_BLOCK]) {\n\t\tretval = update_tind_extent_range(handle, tmp_inode,\n\t\t\t\tle32_to_cpu(i_data[EXT4_TIND_BLOCK]), &lb);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t}\n\t/*\n\t * Build the last extent\n\t */\n\tretval = finish_range(handle, tmp_inode, &lb);\nerr_out:\n\tif (retval)\n\t\t/*\n\t\t * Failure case delete the extent information with the\n\t\t * tmp_inode\n\t\t */\n\t\tfree_ext_block(handle, tmp_inode);\n\telse {\n\t\tretval = ext4_ext_swap_inode_data(handle, inode, tmp_inode);\n\t\tif (retval)\n\t\t\t/*\n\t\t\t * if we fail to swap inode data free the extent\n\t\t\t * details of the tmp inode\n\t\t\t */\n\t\t\tfree_ext_block(handle, tmp_inode);\n\t}\n\n\t/* We mark the tmp_inode dirty via ext4_ext_tree_init. */\n\tif (ext4_journal_extend(handle, 1) != 0)\n\t\text4_journal_restart(handle, 1);\n\n\t/*\n\t * Mark the tmp_inode as of size zero\n\t */\n\ti_size_write(tmp_inode, 0);\n\n\t/*\n\t * set the  i_blocks count to zero\n\t * so that the ext4_evict_inode() does the\n\t * right job\n\t *\n\t * We don't need to take the i_lock because\n\t * the inode is not visible to user space.\n\t */\n\ttmp_inode->i_blocks = 0;\n\n\t/* Reset the extent details */\n\text4_ext_tree_init(handle, tmp_inode);\n\text4_journal_stop(handle);\nout:\n\tunlock_new_inode(tmp_inode);\n\tiput(tmp_inode);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "free_ext_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "415-433",
    "snippet": "static int free_ext_block(handle_t *handle, struct inode *inode)\n{\n\tint i, retval = 0;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_extent_header *eh = (struct ext4_extent_header *)ei->i_data;\n\tstruct ext4_extent_idx *ix;\n\tif (eh->eh_depth == 0)\n\t\t/*\n\t\t * No extra blocks allocated for extent meta data\n\t\t */\n\t\treturn 0;\n\tix = EXT_FIRST_INDEX(eh);\n\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\tretval = free_ext_idx(handle, inode, ix);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ext_idx",
          "args": [
            "handle",
            "inode",
            "ix"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "free_ext_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "383-410",
          "snippet": "static int free_ext_idx(handle_t *handle, struct inode *inode,\n\t\t\t\t\tstruct ext4_extent_idx *ix)\n{\n\tint i, retval = 0;\n\text4_fsblk_t block;\n\tstruct buffer_head *bh;\n\tstruct ext4_extent_header *eh;\n\n\tblock = ext4_idx_pblock(ix);\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\treturn -EIO;\n\n\teh = (struct ext4_extent_header *)bh->b_data;\n\tif (eh->eh_depth != 0) {\n\t\tix = EXT_FIRST_INDEX(eh);\n\t\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\t\tretval = free_ext_idx(handle, inode, ix);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_ext_idx(handle_t *handle, struct inode *inode,\n\t\t\t\t\tstruct ext4_extent_idx *ix)\n{\n\tint i, retval = 0;\n\text4_fsblk_t block;\n\tstruct buffer_head *bh;\n\tstruct ext4_extent_header *eh;\n\n\tblock = ext4_idx_pblock(ix);\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\treturn -EIO;\n\n\teh = (struct ext4_extent_header *)bh->b_data;\n\tif (eh->eh_depth != 0) {\n\t\tix = EXT_FIRST_INDEX(eh);\n\t\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\t\tretval = free_ext_idx(handle, inode, ix);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "eh->eh_entries"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT_FIRST_INDEX",
          "args": [
            "eh"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_ext_block(handle_t *handle, struct inode *inode)\n{\n\tint i, retval = 0;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_extent_header *eh = (struct ext4_extent_header *)ei->i_data;\n\tstruct ext4_extent_idx *ix;\n\tif (eh->eh_depth == 0)\n\t\t/*\n\t\t * No extra blocks allocated for extent meta data\n\t\t */\n\t\treturn 0;\n\tix = EXT_FIRST_INDEX(eh);\n\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\tretval = free_ext_idx(handle, inode, ix);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "free_ext_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "383-410",
    "snippet": "static int free_ext_idx(handle_t *handle, struct inode *inode,\n\t\t\t\t\tstruct ext4_extent_idx *ix)\n{\n\tint i, retval = 0;\n\text4_fsblk_t block;\n\tstruct buffer_head *bh;\n\tstruct ext4_extent_header *eh;\n\n\tblock = ext4_idx_pblock(ix);\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\treturn -EIO;\n\n\teh = (struct ext4_extent_header *)bh->b_data;\n\tif (eh->eh_depth != 0) {\n\t\tix = EXT_FIRST_INDEX(eh);\n\t\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\t\tretval = free_ext_idx(handle, inode, ix);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\n\treturn retval;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "NULL",
            "block",
            "1",
            "EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extend_credit_for_blkdel",
          "args": [
            "handle",
            "inode"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "extend_credit_for_blkdel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "206-224",
          "snippet": "static int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_ext_idx",
          "args": [
            "handle",
            "inode",
            "ix"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "free_ext_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "383-410",
          "snippet": "static int free_ext_idx(handle_t *handle, struct inode *inode,\n\t\t\t\t\tstruct ext4_extent_idx *ix)\n{\n\tint i, retval = 0;\n\text4_fsblk_t block;\n\tstruct buffer_head *bh;\n\tstruct ext4_extent_header *eh;\n\n\tblock = ext4_idx_pblock(ix);\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\treturn -EIO;\n\n\teh = (struct ext4_extent_header *)bh->b_data;\n\tif (eh->eh_depth != 0) {\n\t\tix = EXT_FIRST_INDEX(eh);\n\t\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\t\tretval = free_ext_idx(handle, inode, ix);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\n\treturn retval;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "eh->eh_entries"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT_FIRST_INDEX",
          "args": [
            "eh"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_idx_pblock",
          "args": [
            "ix"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_idx_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "233-240",
          "snippet": "static inline ext4_fsblk_t ext4_idx_pblock(struct ext4_extent_idx *ix)\n{\n\text4_fsblk_t block;\n\n\tblock = le32_to_cpu(ix->ei_leaf_lo);\n\tblock |= ((ext4_fsblk_t) le16_to_cpu(ix->ei_leaf_hi) << 31) << 1;\n\treturn block;\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\nstatic inline ext4_fsblk_t ext4_idx_pblock(struct ext4_extent_idx *ix)\n{\n\text4_fsblk_t block;\n\n\tblock = le32_to_cpu(ix->ei_leaf_lo);\n\tblock |= ((ext4_fsblk_t) le16_to_cpu(ix->ei_leaf_hi) << 31) << 1;\n\treturn block;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_ext_idx(handle_t *handle, struct inode *inode,\n\t\t\t\t\tstruct ext4_extent_idx *ix)\n{\n\tint i, retval = 0;\n\text4_fsblk_t block;\n\tstruct buffer_head *bh;\n\tstruct ext4_extent_header *eh;\n\n\tblock = ext4_idx_pblock(ix);\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\treturn -EIO;\n\n\teh = (struct ext4_extent_header *)bh->b_data;\n\tif (eh->eh_depth != 0) {\n\t\tix = EXT_FIRST_INDEX(eh);\n\t\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\n\t\t\tretval = free_ext_idx(handle, inode, ix);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\n\treturn retval;\n}"
  },
  {
    "function_name": "ext4_ext_swap_inode_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "316-381",
    "snippet": "static int ext4_ext_swap_inode_data(handle_t *handle, struct inode *inode,\n\t\t\t\t\t\tstruct inode *tmp_inode)\n{\n\tint retval;\n\t__le32\ti_data[3];\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_inode_info *tmp_ei = EXT4_I(tmp_inode);\n\n\t/*\n\t * One credit accounted for writing the\n\t * i_data field of the original inode\n\t */\n\tretval = ext4_journal_extend(handle, 1);\n\tif (retval) {\n\t\tretval = ext4_journal_restart(handle, 1);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t}\n\n\ti_data[0] = ei->i_data[EXT4_IND_BLOCK];\n\ti_data[1] = ei->i_data[EXT4_DIND_BLOCK];\n\ti_data[2] = ei->i_data[EXT4_TIND_BLOCK];\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t/*\n\t * if EXT4_STATE_EXT_MIGRATE is cleared a block allocation\n\t * happened after we started the migrate. We need to\n\t * fail the migrate\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_EXT_MIGRATE)) {\n\t\tretval = -EAGAIN;\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto err_out;\n\t} else\n\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t/*\n\t * We have the extent map build with the tmp inode.\n\t * Now copy the i_data across\n\t */\n\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemcpy(ei->i_data, tmp_ei->i_data, sizeof(ei->i_data));\n\n\t/*\n\t * Update i_blocks with the new blocks that got\n\t * allocated while adding extents for extent index\n\t * blocks.\n\t *\n\t * While converting to extents we need not\n\t * update the orignal inode i_blocks for extent blocks\n\t * via quota APIs. The quota update happened via tmp_inode already.\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += tmp_inode->i_blocks;\n\tspin_unlock(&inode->i_lock);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We mark the inode dirty after, because we decrement the\n\t * i_blocks when freeing the indirect meta-data blocks\n\t */\n\tretval = free_ind_block(handle, inode, i_data);\n\text4_mark_inode_dirty(handle, inode);\n\nerr_out:\n\treturn retval;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ind_block",
          "args": [
            "handle",
            "inode",
            "i_data"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "free_ind_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "287-314",
          "snippet": "static int free_ind_block(handle_t *handle, struct inode *inode, __le32 *i_data)\n{\n\tint retval;\n\n\t/* ei->i_data[EXT4_IND_BLOCK] */\n\tif (i_data[0]) {\n\t\textend_credit_for_blkdel(handle, inode);\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\tle32_to_cpu(i_data[0]), 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\n\t/* ei->i_data[EXT4_DIND_BLOCK] */\n\tif (i_data[1]) {\n\t\tretval = free_dind_blocks(handle, inode, i_data[1]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/* ei->i_data[EXT4_TIND_BLOCK] */\n\tif (i_data[2]) {\n\t\tretval = free_tind_blocks(handle, inode, i_data[2]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_ind_block(handle_t *handle, struct inode *inode, __le32 *i_data)\n{\n\tint retval;\n\n\t/* ei->i_data[EXT4_IND_BLOCK] */\n\tif (i_data[0]) {\n\t\textend_credit_for_blkdel(handle, inode);\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\tle32_to_cpu(i_data[0]), 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\n\t/* ei->i_data[EXT4_DIND_BLOCK] */\n\tif (i_data[1]) {\n\t\tretval = free_dind_blocks(handle, inode, i_data[1]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/* ei->i_data[EXT4_TIND_BLOCK] */\n\tif (i_data[2]) {\n\t\tretval = free_tind_blocks(handle, inode, i_data[2]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ei->i_data",
            "tmp_ei->i_data",
            "sizeof(ei->i_data)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_EXT_MIGRATE"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_EXT_MIGRATE"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_restart",
          "args": [
            "handle",
            "1"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "343-348",
          "snippet": "static inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_extend",
          "args": [
            "handle",
            "1"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "336-341",
          "snippet": "static inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int ext4_ext_swap_inode_data(handle_t *handle, struct inode *inode,\n\t\t\t\t\t\tstruct inode *tmp_inode)\n{\n\tint retval;\n\t__le32\ti_data[3];\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_inode_info *tmp_ei = EXT4_I(tmp_inode);\n\n\t/*\n\t * One credit accounted for writing the\n\t * i_data field of the original inode\n\t */\n\tretval = ext4_journal_extend(handle, 1);\n\tif (retval) {\n\t\tretval = ext4_journal_restart(handle, 1);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t}\n\n\ti_data[0] = ei->i_data[EXT4_IND_BLOCK];\n\ti_data[1] = ei->i_data[EXT4_DIND_BLOCK];\n\ti_data[2] = ei->i_data[EXT4_TIND_BLOCK];\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t/*\n\t * if EXT4_STATE_EXT_MIGRATE is cleared a block allocation\n\t * happened after we started the migrate. We need to\n\t * fail the migrate\n\t */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_EXT_MIGRATE)) {\n\t\tretval = -EAGAIN;\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto err_out;\n\t} else\n\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t/*\n\t * We have the extent map build with the tmp inode.\n\t * Now copy the i_data across\n\t */\n\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\tmemcpy(ei->i_data, tmp_ei->i_data, sizeof(ei->i_data));\n\n\t/*\n\t * Update i_blocks with the new blocks that got\n\t * allocated while adding extents for extent index\n\t * blocks.\n\t *\n\t * While converting to extents we need not\n\t * update the orignal inode i_blocks for extent blocks\n\t * via quota APIs. The quota update happened via tmp_inode already.\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks += tmp_inode->i_blocks;\n\tspin_unlock(&inode->i_lock);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We mark the inode dirty after, because we decrement the\n\t * i_blocks when freeing the indirect meta-data blocks\n\t */\n\tretval = free_ind_block(handle, inode, i_data);\n\text4_mark_inode_dirty(handle, inode);\n\nerr_out:\n\treturn retval;\n}"
  },
  {
    "function_name": "free_ind_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "287-314",
    "snippet": "static int free_ind_block(handle_t *handle, struct inode *inode, __le32 *i_data)\n{\n\tint retval;\n\n\t/* ei->i_data[EXT4_IND_BLOCK] */\n\tif (i_data[0]) {\n\t\textend_credit_for_blkdel(handle, inode);\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\tle32_to_cpu(i_data[0]), 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\n\t/* ei->i_data[EXT4_DIND_BLOCK] */\n\tif (i_data[1]) {\n\t\tretval = free_dind_blocks(handle, inode, i_data[1]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/* ei->i_data[EXT4_TIND_BLOCK] */\n\tif (i_data[2]) {\n\t\tretval = free_tind_blocks(handle, inode, i_data[2]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_tind_blocks",
          "args": [
            "handle",
            "inode",
            "i_data[2]"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "free_tind_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "256-285",
          "snippet": "static int free_tind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i, retval = 0;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\tretval = free_dind_blocks(handle,\n\t\t\t\t\tinode, tmp_idata[i]);\n\t\t\tif (retval) {\n\t\t\t\tput_bh(bh);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_tind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i, retval = 0;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\tretval = free_dind_blocks(handle,\n\t\t\t\t\tinode, tmp_idata[i]);\n\t\t\tif (retval) {\n\t\t\t\tput_bh(bh);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_dind_blocks",
          "args": [
            "handle",
            "inode",
            "i_data[1]"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "free_dind_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "226-254",
          "snippet": "static int free_dind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\textend_credit_for_blkdel(handle, inode);\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t le32_to_cpu(tmp_idata[i]), 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_dind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\textend_credit_for_blkdel(handle, inode);\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t le32_to_cpu(tmp_idata[i]), 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "NULL",
            "le32_to_cpu(i_data[0])",
            "1",
            "EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "i_data[0]"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extend_credit_for_blkdel",
          "args": [
            "handle",
            "inode"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "extend_credit_for_blkdel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "206-224",
          "snippet": "static int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_ind_block(handle_t *handle, struct inode *inode, __le32 *i_data)\n{\n\tint retval;\n\n\t/* ei->i_data[EXT4_IND_BLOCK] */\n\tif (i_data[0]) {\n\t\textend_credit_for_blkdel(handle, inode);\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\tle32_to_cpu(i_data[0]), 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\n\t/* ei->i_data[EXT4_DIND_BLOCK] */\n\tif (i_data[1]) {\n\t\tretval = free_dind_blocks(handle, inode, i_data[1]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/* ei->i_data[EXT4_TIND_BLOCK] */\n\tif (i_data[2]) {\n\t\tretval = free_tind_blocks(handle, inode, i_data[2]);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_tind_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "256-285",
    "snippet": "static int free_tind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i, retval = 0;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\tretval = free_dind_blocks(handle,\n\t\t\t\t\tinode, tmp_idata[i]);\n\t\t\tif (retval) {\n\t\t\t\tput_bh(bh);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "NULL",
            "le32_to_cpu(i_data)",
            "1",
            "EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "i_data"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extend_credit_for_blkdel",
          "args": [
            "handle",
            "inode"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "extend_credit_for_blkdel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "206-224",
          "snippet": "static int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_dind_blocks",
          "args": [
            "handle",
            "inode",
            "tmp_idata[i]"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "free_dind_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "226-254",
          "snippet": "static int free_dind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\textend_credit_for_blkdel(handle, inode);\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t le32_to_cpu(tmp_idata[i]), 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_dind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\textend_credit_for_blkdel(handle, inode);\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t le32_to_cpu(tmp_idata[i]), 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "le32_to_cpu(i_data)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_tind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i, retval = 0;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\tretval = free_dind_blocks(handle,\n\t\t\t\t\tinode, tmp_idata[i]);\n\t\t\tif (retval) {\n\t\t\t\tput_bh(bh);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}"
  },
  {
    "function_name": "free_dind_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "226-254",
    "snippet": "static int free_dind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\textend_credit_for_blkdel(handle, inode);\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t le32_to_cpu(tmp_idata[i]), 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "NULL",
            "le32_to_cpu(i_data)",
            "1",
            "EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "i_data"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extend_credit_for_blkdel",
          "args": [
            "handle",
            "inode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "extend_credit_for_blkdel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "206-224",
          "snippet": "static int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "le32_to_cpu(i_data)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int free_dind_blocks(handle_t *handle,\n\t\t\t\tstruct inode *inode, __le32 i_data)\n{\n\tint i;\n\t__le32 *tmp_idata;\n\tstruct buffer_head *bh;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\n\tif (!bh)\n\t\treturn -EIO;\n\n\ttmp_idata = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (tmp_idata[i]) {\n\t\t\textend_credit_for_blkdel(handle, inode);\n\t\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t\t le32_to_cpu(tmp_idata[i]), 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t\t}\n\t}\n\tput_bh(bh);\n\textend_credit_for_blkdel(handle, inode);\n\text4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\n\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\treturn 0;\n}"
  },
  {
    "function_name": "extend_credit_for_blkdel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "206-224",
    "snippet": "static int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_restart",
          "args": [
            "handle",
            "needed"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "343-348",
          "snippet": "static inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_extend",
          "args": [
            "handle",
            "needed"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "336-341",
          "snippet": "static inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MAXQUOTAS_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_has_enough_credits",
          "args": [
            "handle",
            "EXT4_RESERVE_TRANS_BLOCKS+1"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_has_enough_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "292-297",
          "snippet": "static inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\n{\n\tint retval = 0, needed;\n\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\t/*\n\t * We are freeing a blocks. During this we touch\n\t * superblock, group descriptor and block bitmap.\n\t * So allocate a credit of 3. We may update\n\t * quota (user and group).\n\t */\n\tneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\tif (ext4_journal_extend(handle, needed) != 0)\n\t\tretval = ext4_journal_restart(handle, needed);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "update_tind_extent_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "176-204",
    "snippet": "static int update_tind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_dind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries * max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_dind_extent_range",
          "args": [
            "handle",
            "inode",
            "le32_to_cpu(i_data[i])",
            "lb"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "update_dind_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "146-174",
          "snippet": "static int update_dind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_ind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_dind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_ind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "i_data[i]"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "pblock"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_tind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_dind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries * max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}"
  },
  {
    "function_name": "update_dind_extent_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "146-174",
    "snippet": "static int update_dind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_ind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ind_extent_range",
          "args": [
            "handle",
            "inode",
            "le32_to_cpu(i_data[i])",
            "lb"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "update_ind_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "117-144",
          "snippet": "static int update_ind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t   ext4_fsblk_t pblock,\n\t\t\t\t   struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tlb->curr_block++;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_ind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t   ext4_fsblk_t pblock,\n\t\t\t\t   struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tlb->curr_block++;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "i_data[i]"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "pblock"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_dind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t    ext4_fsblk_t pblock,\n\t\t\t\t    struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_ind_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Only update the file block number */\n\t\t\tlb->curr_block += max_entries;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}"
  },
  {
    "function_name": "update_ind_extent_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "117-144",
    "snippet": "static int update_ind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t   ext4_fsblk_t pblock,\n\t\t\t\t   struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tlb->curr_block++;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_extent_range",
          "args": [
            "handle",
            "inode",
            "le32_to_cpu(i_data[i])",
            "lb"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "update_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "92-115",
          "snippet": "static int update_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_fsblk_t pblock, struct migrate_struct *lb)\n{\n\tint retval;\n\t/*\n\t * See if we can add on to the existing range (if it exists)\n\t */\n\tif (lb->first_pblock &&\n\t\t(lb->last_pblock+1 == pblock) &&\n\t\t(lb->last_block+1 == lb->curr_block)) {\n\t\tlb->last_pblock = pblock;\n\t\tlb->last_block = lb->curr_block;\n\t\tlb->curr_block++;\n\t\treturn 0;\n\t}\n\t/*\n\t * Start a new range.\n\t */\n\tretval = finish_range(handle, inode, lb);\n\tlb->first_pblock = lb->last_pblock = pblock;\n\tlb->first_block = lb->last_block = lb->curr_block;\n\tlb->curr_block++;\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_fsblk_t pblock, struct migrate_struct *lb)\n{\n\tint retval;\n\t/*\n\t * See if we can add on to the existing range (if it exists)\n\t */\n\tif (lb->first_pblock &&\n\t\t(lb->last_pblock+1 == pblock) &&\n\t\t(lb->last_block+1 == lb->curr_block)) {\n\t\tlb->last_pblock = pblock;\n\t\tlb->last_block = lb->curr_block;\n\t\tlb->curr_block++;\n\t\treturn 0;\n\t}\n\t/*\n\t * Start a new range.\n\t */\n\tretval = finish_range(handle, inode, lb);\n\tlb->first_pblock = lb->last_pblock = pblock;\n\tlb->first_block = lb->last_block = lb->curr_block;\n\tlb->curr_block++;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "i_data[i]"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "pblock"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_ind_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t\t   ext4_fsblk_t pblock,\n\t\t\t\t   struct migrate_struct *lb)\n{\n\tstruct buffer_head *bh;\n\t__le32 *i_data;\n\tint i, retval = 0;\n\tunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\n\n\tbh = sb_bread(inode->i_sb, pblock);\n\tif (!bh)\n\t\treturn -EIO;\n\n\ti_data = (__le32 *)bh->b_data;\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (i_data[i]) {\n\t\t\tretval = update_extent_range(handle, inode,\n\t\t\t\t\t\tle32_to_cpu(i_data[i]), lb);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tlb->curr_block++;\n\t\t}\n\t}\n\tput_bh(bh);\n\treturn retval;\n\n}"
  },
  {
    "function_name": "update_extent_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "92-115",
    "snippet": "static int update_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_fsblk_t pblock, struct migrate_struct *lb)\n{\n\tint retval;\n\t/*\n\t * See if we can add on to the existing range (if it exists)\n\t */\n\tif (lb->first_pblock &&\n\t\t(lb->last_pblock+1 == pblock) &&\n\t\t(lb->last_block+1 == lb->curr_block)) {\n\t\tlb->last_pblock = pblock;\n\t\tlb->last_block = lb->curr_block;\n\t\tlb->curr_block++;\n\t\treturn 0;\n\t}\n\t/*\n\t * Start a new range.\n\t */\n\tretval = finish_range(handle, inode, lb);\n\tlb->first_pblock = lb->last_pblock = pblock;\n\tlb->first_block = lb->last_block = lb->curr_block;\n\tlb->curr_block++;\n\treturn retval;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_range",
          "args": [
            "handle",
            "inode",
            "lb"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "finish_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
          "lines": "28-90",
          "snippet": "static int finish_range(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct migrate_struct *lb)\n\n{\n\tint retval = 0, needed;\n\tstruct ext4_extent newext;\n\tstruct ext4_ext_path *path;\n\tif (lb->first_pblock == 0)\n\t\treturn 0;\n\n\t/* Add the extent to temp inode*/\n\tnewext.ee_block = cpu_to_le32(lb->first_block);\n\tnewext.ee_len   = cpu_to_le16(lb->last_block - lb->first_block + 1);\n\text4_ext_store_pblock(&newext, lb->first_pblock);\n\t/* Locking only for convinience since we are operating on temp inode */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tpath = ext4_find_extent(inode, lb->first_block, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tretval = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/*\n\t * Calculate the credit needed to inserting this extent\n\t * Since we are doing this in loop we may accumalate extra\n\t * credit. But below we try to not accumalate too much\n\t * of them by restarting the journal.\n\t */\n\tneeded = ext4_ext_calc_credits_for_single_extent(inode,\n\t\t    lb->last_block - lb->first_block + 1, path);\n\n\t/*\n\t * Make sure the credit we accumalated is not really high\n\t */\n\tif (needed && ext4_handle_has_enough_credits(handle,\n\t\t\t\t\t\tEXT4_RESERVE_TRANS_BLOCKS)) {\n\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\tretval = ext4_journal_restart(handle, needed);\n\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t} else if (needed) {\n\t\tretval = ext4_journal_extend(handle, needed);\n\t\tif (retval) {\n\t\t\t/*\n\t\t\t * IF not able to extend the journal restart the journal\n\t\t\t */\n\t\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tretval = ext4_journal_restart(handle, needed);\n\t\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = ext4_ext_insert_extent(handle, inode, &path, &newext, 0);\nerr_out:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tlb->first_pblock = 0;\n\treturn retval;\n}",
          "includes": [
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int finish_range(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct migrate_struct *lb)\n\n{\n\tint retval = 0, needed;\n\tstruct ext4_extent newext;\n\tstruct ext4_ext_path *path;\n\tif (lb->first_pblock == 0)\n\t\treturn 0;\n\n\t/* Add the extent to temp inode*/\n\tnewext.ee_block = cpu_to_le32(lb->first_block);\n\tnewext.ee_len   = cpu_to_le16(lb->last_block - lb->first_block + 1);\n\text4_ext_store_pblock(&newext, lb->first_pblock);\n\t/* Locking only for convinience since we are operating on temp inode */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tpath = ext4_find_extent(inode, lb->first_block, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tretval = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/*\n\t * Calculate the credit needed to inserting this extent\n\t * Since we are doing this in loop we may accumalate extra\n\t * credit. But below we try to not accumalate too much\n\t * of them by restarting the journal.\n\t */\n\tneeded = ext4_ext_calc_credits_for_single_extent(inode,\n\t\t    lb->last_block - lb->first_block + 1, path);\n\n\t/*\n\t * Make sure the credit we accumalated is not really high\n\t */\n\tif (needed && ext4_handle_has_enough_credits(handle,\n\t\t\t\t\t\tEXT4_RESERVE_TRANS_BLOCKS)) {\n\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\tretval = ext4_journal_restart(handle, needed);\n\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t} else if (needed) {\n\t\tretval = ext4_journal_extend(handle, needed);\n\t\tif (retval) {\n\t\t\t/*\n\t\t\t * IF not able to extend the journal restart the journal\n\t\t\t */\n\t\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tretval = ext4_journal_restart(handle, needed);\n\t\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = ext4_ext_insert_extent(handle, inode, &path, &newext, 0);\nerr_out:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tlb->first_pblock = 0;\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int update_extent_range(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_fsblk_t pblock, struct migrate_struct *lb)\n{\n\tint retval;\n\t/*\n\t * See if we can add on to the existing range (if it exists)\n\t */\n\tif (lb->first_pblock &&\n\t\t(lb->last_pblock+1 == pblock) &&\n\t\t(lb->last_block+1 == lb->curr_block)) {\n\t\tlb->last_pblock = pblock;\n\t\tlb->last_block = lb->curr_block;\n\t\tlb->curr_block++;\n\t\treturn 0;\n\t}\n\t/*\n\t * Start a new range.\n\t */\n\tretval = finish_range(handle, inode, lb);\n\tlb->first_pblock = lb->last_pblock = pblock;\n\tlb->first_block = lb->last_block = lb->curr_block;\n\tlb->curr_block++;\n\treturn retval;\n}"
  },
  {
    "function_name": "finish_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/migrate.c",
    "lines": "28-90",
    "snippet": "static int finish_range(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct migrate_struct *lb)\n\n{\n\tint retval = 0, needed;\n\tstruct ext4_extent newext;\n\tstruct ext4_ext_path *path;\n\tif (lb->first_pblock == 0)\n\t\treturn 0;\n\n\t/* Add the extent to temp inode*/\n\tnewext.ee_block = cpu_to_le32(lb->first_block);\n\tnewext.ee_len   = cpu_to_le16(lb->last_block - lb->first_block + 1);\n\text4_ext_store_pblock(&newext, lb->first_pblock);\n\t/* Locking only for convinience since we are operating on temp inode */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tpath = ext4_find_extent(inode, lb->first_block, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tretval = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/*\n\t * Calculate the credit needed to inserting this extent\n\t * Since we are doing this in loop we may accumalate extra\n\t * credit. But below we try to not accumalate too much\n\t * of them by restarting the journal.\n\t */\n\tneeded = ext4_ext_calc_credits_for_single_extent(inode,\n\t\t    lb->last_block - lb->first_block + 1, path);\n\n\t/*\n\t * Make sure the credit we accumalated is not really high\n\t */\n\tif (needed && ext4_handle_has_enough_credits(handle,\n\t\t\t\t\t\tEXT4_RESERVE_TRANS_BLOCKS)) {\n\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\tretval = ext4_journal_restart(handle, needed);\n\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t} else if (needed) {\n\t\tretval = ext4_journal_extend(handle, needed);\n\t\tif (retval) {\n\t\t\t/*\n\t\t\t * IF not able to extend the journal restart the journal\n\t\t\t */\n\t\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tretval = ext4_journal_restart(handle, needed);\n\t\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = ext4_ext_insert_extent(handle, inode, &path, &newext, 0);\nerr_out:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tlb->first_pblock = 0;\n\treturn retval;\n}",
    "includes": [
      "#include \"ext4_extents.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_drop_refs",
          "args": [
            "path"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_drop_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "708-720",
          "snippet": "void ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_drop_refs(struct ext4_ext_path *path)\n{\n\tint depth, i;\n\n\tif (!path)\n\t\treturn;\n\tdepth = path->p_depth;\n\tfor (i = 0; i <= depth; i++, path++)\n\t\tif (path->p_bh) {\n\t\t\tbrelse(path->p_bh);\n\t\t\tpath->p_bh = NULL;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_insert_extent",
          "args": [
            "handle",
            "inode",
            "&path",
            "&newext",
            "0"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "1929-2148",
          "snippet": "int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_extent *newext, int gb_flags)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tint mb_flags = 0, unwritten;\n\n\tif (gb_flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tmb_flags |= EXT4_MB_DELALLOC_RESERVED;\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EIO;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\teh = path[depth].p_hdr;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(gb_flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\n\t\t/*\n\t\t * Try to see whether we should rather test the extent on\n\t\t * right from ex, or from the left of ex. This is because\n\t\t * ext4_find_extent() can return either extent on the\n\t\t * left, or on the right from the searched position. This\n\t\t * will make merging more effective.\n\t\t */\n\t\tif (ex < EXT_LAST_EXTENT(eh) &&\n\t\t    (le32_to_cpu(ex->ee_block) +\n\t\t    ext4_ext_get_actual_len(ex) <\n\t\t    le32_to_cpu(newext->ee_block))) {\n\t\t\tex += 1;\n\t\t\tgoto prepend;\n\t\t} else if ((ex > EXT_FIRST_EXTENT(eh)) &&\n\t\t\t   (le32_to_cpu(newext->ee_block) +\n\t\t\t   ext4_ext_get_actual_len(newext) <\n\t\t\t   le32_to_cpu(ex->ee_block)))\n\t\t\tex -= 1;\n\n\t\t/* Try to append newex to the ex */\n\t\tif (ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\t\text_debug(\"append [%d]%d block to %u:[%d]%d\"\n\t\t\t\t  \"(from %llu)\\n\",\n\t\t\t\t  ext4_ext_is_unwritten(newext),\n\t\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t\t  ext4_ext_pblock(ex));\n\t\t\terr = ext4_ext_get_access(handle, inode,\n\t\t\t\t\t\t  path + depth);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\t\tif (unwritten)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\teh = path[depth].p_hdr;\n\t\t\tnearex = ex;\n\t\t\tgoto merge;\n\t\t}\n\nprepend:\n\t\t/* Try to prepend newex to the ex */\n\t\tif (ext4_can_extents_be_merged(inode, newext, ex)) {\n\t\t\text_debug(\"prepend %u[%d]%d block to %u:[%d]%d\"\n\t\t\t\t  \"(from %llu)\\n\",\n\t\t\t\t  le32_to_cpu(newext->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(newext),\n\t\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t\t  ext4_ext_pblock(ex));\n\t\t\terr = ext4_ext_get_access(handle, inode,\n\t\t\t\t\t\t  path + depth);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\t\tex->ee_block = newext->ee_block;\n\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(newext));\n\t\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\t\tif (unwritten)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\teh = path[depth].p_hdr;\n\t\t\tnearex = ex;\n\t\t\tgoto merge;\n\t\t}\n\t}\n\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = EXT_MAX_BLOCKS;\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))\n\t\tnext = ext4_ext_next_leaf_block(path);\n\tif (next != EXT_MAX_BLOCKS) {\n\t\text_debug(\"next leaf block - %u\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_find_extent(inode, next, NULL, 0);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto has_space;\n\t\t}\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)\n\t\tmb_flags |= EXT4_MB_USE_RESERVED;\n\terr = ext4_ext_create_new_leaf(handle, inode, mb_flags, gb_flags,\n\t\t\t\t       ppath, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug(\"first extent in the leaf: %u:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tnearex = EXT_FIRST_EXTENT(eh);\n\t} else {\n\t\tif (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n\t\t\t/* Insert after */\n\t\t\text_debug(\"insert %u:%llu:[%d]%d before: \"\n\t\t\t\t\t\"nearest %p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex);\n\t\t\tnearex++;\n\t\t} else {\n\t\t\t/* Insert before */\n\t\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\t\text_debug(\"insert %u:%llu:[%d]%d after: \"\n\t\t\t\t\t\"nearest %p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex);\n\t\t}\n\t\tlen = EXT_LAST_EXTENT(eh) - nearex + 1;\n\t\tif (len > 0) {\n\t\t\text_debug(\"insert %u:%llu:[%d]%d: \"\n\t\t\t\t\t\"move %d extents from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tlen, nearex, nearex + 1);\n\t\t\tmemmove(nearex + 1, nearex,\n\t\t\t\tlen * sizeof(struct ext4_extent));\n\t\t}\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tpath[depth].p_ext = nearex;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents */\n\tif (!(gb_flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(handle, inode, path, nearex);\n\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\ncleanup:\n\text4_ext_drop_refs(npath);\n\tkfree(npath);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_extent *newext, int gb_flags)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tint mb_flags = 0, unwritten;\n\n\tif (gb_flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tmb_flags |= EXT4_MB_DELALLOC_RESERVED;\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EIO;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\teh = path[depth].p_hdr;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(gb_flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\n\t\t/*\n\t\t * Try to see whether we should rather test the extent on\n\t\t * right from ex, or from the left of ex. This is because\n\t\t * ext4_find_extent() can return either extent on the\n\t\t * left, or on the right from the searched position. This\n\t\t * will make merging more effective.\n\t\t */\n\t\tif (ex < EXT_LAST_EXTENT(eh) &&\n\t\t    (le32_to_cpu(ex->ee_block) +\n\t\t    ext4_ext_get_actual_len(ex) <\n\t\t    le32_to_cpu(newext->ee_block))) {\n\t\t\tex += 1;\n\t\t\tgoto prepend;\n\t\t} else if ((ex > EXT_FIRST_EXTENT(eh)) &&\n\t\t\t   (le32_to_cpu(newext->ee_block) +\n\t\t\t   ext4_ext_get_actual_len(newext) <\n\t\t\t   le32_to_cpu(ex->ee_block)))\n\t\t\tex -= 1;\n\n\t\t/* Try to append newex to the ex */\n\t\tif (ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\t\text_debug(\"append [%d]%d block to %u:[%d]%d\"\n\t\t\t\t  \"(from %llu)\\n\",\n\t\t\t\t  ext4_ext_is_unwritten(newext),\n\t\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t\t  ext4_ext_pblock(ex));\n\t\t\terr = ext4_ext_get_access(handle, inode,\n\t\t\t\t\t\t  path + depth);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\t\tif (unwritten)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\teh = path[depth].p_hdr;\n\t\t\tnearex = ex;\n\t\t\tgoto merge;\n\t\t}\n\nprepend:\n\t\t/* Try to prepend newex to the ex */\n\t\tif (ext4_can_extents_be_merged(inode, newext, ex)) {\n\t\t\text_debug(\"prepend %u[%d]%d block to %u:[%d]%d\"\n\t\t\t\t  \"(from %llu)\\n\",\n\t\t\t\t  le32_to_cpu(newext->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(newext),\n\t\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t\t  ext4_ext_pblock(ex));\n\t\t\terr = ext4_ext_get_access(handle, inode,\n\t\t\t\t\t\t  path + depth);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\t\tex->ee_block = newext->ee_block;\n\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(newext));\n\t\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\t\tif (unwritten)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\teh = path[depth].p_hdr;\n\t\t\tnearex = ex;\n\t\t\tgoto merge;\n\t\t}\n\t}\n\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = EXT_MAX_BLOCKS;\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))\n\t\tnext = ext4_ext_next_leaf_block(path);\n\tif (next != EXT_MAX_BLOCKS) {\n\t\text_debug(\"next leaf block - %u\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_find_extent(inode, next, NULL, 0);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto has_space;\n\t\t}\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)\n\t\tmb_flags |= EXT4_MB_USE_RESERVED;\n\terr = ext4_ext_create_new_leaf(handle, inode, mb_flags, gb_flags,\n\t\t\t\t       ppath, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug(\"first extent in the leaf: %u:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tnearex = EXT_FIRST_EXTENT(eh);\n\t} else {\n\t\tif (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n\t\t\t/* Insert after */\n\t\t\text_debug(\"insert %u:%llu:[%d]%d before: \"\n\t\t\t\t\t\"nearest %p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex);\n\t\t\tnearex++;\n\t\t} else {\n\t\t\t/* Insert before */\n\t\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\t\text_debug(\"insert %u:%llu:[%d]%d after: \"\n\t\t\t\t\t\"nearest %p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex);\n\t\t}\n\t\tlen = EXT_LAST_EXTENT(eh) - nearex + 1;\n\t\tif (len > 0) {\n\t\t\text_debug(\"insert %u:%llu:[%d]%d: \"\n\t\t\t\t\t\"move %d extents from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_unwritten(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tlen, nearex, nearex + 1);\n\t\t\tmemmove(nearex + 1, nearex,\n\t\t\t\tlen * sizeof(struct ext4_extent));\n\t\t}\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tpath[depth].p_ext = nearex;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents */\n\tif (!(gb_flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(handle, inode, path, nearex);\n\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\ncleanup:\n\text4_ext_drop_refs(npath);\n\tkfree(npath);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_restart",
          "args": [
            "handle",
            "needed"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "343-348",
          "snippet": "static inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_extend",
          "args": [
            "handle",
            "needed"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "336-341",
          "snippet": "static inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_has_enough_credits",
          "args": [
            "handle",
            "EXT4_RESERVE_TRANS_BLOCKS"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_has_enough_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "292-297",
          "snippet": "static inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_calc_credits_for_single_extent",
          "args": [
            "inode",
            "lb->last_block - lb->first_block + 1",
            "path"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_calc_credits_for_single_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "2415-2441",
          "snippet": "int ext4_ext_calc_credits_for_single_extent(struct inode *inode, int nrblocks,\n\t\t\t\t\t\tstruct ext4_ext_path *path)\n{\n\tif (path) {\n\t\tint depth = ext_depth(inode);\n\t\tint ret = 0;\n\n\t\t/* probably there is space in leaf? */\n\t\tif (le16_to_cpu(path[depth].p_hdr->eh_entries)\n\t\t\t\t< le16_to_cpu(path[depth].p_hdr->eh_max)) {\n\n\t\t\t/*\n\t\t\t *  There are some space in the leaf tree, no\n\t\t\t *  need to account for leaf block credit\n\t\t\t *\n\t\t\t *  bitmaps and block group descriptor blocks\n\t\t\t *  and other metadata blocks still need to be\n\t\t\t *  accounted.\n\t\t\t */\n\t\t\t/* 1 bitmap, 1 block group descriptor */\n\t\t\tret = 2 + EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ext4_chunk_trans_blocks(inode, nrblocks);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_calc_credits_for_single_extent(struct inode *inode, int nrblocks,\n\t\t\t\t\t\tstruct ext4_ext_path *path)\n{\n\tif (path) {\n\t\tint depth = ext_depth(inode);\n\t\tint ret = 0;\n\n\t\t/* probably there is space in leaf? */\n\t\tif (le16_to_cpu(path[depth].p_hdr->eh_entries)\n\t\t\t\t< le16_to_cpu(path[depth].p_hdr->eh_max)) {\n\n\t\t\t/*\n\t\t\t *  There are some space in the leaf tree, no\n\t\t\t *  need to account for leaf block credit\n\t\t\t *\n\t\t\t *  bitmaps and block group descriptor blocks\n\t\t\t *  and other metadata blocks still need to be\n\t\t\t *  accounted.\n\t\t\t */\n\t\t\t/* 1 bitmap, 1 block group descriptor */\n\t\t\tret = 2 + EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ext4_chunk_trans_blocks(inode, nrblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_extent",
          "args": [
            "inode",
            "lb->first_block",
            "NULL",
            "0"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "857-939",
          "snippet": "struct ext4_ext_path *\next4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\t/* account possible depth increase */\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\n\ti = depth;\n\t/* walk through the tree */\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tif (unlikely(ppos > depth)) {\n\t\t\tput_bh(bh);\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"ppos %d > depth %d\", ppos, depth);\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\n\t/* find extent */\n\text4_ext_binsearch(inode, path + ppos, block);\n\t/* if not an empty leaf */\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\n\text4_ext_show_path(inode, path);\n\n\treturn path;\n\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);",
            "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);\nstatic int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);\n\nstruct ext4_ext_path *\next4_find_extent(struct inode *inode, ext4_lblk_t block,\n\t\t struct ext4_ext_path **orig_path, int flags)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct buffer_head *bh;\n\tstruct ext4_ext_path *path = orig_path ? *orig_path : NULL;\n\tshort int depth, i, ppos = 0;\n\tint ret;\n\n\teh = ext_inode_hdr(inode);\n\tdepth = ext_depth(inode);\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tif (depth > path[0].p_maxdepth) {\n\t\t\tkfree(path);\n\t\t\t*orig_path = path = NULL;\n\t\t}\n\t}\n\tif (!path) {\n\t\t/* account possible depth increase */\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),\n\t\t\t\tGFP_NOFS);\n\t\tif (unlikely(!path))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpath[0].p_maxdepth = depth + 1;\n\t}\n\tpath[0].p_hdr = eh;\n\tpath[0].p_bh = NULL;\n\n\ti = depth;\n\t/* walk through the tree */\n\twhile (i) {\n\t\text_debug(\"depth %d: num %d, max %d\\n\",\n\t\t\t  ppos, le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\n\t\text4_ext_binsearch_idx(inode, path + ppos, block);\n\t\tpath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\n\t\tpath[ppos].p_depth = i;\n\t\tpath[ppos].p_ext = NULL;\n\n\t\tbh = read_extent_tree_block(inode, path[ppos].p_block, --i,\n\t\t\t\t\t    flags);\n\t\tif (unlikely(IS_ERR(bh))) {\n\t\t\tret = PTR_ERR(bh);\n\t\t\tgoto err;\n\t\t}\n\n\t\teh = ext_block_hdr(bh);\n\t\tppos++;\n\t\tif (unlikely(ppos > depth)) {\n\t\t\tput_bh(bh);\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"ppos %d > depth %d\", ppos, depth);\n\t\t\tret = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tpath[ppos].p_bh = bh;\n\t\tpath[ppos].p_hdr = eh;\n\t}\n\n\tpath[ppos].p_depth = i;\n\tpath[ppos].p_ext = NULL;\n\tpath[ppos].p_idx = NULL;\n\n\t/* find extent */\n\text4_ext_binsearch(inode, path + ppos, block);\n\t/* if not an empty leaf */\n\tif (path[ppos].p_ext)\n\t\tpath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\n\n\text4_ext_show_path(inode, path);\n\n\treturn path;\n\nerr:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (orig_path)\n\t\t*orig_path = NULL;\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_store_pblock",
          "args": [
            "&newext",
            "lb->first_pblock"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_store_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_extents.h",
          "lines": "247-253",
          "snippet": "static inline void ext4_ext_store_pblock(struct ext4_extent *ex,\n\t\t\t\t\t ext4_fsblk_t pb)\n{\n\tex->ee_start_lo = cpu_to_le32((unsigned long) (pb & 0xffffffff));\n\tex->ee_start_hi = cpu_to_le16((unsigned long) ((pb >> 31) >> 1) &\n\t\t\t\t      0xffff);\n}",
          "includes": [
            "#include \"ext4.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n\nstatic inline void ext4_ext_store_pblock(struct ext4_extent *ex,\n\t\t\t\t\t ext4_fsblk_t pb)\n{\n\tex->ee_start_lo = cpu_to_le32((unsigned long) (pb & 0xffffffff));\n\tex->ee_start_hi = cpu_to_le16((unsigned long) ((pb >> 31) >> 1) &\n\t\t\t\t      0xffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "lb->last_block - lb->first_block + 1"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lb->first_block"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n\nstatic int finish_range(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct migrate_struct *lb)\n\n{\n\tint retval = 0, needed;\n\tstruct ext4_extent newext;\n\tstruct ext4_ext_path *path;\n\tif (lb->first_pblock == 0)\n\t\treturn 0;\n\n\t/* Add the extent to temp inode*/\n\tnewext.ee_block = cpu_to_le32(lb->first_block);\n\tnewext.ee_len   = cpu_to_le16(lb->last_block - lb->first_block + 1);\n\text4_ext_store_pblock(&newext, lb->first_pblock);\n\t/* Locking only for convinience since we are operating on temp inode */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tpath = ext4_find_extent(inode, lb->first_block, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tretval = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/*\n\t * Calculate the credit needed to inserting this extent\n\t * Since we are doing this in loop we may accumalate extra\n\t * credit. But below we try to not accumalate too much\n\t * of them by restarting the journal.\n\t */\n\tneeded = ext4_ext_calc_credits_for_single_extent(inode,\n\t\t    lb->last_block - lb->first_block + 1, path);\n\n\t/*\n\t * Make sure the credit we accumalated is not really high\n\t */\n\tif (needed && ext4_handle_has_enough_credits(handle,\n\t\t\t\t\t\tEXT4_RESERVE_TRANS_BLOCKS)) {\n\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\tretval = ext4_journal_restart(handle, needed);\n\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t} else if (needed) {\n\t\tretval = ext4_journal_extend(handle, needed);\n\t\tif (retval) {\n\t\t\t/*\n\t\t\t * IF not able to extend the journal restart the journal\n\t\t\t */\n\t\t\tup_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tretval = ext4_journal_restart(handle, needed);\n\t\t\tdown_write((&EXT4_I(inode)->i_data_sem));\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\tretval = ext4_ext_insert_extent(handle, inode, &path, &newext, 0);\nerr_out:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tlb->first_pblock = 0;\n\treturn retval;\n}"
  }
]