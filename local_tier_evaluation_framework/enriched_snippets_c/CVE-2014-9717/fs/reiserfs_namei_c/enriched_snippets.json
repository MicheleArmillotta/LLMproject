[
  {
    "function_name": "reiserfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "1281-1608",
    "snippet": "static int reiserfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint retval;\n\tINITIALIZE_PATH(old_entry_path);\n\tINITIALIZE_PATH(new_entry_path);\n\tINITIALIZE_PATH(dot_dot_entry_path);\n\tstruct item_head new_entry_ih, old_entry_ih, dot_dot_ih;\n\tstruct reiserfs_dir_entry old_de, new_de, dot_dot_de;\n\tstruct inode *old_inode, *new_dentry_inode;\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tumode_t old_inode_mode;\n\tunsigned long savelink = 1;\n\tstruct timespec ctime;\n\n\t/*\n\t * three balancings: (1) old name removal, (2) new name insertion\n\t * and (3) maybe \"save\" link insertion\n\t * stat data updates: (1) old directory,\n\t * (2) new directory and (3) maybe old object stat data (when it is\n\t * directory) and (4) maybe stat data of object to which new entry\n\t * pointed initially and (5) maybe block containing \"..\" of\n\t * renamed directory\n\t * quota updates: two parent directories\n\t */\n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 5 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(old_dir->i_sb);\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\told_inode = old_dentry->d_inode;\n\tnew_dentry_inode = new_dentry->d_inode;\n\n\t/*\n\t * make sure that oldname still exists and points to an object we\n\t * are going to rename\n\t */\n\told_de.de_gen_number_bit_string = NULL;\n\treiserfs_write_lock(old_dir->i_sb);\n\tretval =\n\t    reiserfs_find_entry(old_dir, old_dentry->d_name.name,\n\t\t\t\told_dentry->d_name.len, &old_entry_path,\n\t\t\t\t&old_de);\n\tpathrelse(&old_entry_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn -EIO;\n\t}\n\n\tif (retval != NAME_FOUND || old_de.de_objectid != old_inode->i_ino) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn -ENOENT;\n\t}\n\n\told_inode_mode = old_inode->i_mode;\n\tif (S_ISDIR(old_inode_mode)) {\n\t\t/*\n\t\t * make sure that directory being renamed has correct \"..\"\n\t\t * and that its new parent directory has not too many links\n\t\t * already\n\t\t */\n\t\tif (new_dentry_inode) {\n\t\t\tif (!reiserfs_empty_dir(new_dentry_inode)) {\n\t\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\t\treturn -ENOTEMPTY;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * directory is renamed, its parent directory will be changed,\n\t\t * so find \"..\" entry\n\t\t */\n\t\tdot_dot_de.de_gen_number_bit_string = NULL;\n\t\tretval =\n\t\t    reiserfs_find_entry(old_inode, \"..\", 2, &dot_dot_entry_path,\n\t\t\t\t\t&dot_dot_de);\n\t\tpathrelse(&dot_dot_entry_path);\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* inode number of .. must equal old_dir->i_ino */\n\t\tif (dot_dot_de.de_objectid != old_dir->i_ino) {\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tretval = journal_begin(&th, old_dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn retval;\n\t}\n\n\t/* add new entry (or find the existing one) */\n\tretval =\n\t    reiserfs_add_entry(&th, new_dir, new_dentry->d_name.name,\n\t\t\t       new_dentry->d_name.len, old_inode, 0);\n\tif (retval == -EEXIST) {\n\t\tif (!new_dentry_inode) {\n\t\t\treiserfs_panic(old_dir->i_sb, \"vs-7050\",\n\t\t\t\t       \"new entry is found, new inode == 0\");\n\t\t}\n\t} else if (retval) {\n\t\tint err = journal_end(&th);\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn err ? err : retval;\n\t}\n\n\treiserfs_update_inode_transaction(old_dir);\n\treiserfs_update_inode_transaction(new_dir);\n\n\t/*\n\t * this makes it so an fsync on an open fd for the old name will\n\t * commit the rename operation\n\t */\n\treiserfs_update_inode_transaction(old_inode);\n\n\tif (new_dentry_inode)\n\t\treiserfs_update_inode_transaction(new_dentry_inode);\n\n\twhile (1) {\n\t\t/*\n\t\t * look for old name using corresponding entry key\n\t\t * (found by reiserfs_find_entry)\n\t\t */\n\t\tif ((retval =\n\t\t     search_by_entry_key(new_dir->i_sb, &old_de.de_entry_key,\n\t\t\t\t\t &old_entry_path,\n\t\t\t\t\t &old_de)) != NAME_FOUND) {\n\t\t\tpathrelse(&old_entry_path);\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tcopy_item_head(&old_entry_ih, tp_item_head(&old_entry_path));\n\n\t\treiserfs_prepare_for_journal(old_inode->i_sb, old_de.de_bh, 1);\n\n\t\t/* look for new name by reiserfs_find_entry */\n\t\tnew_de.de_gen_number_bit_string = NULL;\n\t\tretval =\n\t\t    reiserfs_find_entry(new_dir, new_dentry->d_name.name,\n\t\t\t\t\tnew_dentry->d_name.len, &new_entry_path,\n\t\t\t\t\t&new_de);\n\t\t/*\n\t\t * reiserfs_add_entry should not return IO_ERROR,\n\t\t * because it is called with essentially same parameters from\n\t\t * reiserfs_add_entry above, and we'll catch any i/o errors\n\t\t * before we get here.\n\t\t */\n\t\tif (retval != NAME_FOUND_INVISIBLE && retval != NAME_FOUND) {\n\t\t\tpathrelse(&new_entry_path);\n\t\t\tpathrelse(&old_entry_path);\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tcopy_item_head(&new_entry_ih, tp_item_head(&new_entry_path));\n\n\t\treiserfs_prepare_for_journal(old_inode->i_sb, new_de.de_bh, 1);\n\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\tif ((retval =\n\t\t\t     search_by_entry_key(new_dir->i_sb,\n\t\t\t\t\t\t &dot_dot_de.de_entry_key,\n\t\t\t\t\t\t &dot_dot_entry_path,\n\t\t\t\t\t\t &dot_dot_de)) != NAME_FOUND) {\n\t\t\t\tpathrelse(&dot_dot_entry_path);\n\t\t\t\tpathrelse(&new_entry_path);\n\t\t\t\tpathrelse(&old_entry_path);\n\t\t\t\tjournal_end(&th);\n\t\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tcopy_item_head(&dot_dot_ih,\n\t\t\t\t       tp_item_head(&dot_dot_entry_path));\n\t\t\t/* node containing \"..\" gets into transaction */\n\t\t\treiserfs_prepare_for_journal(old_inode->i_sb,\n\t\t\t\t\t\t     dot_dot_de.de_bh, 1);\n\t\t}\n\t\t/*\n\t\t * we should check seals here, not do\n\t\t * this stuff, yes? Then, having\n\t\t * gathered everything into RAM we\n\t\t * should lock the buffers, yes?  -Hans\n\t\t */\n\t\t/*\n\t\t * probably.  our rename needs to hold more\n\t\t * than one path at once.  The seals would\n\t\t * have to be written to deal with multi-path\n\t\t * issues -chris\n\t\t */\n\t\t/*\n\t\t * sanity checking before doing the rename - avoid races many\n\t\t * of the above checks could have scheduled.  We have to be\n\t\t * sure our items haven't been shifted by another process.\n\t\t */\n\t\tif (item_moved(&new_entry_ih, &new_entry_path) ||\n\t\t    !entry_points_to_object(new_dentry->d_name.name,\n\t\t\t\t\t    new_dentry->d_name.len,\n\t\t\t\t\t    &new_de, new_dentry_inode) ||\n\t\t    item_moved(&old_entry_ih, &old_entry_path) ||\n\t\t    !entry_points_to_object(old_dentry->d_name.name,\n\t\t\t\t\t    old_dentry->d_name.len,\n\t\t\t\t\t    &old_de, old_inode)) {\n\t\t\treiserfs_restore_prepared_buffer(old_inode->i_sb,\n\t\t\t\t\t\t\t new_de.de_bh);\n\t\t\treiserfs_restore_prepared_buffer(old_inode->i_sb,\n\t\t\t\t\t\t\t old_de.de_bh);\n\t\t\tif (S_ISDIR(old_inode_mode))\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t dot_dot_de.\n\t\t\t\t\t\t\t\t de_bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(old_inode_mode)) {\n\t\t\tif (item_moved(&dot_dot_ih, &dot_dot_entry_path) ||\n\t\t\t    !entry_points_to_object(\"..\", 2, &dot_dot_de,\n\t\t\t\t\t\t    old_dir)) {\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t old_de.de_bh);\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t new_de.de_bh);\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t dot_dot_de.\n\t\t\t\t\t\t\t\t de_bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tRFALSE(S_ISDIR(old_inode_mode) &&\n\t\t       !buffer_journal_prepared(dot_dot_de.de_bh), \"\");\n\n\t\tbreak;\n\t}\n\n\t/*\n\t * ok, all the changes can be done in one fell swoop when we\n\t * have claimed all the buffers needed.\n\t */\n\n\tmark_de_visible(new_de.de_deh + new_de.de_entry_num);\n\tset_ino_in_dir_entry(&new_de, INODE_PKEY(old_inode));\n\tjournal_mark_dirty(&th, new_de.de_bh);\n\n\tmark_de_hidden(old_de.de_deh + old_de.de_entry_num);\n\tjournal_mark_dirty(&th, old_de.de_bh);\n\tctime = CURRENT_TIME_SEC;\n\told_dir->i_ctime = old_dir->i_mtime = ctime;\n\tnew_dir->i_ctime = new_dir->i_mtime = ctime;\n\t/*\n\t * thanks to Alex Adriaanse <alex_a@caltech.edu> for patch\n\t * which adds ctime update of renamed object\n\t */\n\told_inode->i_ctime = ctime;\n\n\tif (new_dentry_inode) {\n\t\t/* adjust link number of the victim */\n\t\tif (S_ISDIR(new_dentry_inode->i_mode)) {\n\t\t\tclear_nlink(new_dentry_inode);\n\t\t} else {\n\t\t\tdrop_nlink(new_dentry_inode);\n\t\t}\n\t\tnew_dentry_inode->i_ctime = ctime;\n\t\tsavelink = new_dentry_inode->i_nlink;\n\t}\n\n\tif (S_ISDIR(old_inode_mode)) {\n\t\t/* adjust \"..\" of renamed directory */\n\t\tset_ino_in_dir_entry(&dot_dot_de, INODE_PKEY(new_dir));\n\t\tjournal_mark_dirty(&th, dot_dot_de.de_bh);\n\n\t\t/*\n\t\t * there (in new_dir) was no directory, so it got new link\n\t\t * (\"..\"  of renamed directory)\n\t\t */\n\t\tif (!new_dentry_inode)\n\t\t\tINC_DIR_INODE_NLINK(new_dir);\n\n\t\t/* old directory lost one link - \".. \" of renamed directory */\n\t\tDEC_DIR_INODE_NLINK(old_dir);\n\t}\n\t/*\n\t * looks like in 2.3.99pre3 brelse is atomic.\n\t * so we can use pathrelse\n\t */\n\tpathrelse(&new_entry_path);\n\tpathrelse(&dot_dot_entry_path);\n\n\t/*\n\t * FIXME: this reiserfs_cut_from_item's return value may screw up\n\t * anybody, but it will panic if will not be able to find the\n\t * entry. This needs one more clean up\n\t */\n\tif (reiserfs_cut_from_item\n\t    (&th, &old_entry_path, &old_de.de_entry_key, old_dir, NULL,\n\t     0) < 0)\n\t\treiserfs_error(old_dir->i_sb, \"vs-7060\",\n\t\t\t       \"couldn't not cut old name. Fsck later?\");\n\n\told_dir->i_size -= DEH_SIZE + old_de.de_entrylen;\n\n\treiserfs_update_sd(&th, old_dir);\n\treiserfs_update_sd(&th, new_dir);\n\treiserfs_update_sd(&th, old_inode);\n\n\tif (new_dentry_inode) {\n\t\tif (savelink == 0)\n\t\t\tadd_save_link(&th, new_dentry_inode,\n\t\t\t\t      0 /* not truncate */ );\n\t\treiserfs_update_sd(&th, new_dentry_inode);\n\t}\n\n\tretval = journal_end(&th);\n\treiserfs_write_unlock(old_dir->i_sb);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "new_dentry_inode"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_save_link",
          "args": [
            "&th",
            "new_dentry_inode",
            "0/* not truncate */"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "add_save_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "395-473",
          "snippet": "void add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "old_dir->i_sb",
            "\"vs-7060\"",
            "\"couldn't not cut old name. Fsck later?\""
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_cut_from_item",
          "args": [
            "&th",
            "&old_entry_path",
            "&old_de.de_entry_key",
            "old_dir",
            "NULL",
            "0"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&dot_dot_entry_path"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEC_DIR_INODE_NLINK",
          "args": [
            "old_dir"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INC_DIR_INODE_NLINK",
          "args": [
            "new_dir"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "dot_dot_de.de_bh"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ino_in_dir_entry",
          "args": [
            "&dot_dot_de",
            "INODE_PKEY(new_dir)"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "set_ino_in_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "1268-1274",
          "snippet": "static void set_ino_in_dir_entry(struct reiserfs_dir_entry *de,\n\t\t\t\t struct reiserfs_key *key)\n{\n\t/* JDM These operations are endian safe - both are le */\n\tde->de_deh[de->de_entry_num].deh_dir_id = key->k_dir_id;\n\tde->de_deh[de->de_entry_num].deh_objectid = key->k_objectid;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic void set_ino_in_dir_entry(struct reiserfs_dir_entry *de,\n\t\t\t\t struct reiserfs_key *key)\n{\n\t/* JDM These operations are endian safe - both are le */\n\tde->de_deh[de->de_entry_num].deh_dir_id = key->k_dir_id;\n\tde->de_deh[de->de_entry_num].deh_objectid = key->k_objectid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "new_dir"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode_mode"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_dentry_inode"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "new_dentry_inode"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_dentry_inode->i_mode"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_hidden",
          "args": [
            "old_de.de_deh + old_de.de_entry_num"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "old_inode"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_visible",
          "args": [
            "new_de.de_deh + new_de.de_entry_num"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "S_ISDIR(old_inode_mode) &&\n\t\t       !buffer_journal_prepared(dot_dot_de.de_bh)",
            "\"\""
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_prepared",
          "args": [
            "dot_dot_de.de_bh"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode_mode"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "old_inode->\n\t\t\t\t\t\t\t\t i_sb",
            "dot_dot_de.\n\t\t\t\t\t\t\t\t de_bh"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_points_to_object",
          "args": [
            "\"..\"",
            "2",
            "&dot_dot_de",
            "old_dir"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "entry_points_to_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "1246-1265",
          "snippet": "static int entry_points_to_object(const char *name, int len,\n\t\t\t\t  struct reiserfs_dir_entry *de,\n\t\t\t\t  struct inode *inode)\n{\n\tif (!de_still_valid(name, len, de))\n\t\treturn 0;\n\n\tif (inode) {\n\t\tif (!de_visible(de->de_deh + de->de_entry_num))\n\t\t\treiserfs_panic(inode->i_sb, \"vs-7042\",\n\t\t\t\t       \"entry must be visible\");\n\t\treturn (de->de_objectid == inode->i_ino) ? 1 : 0;\n\t}\n\n\t/* this must be added hidden entry */\n\tif (de_visible(de->de_deh + de->de_entry_num))\n\t\treiserfs_panic(NULL, \"vs-7043\", \"entry must be visible\");\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int entry_points_to_object(const char *name, int len,\n\t\t\t\t  struct reiserfs_dir_entry *de,\n\t\t\t\t  struct inode *inode)\n{\n\tif (!de_still_valid(name, len, de))\n\t\treturn 0;\n\n\tif (inode) {\n\t\tif (!de_visible(de->de_deh + de->de_entry_num))\n\t\t\treiserfs_panic(inode->i_sb, \"vs-7042\",\n\t\t\t\t       \"entry must be visible\");\n\t\treturn (de->de_objectid == inode->i_ino) ? 1 : 0;\n\t}\n\n\t/* this must be added hidden entry */\n\tif (de_visible(de->de_deh + de->de_entry_num))\n\t\treiserfs_panic(NULL, \"vs-7043\", \"entry must be visible\");\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&dot_dot_ih",
            "&dot_dot_entry_path"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode_mode"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode_mode"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&old_entry_ih",
            "&old_entry_path"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_moved",
          "args": [
            "&new_entry_ih",
            "&new_entry_path"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "old_inode->i_sb",
            "dot_dot_de.de_bh",
            "1"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_item_head",
          "args": [
            "&dot_dot_ih",
            "tp_item_head(&dot_dot_entry_path)"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "copy_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "29-33",
          "snippet": "inline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from)\n{\n\tmemcpy(to, from, IH_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "&dot_dot_entry_path"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_by_entry_key",
          "args": [
            "new_dir->i_sb",
            "&dot_dot_de.de_entry_key",
            "&dot_dot_entry_path",
            "&dot_dot_de"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "search_by_entry_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "120-175",
          "snippet": "int search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_find_entry",
          "args": [
            "new_dir",
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "&new_entry_path",
            "&new_de"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "304-350",
          "snippet": "static int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "new_dentry_inode"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "old_dir->i_sb",
            "\"vs-7050\"",
            "\"new entry is found, new inode == 0\""
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_add_entry",
          "args": [
            "&th",
            "new_dir",
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "old_inode",
            "0"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "429-580",
          "snippet": "static int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "old_dir->i_sb",
            "jbegin_count"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_empty_dir",
          "args": [
            "new_dentry_inode"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "868-881",
          "snippet": "static inline int reiserfs_empty_dir(struct inode *inode)\n{\n\t/*\n\t * we can cheat because an old format dir cannot have\n\t * EMPTY_DIR_SIZE, and a new format dir cannot have\n\t * EMPTY_DIR_SIZE_V1.  So, if the inode is either size,\n\t * regardless of disk format version, the directory is empty.\n\t */\n\tif (inode->i_size != EMPTY_DIR_SIZE &&\n\t    inode->i_size != EMPTY_DIR_SIZE_V1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline int reiserfs_empty_dir(struct inode *inode)\n{\n\t/*\n\t * we can cheat because an old format dir cannot have\n\t * EMPTY_DIR_SIZE, and a new format dir cannot have\n\t * EMPTY_DIR_SIZE_V1.  So, if the inode is either size,\n\t * regardless of disk format version, the directory is empty.\n\t */\n\tif (inode->i_size != EMPTY_DIR_SIZE &&\n\t    inode->i_size != EMPTY_DIR_SIZE_V1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode_mode"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "new_dir"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "old_dir->i_sb"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "dot_dot_entry_path"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "new_entry_path"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "old_entry_path"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint retval;\n\tINITIALIZE_PATH(old_entry_path);\n\tINITIALIZE_PATH(new_entry_path);\n\tINITIALIZE_PATH(dot_dot_entry_path);\n\tstruct item_head new_entry_ih, old_entry_ih, dot_dot_ih;\n\tstruct reiserfs_dir_entry old_de, new_de, dot_dot_de;\n\tstruct inode *old_inode, *new_dentry_inode;\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tumode_t old_inode_mode;\n\tunsigned long savelink = 1;\n\tstruct timespec ctime;\n\n\t/*\n\t * three balancings: (1) old name removal, (2) new name insertion\n\t * and (3) maybe \"save\" link insertion\n\t * stat data updates: (1) old directory,\n\t * (2) new directory and (3) maybe old object stat data (when it is\n\t * directory) and (4) maybe stat data of object to which new entry\n\t * pointed initially and (5) maybe block containing \"..\" of\n\t * renamed directory\n\t * quota updates: two parent directories\n\t */\n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 + 5 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(old_dir->i_sb);\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\told_inode = old_dentry->d_inode;\n\tnew_dentry_inode = new_dentry->d_inode;\n\n\t/*\n\t * make sure that oldname still exists and points to an object we\n\t * are going to rename\n\t */\n\told_de.de_gen_number_bit_string = NULL;\n\treiserfs_write_lock(old_dir->i_sb);\n\tretval =\n\t    reiserfs_find_entry(old_dir, old_dentry->d_name.name,\n\t\t\t\told_dentry->d_name.len, &old_entry_path,\n\t\t\t\t&old_de);\n\tpathrelse(&old_entry_path);\n\tif (retval == IO_ERROR) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn -EIO;\n\t}\n\n\tif (retval != NAME_FOUND || old_de.de_objectid != old_inode->i_ino) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn -ENOENT;\n\t}\n\n\told_inode_mode = old_inode->i_mode;\n\tif (S_ISDIR(old_inode_mode)) {\n\t\t/*\n\t\t * make sure that directory being renamed has correct \"..\"\n\t\t * and that its new parent directory has not too many links\n\t\t * already\n\t\t */\n\t\tif (new_dentry_inode) {\n\t\t\tif (!reiserfs_empty_dir(new_dentry_inode)) {\n\t\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\t\treturn -ENOTEMPTY;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * directory is renamed, its parent directory will be changed,\n\t\t * so find \"..\" entry\n\t\t */\n\t\tdot_dot_de.de_gen_number_bit_string = NULL;\n\t\tretval =\n\t\t    reiserfs_find_entry(old_inode, \"..\", 2, &dot_dot_entry_path,\n\t\t\t\t\t&dot_dot_de);\n\t\tpathrelse(&dot_dot_entry_path);\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* inode number of .. must equal old_dir->i_ino */\n\t\tif (dot_dot_de.de_objectid != old_dir->i_ino) {\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tretval = journal_begin(&th, old_dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn retval;\n\t}\n\n\t/* add new entry (or find the existing one) */\n\tretval =\n\t    reiserfs_add_entry(&th, new_dir, new_dentry->d_name.name,\n\t\t\t       new_dentry->d_name.len, old_inode, 0);\n\tif (retval == -EEXIST) {\n\t\tif (!new_dentry_inode) {\n\t\t\treiserfs_panic(old_dir->i_sb, \"vs-7050\",\n\t\t\t\t       \"new entry is found, new inode == 0\");\n\t\t}\n\t} else if (retval) {\n\t\tint err = journal_end(&th);\n\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\treturn err ? err : retval;\n\t}\n\n\treiserfs_update_inode_transaction(old_dir);\n\treiserfs_update_inode_transaction(new_dir);\n\n\t/*\n\t * this makes it so an fsync on an open fd for the old name will\n\t * commit the rename operation\n\t */\n\treiserfs_update_inode_transaction(old_inode);\n\n\tif (new_dentry_inode)\n\t\treiserfs_update_inode_transaction(new_dentry_inode);\n\n\twhile (1) {\n\t\t/*\n\t\t * look for old name using corresponding entry key\n\t\t * (found by reiserfs_find_entry)\n\t\t */\n\t\tif ((retval =\n\t\t     search_by_entry_key(new_dir->i_sb, &old_de.de_entry_key,\n\t\t\t\t\t &old_entry_path,\n\t\t\t\t\t &old_de)) != NAME_FOUND) {\n\t\t\tpathrelse(&old_entry_path);\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tcopy_item_head(&old_entry_ih, tp_item_head(&old_entry_path));\n\n\t\treiserfs_prepare_for_journal(old_inode->i_sb, old_de.de_bh, 1);\n\n\t\t/* look for new name by reiserfs_find_entry */\n\t\tnew_de.de_gen_number_bit_string = NULL;\n\t\tretval =\n\t\t    reiserfs_find_entry(new_dir, new_dentry->d_name.name,\n\t\t\t\t\tnew_dentry->d_name.len, &new_entry_path,\n\t\t\t\t\t&new_de);\n\t\t/*\n\t\t * reiserfs_add_entry should not return IO_ERROR,\n\t\t * because it is called with essentially same parameters from\n\t\t * reiserfs_add_entry above, and we'll catch any i/o errors\n\t\t * before we get here.\n\t\t */\n\t\tif (retval != NAME_FOUND_INVISIBLE && retval != NAME_FOUND) {\n\t\t\tpathrelse(&new_entry_path);\n\t\t\tpathrelse(&old_entry_path);\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tcopy_item_head(&new_entry_ih, tp_item_head(&new_entry_path));\n\n\t\treiserfs_prepare_for_journal(old_inode->i_sb, new_de.de_bh, 1);\n\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\tif ((retval =\n\t\t\t     search_by_entry_key(new_dir->i_sb,\n\t\t\t\t\t\t &dot_dot_de.de_entry_key,\n\t\t\t\t\t\t &dot_dot_entry_path,\n\t\t\t\t\t\t &dot_dot_de)) != NAME_FOUND) {\n\t\t\t\tpathrelse(&dot_dot_entry_path);\n\t\t\t\tpathrelse(&new_entry_path);\n\t\t\t\tpathrelse(&old_entry_path);\n\t\t\t\tjournal_end(&th);\n\t\t\t\treiserfs_write_unlock(old_dir->i_sb);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tcopy_item_head(&dot_dot_ih,\n\t\t\t\t       tp_item_head(&dot_dot_entry_path));\n\t\t\t/* node containing \"..\" gets into transaction */\n\t\t\treiserfs_prepare_for_journal(old_inode->i_sb,\n\t\t\t\t\t\t     dot_dot_de.de_bh, 1);\n\t\t}\n\t\t/*\n\t\t * we should check seals here, not do\n\t\t * this stuff, yes? Then, having\n\t\t * gathered everything into RAM we\n\t\t * should lock the buffers, yes?  -Hans\n\t\t */\n\t\t/*\n\t\t * probably.  our rename needs to hold more\n\t\t * than one path at once.  The seals would\n\t\t * have to be written to deal with multi-path\n\t\t * issues -chris\n\t\t */\n\t\t/*\n\t\t * sanity checking before doing the rename - avoid races many\n\t\t * of the above checks could have scheduled.  We have to be\n\t\t * sure our items haven't been shifted by another process.\n\t\t */\n\t\tif (item_moved(&new_entry_ih, &new_entry_path) ||\n\t\t    !entry_points_to_object(new_dentry->d_name.name,\n\t\t\t\t\t    new_dentry->d_name.len,\n\t\t\t\t\t    &new_de, new_dentry_inode) ||\n\t\t    item_moved(&old_entry_ih, &old_entry_path) ||\n\t\t    !entry_points_to_object(old_dentry->d_name.name,\n\t\t\t\t\t    old_dentry->d_name.len,\n\t\t\t\t\t    &old_de, old_inode)) {\n\t\t\treiserfs_restore_prepared_buffer(old_inode->i_sb,\n\t\t\t\t\t\t\t new_de.de_bh);\n\t\t\treiserfs_restore_prepared_buffer(old_inode->i_sb,\n\t\t\t\t\t\t\t old_de.de_bh);\n\t\t\tif (S_ISDIR(old_inode_mode))\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t dot_dot_de.\n\t\t\t\t\t\t\t\t de_bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(old_inode_mode)) {\n\t\t\tif (item_moved(&dot_dot_ih, &dot_dot_entry_path) ||\n\t\t\t    !entry_points_to_object(\"..\", 2, &dot_dot_de,\n\t\t\t\t\t\t    old_dir)) {\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t old_de.de_bh);\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t new_de.de_bh);\n\t\t\t\treiserfs_restore_prepared_buffer(old_inode->\n\t\t\t\t\t\t\t\t i_sb,\n\t\t\t\t\t\t\t\t dot_dot_de.\n\t\t\t\t\t\t\t\t de_bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tRFALSE(S_ISDIR(old_inode_mode) &&\n\t\t       !buffer_journal_prepared(dot_dot_de.de_bh), \"\");\n\n\t\tbreak;\n\t}\n\n\t/*\n\t * ok, all the changes can be done in one fell swoop when we\n\t * have claimed all the buffers needed.\n\t */\n\n\tmark_de_visible(new_de.de_deh + new_de.de_entry_num);\n\tset_ino_in_dir_entry(&new_de, INODE_PKEY(old_inode));\n\tjournal_mark_dirty(&th, new_de.de_bh);\n\n\tmark_de_hidden(old_de.de_deh + old_de.de_entry_num);\n\tjournal_mark_dirty(&th, old_de.de_bh);\n\tctime = CURRENT_TIME_SEC;\n\told_dir->i_ctime = old_dir->i_mtime = ctime;\n\tnew_dir->i_ctime = new_dir->i_mtime = ctime;\n\t/*\n\t * thanks to Alex Adriaanse <alex_a@caltech.edu> for patch\n\t * which adds ctime update of renamed object\n\t */\n\told_inode->i_ctime = ctime;\n\n\tif (new_dentry_inode) {\n\t\t/* adjust link number of the victim */\n\t\tif (S_ISDIR(new_dentry_inode->i_mode)) {\n\t\t\tclear_nlink(new_dentry_inode);\n\t\t} else {\n\t\t\tdrop_nlink(new_dentry_inode);\n\t\t}\n\t\tnew_dentry_inode->i_ctime = ctime;\n\t\tsavelink = new_dentry_inode->i_nlink;\n\t}\n\n\tif (S_ISDIR(old_inode_mode)) {\n\t\t/* adjust \"..\" of renamed directory */\n\t\tset_ino_in_dir_entry(&dot_dot_de, INODE_PKEY(new_dir));\n\t\tjournal_mark_dirty(&th, dot_dot_de.de_bh);\n\n\t\t/*\n\t\t * there (in new_dir) was no directory, so it got new link\n\t\t * (\"..\"  of renamed directory)\n\t\t */\n\t\tif (!new_dentry_inode)\n\t\t\tINC_DIR_INODE_NLINK(new_dir);\n\n\t\t/* old directory lost one link - \".. \" of renamed directory */\n\t\tDEC_DIR_INODE_NLINK(old_dir);\n\t}\n\t/*\n\t * looks like in 2.3.99pre3 brelse is atomic.\n\t * so we can use pathrelse\n\t */\n\tpathrelse(&new_entry_path);\n\tpathrelse(&dot_dot_entry_path);\n\n\t/*\n\t * FIXME: this reiserfs_cut_from_item's return value may screw up\n\t * anybody, but it will panic if will not be able to find the\n\t * entry. This needs one more clean up\n\t */\n\tif (reiserfs_cut_from_item\n\t    (&th, &old_entry_path, &old_de.de_entry_key, old_dir, NULL,\n\t     0) < 0)\n\t\treiserfs_error(old_dir->i_sb, \"vs-7060\",\n\t\t\t       \"couldn't not cut old name. Fsck later?\");\n\n\told_dir->i_size -= DEH_SIZE + old_de.de_entrylen;\n\n\treiserfs_update_sd(&th, old_dir);\n\treiserfs_update_sd(&th, new_dir);\n\treiserfs_update_sd(&th, old_inode);\n\n\tif (new_dentry_inode) {\n\t\tif (savelink == 0)\n\t\t\tadd_save_link(&th, new_dentry_inode,\n\t\t\t\t      0 /* not truncate */ );\n\t\treiserfs_update_sd(&th, new_dentry_inode);\n\t}\n\n\tretval = journal_end(&th);\n\treiserfs_write_unlock(old_dir->i_sb);\n\treturn retval;\n}"
  },
  {
    "function_name": "set_ino_in_dir_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "1268-1274",
    "snippet": "static void set_ino_in_dir_entry(struct reiserfs_dir_entry *de,\n\t\t\t\t struct reiserfs_key *key)\n{\n\t/* JDM These operations are endian safe - both are le */\n\tde->de_deh[de->de_entry_num].deh_dir_id = key->k_dir_id;\n\tde->de_deh[de->de_entry_num].deh_objectid = key->k_objectid;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic void set_ino_in_dir_entry(struct reiserfs_dir_entry *de,\n\t\t\t\t struct reiserfs_key *key)\n{\n\t/* JDM These operations are endian safe - both are le */\n\tde->de_deh[de->de_entry_num].deh_dir_id = key->k_dir_id;\n\tde->de_deh[de->de_entry_num].deh_objectid = key->k_objectid;\n}"
  },
  {
    "function_name": "entry_points_to_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "1246-1265",
    "snippet": "static int entry_points_to_object(const char *name, int len,\n\t\t\t\t  struct reiserfs_dir_entry *de,\n\t\t\t\t  struct inode *inode)\n{\n\tif (!de_still_valid(name, len, de))\n\t\treturn 0;\n\n\tif (inode) {\n\t\tif (!de_visible(de->de_deh + de->de_entry_num))\n\t\t\treiserfs_panic(inode->i_sb, \"vs-7042\",\n\t\t\t\t       \"entry must be visible\");\n\t\treturn (de->de_objectid == inode->i_ino) ? 1 : 0;\n\t}\n\n\t/* this must be added hidden entry */\n\tif (de_visible(de->de_deh + de->de_entry_num))\n\t\treiserfs_panic(NULL, \"vs-7043\", \"entry must be visible\");\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "NULL",
            "\"vs-7043\"",
            "\"entry must be visible\""
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_visible",
          "args": [
            "de->de_deh + de->de_entry_num"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "inode->i_sb",
            "\"vs-7042\"",
            "\"entry must be visible\""
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_visible",
          "args": [
            "de->de_deh + de->de_entry_num"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_still_valid",
          "args": [
            "name",
            "len",
            "de"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "de_still_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "1233-1244",
          "snippet": "static int de_still_valid(const char *name, int len,\n\t\t\t  struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_dir_entry tmp = *de;\n\n\t/* recalculate pointer to name and name length */\n\tset_de_name_and_namelen(&tmp);\n\t/* FIXME: could check more */\n\tif (tmp.de_namelen != len || memcmp(name, de->de_name, len))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int de_still_valid(const char *name, int len,\n\t\t\t  struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_dir_entry tmp = *de;\n\n\t/* recalculate pointer to name and name length */\n\tset_de_name_and_namelen(&tmp);\n\t/* FIXME: could check more */\n\tif (tmp.de_namelen != len || memcmp(name, de->de_name, len))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int entry_points_to_object(const char *name, int len,\n\t\t\t\t  struct reiserfs_dir_entry *de,\n\t\t\t\t  struct inode *inode)\n{\n\tif (!de_still_valid(name, len, de))\n\t\treturn 0;\n\n\tif (inode) {\n\t\tif (!de_visible(de->de_deh + de->de_entry_num))\n\t\t\treiserfs_panic(inode->i_sb, \"vs-7042\",\n\t\t\t\t       \"entry must be visible\");\n\t\treturn (de->de_objectid == inode->i_ino) ? 1 : 0;\n\t}\n\n\t/* this must be added hidden entry */\n\tif (de_visible(de->de_deh + de->de_entry_num))\n\t\treiserfs_panic(NULL, \"vs-7043\", \"entry must be visible\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "de_still_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "1233-1244",
    "snippet": "static int de_still_valid(const char *name, int len,\n\t\t\t  struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_dir_entry tmp = *de;\n\n\t/* recalculate pointer to name and name length */\n\tset_de_name_and_namelen(&tmp);\n\t/* FIXME: could check more */\n\tif (tmp.de_namelen != len || memcmp(name, de->de_name, len))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "de->de_name",
            "len"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_de_name_and_namelen",
          "args": [
            "&tmp"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_name_and_namelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "72-83",
          "snippet": "inline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\ninline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int de_still_valid(const char *name, int len,\n\t\t\t  struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_dir_entry tmp = *de;\n\n\t/* recalculate pointer to name and name length */\n\tset_de_name_and_namelen(&tmp);\n\t/* FIXME: could check more */\n\tif (tmp.de_namelen != len || memcmp(name, de->de_name, len))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "reiserfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "1173-1230",
    "snippet": "static int reiserfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct reiserfs_transaction_handle th;\n\t/*\n\t * We need blocks for transaction + update of quotas for\n\t * the owners of the directory\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\tdquot_initialize(dir);\n\n\treiserfs_write_lock(dir->i_sb);\n\tif (inode->i_nlink >= REISERFS_LINK_MAX) {\n\t\t/* FIXME: sd_nlink is 32 bit for new files */\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn -EMLINK;\n\t}\n\n\t/* inc before scheduling so reiserfs_unlink knows we are here */\n\tinc_nlink(inode);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_nlink(inode);\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn retval;\n\t}\n\n\t/* create new entry */\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1 /*visible */ );\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\terr = journal_end(&th);\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn err ? err : retval;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\treiserfs_update_sd(&th, inode);\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "inode"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "dir"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_add_entry",
          "args": [
            "&th",
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "inode",
            "1/*visible */"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "429-580",
          "snippet": "static int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dir->i_sb",
            "jbegin_count"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *dentry)\n{\n\tint retval;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct reiserfs_transaction_handle th;\n\t/*\n\t * We need blocks for transaction + update of quotas for\n\t * the owners of the directory\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\tdquot_initialize(dir);\n\n\treiserfs_write_lock(dir->i_sb);\n\tif (inode->i_nlink >= REISERFS_LINK_MAX) {\n\t\t/* FIXME: sd_nlink is 32 bit for new files */\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn -EMLINK;\n\t}\n\n\t/* inc before scheduling so reiserfs_unlink knows we are here */\n\tinc_nlink(inode);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_nlink(inode);\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn retval;\n\t}\n\n\t/* create new entry */\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1 /*visible */ );\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\terr = journal_end(&th);\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn err ? err : retval;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\treiserfs_update_sd(&th, inode);\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "1079-1171",
    "snippet": "static int reiserfs_symlink(struct inode *parent_dir,\n\t\t\t    struct dentry *dentry, const char *symname)\n{\n\tint retval;\n\tstruct inode *inode;\n\tchar *name;\n\tint item_len;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\tint mode = S_IFLNK | S_IRWXUGO;\n\t/*\n\t * We need blocks for transaction + (user+group)*(quotas for\n\t * new inode + update of quota for directory owner)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(parent_dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(parent_dir->i_sb));\n\n\tdquot_initialize(parent_dir);\n\n\tif (!(inode = new_inode(parent_dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tnew_inode_init(inode, parent_dir, mode);\n\n\tretval = reiserfs_security_init(parent_dir, inode, &dentry->d_name,\n\t\t\t\t\t&security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\n\treiserfs_write_lock(parent_dir->i_sb);\n\titem_len = ROUND_UP(strlen(symname));\n\tif (item_len > MAX_DIRECT_ITEM_LEN(parent_dir->i_sb->s_blocksize)) {\n\t\tretval = -ENAMETOOLONG;\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tname = kmalloc(item_len, GFP_NOFS);\n\tif (!name) {\n\t\tdrop_new_inode(inode);\n\t\tretval = -ENOMEM;\n\t\tgoto out_failed;\n\t}\n\tmemcpy(name, symname, strlen(symname));\n\tpadd_item(name, item_len, strlen(symname));\n\n\tretval = journal_begin(&th, parent_dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tkfree(name);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, parent_dir, mode, name, strlen(symname),\n\t\t\t       dentry, inode, &security);\n\tkfree(name);\n\tif (retval) {\t\t/* reiserfs_new_inode iputs for us */\n\t\tgoto out_failed;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(parent_dir);\n\n\tinode->i_op = &reiserfs_symlink_inode_operations;\n\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\n\tretval = reiserfs_add_entry(&th, parent_dir, dentry->d_name.name,\n\t\t\t\t    dentry->d_name.len, inode, 1 /*visible */ );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\nout_failed:\n\treiserfs_write_unlock(parent_dir->i_sb);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations reiserfs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = page_follow_link_light,\n\t.put_link = page_put_link,\n\t.setattr = reiserfs_setattr,\n\t.setxattr = reiserfs_setxattr,\n\t.getxattr = reiserfs_getxattr,\n\t.listxattr = reiserfs_listxattr,\n\t.removexattr = reiserfs_removexattr,\n\t.permission = reiserfs_permission,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "parent_dir->i_sb"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "inode"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_add_entry",
          "args": [
            "&th",
            "parent_dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "inode",
            "1/*visible */"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "429-580",
          "snippet": "static int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "parent_dir"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_new_inode",
          "args": [
            "&th",
            "parent_dir",
            "mode",
            "name",
            "strlen(symname)",
            "dentry",
            "inode",
            "&security"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1926-2167",
          "snippet": "int reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_new_inode",
          "args": [
            "inode"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "parent_dir->i_sb",
            "jbegin_count"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padd_item",
          "args": [
            "name",
            "item_len",
            "strlen(symname)"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "padd_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1189-1195",
          "snippet": "void padd_item(char *item, int total_length, int length)\n{\n\tint i;\n\n\tfor (i = total_length; i > length;)\n\t\titem[--i] = 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid padd_item(char *item, int total_length, int length)\n{\n\tint i;\n\n\tfor (i = total_length; i > length;)\n\t\titem[--i] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name",
            "symname",
            "strlen(symname)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "item_len",
            "GFP_NOFS"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_DIRECT_ITEM_LEN",
          "args": [
            "parent_dir->i_sb->s_blocksize"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "strlen(symname)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "parent_dir->i_sb"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_security_init",
          "args": [
            "parent_dir",
            "inode",
            "&dentry->d_name",
            "&security"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_security_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
          "lines": "56-89",
          "snippet": "int reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include \"xattr.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nint reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_init",
          "args": [
            "inode",
            "parent_dir",
            "mode"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "603-618",
          "snippet": "static int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "parent_dir"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "parent_dir->i_sb"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_INIT_BLOCKS",
          "args": [
            "parent_dir->i_sb"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nconst struct inode_operations reiserfs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = page_follow_link_light,\n\t.put_link = page_put_link,\n\t.setattr = reiserfs_setattr,\n\t.setxattr = reiserfs_setxattr,\n\t.getxattr = reiserfs_getxattr,\n\t.listxattr = reiserfs_listxattr,\n\t.removexattr = reiserfs_removexattr,\n\t.permission = reiserfs_permission,\n};\n\nstatic int reiserfs_symlink(struct inode *parent_dir,\n\t\t\t    struct dentry *dentry, const char *symname)\n{\n\tint retval;\n\tstruct inode *inode;\n\tchar *name;\n\tint item_len;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\tint mode = S_IFLNK | S_IRWXUGO;\n\t/*\n\t * We need blocks for transaction + (user+group)*(quotas for\n\t * new inode + update of quota for directory owner)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(parent_dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(parent_dir->i_sb));\n\n\tdquot_initialize(parent_dir);\n\n\tif (!(inode = new_inode(parent_dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tnew_inode_init(inode, parent_dir, mode);\n\n\tretval = reiserfs_security_init(parent_dir, inode, &dentry->d_name,\n\t\t\t\t\t&security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\n\treiserfs_write_lock(parent_dir->i_sb);\n\titem_len = ROUND_UP(strlen(symname));\n\tif (item_len > MAX_DIRECT_ITEM_LEN(parent_dir->i_sb->s_blocksize)) {\n\t\tretval = -ENAMETOOLONG;\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tname = kmalloc(item_len, GFP_NOFS);\n\tif (!name) {\n\t\tdrop_new_inode(inode);\n\t\tretval = -ENOMEM;\n\t\tgoto out_failed;\n\t}\n\tmemcpy(name, symname, strlen(symname));\n\tpadd_item(name, item_len, strlen(symname));\n\n\tretval = journal_begin(&th, parent_dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tkfree(name);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, parent_dir, mode, name, strlen(symname),\n\t\t\t       dentry, inode, &security);\n\tkfree(name);\n\tif (retval) {\t\t/* reiserfs_new_inode iputs for us */\n\t\tgoto out_failed;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(parent_dir);\n\n\tinode->i_op = &reiserfs_symlink_inode_operations;\n\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\n\tretval = reiserfs_add_entry(&th, parent_dir, dentry->d_name.name,\n\t\t\t\t    dentry->d_name.len, inode, 1 /*visible */ );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\nout_failed:\n\treiserfs_write_unlock(parent_dir->i_sb);\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "978-1077",
    "snippet": "static int reiserfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval, err;\n\tstruct inode *inode;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tunsigned long savelink;\n\n\tdquot_initialize(dir);\n\n\tinode = dentry->d_inode;\n\n\t/*\n\t * in this transaction we can be doing at max two balancings and\n\t * update two stat datas, we change quotas of the owner of the\n\t * directory and of the owner of the parent directory. The quota\n\t * structure is possibly deleted only on iput => outside of\n\t * this transaction\n\t */\n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval)\n\t\tgoto out_unlink;\n\n\tde.de_gen_number_bit_string = NULL;\n\tif ((retval =\n\t     reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t &path, &de)) == NAME_NOT_FOUND) {\n\t\tretval = -ENOENT;\n\t\tgoto end_unlink;\n\t} else if (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto end_unlink;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (de.de_objectid != inode->i_ino) {\n\t\t/*\n\t\t * FIXME: compare key of an object and a key found in the entry\n\t\t */\n\t\tretval = -EIO;\n\t\tgoto end_unlink;\n\t}\n\n\tif (!inode->i_nlink) {\n\t\treiserfs_warning(inode->i_sb, \"reiserfs-7042\",\n\t\t\t\t \"deleting nonexistent file (%lu), %d\",\n\t\t\t\t inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\n\tdrop_nlink(inode);\n\n\t/*\n\t * we schedule before doing the add_save_link call, save the link\n\t * count so we don't race\n\t */\n\tsavelink = inode->i_nlink;\n\n\tretval =\n\t    reiserfs_cut_from_item(&th, &path, &de.de_entry_key, dir, NULL,\n\t\t\t\t   0);\n\tif (retval < 0) {\n\t\tinc_nlink(inode);\n\t\tgoto end_unlink;\n\t}\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\treiserfs_update_sd(&th, inode);\n\n\tdir->i_size -= (de.de_entrylen + DEH_SIZE);\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\treiserfs_update_sd(&th, dir);\n\n\tif (!savelink)\n\t\t/* prevent file from getting lost */\n\t\tadd_save_link(&th, inode, 0 /* not truncate */ );\n\n\tretval = journal_end(&th);\n\treiserfs_check_path(&path);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n\nend_unlink:\n\tpathrelse(&path);\n\terr = journal_end(&th);\n\treiserfs_check_path(&path);\n\tif (err)\n\t\tretval = err;\nout_unlink:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&path"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_save_link",
          "args": [
            "&th",
            "inode",
            "0/* not truncate */"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "add_save_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "395-473",
          "snippet": "void add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "dir"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_cut_from_item",
          "args": [
            "&th",
            "&path",
            "&de.de_entry_key",
            "dir",
            "NULL",
            "0"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"reiserfs-7042\"",
            "\"deleting nonexistent file (%lu), %d\"",
            "inode->i_ino",
            "inode->i_nlink"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "dir"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_find_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&path",
            "&de"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "304-350",
          "snippet": "static int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dir->i_sb",
            "jbegin_count"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint retval, err;\n\tstruct inode *inode;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tunsigned long savelink;\n\n\tdquot_initialize(dir);\n\n\tinode = dentry->d_inode;\n\n\t/*\n\t * in this transaction we can be doing at max two balancings and\n\t * update two stat datas, we change quotas of the owner of the\n\t * directory and of the owner of the parent directory. The quota\n\t * structure is possibly deleted only on iput => outside of\n\t * this transaction\n\t */\n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval)\n\t\tgoto out_unlink;\n\n\tde.de_gen_number_bit_string = NULL;\n\tif ((retval =\n\t     reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t &path, &de)) == NAME_NOT_FOUND) {\n\t\tretval = -ENOENT;\n\t\tgoto end_unlink;\n\t} else if (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto end_unlink;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (de.de_objectid != inode->i_ino) {\n\t\t/*\n\t\t * FIXME: compare key of an object and a key found in the entry\n\t\t */\n\t\tretval = -EIO;\n\t\tgoto end_unlink;\n\t}\n\n\tif (!inode->i_nlink) {\n\t\treiserfs_warning(inode->i_sb, \"reiserfs-7042\",\n\t\t\t\t \"deleting nonexistent file (%lu), %d\",\n\t\t\t\t inode->i_ino, inode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\n\tdrop_nlink(inode);\n\n\t/*\n\t * we schedule before doing the add_save_link call, save the link\n\t * count so we don't race\n\t */\n\tsavelink = inode->i_nlink;\n\n\tretval =\n\t    reiserfs_cut_from_item(&th, &path, &de.de_entry_key, dir, NULL,\n\t\t\t\t   0);\n\tif (retval < 0) {\n\t\tinc_nlink(inode);\n\t\tgoto end_unlink;\n\t}\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\treiserfs_update_sd(&th, inode);\n\n\tdir->i_size -= (de.de_entrylen + DEH_SIZE);\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\treiserfs_update_sd(&th, dir);\n\n\tif (!savelink)\n\t\t/* prevent file from getting lost */\n\t\tadd_save_link(&th, inode, 0 /* not truncate */ );\n\n\tretval = journal_end(&th);\n\treiserfs_check_path(&path);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n\nend_unlink:\n\tpathrelse(&path);\n\terr = journal_end(&th);\n\treiserfs_check_path(&path);\n\tif (err)\n\t\tretval = err;\nout_unlink:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "883-976",
    "snippet": "static int reiserfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval, err;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\n\t/*\n\t * we will be doing 2 balancings and update 2 stat data, we\n\t * change quotas of the owner of the directory and of the owner\n\t * of the parent directory.  The quota structure is possibly\n\t * deleted only on last iput => outside of this transaction\n\t */\n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\tdquot_initialize(dir);\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval)\n\t\tgoto out_rmdir;\n\n\tde.de_gen_number_bit_string = NULL;\n\tif ((retval =\n\t     reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t &path, &de)) == NAME_NOT_FOUND) {\n\t\tretval = -ENOENT;\n\t\tgoto end_rmdir;\n\t} else if (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto end_rmdir;\n\t}\n\n\tinode = dentry->d_inode;\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (de.de_objectid != inode->i_ino) {\n\t\t/*\n\t\t * FIXME: compare key of an object and a key found in the entry\n\t\t */\n\t\tretval = -EIO;\n\t\tgoto end_rmdir;\n\t}\n\tif (!reiserfs_empty_dir(inode)) {\n\t\tretval = -ENOTEMPTY;\n\t\tgoto end_rmdir;\n\t}\n\n\t/* cut entry from dir directory */\n\tretval = reiserfs_cut_from_item(&th, &path, &de.de_entry_key,\n\t\t\t\t\tdir, NULL,\t/* page */\n\t\t\t\t\t0 /*new file size - not used here */ );\n\tif (retval < 0)\n\t\tgoto end_rmdir;\n\n\tif (inode->i_nlink != 2 && inode->i_nlink != 1)\n\t\treiserfs_error(inode->i_sb, \"reiserfs-7040\",\n\t\t\t       \"empty directory has nlink != 2 (%d)\",\n\t\t\t       inode->i_nlink);\n\n\tclear_nlink(inode);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\treiserfs_update_sd(&th, inode);\n\n\tDEC_DIR_INODE_NLINK(dir)\n\t    dir->i_size -= (DEH_SIZE + de.de_entrylen);\n\treiserfs_update_sd(&th, dir);\n\n\t/* prevent empty directory from getting lost */\n\tadd_save_link(&th, inode, 0 /* not truncate */ );\n\n\tretval = journal_end(&th);\n\treiserfs_check_path(&path);\nout_rmdir:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n\nend_rmdir:\n\t/*\n\t * we must release path, because we did not call\n\t * reiserfs_cut_from_item, or reiserfs_cut_from_item does not\n\t * release path if operation was not complete\n\t */\n\tpathrelse(&path);\n\terr = journal_end(&th);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn err ? err : retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&path"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_save_link",
          "args": [
            "&th",
            "inode",
            "0/* not truncate */"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "add_save_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "395-473",
          "snippet": "void add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid add_save_link(struct reiserfs_transaction_handle *th,\n\t\t   struct inode *inode, int truncate)\n{\n\tINITIALIZE_PATH(path);\n\tint retval;\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\t__le32 link;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* file can only get one \"save link\" of each kind */\n\tRFALSE(truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_truncate_mask),\n\t       \"saved link already exists for truncated inode %lx\",\n\t       (long)inode->i_ino);\n\tRFALSE(!truncate &&\n\t       (REISERFS_I(inode)->i_flags & i_link_saved_unlink_mask),\n\t       \"saved link already exists for unlinked inode %lx\",\n\t       (long)inode->i_ino);\n\n\t/* setup key of \"save\" link */\n\tkey.version = KEY_FORMAT_3_5;\n\tkey.on_disk_key.k_dir_id = MAX_KEY_OBJECTID;\n\tkey.on_disk_key.k_objectid = inode->i_ino;\n\tif (!truncate) {\n\t\t/* unlink, rmdir, rename */\n\t\tset_cpu_key_k_offset(&key, 1 + inode->i_sb->s_blocksize);\n\t\tset_cpu_key_k_type(&key, TYPE_DIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version,\n\t\t\t\t  1 + inode->i_sb->s_blocksize, TYPE_DIRECT,\n\t\t\t\t  4 /*length */ , 0xffff /*free space */ );\n\t} else {\n\t\t/* truncate */\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treiserfs_warning(inode->i_sb, \"green-2102\",\n\t\t\t\t\t \"Adding a truncate savelink for \"\n\t\t\t\t\t \"a directory %k! Please report\",\n\t\t\t\t\t INODE_PKEY(inode));\n\t\tset_cpu_key_k_offset(&key, 1);\n\t\tset_cpu_key_k_type(&key, TYPE_INDIRECT);\n\n\t\t/* item head of \"safe\" link */\n\t\tmake_le_item_head(&ih, &key, key.version, 1, TYPE_INDIRECT,\n\t\t\t\t  4 /*length */ , 0 /*free space */ );\n\t}\n\tkey.key_length = 3;\n\n\t/* look for its place in the tree */\n\tretval = search_item(inode->i_sb, &key, &path);\n\tif (retval != ITEM_NOT_FOUND) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2100\",\n\t\t\t\t       \"search_by_key (%K) returned %d\", &key,\n\t\t\t\t       retval);\n\t\tpathrelse(&path);\n\t\treturn;\n\t}\n\n\t/* body of \"save\" link */\n\tlink = INODE_PKEY(inode)->k_dir_id;\n\n\t/* put \"save\" link into tree, don't charge quota to anyone */\n\tretval =\n\t    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);\n\tif (retval) {\n\t\tif (retval != -ENOSPC)\n\t\t\treiserfs_error(inode->i_sb, \"vs-2120\",\n\t\t\t\t       \"insert_item returned %d\", retval);\n\t} else {\n\t\tif (truncate)\n\t\t\tREISERFS_I(inode)->i_flags |=\n\t\t\t    i_link_saved_truncate_mask;\n\t\telse\n\t\t\tREISERFS_I(inode)->i_flags |= i_link_saved_unlink_mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "dir"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "inode->i_sb",
            "\"reiserfs-7040\"",
            "\"empty directory has nlink != 2 (%d)\"",
            "inode->i_nlink"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_cut_from_item",
          "args": [
            "&th",
            "&path",
            "&de.de_entry_key",
            "dir",
            "NULL",
            "/* page */0/*new file size - not used here */"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_empty_dir",
          "args": [
            "inode"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "868-881",
          "snippet": "static inline int reiserfs_empty_dir(struct inode *inode)\n{\n\t/*\n\t * we can cheat because an old format dir cannot have\n\t * EMPTY_DIR_SIZE, and a new format dir cannot have\n\t * EMPTY_DIR_SIZE_V1.  So, if the inode is either size,\n\t * regardless of disk format version, the directory is empty.\n\t */\n\tif (inode->i_size != EMPTY_DIR_SIZE &&\n\t    inode->i_size != EMPTY_DIR_SIZE_V1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline int reiserfs_empty_dir(struct inode *inode)\n{\n\t/*\n\t * we can cheat because an old format dir cannot have\n\t * EMPTY_DIR_SIZE, and a new format dir cannot have\n\t * EMPTY_DIR_SIZE_V1.  So, if the inode is either size,\n\t * regardless of disk format version, the directory is empty.\n\t */\n\tif (inode->i_size != EMPTY_DIR_SIZE &&\n\t    inode->i_size != EMPTY_DIR_SIZE_V1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "dir"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_find_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&path",
            "&de"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "304-350",
          "snippet": "static int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dir->i_sb",
            "jbegin_count"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint retval, err;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tint jbegin_count;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\n\t/*\n\t * we will be doing 2 balancings and update 2 stat data, we\n\t * change quotas of the owner of the directory and of the owner\n\t * of the parent directory.  The quota structure is possibly\n\t * deleted only on last iput => outside of this transaction\n\t */\n\tjbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t    4 * REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb);\n\n\tdquot_initialize(dir);\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval)\n\t\tgoto out_rmdir;\n\n\tde.de_gen_number_bit_string = NULL;\n\tif ((retval =\n\t     reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t &path, &de)) == NAME_NOT_FOUND) {\n\t\tretval = -ENOENT;\n\t\tgoto end_rmdir;\n\t} else if (retval == IO_ERROR) {\n\t\tretval = -EIO;\n\t\tgoto end_rmdir;\n\t}\n\n\tinode = dentry->d_inode;\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tif (de.de_objectid != inode->i_ino) {\n\t\t/*\n\t\t * FIXME: compare key of an object and a key found in the entry\n\t\t */\n\t\tretval = -EIO;\n\t\tgoto end_rmdir;\n\t}\n\tif (!reiserfs_empty_dir(inode)) {\n\t\tretval = -ENOTEMPTY;\n\t\tgoto end_rmdir;\n\t}\n\n\t/* cut entry from dir directory */\n\tretval = reiserfs_cut_from_item(&th, &path, &de.de_entry_key,\n\t\t\t\t\tdir, NULL,\t/* page */\n\t\t\t\t\t0 /*new file size - not used here */ );\n\tif (retval < 0)\n\t\tgoto end_rmdir;\n\n\tif (inode->i_nlink != 2 && inode->i_nlink != 1)\n\t\treiserfs_error(inode->i_sb, \"reiserfs-7040\",\n\t\t\t       \"empty directory has nlink != 2 (%d)\",\n\t\t\t       inode->i_nlink);\n\n\tclear_nlink(inode);\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\treiserfs_update_sd(&th, inode);\n\n\tDEC_DIR_INODE_NLINK(dir)\n\t    dir->i_size -= (DEH_SIZE + de.de_entrylen);\n\treiserfs_update_sd(&th, dir);\n\n\t/* prevent empty directory from getting lost */\n\tadd_save_link(&th, inode, 0 /* not truncate */ );\n\n\tretval = journal_end(&th);\n\treiserfs_check_path(&path);\nout_rmdir:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n\nend_rmdir:\n\t/*\n\t * we must release path, because we did not call\n\t * reiserfs_cut_from_item, or reiserfs_cut_from_item does not\n\t * release path if operation was not complete\n\t */\n\tpathrelse(&path);\n\terr = journal_end(&th);\n\treiserfs_write_unlock(dir->i_sb);\n\treturn err ? err : retval;\n}"
  },
  {
    "function_name": "reiserfs_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "868-881",
    "snippet": "static inline int reiserfs_empty_dir(struct inode *inode)\n{\n\t/*\n\t * we can cheat because an old format dir cannot have\n\t * EMPTY_DIR_SIZE, and a new format dir cannot have\n\t * EMPTY_DIR_SIZE_V1.  So, if the inode is either size,\n\t * regardless of disk format version, the directory is empty.\n\t */\n\tif (inode->i_size != EMPTY_DIR_SIZE &&\n\t    inode->i_size != EMPTY_DIR_SIZE_V1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline int reiserfs_empty_dir(struct inode *inode)\n{\n\t/*\n\t * we can cheat because an old format dir cannot have\n\t * EMPTY_DIR_SIZE, and a new format dir cannot have\n\t * EMPTY_DIR_SIZE_V1.  So, if the inode is either size,\n\t * regardless of disk format version, the directory is empty.\n\t */\n\tif (inode->i_size != EMPTY_DIR_SIZE &&\n\t    inode->i_size != EMPTY_DIR_SIZE_V1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "reiserfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "775-866",
    "snippet": "static int reiserfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\t/*\n\t * We need blocks for transaction + (user+group)*(quotas\n\t * for new inode + update of quota for directory owner)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\n\tdquot_initialize(dir);\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t/*\n\t * set flag that new packing locality created and new blocks\n\t * for the content of that directory are not displaced yet\n\t */\n\tREISERFS_I(dir)->new_packing_locality = 1;\n#endif\n\tmode = S_IFDIR | mode;\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tnew_inode_init(inode, dir, mode);\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\t/*\n\t * inc the link count now, so another writer doesn't overflow\n\t * it while we sleep later on.\n\t */\n\tINC_DIR_INODE_NLINK(dir)\n\n\t    retval = reiserfs_new_inode(&th, dir, mode, NULL /*symlink */ ,\n\t\t\t\t\told_format_only(dir->i_sb) ?\n\t\t\t\t\tEMPTY_DIR_SIZE_V1 : EMPTY_DIR_SIZE,\n\t\t\t\t\tdentry, inode, &security);\n\tif (retval) {\n\t\tDEC_DIR_INODE_NLINK(dir)\n\t\tgoto out_failed;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tinode->i_op = &reiserfs_dir_inode_operations;\n\tinode->i_fop = &reiserfs_dir_operations;\n\n\t/* note, _this_ add_entry will not update dir's stat data */\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1 /*visible */ );\n\tif (retval) {\n\t\tint err;\n\t\tclear_nlink(inode);\n\t\tDEC_DIR_INODE_NLINK(dir);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\t/* the above add_entry did not update dir's stat data */\n\treiserfs_update_sd(&th, dir);\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations reiserfs_dir_inode_operations = {\n\t.create = reiserfs_create,\n\t.lookup = reiserfs_lookup,\n\t.link = reiserfs_link,\n\t.unlink = reiserfs_unlink,\n\t.symlink = reiserfs_symlink,\n\t.mkdir = reiserfs_mkdir,\n\t.rmdir = reiserfs_rmdir,\n\t.mknod = reiserfs_mknod,\n\t.rename = reiserfs_rename,\n\t.setattr = reiserfs_setattr,\n\t.setxattr = reiserfs_setxattr,\n\t.getxattr = reiserfs_getxattr,\n\t.listxattr = reiserfs_listxattr,\n\t.removexattr = reiserfs_removexattr,\n\t.permission = reiserfs_permission,\n\t.get_acl = reiserfs_get_acl,\n\t.set_acl = reiserfs_set_acl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "dir"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEC_DIR_INODE_NLINK",
          "args": [
            "dir"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_add_entry",
          "args": [
            "&th",
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "inode",
            "1/*visible */"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "429-580",
          "snippet": "static int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "dir"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_new_inode",
          "args": [
            "&th",
            "dir",
            "mode",
            "NULL/*symlink */",
            "old_format_only(dir->i_sb) ?\n\t\t\t\t\tEMPTY_DIR_SIZE_V1 : EMPTY_DIR_SIZE",
            "dentry",
            "inode",
            "&security"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1926-2167",
          "snippet": "int reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "dir->i_sb"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_new_inode",
          "args": [
            "inode"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dir->i_sb",
            "jbegin_count"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_security_init",
          "args": [
            "dir",
            "inode",
            "&dentry->d_name",
            "&security"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_security_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
          "lines": "56-89",
          "snippet": "int reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include \"xattr.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nint reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_cache_default_acl",
          "args": [
            "dir"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_cache_default_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "365-393",
          "snippet": "int reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nint reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_init",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "603-618",
          "snippet": "static int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "dir"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nconst struct inode_operations reiserfs_dir_inode_operations = {\n\t.create = reiserfs_create,\n\t.lookup = reiserfs_lookup,\n\t.link = reiserfs_link,\n\t.unlink = reiserfs_unlink,\n\t.symlink = reiserfs_symlink,\n\t.mkdir = reiserfs_mkdir,\n\t.rmdir = reiserfs_rmdir,\n\t.mknod = reiserfs_mknod,\n\t.rename = reiserfs_rename,\n\t.setattr = reiserfs_setattr,\n\t.setxattr = reiserfs_setxattr,\n\t.getxattr = reiserfs_getxattr,\n\t.listxattr = reiserfs_listxattr,\n\t.removexattr = reiserfs_removexattr,\n\t.permission = reiserfs_permission,\n\t.get_acl = reiserfs_get_acl,\n\t.set_acl = reiserfs_set_acl,\n};\n\nstatic int reiserfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\t/*\n\t * We need blocks for transaction + (user+group)*(quotas\n\t * for new inode + update of quota for directory owner)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\n\tdquot_initialize(dir);\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t/*\n\t * set flag that new packing locality created and new blocks\n\t * for the content of that directory are not displaced yet\n\t */\n\tREISERFS_I(dir)->new_packing_locality = 1;\n#endif\n\tmode = S_IFDIR | mode;\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tnew_inode_init(inode, dir, mode);\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\t/*\n\t * inc the link count now, so another writer doesn't overflow\n\t * it while we sleep later on.\n\t */\n\tINC_DIR_INODE_NLINK(dir)\n\n\t    retval = reiserfs_new_inode(&th, dir, mode, NULL /*symlink */ ,\n\t\t\t\t\told_format_only(dir->i_sb) ?\n\t\t\t\t\tEMPTY_DIR_SIZE_V1 : EMPTY_DIR_SIZE,\n\t\t\t\t\tdentry, inode, &security);\n\tif (retval) {\n\t\tDEC_DIR_INODE_NLINK(dir)\n\t\tgoto out_failed;\n\t}\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tinode->i_op = &reiserfs_dir_inode_operations;\n\tinode->i_fop = &reiserfs_dir_operations;\n\n\t/* note, _this_ add_entry will not update dir's stat data */\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1 /*visible */ );\n\tif (retval) {\n\t\tint err;\n\t\tclear_nlink(inode);\n\t\tDEC_DIR_INODE_NLINK(dir);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\t/* the above add_entry did not update dir's stat data */\n\treiserfs_update_sd(&th, dir);\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "694-773",
    "snippet": "static int reiserfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t  dev_t rdev)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\t/*\n\t * We need blocks for transaction + (user+group)*(quotas\n\t * for new inode + update of quota for directory owner)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tdquot_initialize(dir);\n\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tnew_inode_init(inode, dir, mode);\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, dir, mode, NULL, 0 /*i_size */ , dentry,\n\t\t\t       inode, &security);\n\tif (retval) {\n\t\tgoto out_failed;\n\t}\n\n\tinode->i_op = &reiserfs_special_inode_operations;\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\n\t/* FIXME: needed for block and char devices only */\n\treiserfs_update_sd(&th, inode);\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1 /*visible */ );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\n\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations reiserfs_special_inode_operations = {\n\t.setattr = reiserfs_setattr,\n\t.setxattr = reiserfs_setxattr,\n\t.getxattr = reiserfs_getxattr,\n\t.listxattr = reiserfs_listxattr,\n\t.removexattr = reiserfs_removexattr,\n\t.permission = reiserfs_permission,\n\t.get_acl = reiserfs_get_acl,\n\t.set_acl = reiserfs_set_acl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "inode"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_add_entry",
          "args": [
            "&th",
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "inode",
            "1/*visible */"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "429-580",
          "snippet": "static int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "dir"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "rdev"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_new_inode",
          "args": [
            "&th",
            "dir",
            "mode",
            "NULL",
            "0/*i_size */",
            "dentry",
            "inode",
            "&security"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1926-2167",
          "snippet": "int reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_new_inode",
          "args": [
            "inode"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dir->i_sb",
            "jbegin_count"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_security_init",
          "args": [
            "dir",
            "inode",
            "&dentry->d_name",
            "&security"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_security_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
          "lines": "56-89",
          "snippet": "int reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include \"xattr.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nint reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_cache_default_acl",
          "args": [
            "dir"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_cache_default_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "365-393",
          "snippet": "int reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nint reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_init",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "603-618",
          "snippet": "static int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nconst struct inode_operations reiserfs_special_inode_operations = {\n\t.setattr = reiserfs_setattr,\n\t.setxattr = reiserfs_setxattr,\n\t.getxattr = reiserfs_getxattr,\n\t.listxattr = reiserfs_listxattr,\n\t.removexattr = reiserfs_removexattr,\n\t.permission = reiserfs_permission,\n\t.get_acl = reiserfs_get_acl,\n\t.set_acl = reiserfs_set_acl,\n};\n\nstatic int reiserfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t  dev_t rdev)\n{\n\tint retval;\n\tstruct inode *inode;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\t/*\n\t * We need blocks for transaction + (user+group)*(quotas\n\t * for new inode + update of quota for directory owner)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 3 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tdquot_initialize(dir);\n\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tnew_inode_init(inode, dir, mode);\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, dir, mode, NULL, 0 /*i_size */ , dentry,\n\t\t\t       inode, &security);\n\tif (retval) {\n\t\tgoto out_failed;\n\t}\n\n\tinode->i_op = &reiserfs_special_inode_operations;\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\n\t/* FIXME: needed for block and char devices only */\n\treiserfs_update_sd(&th, inode);\n\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1 /*visible */ );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\n\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "620-692",
    "snippet": "static int reiserfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t   bool excl)\n{\n\tint retval;\n\tstruct inode *inode;\n\t/*\n\t * We need blocks for transaction + (user+group)*(quotas\n\t * for new inode + update of quota for directory owner)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\n\tdquot_initialize(dir);\n\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tnew_inode_init(inode, dir, mode);\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, dir, mode, NULL, 0 /*i_size */ , dentry,\n\t\t\t       inode, &security);\n\tif (retval)\n\t\tgoto out_failed;\n\n\tinode->i_op = &reiserfs_file_inode_operations;\n\tinode->i_fop = &reiserfs_file_operations;\n\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1 /*visible */ );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\n\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "dir"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "&th",
            "inode"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_add_entry",
          "args": [
            "&th",
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "inode",
            "1/*visible */"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "429-580",
          "snippet": "static int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_new_inode",
          "args": [
            "&th",
            "dir",
            "mode",
            "NULL",
            "0/*i_size */",
            "dentry",
            "inode",
            "&security"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1926-2167",
          "snippet": "int reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_new_inode(struct reiserfs_transaction_handle *th,\n\t\t       struct inode *dir, umode_t mode, const char *symname,\n\t\t       /* 0 for regular, EMTRY_DIR_SIZE for dirs,\n\t\t          strlen (symname) for symlinks) */\n\t\t       loff_t i_size, struct dentry *dentry,\n\t\t       struct inode *inode,\n\t\t       struct reiserfs_security_handle *security)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct reiserfs_iget_args args;\n\tINITIALIZE_PATH(path_to_key);\n\tstruct cpu_key key;\n\tstruct item_head ih;\n\tstruct stat_data sd;\n\tint retval;\n\tint err;\n\tint depth;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tdepth = reiserfs_write_unlock_nested(sb);\n\terr = dquot_alloc_inode(inode);\n\treiserfs_write_lock_nested(sb, depth);\n\tif (err)\n\t\tgoto out_end_trans;\n\tif (!dir->i_nlink) {\n\t\terr = -EPERM;\n\t\tgoto out_bad_inode;\n\t}\n\n\t/* item head of new item */\n\tih.ih_key.k_dir_id = reiserfs_choose_packing(dir);\n\tih.ih_key.k_objectid = cpu_to_le32(reiserfs_get_unused_objectid(th));\n\tif (!ih.ih_key.k_objectid) {\n\t\terr = -ENOMEM;\n\t\tgoto out_bad_inode;\n\t}\n\targs.objectid = inode->i_ino = le32_to_cpu(ih.ih_key.k_objectid);\n\tif (old_format_only(sb))\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);\n\telse\n\t\tmake_le_item_head(&ih, NULL, KEY_FORMAT_3_6, SD_OFFSET,\n\t\t\t\t  TYPE_STAT_DATA, SD_SIZE, MAX_US_INT);\n\tmemcpy(INODE_PKEY(inode), &ih.ih_key, KEY_SIZE);\n\targs.dirid = le32_to_cpu(ih.ih_key.k_dir_id);\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\terr = insert_inode_locked4(inode, args.objectid,\n\t\t\t     reiserfs_find_actor, &args);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out_bad_inode;\n\t}\n\n\tif (old_format_only(sb))\n\t\t/*\n\t\t * not a perfect generation count, as object ids can be reused,\n\t\t * but this is as good as reiserfs can do right now.\n\t\t * note that the private part of inode isn't filled in yet,\n\t\t * we have to use the directory.\n\t\t */\n\t\tinode->i_generation = le32_to_cpu(INODE_PKEY(dir)->k_objectid);\n\telse\n#if defined( USE_INODE_GENERATION_COUNTER )\n\t\tinode->i_generation =\n\t\t    le32_to_cpu(REISERFS_SB(sb)->s_rs->s_inode_generation);\n#else\n\t\tinode->i_generation = ++event;\n#endif\n\n\t/* fill stat data */\n\tset_nlink(inode, (S_ISDIR(mode) ? 2 : 1));\n\n\t/* uid and gid must already be set by the caller for quota init */\n\n\t/* symlink cannot be immutable or append only, right? */\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND);\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_size = i_size;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tREISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 :\n\t    U32_MAX /*NO_BYTES_IN_DIRECT_ITEM */ ;\n\n\tINIT_LIST_HEAD(&REISERFS_I(inode)->i_prealloc_list);\n\tREISERFS_I(inode)->i_flags = 0;\n\tREISERFS_I(inode)->i_prealloc_block = 0;\n\tREISERFS_I(inode)->i_prealloc_count = 0;\n\tREISERFS_I(inode)->i_trans_id = 0;\n\tREISERFS_I(inode)->i_jl = NULL;\n\tREISERFS_I(inode)->i_attrs =\n\t    REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;\n\tsd_attrs_to_i_attrs(REISERFS_I(inode)->i_attrs, inode);\n\treiserfs_init_xattr_rwsem(inode);\n\n\t/* key to search for correct place for new stat data */\n\t_make_cpu_key(&key, KEY_FORMAT_3_6, le32_to_cpu(ih.ih_key.k_dir_id),\n\t\t      le32_to_cpu(ih.ih_key.k_objectid), SD_OFFSET,\n\t\t      TYPE_STAT_DATA, 3 /*key length */ );\n\n\t/* find proper place for inserting of stat data */\n\tretval = search_item(sb, &key, &path_to_key);\n\tif (retval == IO_ERROR) {\n\t\terr = -EIO;\n\t\tgoto out_bad_inode;\n\t}\n\tif (retval == ITEM_FOUND) {\n\t\tpathrelse(&path_to_key);\n\t\terr = -EEXIST;\n\t\tgoto out_bad_inode;\n\t}\n\tif (old_format_only(sb)) {\n\t\t/* i_uid or i_gid is too big to be stored in stat data v3.5 */\n\t\tif (i_uid_read(inode) & ~0xffff || i_gid_read(inode) & ~0xffff) {\n\t\t\tpathrelse(&path_to_key);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_bad_inode;\n\t\t}\n\t\tinode2sd_v1(&sd, inode, inode->i_size);\n\t} else {\n\t\tinode2sd(&sd, inode, inode->i_size);\n\t}\n\t/*\n\t * store in in-core inode the key of stat data and version all\n\t * object items will have (directory items will have old offset\n\t * format, other new objects will consist of new items)\n\t */\n\tif (old_format_only(sb) || S_ISDIR(mode) || S_ISLNK(mode))\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_5);\n\telse\n\t\tset_inode_item_key_version(inode, KEY_FORMAT_3_6);\n\tif (old_format_only(sb))\n\t\tset_inode_sd_version(inode, STAT_DATA_V1);\n\telse\n\t\tset_inode_sd_version(inode, STAT_DATA_V2);\n\n\t/* insert the stat data into the tree */\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (REISERFS_I(dir)->new_packing_locality)\n\t\tth->displace_new_blocks = 1;\n#endif\n\tretval =\n\t    reiserfs_insert_item(th, &path_to_key, &key, &ih, inode,\n\t\t\t\t (char *)(&sd));\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tgoto out_bad_inode;\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (!th->displace_new_blocks)\n\t\tREISERFS_I(dir)->new_packing_locality = 0;\n#endif\n\tif (S_ISDIR(mode)) {\n\t\t/* insert item with \".\" and \"..\" */\n\t\tretval =\n\t\t    reiserfs_new_directory(th, inode, &ih, &path_to_key, dir);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* insert body of symlink */\n\t\tif (!old_format_only(sb))\n\t\t\ti_size = ROUND_UP(i_size);\n\t\tretval =\n\t\t    reiserfs_new_symlink(th, inode, &ih, &path_to_key, symname,\n\t\t\t\t\t i_size);\n\t}\n\tif (retval) {\n\t\terr = retval;\n\t\treiserfs_check_path(&path_to_key);\n\t\tjournal_end(th);\n\t\tgoto out_inserted_sd;\n\t}\n\n\tif (reiserfs_posixacl(inode->i_sb)) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_inherit_default_acl(th, dir, dentry, inode);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tjournal_end(th);\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t} else if (inode->i_sb->s_flags & MS_POSIXACL) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-13090\",\n\t\t\t\t \"ACLs aren't enabled in the fs, \"\n\t\t\t\t \"but vfs thinks they are!\");\n\t} else if (IS_PRIVATE(dir))\n\t\tinode->i_flags |= S_PRIVATE;\n\n\tif (security->name) {\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tretval = reiserfs_security_write(th, inode, security);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (retval) {\n\t\t\terr = retval;\n\t\t\treiserfs_check_path(&path_to_key);\n\t\t\tretval = journal_end(th);\n\t\t\tif (retval)\n\t\t\t\terr = retval;\n\t\t\tgoto out_inserted_sd;\n\t\t}\n\t}\n\n\treiserfs_update_sd(th, inode);\n\treiserfs_check_path(&path_to_key);\n\n\treturn 0;\n\nout_bad_inode:\n\t/* Invalidate the object, nothing was inserted yet */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/* Quota change must be inside a transaction for journaling */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_free_inode(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\nout_end_trans:\n\tjournal_end(th);\n\t/*\n\t * Drop can be outside and it needs more credits so it's better\n\t * to have it outside\n\t */\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\tdquot_drop(inode);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\tinode->i_flags |= S_NOQUOTA;\n\tmake_bad_inode(inode);\n\nout_inserted_sd:\n\tclear_nlink(inode);\n\tth->t_trans_id = 0;\t/* so the caller can't use this handle later */\n\tunlock_new_inode(inode); /* OK to do even if we hadn't locked it */\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_new_inode",
          "args": [
            "inode"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "dir->i_sb",
            "jbegin_count"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_security_init",
          "args": [
            "dir",
            "inode",
            "&dentry->d_name",
            "&security"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_security_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_security.c",
          "lines": "56-89",
          "snippet": "int reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include \"xattr.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/security.h>\n#include \"xattr.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nint reiserfs_security_init(struct inode *dir, struct inode *inode,\n\t\t\t   const struct qstr *qstr,\n\t\t\t   struct reiserfs_security_handle *sec)\n{\n\tint blocks = 0;\n\tint error;\n\n\tsec->name = NULL;\n\n\t/* Don't add selinux attributes on xattrs - they'll never get used */\n\tif (IS_PRIVATE(dir))\n\t\treturn 0;\n\n\terror = security_old_inode_init_security(inode, dir, qstr, &sec->name,\n\t\t\t\t\t\t &sec->value, &sec->length);\n\tif (error) {\n\t\tif (error == -EOPNOTSUPP)\n\t\t\terror = 0;\n\n\t\tsec->name = NULL;\n\t\tsec->value = NULL;\n\t\tsec->length = 0;\n\t\treturn error;\n\t}\n\n\tif (sec->length && reiserfs_xattrs_initialized(inode->i_sb)) {\n\t\tblocks = reiserfs_xattr_jcreate_nblocks(inode) +\n\t\t\t reiserfs_xattr_nblocks(inode, sec->length);\n\t\t/* We don't want to count the directories twice if we have\n\t\t * a default ACL. */\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\t}\n\treturn blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_cache_default_acl",
          "args": [
            "dir"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_cache_default_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_acl.c",
          "lines": "365-393",
          "snippet": "int reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/posix_acl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __reiserfs_set_acl(struct reiserfs_transaction_handle *th,\n\t\t\t    struct inode *inode, int type,\n\t\t\t    struct posix_acl *acl);\n\nint reiserfs_cache_default_acl(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint nblocks = 0;\n\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\tacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\n\n\tif (acl && !IS_ERR(acl)) {\n\t\tint size = reiserfs_acl_size(acl->a_count);\n\n\t\t/* Other xattrs can be created during inode creation. We don't\n\t\t * want to claim too many blocks, so we check to see if we\n\t\t * we need to create the tree to the xattrs, and then we\n\t\t * just want two files. */\n\t\tnblocks = reiserfs_xattr_jcreate_nblocks(inode);\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\t\tREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\n\n\t\t/* We need to account for writes + bitmaps for two files */\n\t\tnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn nblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_init",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "603-618",
          "snippet": "static int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_INIT_BLOCKS",
          "args": [
            "dir->i_sb"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t   bool excl)\n{\n\tint retval;\n\tstruct inode *inode;\n\t/*\n\t * We need blocks for transaction + (user+group)*(quotas\n\t * for new inode + update of quota for directory owner)\n\t */\n\tint jbegin_count =\n\t    JOURNAL_PER_BALANCE_CNT * 2 +\n\t    2 * (REISERFS_QUOTA_INIT_BLOCKS(dir->i_sb) +\n\t\t REISERFS_QUOTA_TRANS_BLOCKS(dir->i_sb));\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_security_handle security;\n\n\tdquot_initialize(dir);\n\n\tif (!(inode = new_inode(dir->i_sb))) {\n\t\treturn -ENOMEM;\n\t}\n\tnew_inode_init(inode, dir, mode);\n\n\tjbegin_count += reiserfs_cache_default_acl(dir);\n\tretval = reiserfs_security_init(dir, inode, &dentry->d_name, &security);\n\tif (retval < 0) {\n\t\tdrop_new_inode(inode);\n\t\treturn retval;\n\t}\n\tjbegin_count += retval;\n\treiserfs_write_lock(dir->i_sb);\n\n\tretval = journal_begin(&th, dir->i_sb, jbegin_count);\n\tif (retval) {\n\t\tdrop_new_inode(inode);\n\t\tgoto out_failed;\n\t}\n\n\tretval =\n\t    reiserfs_new_inode(&th, dir, mode, NULL, 0 /*i_size */ , dentry,\n\t\t\t       inode, &security);\n\tif (retval)\n\t\tgoto out_failed;\n\n\tinode->i_op = &reiserfs_file_inode_operations;\n\tinode->i_fop = &reiserfs_file_operations;\n\tinode->i_mapping->a_ops = &reiserfs_address_space_operations;\n\n\tretval =\n\t    reiserfs_add_entry(&th, dir, dentry->d_name.name,\n\t\t\t       dentry->d_name.len, inode, 1 /*visible */ );\n\tif (retval) {\n\t\tint err;\n\t\tdrop_nlink(inode);\n\t\treiserfs_update_sd(&th, inode);\n\t\terr = journal_end(&th);\n\t\tif (err)\n\t\t\tretval = err;\n\t\tunlock_new_inode(inode);\n\t\tiput(inode);\n\t\tgoto out_failed;\n\t}\n\treiserfs_update_inode_transaction(inode);\n\treiserfs_update_inode_transaction(dir);\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\n\tretval = journal_end(&th);\n\nout_failed:\n\treiserfs_write_unlock(dir->i_sb);\n\treturn retval;\n}"
  },
  {
    "function_name": "new_inode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "603-618",
    "snippet": "static int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int new_inode_init(struct inode *inode, struct inode *dir, umode_t mode)\n{\n\t/*\n\t * Make inode invalid - just in case we are going to drop it before\n\t * the initialization happens\n\t */\n\tINODE_PKEY(inode)->k_objectid = 0;\n\n\t/*\n\t * the quota init calls have to know who to charge the quota to, so\n\t * we have to set uid and gid here\n\t */\n\tinode_init_owner(inode, dir, mode);\n\tdquot_initialize(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "drop_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "588-595",
    "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "429-580",
    "snippet": "static int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_check_path",
          "args": [
            "&path"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "346-351",
          "snippet": "int reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nint reiserfs_check_path(struct treepath *p)\n{\n\tRFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"path not properly relsed\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "dir"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_paste_into_item",
          "args": [
            "th",
            "&path",
            "&entry_key",
            "dir",
            "buffer",
            "paste_size"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "dir->i_sb",
            "\"vs-7032\"",
            "\"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\"",
            "&entry_key"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_by_entry_key",
          "args": [
            "dir->i_sb",
            "&entry_key",
            "&path",
            "&de"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "search_by_entry_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "120-175",
          "snippet": "int search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_INFO_MAX",
          "args": [
            "th->t_super",
            "max_hash_collisions",
            "gen_number"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&entry_key",
            "deh_offset(deh)"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_offset",
          "args": [
            "deh",
            "SET_GENERATION_NUMBER(deh_offset(deh), gen_number)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_GENERATION_NUMBER",
          "args": [
            "deh_offset(deh)",
            "gen_number"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "dir->i_sb",
            "\"reiserfs-7010\"",
            "\"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\""
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "bit_string",
            "MAX_GENERATION_NUMBER + 1"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "minix_find_first_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "124-140",
          "snippet": "static inline int minix_find_first_zero_bit(const void *vaddr, unsigned size)\n{\n\tconst unsigned short *p = vaddr, *addr = vaddr;\n\tunsigned short num;\n\n\tif (!size)\n\t\treturn 0;\n\n\tsize >>= 4;\n\twhile (*p++ == 0xffff) {\n\t\tif (--size == 0)\n\t\t\treturn (p - addr) << 4;\n\t}\n\n\tnum = *--p;\n\treturn ((p - addr) << 4) + ffz(num);\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define minix_find_first_zero_bit\tfind_first_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define minix_find_first_zero_bit\tfind_first_zero_bit_le\n\nstatic inline int minix_find_first_zero_bit(const void *vaddr, unsigned size)\n{\n\tconst unsigned short *p = vaddr, *addr = vaddr;\n\tunsigned short num;\n\n\tif (!size)\n\t\treturn 0;\n\n\tsize >>= 4;\n\twhile (*p++ == 0xffff) {\n\t\tif (--size == 0)\n\t\t\treturn (p - addr) << 4;\n\t}\n\n\tnum = *--p;\n\treturn ((p - addr) << 4) + ffz(num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "dir->i_sb",
            "\"zam-7002\"",
            "\"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\"",
            "retval"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_find_entry",
          "args": [
            "dir",
            "name",
            "namelen",
            "&path",
            "&de"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "304-350",
          "snippet": "static int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bit_string",
            "0",
            "sizeof(bit_string)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_hidden",
          "args": [
            "deh"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_visible",
          "args": [
            "deh"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_de_without_sd",
          "args": [
            "deh"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padd_item",
          "args": [
            "(char *)(deh + 1)",
            "ROUND_UP(namelen)",
            "namelen"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "padd_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "1189-1195",
          "snippet": "void padd_item(char *item, int total_length, int length)\n{\n\tint i;\n\n\tfor (i = total_length; i > length;)\n\t\titem[--i] = 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid padd_item(char *item, int total_length, int length)\n{\n\tint i;\n\n\tfor (i = total_length; i > length;)\n\t\titem[--i] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "namelen"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(deh + 1)",
            "name",
            "namelen"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_deh_offset",
          "args": [
            "deh",
            "cpu_key_k_offset(&entry_key)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "&entry_key"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "dir"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "buflen",
            "GFP_NOFS"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ROUND_UP",
          "args": [
            "namelen"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&entry_key",
            "dir",
            "get_third_component(dir->i_sb, name, namelen)",
            "TYPE_DIRENTRY",
            "3"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_third_component",
          "args": [
            "dir->i_sb",
            "name",
            "namelen"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "get_third_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "185-206",
          "snippet": "static __u32 get_third_component(struct super_block *s,\n\t\t\t\t const char *name, int len)\n{\n\t__u32 res;\n\n\tif (!len || (len == 1 && name[0] == '.'))\n\t\treturn DOT_OFFSET;\n\tif (len == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn DOT_DOT_OFFSET;\n\n\tres = REISERFS_SB(s)->s_hash_function(name, len);\n\n\t/* take bits from 7-th to 30-th including both bounds */\n\tres = GET_HASH_VALUE(res);\n\tif (res == 0)\n\t\t/*\n\t\t * needed to have no names before \".\" and \"..\" those have hash\n\t\t * value == 0 and generation conters 1 and 2 accordingly\n\t\t */\n\t\tres = 128;\n\treturn res + MAX_GENERATION_NUMBER;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic __u32 get_third_component(struct super_block *s,\n\t\t\t\t const char *name, int len)\n{\n\t__u32 res;\n\n\tif (!len || (len == 1 && name[0] == '.'))\n\t\treturn DOT_OFFSET;\n\tif (len == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn DOT_DOT_OFFSET;\n\n\tres = REISERFS_SB(s)->s_hash_function(name, len);\n\n\t/* take bits from 7-th to 30-th including both bounds */\n\tres = GET_HASH_VALUE(res);\n\tif (res == 0)\n\t\t/*\n\t\t * needed to have no names before \".\" and \"..\" those have hash\n\t\t * value == 0 and generation conters 1 and 2 accordingly\n\t\t */\n\t\tres = 128;\n\treturn res + MAX_GENERATION_NUMBER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_MAX_NAME",
          "args": [
            "dir->i_sb->s_blocksize"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_BITMAP",
          "args": [
            "bit_string",
            "MAX_GENERATION_NUMBER + 1"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_add_entry(struct reiserfs_transaction_handle *th,\n\t\t\t      struct inode *dir, const char *name, int namelen,\n\t\t\t      struct inode *inode, int visible)\n{\n\tstruct cpu_key entry_key;\n\tstruct reiserfs_de_head *deh;\n\tINITIALIZE_PATH(path);\n\tstruct reiserfs_dir_entry de;\n\tDECLARE_BITMAP(bit_string, MAX_GENERATION_NUMBER + 1);\n\tint gen_number;\n\n\t/*\n\t * 48 bytes now and we avoid kmalloc if we\n\t * create file with short name\n\t */\n\tchar small_buf[32 + DEH_SIZE];\n\n\tchar *buffer;\n\tint buflen, paste_size;\n\tint retval;\n\n\tBUG_ON(!th->t_trans_id);\n\n\t/* cannot allow items to be added into a busy deleted directory */\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn -ENAMETOOLONG;\n\n\t/* each entry has unique key. compose it */\n\tmake_cpu_key(&entry_key, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\t/* get memory for composing the entry */\n\tbuflen = DEH_SIZE + ROUND_UP(namelen);\n\tif (buflen > sizeof(small_buf)) {\n\t\tbuffer = kmalloc(buflen, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuffer = small_buf;\n\n\tpaste_size =\n\t    (get_inode_sd_version(dir) ==\n\t     STAT_DATA_V1) ? (DEH_SIZE + namelen) : buflen;\n\n\t/*\n\t * fill buffer : directory entry head, name[, dir objectid | ,\n\t * stat data | ,stat data, dir objectid ]\n\t */\n\tdeh = (struct reiserfs_de_head *)buffer;\n\tdeh->deh_location = 0;\t/* JDM Endian safe if 0 */\n\tput_deh_offset(deh, cpu_key_k_offset(&entry_key));\n\tdeh->deh_state = 0;\t/* JDM Endian safe if 0 */\n\t/* put key (ino analog) to de */\n\n\t/* safe: k_dir_id is le */\n\tdeh->deh_dir_id = INODE_PKEY(inode)->k_dir_id;\n\t/* safe: k_objectid is le */\n\tdeh->deh_objectid = INODE_PKEY(inode)->k_objectid;\n\n\t/* copy name */\n\tmemcpy((char *)(deh + 1), name, namelen);\n\t/* padd by 0s to the 4 byte boundary */\n\tpadd_item((char *)(deh + 1), ROUND_UP(namelen), namelen);\n\n\t/*\n\t * entry is ready to be pasted into tree, set 'visibility'\n\t * and 'stat data in entry' attributes\n\t */\n\tmark_de_without_sd(deh);\n\tvisible ? mark_de_visible(deh) : mark_de_hidden(deh);\n\n\t/* find the proper place for the new entry */\n\tmemset(bit_string, 0, sizeof(bit_string));\n\tde.de_gen_number_bit_string = bit_string;\n\tretval = reiserfs_find_entry(dir, name, namelen, &path, &de);\n\tif (retval != NAME_NOT_FOUND) {\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\n\t\tif (retval == IO_ERROR) {\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (retval != NAME_FOUND) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7002\",\n\t\t\t\t       \"reiserfs_find_entry() returned \"\n\t\t\t\t       \"unexpected value (%d)\", retval);\n\t\t}\n\n\t\treturn -EEXIST;\n\t}\n\n\tgen_number =\n\t    find_first_zero_bit(bit_string,\n\t\t\t\tMAX_GENERATION_NUMBER + 1);\n\tif (gen_number > MAX_GENERATION_NUMBER) {\n\t\t/* there is no free generation number */\n\t\treiserfs_warning(dir->i_sb, \"reiserfs-7010\",\n\t\t\t\t \"Congratulations! we have got hash function \"\n\t\t\t\t \"screwed up\");\n\t\tif (buffer != small_buf)\n\t\t\tkfree(buffer);\n\t\tpathrelse(&path);\n\t\treturn -EBUSY;\n\t}\n\t/* adjust offset of directory enrty */\n\tput_deh_offset(deh, SET_GENERATION_NUMBER(deh_offset(deh), gen_number));\n\tset_cpu_key_k_offset(&entry_key, deh_offset(deh));\n\n\t/* update max-hash-collisions counter in reiserfs_sb_info */\n\tPROC_INFO_MAX(th->t_super, max_hash_collisions, gen_number);\n\n\t/* we need to re-search for the insertion point */\n\tif (gen_number != 0) {\n\t\tif (search_by_entry_key(dir->i_sb, &entry_key, &path, &de) !=\n\t\t    NAME_NOT_FOUND) {\n\t\t\treiserfs_warning(dir->i_sb, \"vs-7032\",\n\t\t\t\t\t \"entry with this key (%K) already \"\n\t\t\t\t\t \"exists\", &entry_key);\n\n\t\t\tif (buffer != small_buf)\n\t\t\t\tkfree(buffer);\n\t\t\tpathrelse(&path);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t/* perform the insertion of the entry that we have prepared */\n\tretval =\n\t    reiserfs_paste_into_item(th, &path, &entry_key, dir, buffer,\n\t\t\t\t     paste_size);\n\tif (buffer != small_buf)\n\t\tkfree(buffer);\n\tif (retval) {\n\t\treiserfs_check_path(&path);\n\t\treturn retval;\n\t}\n\n\tdir->i_size += paste_size;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tif (!S_ISDIR(inode->i_mode) && visible)\n\t\t/* reiserfs_mkdir or reiserfs_rename will do that by itself */\n\t\treiserfs_update_sd(th, dir);\n\n\treiserfs_check_path(&path);\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "397-421",
    "snippet": "struct dentry *reiserfs_get_parent(struct dentry *child)\n{\n\tint retval;\n\tstruct inode *inode = NULL;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct inode *dir = child->d_inode;\n\n\tif (dir->i_nlink == 0) {\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tde.de_gen_number_bit_string = NULL;\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = reiserfs_find_entry(dir, \"..\", 2, &path_to_entry, &de);\n\tpathrelse(&path_to_entry);\n\tif (retval != NAME_FOUND) {\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tinode = reiserfs_iget(dir->i_sb, (struct cpu_key *)&de.de_dir_id);\n\treiserfs_write_unlock(dir->i_sb);\n\n\treturn d_obtain_alias(inode);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "inode"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_iget",
          "args": [
            "dir->i_sb",
            "(struct cpu_key *)&de.de_dir_id"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1642-1669",
          "snippet": "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path_to_entry"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_find_entry",
          "args": [
            "dir",
            "\"..\"",
            "2",
            "&path_to_entry",
            "&de"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "304-350",
          "snippet": "static int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path_to_entry"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstruct dentry *reiserfs_get_parent(struct dentry *child)\n{\n\tint retval;\n\tstruct inode *inode = NULL;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct inode *dir = child->d_inode;\n\n\tif (dir->i_nlink == 0) {\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tde.de_gen_number_bit_string = NULL;\n\n\treiserfs_write_lock(dir->i_sb);\n\tretval = reiserfs_find_entry(dir, \"..\", 2, &path_to_entry, &de);\n\tpathrelse(&path_to_entry);\n\tif (retval != NAME_FOUND) {\n\t\treiserfs_write_unlock(dir->i_sb);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\tinode = reiserfs_iget(dir->i_sb, (struct cpu_key *)&de.de_dir_id);\n\treiserfs_write_unlock(dir->i_sb);\n\n\treturn d_obtain_alias(inode);\n}"
  },
  {
    "function_name": "reiserfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "352-391",
    "snippet": "static struct dentry *reiserfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tint retval;\n\tstruct inode *inode = NULL;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path_to_entry);\n\n\tif (REISERFS_MAX_NAME(dir->i_sb->s_blocksize) < dentry->d_name.len)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\treiserfs_write_lock(dir->i_sb);\n\n\tde.de_gen_number_bit_string = NULL;\n\tretval =\n\t    reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t&path_to_entry, &de);\n\tpathrelse(&path_to_entry);\n\tif (retval == NAME_FOUND) {\n\t\tinode = reiserfs_iget(dir->i_sb,\n\t\t\t\t      (struct cpu_key *)&de.de_dir_id);\n\t\tif (!inode || IS_ERR(inode)) {\n\t\t\treiserfs_write_unlock(dir->i_sb);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\t/*\n\t\t * Propagate the private flag so we know we're\n\t\t * in the priv tree\n\t\t */\n\t\tif (IS_PRIVATE(dir))\n\t\t\tinode->i_flags |= S_PRIVATE;\n\t}\n\treiserfs_write_unlock(dir->i_sb);\n\tif (retval == IO_ERROR) {\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "dir"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_iget",
          "args": [
            "dir->i_sb",
            "(struct cpu_key *)&de.de_dir_id"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1642-1669",
          "snippet": "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)\n{\n\tstruct inode *inode;\n\tstruct reiserfs_iget_args args;\n\tint depth;\n\n\targs.objectid = key->on_disk_key.k_objectid;\n\targs.dirid = key->on_disk_key.k_dir_id;\n\tdepth = reiserfs_write_unlock_nested(s);\n\tinode = iget5_locked(s, key->on_disk_key.k_objectid,\n\t\t\t     reiserfs_find_actor, reiserfs_init_locked_inode,\n\t\t\t     (void *)(&args));\n\treiserfs_write_lock_nested(s, depth);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\treiserfs_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tif (comp_short_keys(INODE_PKEY(inode), key) || is_bad_inode(inode)) {\n\t\t/* either due to i/o error or a stale NFS handle */\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "&path_to_entry"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_find_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&path_to_entry",
            "&de"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "304-350",
          "snippet": "static int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_MAX_NAME",
          "args": [
            "dir->i_sb->s_blocksize"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INITIALIZE_PATH",
          "args": [
            "path_to_entry"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic struct dentry *reiserfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tint retval;\n\tstruct inode *inode = NULL;\n\tstruct reiserfs_dir_entry de;\n\tINITIALIZE_PATH(path_to_entry);\n\n\tif (REISERFS_MAX_NAME(dir->i_sb->s_blocksize) < dentry->d_name.len)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\treiserfs_write_lock(dir->i_sb);\n\n\tde.de_gen_number_bit_string = NULL;\n\tretval =\n\t    reiserfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t&path_to_entry, &de);\n\tpathrelse(&path_to_entry);\n\tif (retval == NAME_FOUND) {\n\t\tinode = reiserfs_iget(dir->i_sb,\n\t\t\t\t      (struct cpu_key *)&de.de_dir_id);\n\t\tif (!inode || IS_ERR(inode)) {\n\t\t\treiserfs_write_unlock(dir->i_sb);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\t/*\n\t\t * Propagate the private flag so we know we're\n\t\t * in the priv tree\n\t\t */\n\t\tif (IS_PRIVATE(dir))\n\t\t\tinode->i_flags |= S_PRIVATE;\n\t}\n\treiserfs_write_unlock(dir->i_sb);\n\tif (retval == IO_ERROR) {\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "reiserfs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "304-350",
    "snippet": "static int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "path_to_entry"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&key_to_search",
            "le_ih_k_offset(de->de_ih) - 1"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "de->de_ih"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "linear_search_in_dir_item",
          "args": [
            "&key_to_search",
            "de",
            "name",
            "namelen"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "linear_search_in_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "226-298",
          "snippet": "static int linear_search_in_dir_item(struct cpu_key *key,\n\t\t\t\t     struct reiserfs_dir_entry *de,\n\t\t\t\t     const char *name, int namelen)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint retval;\n\tint i;\n\n\ti = de->de_entry_num;\n\n\tif (i == ih_entry_count(de->de_ih) ||\n\t    GET_HASH_VALUE(deh_offset(deh + i)) !=\n\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\ti--;\n\t}\n\n\tRFALSE(de->de_deh != B_I_DEH(de->de_bh, de->de_ih),\n\t       \"vs-7010: array of entry headers not found\");\n\n\tdeh += i;\n\n\tfor (; i >= 0; i--, deh--) {\n\t\t/* hash value does not match, no need to check whole name */\n\t\tif (GET_HASH_VALUE(deh_offset(deh)) !=\n\t\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\t\treturn NAME_NOT_FOUND;\n\t\t}\n\n\t\t/* mark that this generation number is used */\n\t\tif (de->de_gen_number_bit_string)\n\t\t\tset_bit(GET_GENERATION_NUMBER(deh_offset(deh)),\n\t\t\t\tde->de_gen_number_bit_string);\n\n\t\t/* calculate pointer to name and namelen */\n\t\tde->de_entry_num = i;\n\t\tset_de_name_and_namelen(de);\n\n\t\t/*\n\t\t * de's de_name, de_namelen, de_recordlen are set.\n\t\t * Fill the rest.\n\t\t */\n\t\tif ((retval =\n\t\t     reiserfs_match(de, name, namelen)) != NAME_NOT_FOUND) {\n\n\t\t\t/* key of pointed object */\n\t\t\tset_de_object_key(de);\n\n\t\t\tstore_de_entry_key(de);\n\n\t\t\t/* retval can be NAME_FOUND or NAME_FOUND_INVISIBLE */\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (GET_GENERATION_NUMBER(le_ih_k_offset(de->de_ih)) == 0)\n\t\t/*\n\t\t * we have reached left most entry in the node. In common we\n\t\t * have to go to the left neighbor, but if generation counter\n\t\t * is 0 already, we know for sure, that there is no name with\n\t\t * the same hash value\n\t\t */\n\t\t/*\n\t\t * FIXME: this work correctly only because hash value can not\n\t\t *  be 0. Btw, in case of Yura's hash it is probably possible,\n\t\t * so, this is a bug\n\t\t */\n\t\treturn NAME_NOT_FOUND;\n\n\tRFALSE(de->de_item_num,\n\t       \"vs-7015: two diritems of the same directory in one node?\");\n\n\treturn GOTO_PREVIOUS_ITEM;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int linear_search_in_dir_item(struct cpu_key *key,\n\t\t\t\t     struct reiserfs_dir_entry *de,\n\t\t\t\t     const char *name, int namelen)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint retval;\n\tint i;\n\n\ti = de->de_entry_num;\n\n\tif (i == ih_entry_count(de->de_ih) ||\n\t    GET_HASH_VALUE(deh_offset(deh + i)) !=\n\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\ti--;\n\t}\n\n\tRFALSE(de->de_deh != B_I_DEH(de->de_bh, de->de_ih),\n\t       \"vs-7010: array of entry headers not found\");\n\n\tdeh += i;\n\n\tfor (; i >= 0; i--, deh--) {\n\t\t/* hash value does not match, no need to check whole name */\n\t\tif (GET_HASH_VALUE(deh_offset(deh)) !=\n\t\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\t\treturn NAME_NOT_FOUND;\n\t\t}\n\n\t\t/* mark that this generation number is used */\n\t\tif (de->de_gen_number_bit_string)\n\t\t\tset_bit(GET_GENERATION_NUMBER(deh_offset(deh)),\n\t\t\t\tde->de_gen_number_bit_string);\n\n\t\t/* calculate pointer to name and namelen */\n\t\tde->de_entry_num = i;\n\t\tset_de_name_and_namelen(de);\n\n\t\t/*\n\t\t * de's de_name, de_namelen, de_recordlen are set.\n\t\t * Fill the rest.\n\t\t */\n\t\tif ((retval =\n\t\t     reiserfs_match(de, name, namelen)) != NAME_NOT_FOUND) {\n\n\t\t\t/* key of pointed object */\n\t\t\tset_de_object_key(de);\n\n\t\t\tstore_de_entry_key(de);\n\n\t\t\t/* retval can be NAME_FOUND or NAME_FOUND_INVISIBLE */\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (GET_GENERATION_NUMBER(le_ih_k_offset(de->de_ih)) == 0)\n\t\t/*\n\t\t * we have reached left most entry in the node. In common we\n\t\t * have to go to the left neighbor, but if generation counter\n\t\t * is 0 already, we know for sure, that there is no name with\n\t\t * the same hash value\n\t\t */\n\t\t/*\n\t\t * FIXME: this work correctly only because hash value can not\n\t\t *  be 0. Btw, in case of Yura's hash it is probably possible,\n\t\t * so, this is a bug\n\t\t */\n\t\treturn NAME_NOT_FOUND;\n\n\tRFALSE(de->de_item_num,\n\t       \"vs-7015: two diritems of the same directory in one node?\");\n\n\treturn GOTO_PREVIOUS_ITEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "dir->i_sb",
            "\"zam-7001\"",
            "\"io error\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_by_entry_key",
          "args": [
            "dir->i_sb",
            "&key_to_search",
            "path_to_entry",
            "de"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "search_by_entry_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "120-175",
          "snippet": "int search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_cpu_key",
          "args": [
            "&key_to_search",
            "dir",
            "get_third_component(dir->i_sb, name, namelen)",
            "TYPE_DIRENTRY",
            "3"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "make_cpu_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "126-133",
          "snippet": "void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,\n\t\t  int type, int length)\n{\n\t_make_cpu_key(key, get_inode_item_key_version(inode),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),\n\t\t      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,\n\t\t      length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_third_component",
          "args": [
            "dir->i_sb",
            "name",
            "namelen"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "get_third_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "185-206",
          "snippet": "static __u32 get_third_component(struct super_block *s,\n\t\t\t\t const char *name, int len)\n{\n\t__u32 res;\n\n\tif (!len || (len == 1 && name[0] == '.'))\n\t\treturn DOT_OFFSET;\n\tif (len == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn DOT_DOT_OFFSET;\n\n\tres = REISERFS_SB(s)->s_hash_function(name, len);\n\n\t/* take bits from 7-th to 30-th including both bounds */\n\tres = GET_HASH_VALUE(res);\n\tif (res == 0)\n\t\t/*\n\t\t * needed to have no names before \".\" and \"..\" those have hash\n\t\t * value == 0 and generation conters 1 and 2 accordingly\n\t\t */\n\t\tres = 128;\n\treturn res + MAX_GENERATION_NUMBER;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic __u32 get_third_component(struct super_block *s,\n\t\t\t\t const char *name, int len)\n{\n\t__u32 res;\n\n\tif (!len || (len == 1 && name[0] == '.'))\n\t\treturn DOT_OFFSET;\n\tif (len == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn DOT_DOT_OFFSET;\n\n\tres = REISERFS_SB(s)->s_hash_function(name, len);\n\n\t/* take bits from 7-th to 30-th including both bounds */\n\tres = GET_HASH_VALUE(res);\n\tif (res == 0)\n\t\t/*\n\t\t * needed to have no names before \".\" and \"..\" those have hash\n\t\t * value == 0 and generation conters 1 and 2 accordingly\n\t\t */\n\t\tres = 128;\n\treturn res + MAX_GENERATION_NUMBER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_MAX_NAME",
          "args": [
            "dir->i_sb->s_blocksize"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_find_entry(struct inode *dir, const char *name, int namelen,\n\t\t\t       struct treepath *path_to_entry,\n\t\t\t       struct reiserfs_dir_entry *de)\n{\n\tstruct cpu_key key_to_search;\n\tint retval;\n\n\tif (namelen > REISERFS_MAX_NAME(dir->i_sb->s_blocksize))\n\t\treturn NAME_NOT_FOUND;\n\n\t/* we will search for this key in the tree */\n\tmake_cpu_key(&key_to_search, dir,\n\t\t     get_third_component(dir->i_sb, name, namelen),\n\t\t     TYPE_DIRENTRY, 3);\n\n\twhile (1) {\n\t\tretval =\n\t\t    search_by_entry_key(dir->i_sb, &key_to_search,\n\t\t\t\t\tpath_to_entry, de);\n\t\tif (retval == IO_ERROR) {\n\t\t\treiserfs_error(dir->i_sb, \"zam-7001\", \"io error\");\n\t\t\treturn IO_ERROR;\n\t\t}\n\n\t\t/* compare names for all entries having given hash value */\n\t\tretval =\n\t\t    linear_search_in_dir_item(&key_to_search, de, name,\n\t\t\t\t\t      namelen);\n\t\t/*\n\t\t * there is no need to scan directory anymore.\n\t\t * Given entry found or does not exist\n\t\t */\n\t\tif (retval != GOTO_PREVIOUS_ITEM) {\n\t\t\tpath_to_entry->pos_in_item = de->de_entry_num;\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\t * there is left neighboring item of this directory\n\t\t * and given entry can be there\n\t\t */\n\t\tset_cpu_key_k_offset(&key_to_search,\n\t\t\t\t     le_ih_k_offset(de->de_ih) - 1);\n\t\tpathrelse(path_to_entry);\n\n\t}\t\t\t/* while (1) */\n}"
  },
  {
    "function_name": "linear_search_in_dir_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "226-298",
    "snippet": "static int linear_search_in_dir_item(struct cpu_key *key,\n\t\t\t\t     struct reiserfs_dir_entry *de,\n\t\t\t\t     const char *name, int namelen)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint retval;\n\tint i;\n\n\ti = de->de_entry_num;\n\n\tif (i == ih_entry_count(de->de_ih) ||\n\t    GET_HASH_VALUE(deh_offset(deh + i)) !=\n\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\ti--;\n\t}\n\n\tRFALSE(de->de_deh != B_I_DEH(de->de_bh, de->de_ih),\n\t       \"vs-7010: array of entry headers not found\");\n\n\tdeh += i;\n\n\tfor (; i >= 0; i--, deh--) {\n\t\t/* hash value does not match, no need to check whole name */\n\t\tif (GET_HASH_VALUE(deh_offset(deh)) !=\n\t\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\t\treturn NAME_NOT_FOUND;\n\t\t}\n\n\t\t/* mark that this generation number is used */\n\t\tif (de->de_gen_number_bit_string)\n\t\t\tset_bit(GET_GENERATION_NUMBER(deh_offset(deh)),\n\t\t\t\tde->de_gen_number_bit_string);\n\n\t\t/* calculate pointer to name and namelen */\n\t\tde->de_entry_num = i;\n\t\tset_de_name_and_namelen(de);\n\n\t\t/*\n\t\t * de's de_name, de_namelen, de_recordlen are set.\n\t\t * Fill the rest.\n\t\t */\n\t\tif ((retval =\n\t\t     reiserfs_match(de, name, namelen)) != NAME_NOT_FOUND) {\n\n\t\t\t/* key of pointed object */\n\t\t\tset_de_object_key(de);\n\n\t\t\tstore_de_entry_key(de);\n\n\t\t\t/* retval can be NAME_FOUND or NAME_FOUND_INVISIBLE */\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (GET_GENERATION_NUMBER(le_ih_k_offset(de->de_ih)) == 0)\n\t\t/*\n\t\t * we have reached left most entry in the node. In common we\n\t\t * have to go to the left neighbor, but if generation counter\n\t\t * is 0 already, we know for sure, that there is no name with\n\t\t * the same hash value\n\t\t */\n\t\t/*\n\t\t * FIXME: this work correctly only because hash value can not\n\t\t *  be 0. Btw, in case of Yura's hash it is probably possible,\n\t\t * so, this is a bug\n\t\t */\n\t\treturn NAME_NOT_FOUND;\n\n\tRFALSE(de->de_item_num,\n\t       \"vs-7015: two diritems of the same directory in one node?\");\n\n\treturn GOTO_PREVIOUS_ITEM;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "de->de_item_num",
            "\"vs-7015: two diritems of the same directory in one node?\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_GENERATION_NUMBER",
          "args": [
            "le_ih_k_offset(de->de_ih)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "de->de_ih"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_de_entry_key",
          "args": [
            "de"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "store_de_entry_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "93-107",
          "snippet": "static inline void store_de_entry_key(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\t/* store key of the found entry */\n\tde->de_entry_key.version = KEY_FORMAT_3_5;\n\tde->de_entry_key.on_disk_key.k_dir_id =\n\t    le32_to_cpu(de->de_ih->ih_key.k_dir_id);\n\tde->de_entry_key.on_disk_key.k_objectid =\n\t    le32_to_cpu(de->de_ih->ih_key.k_objectid);\n\tset_cpu_key_k_offset(&de->de_entry_key, deh_offset(deh));\n\tset_cpu_key_k_type(&de->de_entry_key, TYPE_DIRENTRY);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline void store_de_entry_key(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\t/* store key of the found entry */\n\tde->de_entry_key.version = KEY_FORMAT_3_5;\n\tde->de_entry_key.on_disk_key.k_dir_id =\n\t    le32_to_cpu(de->de_ih->ih_key.k_dir_id);\n\tde->de_entry_key.on_disk_key.k_objectid =\n\t    le32_to_cpu(de->de_ih->ih_key.k_objectid);\n\tset_cpu_key_k_offset(&de->de_entry_key, deh_offset(deh));\n\tset_cpu_key_k_type(&de->de_entry_key, TYPE_DIRENTRY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_de_object_key",
          "args": [
            "de"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_object_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "86-91",
          "snippet": "static inline void set_de_object_key(struct reiserfs_dir_entry *de)\n{\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\tde->de_dir_id = deh_dir_id(&de->de_deh[de->de_entry_num]);\n\tde->de_objectid = deh_objectid(&de->de_deh[de->de_entry_num]);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline void set_de_object_key(struct reiserfs_dir_entry *de)\n{\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\tde->de_dir_id = deh_dir_id(&de->de_deh[de->de_entry_num]);\n\tde->de_objectid = deh_objectid(&de->de_deh[de->de_entry_num]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_match",
          "args": [
            "de",
            "name",
            "namelen"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "208-220",
          "snippet": "static int reiserfs_match(struct reiserfs_dir_entry *de,\n\t\t\t  const char *name, int namelen)\n{\n\tint retval = NAME_NOT_FOUND;\n\n\tif ((namelen == de->de_namelen) &&\n\t    !memcmp(de->de_name, name, de->de_namelen))\n\t\tretval =\n\t\t    (de_visible(de->de_deh + de->de_entry_num) ? NAME_FOUND :\n\t\t     NAME_FOUND_INVISIBLE);\n\n\treturn retval;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_match(struct reiserfs_dir_entry *de,\n\t\t\t  const char *name, int namelen)\n{\n\tint retval = NAME_NOT_FOUND;\n\n\tif ((namelen == de->de_namelen) &&\n\t    !memcmp(de->de_name, name, de->de_namelen))\n\t\tretval =\n\t\t    (de_visible(de->de_deh + de->de_entry_num) ? NAME_FOUND :\n\t\t     NAME_FOUND_INVISIBLE);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_de_name_and_namelen",
          "args": [
            "de"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_name_and_namelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "72-83",
          "snippet": "inline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\ninline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GET_GENERATION_NUMBER(deh_offset(deh))",
            "de->de_gen_number_bit_string"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_GENERATION_NUMBER",
          "args": [
            "deh_offset(deh)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "cpu_key_k_offset(key)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "key"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "deh_offset(deh)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "de->de_deh != B_I_DEH(de->de_bh, de->de_ih)",
            "\"vs-7010: array of entry headers not found\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "de->de_bh",
            "de->de_ih"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "cpu_key_k_offset(key)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "deh_offset(deh + i)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh + i"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "de->de_ih"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int linear_search_in_dir_item(struct cpu_key *key,\n\t\t\t\t     struct reiserfs_dir_entry *de,\n\t\t\t\t     const char *name, int namelen)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint retval;\n\tint i;\n\n\ti = de->de_entry_num;\n\n\tif (i == ih_entry_count(de->de_ih) ||\n\t    GET_HASH_VALUE(deh_offset(deh + i)) !=\n\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\ti--;\n\t}\n\n\tRFALSE(de->de_deh != B_I_DEH(de->de_bh, de->de_ih),\n\t       \"vs-7010: array of entry headers not found\");\n\n\tdeh += i;\n\n\tfor (; i >= 0; i--, deh--) {\n\t\t/* hash value does not match, no need to check whole name */\n\t\tif (GET_HASH_VALUE(deh_offset(deh)) !=\n\t\t    GET_HASH_VALUE(cpu_key_k_offset(key))) {\n\t\t\treturn NAME_NOT_FOUND;\n\t\t}\n\n\t\t/* mark that this generation number is used */\n\t\tif (de->de_gen_number_bit_string)\n\t\t\tset_bit(GET_GENERATION_NUMBER(deh_offset(deh)),\n\t\t\t\tde->de_gen_number_bit_string);\n\n\t\t/* calculate pointer to name and namelen */\n\t\tde->de_entry_num = i;\n\t\tset_de_name_and_namelen(de);\n\n\t\t/*\n\t\t * de's de_name, de_namelen, de_recordlen are set.\n\t\t * Fill the rest.\n\t\t */\n\t\tif ((retval =\n\t\t     reiserfs_match(de, name, namelen)) != NAME_NOT_FOUND) {\n\n\t\t\t/* key of pointed object */\n\t\t\tset_de_object_key(de);\n\n\t\t\tstore_de_entry_key(de);\n\n\t\t\t/* retval can be NAME_FOUND or NAME_FOUND_INVISIBLE */\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (GET_GENERATION_NUMBER(le_ih_k_offset(de->de_ih)) == 0)\n\t\t/*\n\t\t * we have reached left most entry in the node. In common we\n\t\t * have to go to the left neighbor, but if generation counter\n\t\t * is 0 already, we know for sure, that there is no name with\n\t\t * the same hash value\n\t\t */\n\t\t/*\n\t\t * FIXME: this work correctly only because hash value can not\n\t\t *  be 0. Btw, in case of Yura's hash it is probably possible,\n\t\t * so, this is a bug\n\t\t */\n\t\treturn NAME_NOT_FOUND;\n\n\tRFALSE(de->de_item_num,\n\t       \"vs-7015: two diritems of the same directory in one node?\");\n\n\treturn GOTO_PREVIOUS_ITEM;\n}"
  },
  {
    "function_name": "reiserfs_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "208-220",
    "snippet": "static int reiserfs_match(struct reiserfs_dir_entry *de,\n\t\t\t  const char *name, int namelen)\n{\n\tint retval = NAME_NOT_FOUND;\n\n\tif ((namelen == de->de_namelen) &&\n\t    !memcmp(de->de_name, name, de->de_namelen))\n\t\tretval =\n\t\t    (de_visible(de->de_deh + de->de_entry_num) ? NAME_FOUND :\n\t\t     NAME_FOUND_INVISIBLE);\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de_visible",
          "args": [
            "de->de_deh + de->de_entry_num"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "de->de_name",
            "name",
            "de->de_namelen"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int reiserfs_match(struct reiserfs_dir_entry *de,\n\t\t\t  const char *name, int namelen)\n{\n\tint retval = NAME_NOT_FOUND;\n\n\tif ((namelen == de->de_namelen) &&\n\t    !memcmp(de->de_name, name, de->de_namelen))\n\t\tretval =\n\t\t    (de_visible(de->de_deh + de->de_entry_num) ? NAME_FOUND :\n\t\t     NAME_FOUND_INVISIBLE);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "get_third_component",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "185-206",
    "snippet": "static __u32 get_third_component(struct super_block *s,\n\t\t\t\t const char *name, int len)\n{\n\t__u32 res;\n\n\tif (!len || (len == 1 && name[0] == '.'))\n\t\treturn DOT_OFFSET;\n\tif (len == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn DOT_DOT_OFFSET;\n\n\tres = REISERFS_SB(s)->s_hash_function(name, len);\n\n\t/* take bits from 7-th to 30-th including both bounds */\n\tres = GET_HASH_VALUE(res);\n\tif (res == 0)\n\t\t/*\n\t\t * needed to have no names before \".\" and \"..\" those have hash\n\t\t * value == 0 and generation conters 1 and 2 accordingly\n\t\t */\n\t\tres = 128;\n\treturn res + MAX_GENERATION_NUMBER;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GET_HASH_VALUE",
          "args": [
            "res"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "name",
            "len"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic __u32 get_third_component(struct super_block *s,\n\t\t\t\t const char *name, int len)\n{\n\t__u32 res;\n\n\tif (!len || (len == 1 && name[0] == '.'))\n\t\treturn DOT_OFFSET;\n\tif (len == 2 && name[0] == '.' && name[1] == '.')\n\t\treturn DOT_DOT_OFFSET;\n\n\tres = REISERFS_SB(s)->s_hash_function(name, len);\n\n\t/* take bits from 7-th to 30-th including both bounds */\n\tres = GET_HASH_VALUE(res);\n\tif (res == 0)\n\t\t/*\n\t\t * needed to have no names before \".\" and \"..\" those have hash\n\t\t * value == 0 and generation conters 1 and 2 accordingly\n\t\t */\n\t\tres = 128;\n\treturn res + MAX_GENERATION_NUMBER;\n}"
  },
  {
    "function_name": "search_by_entry_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "120-175",
    "snippet": "int search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_de_object_key",
          "args": [
            "de"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_object_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "86-91",
          "snippet": "static inline void set_de_object_key(struct reiserfs_dir_entry *de)\n{\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\tde->de_dir_id = deh_dir_id(&de->de_deh[de->de_entry_num]);\n\tde->de_objectid = deh_objectid(&de->de_deh[de->de_entry_num]);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline void set_de_object_key(struct reiserfs_dir_entry *de)\n{\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\tde->de_dir_id = deh_dir_id(&de->de_deh[de->de_entry_num]);\n\tde->de_objectid = deh_objectid(&de->de_deh[de->de_entry_num]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_de_name_and_namelen",
          "args": [
            "de"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_name_and_namelen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "72-83",
          "snippet": "inline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\ninline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bin_search_in_dir_item",
          "args": [
            "de",
            "cpu_key_k_offset(key)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "bin_search_in_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "29-55",
          "snippet": "static int bin_search_in_dir_item(struct reiserfs_dir_entry *de, loff_t off)\n{\n\tstruct item_head *ih = de->de_ih;\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint rbound, lbound, j;\n\n\tlbound = 0;\n\trbound = ih_entry_count(ih) - 1;\n\n\tfor (j = (rbound + lbound) / 2; lbound <= rbound;\n\t     j = (rbound + lbound) / 2) {\n\t\tif (off < deh_offset(deh + j)) {\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (off > deh_offset(deh + j)) {\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* this is not name found, but matched third key component */\n\t\tde->de_entry_num = j;\n\t\treturn NAME_FOUND;\n\t}\n\n\tde->de_entry_num = lbound;\n\treturn NAME_NOT_FOUND;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int bin_search_in_dir_item(struct reiserfs_dir_entry *de, loff_t off)\n{\n\tstruct item_head *ih = de->de_ih;\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint rbound, lbound, j;\n\n\tlbound = 0;\n\trbound = ih_entry_count(ih) - 1;\n\n\tfor (j = (rbound + lbound) / 2; lbound <= rbound;\n\t     j = (rbound + lbound) / 2) {\n\t\tif (off < deh_offset(deh + j)) {\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (off > deh_offset(deh + j)) {\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* this is not name found, but matched third key component */\n\t\tde->de_entry_num = j;\n\t\treturn NAME_FOUND;\n\t}\n\n\tde->de_entry_num = lbound;\n\treturn NAME_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_key_k_offset",
          "args": [
            "key"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_key_k_offset_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1603-1606",
          "snippet": "static inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void cpu_key_k_offset_dec(struct cpu_key *key)\n{\n\tkey->on_disk_key.k_offset--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"vs-7005\"",
            "\"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\"",
            "de->de_ih",
            "key"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_block",
          "args": [
            "de->de_bh",
            "0",
            "-1",
            "-1"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "print_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "593-617",
          "snippet": "void print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid print_block(struct buffer_head *bh, ...)\n{\n\tva_list args;\n\tint mode, first, last;\n\n\tif (!bh) {\n\t\tprintk(\"print_block: buffer is NULL\\n\");\n\t\treturn;\n\t}\n\n\tva_start(args, bh);\n\n\tmode = va_arg(args, int);\n\tfirst = va_arg(args, int);\n\tlast = va_arg(args, int);\n\tif (print_leaf(bh, mode, first, last))\n\t\tif (print_internal(bh, first, last))\n\t\t\tif (print_super_block(bh))\n\t\t\t\tif (print_desc_block(bh))\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"Block %llu contains unformatted data\\n\",\n\t\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMP_SHORT_KEYS",
          "args": [
            "&de->de_ih->ih_key",
            "key"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "de->de_ih"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_de_item_location",
          "args": [
            "de",
            "path"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_item_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "60-67",
          "snippet": "static inline void set_de_item_location(struct reiserfs_dir_entry *de,\n\t\t\t\t\tstruct treepath *path)\n{\n\tde->de_bh = get_last_bh(path);\n\tde->de_ih = tp_item_head(path);\n\tde->de_deh = B_I_DEH(de->de_bh, de->de_ih);\n\tde->de_item_num = PATH_LAST_POSITION(path);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline void set_de_item_location(struct reiserfs_dir_entry *de,\n\t\t\t\t\tstruct treepath *path)\n{\n\tde->de_bh = get_last_bh(path);\n\tde->de_ih = tp_item_head(path);\n\tde->de_deh = B_I_DEH(de->de_bh, de->de_ih);\n\tde->de_item_num = PATH_LAST_POSITION(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "sb",
            "\"vs-7002\"",
            "\"no path to here\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathrelse",
          "args": [
            "path"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "pathrelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "376-387",
          "snippet": "void pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nvoid pathrelse(struct treepath *search_path)\n{\n\tint path_offset = search_path->path_length;\n\n\tRFALSE(path_offset < ILLEGAL_PATH_ELEMENT_OFFSET,\n\t       \"PAP-5090: invalid path offset\");\n\n\twhile (path_offset > ILLEGAL_PATH_ELEMENT_OFFSET)\n\t\tbrelse(PATH_OFFSET_PBUFFER(search_path, path_offset--));\n\n\tsearch_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "sb",
            "\"vs-7000\"",
            "\"search_by_key \"\n\t\t\t\t       \"returned item position == 0\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_item",
          "args": [
            "sb",
            "key",
            "path"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nint search_by_entry_key(struct super_block *sb, const struct cpu_key *key,\n\t\t\tstruct treepath *path, struct reiserfs_dir_entry *de)\n{\n\tint retval;\n\n\tretval = search_item(sb, key, path);\n\tswitch (retval) {\n\tcase ITEM_NOT_FOUND:\n\t\tif (!PATH_LAST_POSITION(path)) {\n\t\t\treiserfs_error(sb, \"vs-7000\", \"search_by_key \"\n\t\t\t\t       \"returned item position == 0\");\n\t\t\tpathrelse(path);\n\t\t\treturn IO_ERROR;\n\t\t}\n\t\tPATH_LAST_POSITION(path)--;\n\n\tcase ITEM_FOUND:\n\t\tbreak;\n\n\tcase IO_ERROR:\n\t\treturn retval;\n\n\tdefault:\n\t\tpathrelse(path);\n\t\treiserfs_error(sb, \"vs-7002\", \"no path to here\");\n\t\treturn IO_ERROR;\n\t}\n\n\tset_de_item_location(de, path);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (!is_direntry_le_ih(de->de_ih) ||\n\t    COMP_SHORT_KEYS(&de->de_ih->ih_key, key)) {\n\t\tprint_block(de->de_bh, 0, -1, -1);\n\t\treiserfs_panic(sb, \"vs-7005\", \"found item %h is not directory \"\n\t\t\t       \"item or does not belong to the same directory \"\n\t\t\t       \"as key %K\", de->de_ih, key);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/*\n\t * binary search in directory item by third component of the\n\t * key. sets de->de_entry_num of de\n\t */\n\tretval = bin_search_in_dir_item(de, cpu_key_k_offset(key));\n\tpath->pos_in_item = de->de_entry_num;\n\tif (retval != NAME_NOT_FOUND) {\n\t\t/*\n\t\t * ugly, but rename needs de_bh, de_deh, de_name,\n\t\t * de_namelen, de_objectid set\n\t\t */\n\t\tset_de_name_and_namelen(de);\n\t\tset_de_object_key(de);\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "store_de_entry_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "93-107",
    "snippet": "static inline void store_de_entry_key(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\t/* store key of the found entry */\n\tde->de_entry_key.version = KEY_FORMAT_3_5;\n\tde->de_entry_key.on_disk_key.k_dir_id =\n\t    le32_to_cpu(de->de_ih->ih_key.k_dir_id);\n\tde->de_entry_key.on_disk_key.k_objectid =\n\t    le32_to_cpu(de->de_ih->ih_key.k_objectid);\n\tset_cpu_key_k_offset(&de->de_entry_key, deh_offset(deh));\n\tset_cpu_key_k_type(&de->de_entry_key, TYPE_DIRENTRY);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpu_key_k_type",
          "args": [
            "&de->de_entry_key",
            "TYPE_DIRENTRY"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1598-1601",
          "snippet": "static inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline void set_cpu_key_k_type(struct cpu_key *key, int type)\n{\n\tkey->on_disk_key.k_type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_key_k_offset",
          "args": [
            "&de->de_entry_key",
            "deh_offset(deh)"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1593-1596",
          "snippet": "static inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_short_keys(const struct reiserfs_key *le_key,\n\t\t\t   const struct cpu_key *cpu_key);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_cpu_key_k_offset(struct cpu_key *key, loff_t offset)\n{\n\tkey->on_disk_key.k_offset = offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->de_ih->ih_key.k_objectid"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "de->de_entry_num >= ih_entry_count(de->de_ih)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "de->de_ih"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline void store_de_entry_key(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\t/* store key of the found entry */\n\tde->de_entry_key.version = KEY_FORMAT_3_5;\n\tde->de_entry_key.on_disk_key.k_dir_id =\n\t    le32_to_cpu(de->de_ih->ih_key.k_dir_id);\n\tde->de_entry_key.on_disk_key.k_objectid =\n\t    le32_to_cpu(de->de_ih->ih_key.k_objectid);\n\tset_cpu_key_k_offset(&de->de_entry_key, deh_offset(deh));\n\tset_cpu_key_k_type(&de->de_entry_key, TYPE_DIRENTRY);\n}"
  },
  {
    "function_name": "set_de_object_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "86-91",
    "snippet": "static inline void set_de_object_key(struct reiserfs_dir_entry *de)\n{\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\tde->de_dir_id = deh_dir_id(&de->de_deh[de->de_entry_num]);\n\tde->de_objectid = deh_objectid(&de->de_deh[de->de_entry_num]);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deh_objectid",
          "args": [
            "&de->de_deh[de->de_entry_num]"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_dir_id",
          "args": [
            "&de->de_deh[de->de_entry_num]"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "de->de_entry_num >= ih_entry_count(de->de_ih)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "de->de_ih"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline void set_de_object_key(struct reiserfs_dir_entry *de)\n{\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\tde->de_dir_id = deh_dir_id(&de->de_deh[de->de_entry_num]);\n\tde->de_objectid = deh_objectid(&de->de_deh[de->de_entry_num]);\n}"
  },
  {
    "function_name": "set_de_name_and_namelen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "72-83",
    "snippet": "inline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "de->de_name"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "deh_location",
          "args": [
            "deh"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_body",
          "args": [
            "de->de_bh",
            "de->de_ih"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ih_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2213-2217",
          "snippet": "static inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline void *ih_item_body(const struct buffer_head *bh,\n\t\t\t\t const struct item_head *ih)\n{\n\treturn bh->b_data + ih_location(ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_with_sd",
          "args": [
            "deh"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry_length",
          "args": [
            "de->de_bh",
            "de->de_ih",
            "de->de_entry_num"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "entry_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2252-2262",
          "snippet": "static inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline int entry_length(const struct buffer_head *bh,\n\t\t\t       const struct item_head *ih, int pos_in_item)\n{\n\tstruct reiserfs_de_head *deh;\n\n\tdeh = B_I_DEH(bh, ih) + pos_in_item;\n\tif (pos_in_item)\n\t\treturn deh_location(deh - 1) - deh_location(deh);\n\n\treturn ih_item_len(ih) - deh_location(deh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "de->de_entry_num >= ih_entry_count(de->de_ih)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "de->de_ih"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\ninline void set_de_name_and_namelen(struct reiserfs_dir_entry *de)\n{\n\tstruct reiserfs_de_head *deh = de->de_deh + de->de_entry_num;\n\n\tBUG_ON(de->de_entry_num >= ih_entry_count(de->de_ih));\n\n\tde->de_entrylen = entry_length(de->de_bh, de->de_ih, de->de_entry_num);\n\tde->de_namelen = de->de_entrylen - (de_with_sd(deh) ? SD_SIZE : 0);\n\tde->de_name = ih_item_body(de->de_bh, de->de_ih) + deh_location(deh);\n\tif (de->de_name[de->de_namelen - 1] == 0)\n\t\tde->de_namelen = strlen(de->de_name);\n}"
  },
  {
    "function_name": "set_de_item_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "60-67",
    "snippet": "static inline void set_de_item_location(struct reiserfs_dir_entry *de,\n\t\t\t\t\tstruct treepath *path)\n{\n\tde->de_bh = get_last_bh(path);\n\tde->de_ih = tp_item_head(path);\n\tde->de_deh = B_I_DEH(de->de_bh, de->de_ih);\n\tde->de_item_num = PATH_LAST_POSITION(path);\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "path"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_I_DEH",
          "args": [
            "de->de_bh",
            "de->de_ih"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "path"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic inline void set_de_item_location(struct reiserfs_dir_entry *de,\n\t\t\t\t\tstruct treepath *path)\n{\n\tde->de_bh = get_last_bh(path);\n\tde->de_ih = tp_item_head(path);\n\tde->de_deh = B_I_DEH(de->de_bh, de->de_ih);\n\tde->de_item_num = PATH_LAST_POSITION(path);\n}"
  },
  {
    "function_name": "bin_search_in_dir_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
    "lines": "29-55",
    "snippet": "static int bin_search_in_dir_item(struct reiserfs_dir_entry *de, loff_t off)\n{\n\tstruct item_head *ih = de->de_ih;\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint rbound, lbound, j;\n\n\tlbound = 0;\n\trbound = ih_entry_count(ih) - 1;\n\n\tfor (j = (rbound + lbound) / 2; lbound <= rbound;\n\t     j = (rbound + lbound) / 2) {\n\t\tif (off < deh_offset(deh + j)) {\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (off > deh_offset(deh + j)) {\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* this is not name found, but matched third key component */\n\t\tde->de_entry_num = j;\n\t\treturn NAME_FOUND;\n\t}\n\n\tde->de_entry_num = lbound;\n\treturn NAME_NOT_FOUND;\n}",
    "includes": [
      "#include <linux/quotaops.h>",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"reiserfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh + j"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deh_offset",
          "args": [
            "deh + j"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "ih"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int bin_search_in_dir_item(struct reiserfs_dir_entry *de, loff_t off)\n{\n\tstruct item_head *ih = de->de_ih;\n\tstruct reiserfs_de_head *deh = de->de_deh;\n\tint rbound, lbound, j;\n\n\tlbound = 0;\n\trbound = ih_entry_count(ih) - 1;\n\n\tfor (j = (rbound + lbound) / 2; lbound <= rbound;\n\t     j = (rbound + lbound) / 2) {\n\t\tif (off < deh_offset(deh + j)) {\n\t\t\trbound = j - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (off > deh_offset(deh + j)) {\n\t\t\tlbound = j + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* this is not name found, but matched third key component */\n\t\tde->de_entry_num = j;\n\t\treturn NAME_FOUND;\n\t}\n\n\tde->de_entry_num = lbound;\n\treturn NAME_NOT_FOUND;\n}"
  }
]