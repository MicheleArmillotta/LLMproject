[
  {
    "function_name": "dlm_purge_requestqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
    "lines": "155-170",
    "snippet": "void dlm_purge_requestqueue(struct dlm_ls *ls)\n{\n\tstruct dlm_message *ms;\n\tstruct rq_entry *e, *safe;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\n\t\tms =  &e->request;\n\n\t\tif (purge_request(ls, ms, e->nodeid)) {\n\t\t\tlist_del(&e->list);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}",
    "includes": [
      "#include \"requestqueue.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"member.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "e"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->list"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "purge_request",
          "args": [
            "ls",
            "ms",
            "e->nodeid"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "purge_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
          "lines": "130-153",
          "snippet": "static int purge_request(struct dlm_ls *ls, struct dlm_message *ms, int nodeid)\n{\n\tuint32_t type = ms->m_type;\n\n\t/* the ls is being cleaned up and freed by release_lockspace */\n\tif (!ls->ls_count)\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, nodeid))\n\t\treturn 1;\n\n\t/* directory operations are always purged because the directory is\n\t   always rebuilt during recovery and the lookups resent */\n\n\tif (type == DLM_MSG_REMOVE ||\n\t    type == DLM_MSG_LOOKUP ||\n\t    type == DLM_MSG_LOOKUP_REPLY)\n\t\treturn 1;\n\n\tif (!dlm_no_directory(ls))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"requestqueue.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"member.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nstatic int purge_request(struct dlm_ls *ls, struct dlm_message *ms, int nodeid)\n{\n\tuint32_t type = ms->m_type;\n\n\t/* the ls is being cleaned up and freed by release_lockspace */\n\tif (!ls->ls_count)\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, nodeid))\n\t\treturn 1;\n\n\t/* directory operations are always purged because the directory is\n\t   always rebuilt during recovery and the lookups resent */\n\n\tif (type == DLM_MSG_REMOVE ||\n\t    type == DLM_MSG_LOOKUP ||\n\t    type == DLM_MSG_LOOKUP_REPLY)\n\t\treturn 1;\n\n\tif (!dlm_no_directory(ls))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "e",
            "safe",
            "&ls->ls_requestqueue",
            "list"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_purge_requestqueue(struct dlm_ls *ls)\n{\n\tstruct dlm_message *ms;\n\tstruct rq_entry *e, *safe;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_for_each_entry_safe(e, safe, &ls->ls_requestqueue, list) {\n\t\tms =  &e->request;\n\n\t\tif (purge_request(ls, ms, e->nodeid)) {\n\t\t\tlist_del(&e->list);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}"
  },
  {
    "function_name": "purge_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
    "lines": "130-153",
    "snippet": "static int purge_request(struct dlm_ls *ls, struct dlm_message *ms, int nodeid)\n{\n\tuint32_t type = ms->m_type;\n\n\t/* the ls is being cleaned up and freed by release_lockspace */\n\tif (!ls->ls_count)\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, nodeid))\n\t\treturn 1;\n\n\t/* directory operations are always purged because the directory is\n\t   always rebuilt during recovery and the lookups resent */\n\n\tif (type == DLM_MSG_REMOVE ||\n\t    type == DLM_MSG_LOOKUP ||\n\t    type == DLM_MSG_LOOKUP_REPLY)\n\t\treturn 1;\n\n\tif (!dlm_no_directory(ls))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"requestqueue.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"member.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_removed",
          "args": [
            "ls",
            "nodeid"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "358-363",
          "snippet": "int dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nstatic int purge_request(struct dlm_ls *ls, struct dlm_message *ms, int nodeid)\n{\n\tuint32_t type = ms->m_type;\n\n\t/* the ls is being cleaned up and freed by release_lockspace */\n\tif (!ls->ls_count)\n\t\treturn 1;\n\n\tif (dlm_is_removed(ls, nodeid))\n\t\treturn 1;\n\n\t/* directory operations are always purged because the directory is\n\t   always rebuilt during recovery and the lookups resent */\n\n\tif (type == DLM_MSG_REMOVE ||\n\t    type == DLM_MSG_LOOKUP ||\n\t    type == DLM_MSG_LOOKUP_REPLY)\n\t\treturn 1;\n\n\tif (!dlm_no_directory(ls))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "dlm_wait_requestqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
    "lines": "118-128",
    "snippet": "void dlm_wait_requestqueue(struct dlm_ls *ls)\n{\n\tfor (;;) {\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tif (list_empty(&ls->ls_requestqueue))\n\t\t\tbreak;\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}",
    "includes": [
      "#include \"requestqueue.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"member.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_requestqueue"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_wait_requestqueue(struct dlm_ls *ls)\n{\n\tfor (;;) {\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tif (list_empty(&ls->ls_requestqueue))\n\t\t\tbreak;\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\tschedule();\n\t}\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}"
  },
  {
    "function_name": "dlm_process_requestqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
    "lines": "65-106",
    "snippet": "int dlm_process_requestqueue(struct dlm_ls *ls)\n{\n\tstruct rq_entry *e;\n\tstruct dlm_message *ms;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\n\tfor (;;) {\n\t\tif (list_empty(&ls->ls_requestqueue)) {\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\te = list_entry(ls->ls_requestqueue.next, struct rq_entry, list);\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\n\t\tms = &e->request;\n\n\t\tlog_limit(ls, \"dlm_process_requestqueue msg %d from %d \"\n\t\t\t  \"lkid %x remid %x result %d seq %u\",\n\t\t\t  ms->m_type, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, ms->m_remid, ms->m_result,\n\t\t\t  e->recover_seq);\n\n\t\tdlm_receive_message_saved(ls, &e->request, e->recover_seq);\n\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tlist_del(&e->list);\n\t\tkfree(e);\n\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"process_requestqueue abort running\");\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"requestqueue.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"member.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"process_requestqueue abort running\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_locking_stopped",
          "args": [
            "ls"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_locking_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "695-698",
          "snippet": "static inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RUNNING\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RUNNING\t\t4\n\nstatic inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "e"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&e->list"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_receive_message_saved",
          "args": [
            "ls",
            "&e->request",
            "e->recover_seq"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_receive_message_saved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5007-5011",
          "snippet": "void dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);",
            "static int receive_extralen(struct dlm_message *ms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t\t    struct dlm_message *ms);\nstatic int receive_extralen(struct dlm_message *ms);\n\nvoid dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\n\t\t\t       uint32_t saved_seq)\n{\n\t_receive_message(ls, ms, saved_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_limit",
          "args": [
            "ls",
            "\"dlm_process_requestqueue msg %d from %d \"\n\t\t\t  \"lkid %x remid %x result %d seq %u\"",
            "ms->m_type",
            "ms->m_header.h_nodeid",
            "ms->m_lkid",
            "ms->m_remid",
            "ms->m_result",
            "e->recover_seq"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ls->ls_requestqueue.next",
            "structrq_entry",
            "list"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_requestqueue"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nint dlm_process_requestqueue(struct dlm_ls *ls)\n{\n\tstruct rq_entry *e;\n\tstruct dlm_message *ms;\n\tint error = 0;\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\n\tfor (;;) {\n\t\tif (list_empty(&ls->ls_requestqueue)) {\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\te = list_entry(ls->ls_requestqueue.next, struct rq_entry, list);\n\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\n\t\tms = &e->request;\n\n\t\tlog_limit(ls, \"dlm_process_requestqueue msg %d from %d \"\n\t\t\t  \"lkid %x remid %x result %d seq %u\",\n\t\t\t  ms->m_type, ms->m_header.h_nodeid,\n\t\t\t  ms->m_lkid, ms->m_remid, ms->m_result,\n\t\t\t  e->recover_seq);\n\n\t\tdlm_receive_message_saved(ls, &e->request, e->recover_seq);\n\n\t\tmutex_lock(&ls->ls_requestqueue_mutex);\n\t\tlist_del(&e->list);\n\t\tkfree(e);\n\n\t\tif (dlm_locking_stopped(ls)) {\n\t\t\tlog_debug(ls, \"process_requestqueue abort running\");\n\t\t\tmutex_unlock(&ls->ls_requestqueue_mutex);\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_add_requestqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/requestqueue.c",
    "lines": "34-52",
    "snippet": "void dlm_add_requestqueue(struct dlm_ls *ls, int nodeid, struct dlm_message *ms)\n{\n\tstruct rq_entry *e;\n\tint length = ms->m_header.h_length - sizeof(struct dlm_message);\n\n\te = kmalloc(sizeof(struct rq_entry) + length, GFP_NOFS);\n\tif (!e) {\n\t\tlog_print(\"dlm_add_requestqueue: out of memory len %d\", length);\n\t\treturn;\n\t}\n\n\te->recover_seq = ls->ls_recover_seq & 0xFFFFFFFF;\n\te->nodeid = nodeid;\n\tmemcpy(&e->request, ms, ms->m_header.h_length);\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_add_tail(&e->list, &ls->ls_requestqueue);\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}",
    "includes": [
      "#include \"requestqueue.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lock.h\"",
      "#include \"member.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&e->list",
            "&ls->ls_requestqueue"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_requestqueue_mutex"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&e->request",
            "ms",
            "ms->m_header.h_length"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"dlm_add_requestqueue: out of memory len %d\"",
            "length"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct rq_entry) + length",
            "GFP_NOFS"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"requestqueue.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lock.h\"\n#include \"member.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_add_requestqueue(struct dlm_ls *ls, int nodeid, struct dlm_message *ms)\n{\n\tstruct rq_entry *e;\n\tint length = ms->m_header.h_length - sizeof(struct dlm_message);\n\n\te = kmalloc(sizeof(struct rq_entry) + length, GFP_NOFS);\n\tif (!e) {\n\t\tlog_print(\"dlm_add_requestqueue: out of memory len %d\", length);\n\t\treturn;\n\t}\n\n\te->recover_seq = ls->ls_recover_seq & 0xFFFFFFFF;\n\te->nodeid = nodeid;\n\tmemcpy(&e->request, ms, ms->m_header.h_length);\n\n\tmutex_lock(&ls->ls_requestqueue_mutex);\n\tlist_add_tail(&e->list, &ls->ls_requestqueue);\n\tmutex_unlock(&ls->ls_requestqueue_mutex);\n}"
  }
]