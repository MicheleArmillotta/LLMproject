[
  {
    "function_name": "udf_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/dir.c",
    "lines": "39-191",
    "snippet": "static int udf_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\tstruct udf_fileident_bh fibh = { .sbh = NULL, .ebh = NULL};\n\tstruct fileIdentDesc *fi = NULL;\n\tstruct fileIdentDesc cfi;\n\tint block, iblock;\n\tloff_t nf_pos;\n\tint flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint16_t liu;\n\tuint8_t lfi;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tint i, num, ret = 0;\n\tstruct extent_position epos = { NULL, 0, {0, 0} };\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1;\n\t}\n\tnf_pos = (ctx->pos - 1) << 2;\n\tif (nf_pos >= size)\n\t\tgoto out;\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nf_pos == 0)\n\t\tnf_pos = udf_ext0_offset(dir);\n\n\tfibh.soffset = fibh.eoffset = nf_pos & (sb->s_blocksize - 1);\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, nf_pos >> sb->s_blocksize_bits,\n\t\t    &epos, &eloc, &elen, &offset)\n\t\t    != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (iinfo->i_alloc_type ==\n\t\t\t\t\tICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else {\n\t\t\toffset = 0;\n\t\t}\n\n\t\tif (!(fibh.sbh = fibh.ebh = udf_tread(sb, block))) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(offset & ((16 >> (sb->s_blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (sb->s_blocksize_bits - 9);\n\t\t\tif (i + offset > (elen >> sb->s_blocksize_bits))\n\t\t\t\ti = (elen >> sb->s_blocksize_bits) - offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(sb, &eloc, offset + i);\n\t\t\t\ttmp = udf_tgetblk(sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) && !buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (nf_pos < size) {\n\t\tstruct kernel_lb_addr tloc;\n\n\t\tctx->pos = (nf_pos >> 2) + 1;\n\n\t\tfi = udf_fileident_read(dir, &nf_pos, &fibh, &cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out;\n\n\t\tliu = le16_to_cpu(cfi.lengthOfImpUse);\n\t\tlfi = cfi.lengthFileIdent;\n\n\t\tif (fibh.sbh == fibh.ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh.soffset + sizeof(struct fileIdentDesc) + liu + lfi;\n\n\t\t\tif (poffset >= lfi) {\n\t\t\t\tnameptr = (char *)(fibh.ebh->b_data + poffset - lfi);\n\t\t\t} else {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t       lfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t       fibh.ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (cfi.fileCharacteristics & FID_FILE_CHAR_PARENT) {\n\t\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (!flen)\n\t\t\tcontinue;\n\n\t\ttloc = lelb_to_cpu(cfi.icb.extLocation);\n\t\tiblock = udf_get_lb_pblock(sb, &tloc, 0);\n\t\tif (!dir_emit(ctx, fname, flen, iblock, DT_UNKNOWN))\n\t\t\tgoto out;\n\t} /* end while */\n\n\tctx->pos = (nf_pos >> 2) + 1;\n\nout:\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fname"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "fname",
            "flen",
            "iblock",
            "DT_UNKNOWN"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "&tloc",
            "0"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "cfi.icb.extLocation"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_filename",
          "args": [
            "sb",
            "nameptr",
            "lfi",
            "fname",
            "UDF_NAME_LEN"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/unicode.c",
          "lines": "337-378",
          "snippet": "int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, slen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, dlen,\n\t\t\t\t     filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>\t/* for memset */",
            "#include <linux/kernel.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include <linux/slab.h>\n#include <linux/crc-itu-t.h>\n#include <linux/nls.h>\n#include <linux/string.h>\t/* for memset */\n#include <linux/kernel.h>\n#include \"udfdecl.h\"\n\nstatic int udf_translate_to_linux(uint8_t *, int, uint8_t *, int, uint8_t *,\n\t\t\t\t  int);\n\nint udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, slen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, dlen,\n\t\t\t\t     filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dotdot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_UNHIDE"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nameptr + lfi - poffset",
            "fibh.ebh->b_data",
            "poffset"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nameptr",
            "fi->fileIdent + liu",
            "lfi - poffset"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cfi.lengthOfImpUse"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_fileident_read",
          "args": [
            "dir",
            "&nf_pos",
            "&fibh",
            "&cfi",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "udf_fileident_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "21-155",
          "snippet": "struct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READA",
            "num",
            "bha"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "tmp"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "tmp"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tgetblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tgetblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "32-38",
          "snippet": "struct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "sb",
            "block"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_bmap",
          "args": [
            "dir",
            "nf_pos >> sb->s_blocksize_bits",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "inode_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2237-2268",
          "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_ext0_offset",
          "args": [
            "dir"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "udf_ext0_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "66-72",
          "snippet": "static inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "UDF_NAME_LEN",
            "GFP_NOFS"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "dir"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udfdecl.h\"\n\nstatic int udf_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\tstruct udf_fileident_bh fibh = { .sbh = NULL, .ebh = NULL};\n\tstruct fileIdentDesc *fi = NULL;\n\tstruct fileIdentDesc cfi;\n\tint block, iblock;\n\tloff_t nf_pos;\n\tint flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint16_t liu;\n\tuint8_t lfi;\n\tloff_t size = udf_ext0_offset(dir) + dir->i_size;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tint i, num, ret = 0;\n\tstruct extent_position epos = { NULL, 0, {0, 0} };\n\tstruct super_block *sb = dir->i_sb;\n\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1;\n\t}\n\tnf_pos = (ctx->pos - 1) << 2;\n\tif (nf_pos >= size)\n\t\tgoto out;\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nf_pos == 0)\n\t\tnf_pos = udf_ext0_offset(dir);\n\n\tfibh.soffset = fibh.eoffset = nf_pos & (sb->s_blocksize - 1);\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, nf_pos >> sb->s_blocksize_bits,\n\t\t    &epos, &eloc, &elen, &offset)\n\t\t    != (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tblock = udf_get_lb_pblock(sb, &eloc, offset);\n\t\tif ((++offset << sb->s_blocksize_bits) < elen) {\n\t\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (iinfo->i_alloc_type ==\n\t\t\t\t\tICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else {\n\t\t\toffset = 0;\n\t\t}\n\n\t\tif (!(fibh.sbh = fibh.ebh = udf_tread(sb, block))) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(offset & ((16 >> (sb->s_blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (sb->s_blocksize_bits - 9);\n\t\t\tif (i + offset > (elen >> sb->s_blocksize_bits))\n\t\t\t\ti = (elen >> sb->s_blocksize_bits) - offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(sb, &eloc, offset + i);\n\t\t\t\ttmp = udf_tgetblk(sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) && !buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (nf_pos < size) {\n\t\tstruct kernel_lb_addr tloc;\n\n\t\tctx->pos = (nf_pos >> 2) + 1;\n\n\t\tfi = udf_fileident_read(dir, &nf_pos, &fibh, &cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out;\n\n\t\tliu = le16_to_cpu(cfi.lengthOfImpUse);\n\t\tlfi = cfi.lengthFileIdent;\n\n\t\tif (fibh.sbh == fibh.ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh.soffset + sizeof(struct fileIdentDesc) + liu + lfi;\n\n\t\t\tif (poffset >= lfi) {\n\t\t\t\tnameptr = (char *)(fibh.ebh->b_data + poffset - lfi);\n\t\t\t} else {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t       lfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t       fibh.ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (cfi.fileCharacteristics & FID_FILE_CHAR_PARENT) {\n\t\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\tflen = udf_get_filename(sb, nameptr, lfi, fname, UDF_NAME_LEN);\n\t\tif (!flen)\n\t\t\tcontinue;\n\n\t\ttloc = lelb_to_cpu(cfi.icb.extLocation);\n\t\tiblock = udf_get_lb_pblock(sb, &tloc, 0);\n\t\tif (!dir_emit(ctx, fname, flen, iblock, DT_UNKNOWN))\n\t\t\tgoto out;\n\t} /* end while */\n\n\tctx->pos = (nf_pos >> 2) + 1;\n\nout:\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn ret;\n}"
  }
]