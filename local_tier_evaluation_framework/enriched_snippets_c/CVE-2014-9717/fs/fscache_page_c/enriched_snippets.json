[
  {
    "function_name": "__fscache_uncache_all_inode_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "1161-1194",
    "snippet": "void __fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,\n\t\t\t\t       struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i;\n\n\t_enter(\"%p,%p\", cookie, inode);\n\n\tif (!mapping || mapping->nrpages == 0) {\n\t\t_leave(\" [no pages]\");\n\t\treturn;\n\t}\n\n\tpagevec_init(&pvec, 0);\n\tnext = 0;\n\tdo {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tnext = page->index;\n\t\t\tif (PageFsCache(page)) {\n\t\t\t\t__fscache_wait_on_page_write(cookie, page);\n\t\t\t\t__fscache_uncache_page(cookie, page);\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t} while (++next);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_uncache_page",
          "args": [
            "cookie",
            "page"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_wait_on_page_write",
          "args": [
            "cookie",
            "page"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "38-43",
          "snippet": "void __fscache_wait_on_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&cookie->flags, 0);\n\n\twait_event(*wq, !__fscache_check_page_write(cookie, page));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_wait_on_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&cookie->flags, 0);\n\n\twait_event(*wq, !__fscache_check_page_write(cookie, page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "mapping",
            "next",
            "PAGEVEC_SIZE"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p\"",
            "cookie",
            "inode"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,\n\t\t\t\t       struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t next;\n\tint i;\n\n\t_enter(\"%p,%p\", cookie, inode);\n\n\tif (!mapping || mapping->nrpages == 0) {\n\t\t_leave(\" [no pages]\");\n\t\treturn;\n\t}\n\n\tpagevec_init(&pvec, 0);\n\tnext = 0;\n\tdo {\n\t\tif (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))\n\t\t\tbreak;\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tnext = page->index;\n\t\t\tif (PageFsCache(page)) {\n\t\t\t\t__fscache_wait_on_page_write(cookie, page);\n\t\t\t\t__fscache_uncache_page(cookie, page);\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t} while (++next);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_mark_pages_cached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "1145-1154",
    "snippet": "void fscache_mark_pages_cached(struct fscache_retrieval *op,\n\t\t\t       struct pagevec *pagevec)\n{\n\tunsigned long loop;\n\n\tfor (loop = 0; loop < pagevec->nr; loop++)\n\t\tfscache_mark_page_cached(op, pagevec->pages[loop]);\n\n\tpagevec_reinit(pagevec);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_reinit",
          "args": [
            "pagevec"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_mark_page_cached",
          "args": [
            "op",
            "pagevec->pages[loop]"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_mark_page_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1113-1134",
          "snippet": "void fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_pages_cached(struct fscache_retrieval *op,\n\t\t\t       struct pagevec *pagevec)\n{\n\tunsigned long loop;\n\n\tfor (loop = 0; loop < pagevec->nr; loop++)\n\t\tfscache_mark_page_cached(op, pagevec->pages[loop]);\n\n\tpagevec_reinit(pagevec);\n}"
  },
  {
    "function_name": "fscache_mark_page_cached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "1113-1134",
    "snippet": "void fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cookie->def->mark_page_cached",
          "args": [
            "cookie->netfs_data",
            "op->mapping",
            "page"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Cookie type %s marked page %lx multiple times\\n\"",
            "cookie->def->name",
            "page->index"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageFsCache",
          "args": [
            "page"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"- mark %p{%lx}\"",
            "page",
            "page->index"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fscache_n_marks"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_mark_page_cached(struct fscache_retrieval *op, struct page *page)\n{\n\tstruct fscache_cookie *cookie = op->op.object->cookie;\n\n#ifdef CONFIG_FSCACHE_STATS\n\tatomic_inc(&fscache_n_marks);\n#endif\n\n\t_debug(\"- mark %p{%lx}\", page, page->index);\n\tif (TestSetPageFsCache(page)) {\n\t\tstatic bool once_only;\n\t\tif (!once_only) {\n\t\t\tonce_only = true;\n\t\t\tpr_warn(\"Cookie type %s marked page %lx multiple times\\n\",\n\t\t\t\tcookie->def->name, page->index);\n\t\t}\n\t}\n\n\tif (cookie->def->mark_page_cached)\n\t\tcookie->def->mark_page_cached(cookie->netfs_data,\n\t\t\t\t\t      op->mapping, page);\n}"
  },
  {
    "function_name": "__fscache_uncache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "1058-1102",
    "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_uncache_page"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->uncache_page",
          "args": [
            "object",
            "page"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageFsCache",
          "args": [
            "page"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FSCACHE_COOKIE_NO_DATA_YET",
            "&cookie->flags"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageFsCache",
          "args": [
            "page"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "page",
            "!=, NULL"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "cookie->def->type",
            "!=, FSCACHE_COOKIE_TYPE_INDEX"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%p\"",
            "page"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "__fscache_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "922-1052",
    "snippet": "int __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_stores_oom"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_wake_unused_cookie",
          "args": [
            "cookie"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_unuse_cookie",
          "args": [
            "cookie"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&cookie->stores",
            "page->index"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->stores_lock"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "&op->op"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_submit_op",
          "args": [
            "object",
            "&op->op"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_submit_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "186-248",
          "snippet": "int fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_use_cookie",
          "args": [
            "cookie"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&fscache_op_debug_id"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "FSCACHE_OBJECT_PENDING_WRITE",
            "&object->flags"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&cookie->stores",
            "page->index",
            "FSCACHE_COOKIE_PENDING_TAG"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"insert failed %d\"",
            "ret"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&cookie->stores",
            "page->index",
            "page"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_IOERROR",
            "&object->cache->flags"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_maybe_preload",
          "args": [
            "gfp & ~__GFP_HIGHMEM"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_operation_init",
          "args": [
            "&op->op",
            "fscache_write_op",
            "fscache_release_write_op"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*op)",
            "GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "PageFsCache(page)"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "cookie->def->type",
            "!=, FSCACHE_COOKIE_TYPE_INDEX"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%x,\"",
            "cookie",
            "(u32) page->flags"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "fscache_invalidate_writes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "861-891",
    "snippet": "void fscache_invalidate_writes(struct fscache_cookie *cookie)\n{\n\tstruct page *page;\n\tvoid *results[16];\n\tint n, i;\n\n\t_enter(\"\");\n\n\tfor (;;) {\n\t\tspin_lock(&cookie->stores_lock);\n\t\tn = radix_tree_gang_lookup_tag(&cookie->stores, results, 0,\n\t\t\t\t\t       ARRAY_SIZE(results),\n\t\t\t\t\t       FSCACHE_COOKIE_PENDING_TAG);\n\t\tif (n == 0) {\n\t\t\tspin_unlock(&cookie->stores_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\tpage = results[i];\n\t\t\tradix_tree_delete(&cookie->stores, page->index);\n\t\t}\n\n\t\tspin_unlock(&cookie->stores_lock);\n\n\t\tfor (i = n - 1; i >= 0; i--)\n\t\t\tpage_cache_release(results[i]);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "results[i]"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->stores_lock"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&cookie->stores",
            "page->index"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup_tag",
          "args": [
            "&cookie->stores",
            "results",
            "0",
            "ARRAY_SIZE(results)",
            "FSCACHE_COOKIE_PENDING_TAG"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "results"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->stores_lock"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid fscache_invalidate_writes(struct fscache_cookie *cookie)\n{\n\tstruct page *page;\n\tvoid *results[16];\n\tint n, i;\n\n\t_enter(\"\");\n\n\tfor (;;) {\n\t\tspin_lock(&cookie->stores_lock);\n\t\tn = radix_tree_gang_lookup_tag(&cookie->stores, results, 0,\n\t\t\t\t\t       ARRAY_SIZE(results),\n\t\t\t\t\t       FSCACHE_COOKIE_PENDING_TAG);\n\t\tif (n == 0) {\n\t\t\tspin_unlock(&cookie->stores_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\tpage = results[i];\n\t\t\tradix_tree_delete(&cookie->stores, page->index);\n\t\t}\n\n\t\tspin_unlock(&cookie->stores_lock);\n\n\t\tfor (i = n - 1; i >= 0; i--)\n\t\t\tpage_cache_release(results[i]);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_write_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "766-856",
    "snippet": "static void fscache_write_op(struct fscache_operation *_op)\n{\n\tstruct fscache_storage *op =\n\t\tcontainer_of(_op, struct fscache_storage, op);\n\tstruct fscache_object *object = op->op.object;\n\tstruct fscache_cookie *cookie;\n\tstruct page *page;\n\tunsigned n;\n\tvoid *results[1];\n\tint ret;\n\n\t_enter(\"{OP%x,%d}\", op->op.debug_id, atomic_read(&op->op.usage));\n\n\tspin_lock(&object->lock);\n\tcookie = object->cookie;\n\n\tif (!fscache_object_is_active(object)) {\n\t\t/* If we get here, then the on-disk cache object likely longer\n\t\t * exists, so we should just cancel this write operation.\n\t\t */\n\t\tspin_unlock(&object->lock);\n\t\tfscache_op_complete(&op->op, false);\n\t\t_leave(\" [inactive]\");\n\t\treturn;\n\t}\n\n\tif (!cookie) {\n\t\t/* If we get here, then the cookie belonging to the object was\n\t\t * detached, probably by the cookie being withdrawn due to\n\t\t * memory pressure, which means that the pages we might write\n\t\t * to the cache from no longer exist - therefore, we can just\n\t\t * cancel this write operation.\n\t\t */\n\t\tspin_unlock(&object->lock);\n\t\tfscache_op_complete(&op->op, false);\n\t\t_leave(\" [cancel] op{f=%lx s=%u} obj{s=%s f=%lx}\",\n\t\t       _op->flags, _op->state, object->state->short_name,\n\t\t       object->flags);\n\t\treturn;\n\t}\n\n\tspin_lock(&cookie->stores_lock);\n\n\tfscache_stat(&fscache_n_store_calls);\n\n\t/* find a page to store */\n\tpage = NULL;\n\tn = radix_tree_gang_lookup_tag(&cookie->stores, results, 0, 1,\n\t\t\t\t       FSCACHE_COOKIE_PENDING_TAG);\n\tif (n != 1)\n\t\tgoto superseded;\n\tpage = results[0];\n\t_debug(\"gang %d [%lx]\", n, page->index);\n\tif (page->index > op->store_limit) {\n\t\tfscache_stat(&fscache_n_store_pages_over_limit);\n\t\tgoto superseded;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_STORING_TAG);\n\tradix_tree_tag_clear(&cookie->stores, page->index,\n\t\t\t     FSCACHE_COOKIE_PENDING_TAG);\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\tfscache_stat(&fscache_n_store_pages);\n\tfscache_stat(&fscache_n_cop_write_page);\n\tret = object->cache->ops->write_page(op, page);\n\tfscache_stat_d(&fscache_n_cop_write_page);\n\tfscache_end_page_write(object, page);\n\tif (ret < 0) {\n\t\tfscache_abort_object(object);\n\t\tfscache_op_complete(&op->op, true);\n\t} else {\n\t\tfscache_enqueue_operation(&op->op);\n\t}\n\n\t_leave(\"\");\n\treturn;\n\nsuperseded:\n\t/* this writer is going away and there aren't any more things to\n\t * write */\n\t_debug(\"cease\");\n\tspin_unlock(&cookie->stores_lock);\n\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\tspin_unlock(&object->lock);\n\tfscache_op_complete(&op->op, true);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_op_complete",
          "args": [
            "&op->op",
            "true"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_op_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "365-391",
          "snippet": "void fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FSCACHE_OBJECT_PENDING_WRITE",
            "&object->flags"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"cease\""
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_enqueue_operation",
          "args": [
            "&op->op"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_enqueue_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "31-58",
          "snippet": "void fscache_enqueue_operation(struct fscache_operation *op)\n{\n\t_enter(\"{OBJ%x OP%x,%u}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERT(list_empty(&op->pend_link));\n\tASSERT(op->processor != NULL);\n\tASSERT(fscache_object_is_available(op->object));\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\n\tfscache_stat(&fscache_n_op_enqueue);\n\tswitch (op->flags & FSCACHE_OP_TYPE) {\n\tcase FSCACHE_OP_ASYNC:\n\t\t_debug(\"queue async\");\n\t\tatomic_inc(&op->usage);\n\t\tif (!queue_work(fscache_op_wq, &op->work))\n\t\t\tfscache_put_operation(op);\n\t\tbreak;\n\tcase FSCACHE_OP_MYTHREAD:\n\t\t_debug(\"queue for caller's attention\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unexpected op type %lx\", op->flags);\n\t\tBUG();\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_enqueue_operation(struct fscache_operation *op)\n{\n\t_enter(\"{OBJ%x OP%x,%u}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERT(list_empty(&op->pend_link));\n\tASSERT(op->processor != NULL);\n\tASSERT(fscache_object_is_available(op->object));\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\n\tfscache_stat(&fscache_n_op_enqueue);\n\tswitch (op->flags & FSCACHE_OP_TYPE) {\n\tcase FSCACHE_OP_ASYNC:\n\t\t_debug(\"queue async\");\n\t\tatomic_inc(&op->usage);\n\t\tif (!queue_work(fscache_op_wq, &op->work))\n\t\t\tfscache_put_operation(op);\n\t\tbreak;\n\tcase FSCACHE_OP_MYTHREAD:\n\t\t_debug(\"queue for caller's attention\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unexpected op type %lx\", op->flags);\n\t\tBUG();\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_abort_object",
          "args": [
            "object"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_abort_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "254-259",
          "snippet": "void fscache_abort_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_abort_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_end_page_write",
          "args": [
            "object",
            "page"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_end_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "143-168",
          "snippet": "static void fscache_end_page_write(struct fscache_object *object,\n\t\t\t\t   struct page *page)\n{\n\tstruct fscache_cookie *cookie;\n\tstruct page *xpage = NULL;\n\n\tspin_lock(&object->lock);\n\tcookie = object->cookie;\n\tif (cookie) {\n\t\t/* delete the page from the tree if it is now no longer\n\t\t * pending */\n\t\tspin_lock(&cookie->stores_lock);\n\t\tradix_tree_tag_clear(&cookie->stores, page->index,\n\t\t\t\t     FSCACHE_COOKIE_STORING_TAG);\n\t\tif (!radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t\t\tFSCACHE_COOKIE_PENDING_TAG)) {\n\t\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\t\txpage = radix_tree_delete(&cookie->stores, page->index);\n\t\t}\n\t\tspin_unlock(&cookie->stores_lock);\n\t\twake_up_bit(&cookie->flags, 0);\n\t}\n\tspin_unlock(&object->lock);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic void fscache_end_page_write(struct fscache_object *object,\n\t\t\t\t   struct page *page)\n{\n\tstruct fscache_cookie *cookie;\n\tstruct page *xpage = NULL;\n\n\tspin_lock(&object->lock);\n\tcookie = object->cookie;\n\tif (cookie) {\n\t\t/* delete the page from the tree if it is now no longer\n\t\t * pending */\n\t\tspin_lock(&cookie->stores_lock);\n\t\tradix_tree_tag_clear(&cookie->stores, page->index,\n\t\t\t\t     FSCACHE_COOKIE_STORING_TAG);\n\t\tif (!radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t\t\tFSCACHE_COOKIE_PENDING_TAG)) {\n\t\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\t\txpage = radix_tree_delete(&cookie->stores, page->index);\n\t\t}\n\t\tspin_unlock(&cookie->stores_lock);\n\t\twake_up_bit(&cookie->flags, 0);\n\t}\n\tspin_unlock(&object->lock);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_write_page"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->write_page",
          "args": [
            "op",
            "page"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&cookie->stores",
            "page->index",
            "FSCACHE_COOKIE_PENDING_TAG"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&cookie->stores",
            "page->index",
            "FSCACHE_COOKIE_STORING_TAG"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"gang %d [%lx]\"",
            "n",
            "page->index"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup_tag",
          "args": [
            "&cookie->stores",
            "results",
            "0",
            "1",
            "FSCACHE_COOKIE_PENDING_TAG"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->stores_lock"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [cancel] op{f=%lx s=%u} obj{s=%s f=%lx}\"",
            "_op->flags",
            "_op->state",
            "object->state->short_name",
            "object->flags"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_active",
          "args": [
            "object"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OP%x,%d}\"",
            "op->op.debug_id",
            "atomic_read(&op->op.usage)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->op.usage"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_op",
            "structfscache_storage",
            "op"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic void fscache_write_op(struct fscache_operation *_op)\n{\n\tstruct fscache_storage *op =\n\t\tcontainer_of(_op, struct fscache_storage, op);\n\tstruct fscache_object *object = op->op.object;\n\tstruct fscache_cookie *cookie;\n\tstruct page *page;\n\tunsigned n;\n\tvoid *results[1];\n\tint ret;\n\n\t_enter(\"{OP%x,%d}\", op->op.debug_id, atomic_read(&op->op.usage));\n\n\tspin_lock(&object->lock);\n\tcookie = object->cookie;\n\n\tif (!fscache_object_is_active(object)) {\n\t\t/* If we get here, then the on-disk cache object likely longer\n\t\t * exists, so we should just cancel this write operation.\n\t\t */\n\t\tspin_unlock(&object->lock);\n\t\tfscache_op_complete(&op->op, false);\n\t\t_leave(\" [inactive]\");\n\t\treturn;\n\t}\n\n\tif (!cookie) {\n\t\t/* If we get here, then the cookie belonging to the object was\n\t\t * detached, probably by the cookie being withdrawn due to\n\t\t * memory pressure, which means that the pages we might write\n\t\t * to the cache from no longer exist - therefore, we can just\n\t\t * cancel this write operation.\n\t\t */\n\t\tspin_unlock(&object->lock);\n\t\tfscache_op_complete(&op->op, false);\n\t\t_leave(\" [cancel] op{f=%lx s=%u} obj{s=%s f=%lx}\",\n\t\t       _op->flags, _op->state, object->state->short_name,\n\t\t       object->flags);\n\t\treturn;\n\t}\n\n\tspin_lock(&cookie->stores_lock);\n\n\tfscache_stat(&fscache_n_store_calls);\n\n\t/* find a page to store */\n\tpage = NULL;\n\tn = radix_tree_gang_lookup_tag(&cookie->stores, results, 0, 1,\n\t\t\t\t       FSCACHE_COOKIE_PENDING_TAG);\n\tif (n != 1)\n\t\tgoto superseded;\n\tpage = results[0];\n\t_debug(\"gang %d [%lx]\", n, page->index);\n\tif (page->index > op->store_limit) {\n\t\tfscache_stat(&fscache_n_store_pages_over_limit);\n\t\tgoto superseded;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_STORING_TAG);\n\tradix_tree_tag_clear(&cookie->stores, page->index,\n\t\t\t     FSCACHE_COOKIE_PENDING_TAG);\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\tfscache_stat(&fscache_n_store_pages);\n\tfscache_stat(&fscache_n_cop_write_page);\n\tret = object->cache->ops->write_page(op, page);\n\tfscache_stat_d(&fscache_n_cop_write_page);\n\tfscache_end_page_write(object, page);\n\tif (ret < 0) {\n\t\tfscache_abort_object(object);\n\t\tfscache_op_complete(&op->op, true);\n\t} else {\n\t\tfscache_enqueue_operation(&op->op);\n\t}\n\n\t_leave(\"\");\n\treturn;\n\nsuperseded:\n\t/* this writer is going away and there aren't any more things to\n\t * write */\n\t_debug(\"cease\");\n\tspin_unlock(&cookie->stores_lock);\n\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\tspin_unlock(&object->lock);\n\tfscache_op_complete(&op->op, true);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_release_write_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "758-761",
    "snippet": "static void fscache_release_write_op(struct fscache_operation *_op)\n{\n\t_enter(\"{OP%x}\", _op->debug_id);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OP%x}\"",
            "_op->debug_id"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic void fscache_release_write_op(struct fscache_operation *_op)\n{\n\t_enter(\"{OP%x}\", _op->debug_id);\n}"
  },
  {
    "function_name": "__fscache_readpages_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "743-752",
    "snippet": "void __fscache_readpages_cancel(struct fscache_cookie *cookie,\n\t\t\t\tstruct list_head *pages)\n{\n\tstruct page *page;\n\n\tlist_for_each_entry(page, pages, lru) {\n\t\tif (PageFsCache(page))\n\t\t\t__fscache_uncache_page(cookie, page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fscache_uncache_page",
          "args": [
            "cookie",
            "page"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "pages",
            "lru"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_readpages_cancel(struct fscache_cookie *cookie,\n\t\t\t\tstruct list_head *pages)\n{\n\tstruct page *page;\n\n\tlist_for_each_entry(page, pages, lru) {\n\t\tif (PageFsCache(page))\n\t\t\t__fscache_uncache_page(cookie, page);\n\t}\n}"
  },
  {
    "function_name": "__fscache_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "653-736",
    "snippet": "int __fscache_alloc_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_allocs);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping, NULL, NULL);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_alloc_ops);\n\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_alloc_op_waits),\n\t\t__fscache_stat(&fscache_n_allocs_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tfscache_stat(&fscache_n_cop_allocate_page);\n\tret = object->cache->ops->allocate_page(op, page, gfp);\n\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\nerror:\n\tif (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_allocs_intr);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_allocs_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_allocs_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_allocs_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOBUFS\""
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_allocs_nobufs"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_wake_unused_cookie",
          "args": [
            "cookie"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_unuse_cookie",
          "args": [
            "cookie"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_retrieval",
          "args": [
            "op"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object->cache->ops->allocate_page",
          "args": [
            "op",
            "page",
            "gfp"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_wait_for_operation_activation",
          "args": [
            "object",
            "&op->op",
            "__fscache_stat(&fscache_n_alloc_op_waits)",
            "__fscache_stat(&fscache_n_allocs_object_dead)",
            "fscache_do_cancel_retrieval"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_wait_for_operation_activation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "346-388",
          "snippet": "int fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_stat",
          "args": [
            "&fscache_n_allocs_object_dead"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_stat",
          "args": [
            "&fscache_n_alloc_op_waits"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_submit_op",
          "args": [
            "object",
            "&op->op"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_submit_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "186-248",
          "snippet": "int fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_use_cookie",
          "args": [
            "cookie"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&op->n_pages",
            "1"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_alloc_retrieval",
          "args": [
            "cookie",
            "page->mapping",
            "NULL",
            "NULL"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_alloc_retrieval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "273-298",
          "snippet": "static struct fscache_retrieval *fscache_alloc_retrieval(\n\tstruct fscache_cookie *cookie,\n\tstruct address_space *mapping,\n\tfscache_rw_complete_t end_io_func,\n\tvoid *context)\n{\n\tstruct fscache_retrieval *op;\n\n\t/* allocate a retrieval operation and attempt to submit it */\n\top = kzalloc(sizeof(*op), GFP_NOIO);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\t\treturn NULL;\n\t}\n\n\tfscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);\n\top->op.flags\t= FSCACHE_OP_MYTHREAD |\n\t\t(1UL << FSCACHE_OP_WAITING) |\n\t\t(1UL << FSCACHE_OP_UNUSE_COOKIE);\n\top->mapping\t= mapping;\n\top->end_io_func\t= end_io_func;\n\top->context\t= context;\n\top->start_time\t= jiffies;\n\tINIT_LIST_HEAD(&op->to_do);\n\treturn op;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic struct fscache_retrieval *fscache_alloc_retrieval(\n\tstruct fscache_cookie *cookie,\n\tstruct address_space *mapping,\n\tfscache_rw_complete_t end_io_func,\n\tvoid *context)\n{\n\tstruct fscache_retrieval *op;\n\n\t/* allocate a retrieval operation and attempt to submit it */\n\top = kzalloc(sizeof(*op), GFP_NOIO);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\t\treturn NULL;\n\t}\n\n\tfscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);\n\top->op.flags\t= FSCACHE_OP_MYTHREAD |\n\t\t(1UL << FSCACHE_OP_WAITING) |\n\t\t(1UL << FSCACHE_OP_UNUSE_COOKIE);\n\top->mapping\t= mapping;\n\top->end_io_func\t= end_io_func;\n\top->context\t= context;\n\top->start_time\t= jiffies;\n\tINIT_LIST_HEAD(&op->to_do);\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_for_deferred_lookup",
          "args": [
            "cookie"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_wait_for_deferred_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "303-330",
          "snippet": "int fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_COOKIE_INVALIDATING",
            "&cookie->flags"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "page",
            "!=, NULL"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "cookie->def->type",
            "!=, FSCACHE_COOKIE_TYPE_INDEX"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p,,,\"",
            "cookie",
            "page"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_alloc_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_allocs);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping, NULL, NULL);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_alloc_ops);\n\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_alloc_op_waits),\n\t\t__fscache_stat(&fscache_n_allocs_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tfscache_stat(&fscache_n_cop_allocate_page);\n\tret = object->cache->ops->allocate_page(op, page, gfp);\n\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\nerror:\n\tif (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_allocs_intr);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_allocs_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_allocs_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_allocs_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "__fscache_read_or_alloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "532-642",
    "snippet": "int __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOBUFS\""
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_retrievals_nobufs"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_wake_unused_cookie",
          "args": [
            "cookie"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_unuse_cookie",
          "args": [
            "cookie"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&object->n_reads"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_retrieval",
          "args": [
            "op"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object->cache->ops->read_or_alloc_pages",
          "args": [
            "op",
            "pages",
            "nr_pages",
            "gfp"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object->cache->ops->allocate_pages",
          "args": [
            "op",
            "pages",
            "nr_pages",
            "gfp"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_COOKIE_NO_DATA_YET",
            "&object->cookie->flags"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_for_operation_activation",
          "args": [
            "object",
            "&op->op",
            "__fscache_stat(&fscache_n_retrieval_op_waits)",
            "__fscache_stat(&fscache_n_retrievals_object_dead)",
            "fscache_do_cancel_retrieval"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_wait_for_operation_activation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "346-388",
          "snippet": "int fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_stat",
          "args": [
            "&fscache_n_retrievals_object_dead"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_stat",
          "args": [
            "&fscache_n_retrieval_op_waits"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_get_context",
          "args": [
            "object->cookie",
            "op->context"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_get_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "325-331",
          "snippet": "static inline\nvoid *fscache_get_context(struct fscache_cookie *cookie, void *context)\n{\n\tif (cookie->def->get_context)\n\t\tcookie->def->get_context(cookie->netfs_data, context);\n\treturn context;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *);",
            "extern void __fscache_cookie_put(struct fscache_cookie *);",
            "extern int fscache_wait_for_deferred_lookup(struct fscache_cookie *);",
            "extern void fscache_invalidate_writes(struct fscache_cookie *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *);\nextern void __fscache_cookie_put(struct fscache_cookie *);\nextern int fscache_wait_for_deferred_lookup(struct fscache_cookie *);\nextern void fscache_invalidate_writes(struct fscache_cookie *);\n\nstatic inline\nvoid *fscache_get_context(struct fscache_cookie *cookie, void *context)\n{\n\tif (cookie->def->get_context)\n\t\tcookie->def->get_context(cookie->netfs_data, context);\n\treturn context;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_submit_op",
          "args": [
            "object",
            "&op->op"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_submit_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "186-248",
          "snippet": "int fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "FSCACHE_OP_DEC_READ_CNT",
            "&op->op.flags"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&object->n_reads"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_use_cookie",
          "args": [
            "cookie"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&op->n_pages",
            "*nr_pages"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_alloc_retrieval",
          "args": [
            "cookie",
            "mapping",
            "end_io_func",
            "context"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_alloc_retrieval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "273-298",
          "snippet": "static struct fscache_retrieval *fscache_alloc_retrieval(\n\tstruct fscache_cookie *cookie,\n\tstruct address_space *mapping,\n\tfscache_rw_complete_t end_io_func,\n\tvoid *context)\n{\n\tstruct fscache_retrieval *op;\n\n\t/* allocate a retrieval operation and attempt to submit it */\n\top = kzalloc(sizeof(*op), GFP_NOIO);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\t\treturn NULL;\n\t}\n\n\tfscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);\n\top->op.flags\t= FSCACHE_OP_MYTHREAD |\n\t\t(1UL << FSCACHE_OP_WAITING) |\n\t\t(1UL << FSCACHE_OP_UNUSE_COOKIE);\n\top->mapping\t= mapping;\n\top->end_io_func\t= end_io_func;\n\top->context\t= context;\n\top->start_time\t= jiffies;\n\tINIT_LIST_HEAD(&op->to_do);\n\treturn op;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic struct fscache_retrieval *fscache_alloc_retrieval(\n\tstruct fscache_cookie *cookie,\n\tstruct address_space *mapping,\n\tfscache_rw_complete_t end_io_func,\n\tvoid *context)\n{\n\tstruct fscache_retrieval *op;\n\n\t/* allocate a retrieval operation and attempt to submit it */\n\top = kzalloc(sizeof(*op), GFP_NOIO);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\t\treturn NULL;\n\t}\n\n\tfscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);\n\top->op.flags\t= FSCACHE_OP_MYTHREAD |\n\t\t(1UL << FSCACHE_OP_WAITING) |\n\t\t(1UL << FSCACHE_OP_UNUSE_COOKIE);\n\top->mapping\t= mapping;\n\top->end_io_func\t= end_io_func;\n\top->context\t= context;\n\top->start_time\t= jiffies;\n\tINIT_LIST_HEAD(&op->to_do);\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_for_deferred_lookup",
          "args": [
            "cookie"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_wait_for_deferred_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "303-330",
          "snippet": "int fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!list_empty(pages)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "*nr_pages",
            ">,0"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "cookie->def->type",
            "!=, FSCACHE_COOKIE_TYPE_INDEX"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,,%d,,,\"",
            "cookie",
            "*nr_pages"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "__fscache_read_or_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "399-511",
    "snippet": "int __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOBUFS\""
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_retrievals_nobufs"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_wake_unused_cookie",
          "args": [
            "cookie"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_unuse_cookie",
          "args": [
            "cookie"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&object->n_reads"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_retrieval",
          "args": [
            "op"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object->cache->ops->read_or_alloc_page",
          "args": [
            "op",
            "page",
            "gfp"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object->cache->ops->allocate_page",
          "args": [
            "op",
            "page",
            "gfp"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_COOKIE_NO_DATA_YET",
            "&object->cookie->flags"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_for_operation_activation",
          "args": [
            "object",
            "&op->op",
            "__fscache_stat(&fscache_n_retrieval_op_waits)",
            "__fscache_stat(&fscache_n_retrievals_object_dead)",
            "fscache_do_cancel_retrieval"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_wait_for_operation_activation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "346-388",
          "snippet": "int fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_stat",
          "args": [
            "&fscache_n_retrievals_object_dead"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_stat",
          "args": [
            "&fscache_n_retrieval_op_waits"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_get_context",
          "args": [
            "object->cookie",
            "op->context"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_get_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "325-331",
          "snippet": "static inline\nvoid *fscache_get_context(struct fscache_cookie *cookie, void *context)\n{\n\tif (cookie->def->get_context)\n\t\tcookie->def->get_context(cookie->netfs_data, context);\n\treturn context;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *);",
            "extern void __fscache_cookie_put(struct fscache_cookie *);",
            "extern int fscache_wait_for_deferred_lookup(struct fscache_cookie *);",
            "extern void fscache_invalidate_writes(struct fscache_cookie *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *);\nextern void __fscache_cookie_put(struct fscache_cookie *);\nextern int fscache_wait_for_deferred_lookup(struct fscache_cookie *);\nextern void fscache_invalidate_writes(struct fscache_cookie *);\n\nstatic inline\nvoid *fscache_get_context(struct fscache_cookie *cookie, void *context)\n{\n\tif (cookie->def->get_context)\n\t\tcookie->def->get_context(cookie->netfs_data, context);\n\treturn context;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_submit_op",
          "args": [
            "object",
            "&op->op"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_submit_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "186-248",
          "snippet": "int fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "FSCACHE_OP_DEC_READ_CNT",
            "&op->op.flags"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&object->n_reads"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_use_cookie",
          "args": [
            "cookie"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&op->n_pages",
            "1"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_alloc_retrieval",
          "args": [
            "cookie",
            "page->mapping",
            "end_io_func",
            "context"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_alloc_retrieval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "273-298",
          "snippet": "static struct fscache_retrieval *fscache_alloc_retrieval(\n\tstruct fscache_cookie *cookie,\n\tstruct address_space *mapping,\n\tfscache_rw_complete_t end_io_func,\n\tvoid *context)\n{\n\tstruct fscache_retrieval *op;\n\n\t/* allocate a retrieval operation and attempt to submit it */\n\top = kzalloc(sizeof(*op), GFP_NOIO);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\t\treturn NULL;\n\t}\n\n\tfscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);\n\top->op.flags\t= FSCACHE_OP_MYTHREAD |\n\t\t(1UL << FSCACHE_OP_WAITING) |\n\t\t(1UL << FSCACHE_OP_UNUSE_COOKIE);\n\top->mapping\t= mapping;\n\top->end_io_func\t= end_io_func;\n\top->context\t= context;\n\top->start_time\t= jiffies;\n\tINIT_LIST_HEAD(&op->to_do);\n\treturn op;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic struct fscache_retrieval *fscache_alloc_retrieval(\n\tstruct fscache_cookie *cookie,\n\tstruct address_space *mapping,\n\tfscache_rw_complete_t end_io_func,\n\tvoid *context)\n{\n\tstruct fscache_retrieval *op;\n\n\t/* allocate a retrieval operation and attempt to submit it */\n\top = kzalloc(sizeof(*op), GFP_NOIO);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\t\treturn NULL;\n\t}\n\n\tfscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);\n\top->op.flags\t= FSCACHE_OP_MYTHREAD |\n\t\t(1UL << FSCACHE_OP_WAITING) |\n\t\t(1UL << FSCACHE_OP_UNUSE_COOKIE);\n\top->mapping\t= mapping;\n\top->end_io_func\t= end_io_func;\n\top->context\t= context;\n\top->start_time\t= jiffies;\n\tINIT_LIST_HEAD(&op->to_do);\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_for_deferred_lookup",
          "args": [
            "cookie"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_wait_for_deferred_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "303-330",
          "snippet": "int fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "page",
            "!=, NULL"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "cookie->def->type",
            "!=, FSCACHE_COOKIE_TYPE_INDEX"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p,,,\"",
            "cookie",
            "page"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "fscache_wait_for_operation_activation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "346-388",
    "snippet": "int fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "stat_object_dead"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_cancel_op",
          "args": [
            "op",
            "do_cancel"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_cancel_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "295-328",
          "snippet": "int fscache_cancel_op(struct fscache_operation *op,\n\t\t      void (*do_cancel)(struct fscache_operation *))\n{\n\tstruct fscache_object *object = op->object;\n\tint ret;\n\n\t_enter(\"OBJ%x OP%x}\", op->object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, >=, FSCACHE_OP_ST_PENDING);\n\tASSERTCMP(op->state, !=, FSCACHE_OP_ST_CANCELLED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\n\tret = -EBUSY;\n\tif (op->state == FSCACHE_OP_ST_PENDING) {\n\t\tASSERT(!list_empty(&op->pend_link));\n\t\tfscache_stat(&fscache_n_op_cancelled);\n\t\tlist_del_init(&op->pend_link);\n\t\tif (do_cancel)\n\t\t\tdo_cancel(op);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\t\tobject->n_exclusive--;\n\t\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\t\tfscache_put_operation(op);\n\t\tret = 0;\n\t}\n\n\tspin_unlock(&object->lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_cancel_op(struct fscache_operation *op,\n\t\t      void (*do_cancel)(struct fscache_operation *))\n{\n\tstruct fscache_object *object = op->object;\n\tint ret;\n\n\t_enter(\"OBJ%x OP%x}\", op->object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, >=, FSCACHE_OP_ST_PENDING);\n\tASSERTCMP(op->state, !=, FSCACHE_OP_ST_CANCELLED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\n\tret = -EBUSY;\n\tif (op->state == FSCACHE_OP_ST_PENDING) {\n\t\tASSERT(!list_empty(&op->pend_link));\n\t\tfscache_stat(&fscache_n_op_cancelled);\n\t\tlist_del_init(&op->pend_link);\n\t\tif (do_cancel)\n\t\t\tdo_cancel(op);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\t\tobject->n_exclusive--;\n\t\tif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\t\twake_up_bit(&op->flags, FSCACHE_OP_WAITING);\n\t\tfscache_put_operation(op);\n\t\tret = 0;\n\t}\n\n\tspin_unlock(&object->lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s() = -ENOBUFS [obj dead %d]\\n\"",
            "__func__",
            "op->state"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fscache_object_is_dead(object)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_dead",
          "args": [
            "object"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOBUFS [cancelled]\""
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"<<< GO\""
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&op->flags",
            "FSCACHE_OP_WAITING",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&op->flags",
            "FSCACHE_OP_WAITING",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_OP_WAITING",
            "&op->flags"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fscache_do_cancel_retrieval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "335-341",
    "snippet": "static void fscache_do_cancel_retrieval(struct fscache_operation *_op)\n{\n\tstruct fscache_retrieval *op =\n\t\tcontainer_of(_op, struct fscache_retrieval, op);\n\n\tatomic_set(&op->n_pages, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&op->n_pages",
            "0"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_op",
            "structfscache_retrieval",
            "op"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic void fscache_do_cancel_retrieval(struct fscache_operation *_op)\n{\n\tstruct fscache_retrieval *op =\n\t\tcontainer_of(_op, struct fscache_retrieval, op);\n\n\tatomic_set(&op->n_pages, 0);\n}"
  },
  {
    "function_name": "fscache_wait_for_deferred_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "303-330",
    "snippet": "int fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [dly]\""
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_hist",
          "args": [
            "fscache_retrieval_delay_histogram",
            "jif"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "70-76",
          "snippet": "static inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_COOKIE_LOOKING_UP",
            "&cookie->flags"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_retrievals_intr"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_LOOKING_UP",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "fscache_alloc_retrieval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "273-298",
    "snippet": "static struct fscache_retrieval *fscache_alloc_retrieval(\n\tstruct fscache_cookie *cookie,\n\tstruct address_space *mapping,\n\tfscache_rw_complete_t end_io_func,\n\tvoid *context)\n{\n\tstruct fscache_retrieval *op;\n\n\t/* allocate a retrieval operation and attempt to submit it */\n\top = kzalloc(sizeof(*op), GFP_NOIO);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\t\treturn NULL;\n\t}\n\n\tfscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);\n\top->op.flags\t= FSCACHE_OP_MYTHREAD |\n\t\t(1UL << FSCACHE_OP_WAITING) |\n\t\t(1UL << FSCACHE_OP_UNUSE_COOKIE);\n\top->mapping\t= mapping;\n\top->end_io_func\t= end_io_func;\n\top->context\t= context;\n\top->start_time\t= jiffies;\n\tINIT_LIST_HEAD(&op->to_do);\n\treturn op;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&op->to_do"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_operation_init",
          "args": [
            "&op->op",
            "NULL",
            "fscache_release_retrieval_op"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_retrievals_nomem"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*op)",
            "GFP_NOIO"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic struct fscache_retrieval *fscache_alloc_retrieval(\n\tstruct fscache_cookie *cookie,\n\tstruct address_space *mapping,\n\tfscache_rw_complete_t end_io_func,\n\tvoid *context)\n{\n\tstruct fscache_retrieval *op;\n\n\t/* allocate a retrieval operation and attempt to submit it */\n\top = kzalloc(sizeof(*op), GFP_NOIO);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\t\treturn NULL;\n\t}\n\n\tfscache_operation_init(&op->op, NULL, fscache_release_retrieval_op);\n\top->op.flags\t= FSCACHE_OP_MYTHREAD |\n\t\t(1UL << FSCACHE_OP_WAITING) |\n\t\t(1UL << FSCACHE_OP_UNUSE_COOKIE);\n\top->mapping\t= mapping;\n\top->end_io_func\t= end_io_func;\n\top->context\t= context;\n\top->start_time\t= jiffies;\n\tINIT_LIST_HEAD(&op->to_do);\n\treturn op;\n}"
  },
  {
    "function_name": "fscache_release_retrieval_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "254-268",
    "snippet": "static void fscache_release_retrieval_op(struct fscache_operation *_op)\n{\n\tstruct fscache_retrieval *op =\n\t\tcontainer_of(_op, struct fscache_retrieval, op);\n\n\t_enter(\"{OP%x}\", op->op.debug_id);\n\n\tASSERTCMP(atomic_read(&op->n_pages), ==, 0);\n\n\tfscache_hist(fscache_retrieval_histogram, op->start_time);\n\tif (op->context)\n\t\tfscache_put_context(op->op.object->cookie, op->context);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_context",
          "args": [
            "op->op.object->cookie",
            "op->context"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "336-341",
          "snippet": "static inline\nvoid fscache_put_context(struct fscache_cookie *cookie, void *context)\n{\n\tif (cookie->def->put_context)\n\t\tcookie->def->put_context(cookie->netfs_data, context);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *);",
            "extern void __fscache_cookie_put(struct fscache_cookie *);",
            "extern int fscache_wait_for_deferred_lookup(struct fscache_cookie *);",
            "extern void fscache_invalidate_writes(struct fscache_cookie *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *);\nextern void __fscache_cookie_put(struct fscache_cookie *);\nextern int fscache_wait_for_deferred_lookup(struct fscache_cookie *);\nextern void fscache_invalidate_writes(struct fscache_cookie *);\n\nstatic inline\nvoid fscache_put_context(struct fscache_cookie *cookie, void *context)\n{\n\tif (cookie->def->put_context)\n\t\tcookie->def->put_context(cookie->netfs_data, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_hist",
          "args": [
            "fscache_retrieval_histogram",
            "op->start_time"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "70-76",
          "snippet": "static inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_hist(atomic_t histogram[], unsigned long start_jif)\n{\n\tunsigned long jif = jiffies - start_jif;\n\tif (jif >= HZ)\n\t\tjif = HZ - 1;\n\tatomic_inc(&histogram[jif]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&op->n_pages)",
            "==,0"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&op->n_pages"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OP%x}\"",
            "op->op.debug_id"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_op",
            "structfscache_retrieval",
            "op"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic void fscache_release_retrieval_op(struct fscache_operation *_op)\n{\n\tstruct fscache_retrieval *op =\n\t\tcontainer_of(_op, struct fscache_retrieval, op);\n\n\t_enter(\"{OP%x}\", op->op.debug_id);\n\n\tASSERTCMP(atomic_read(&op->n_pages), ==, 0);\n\n\tfscache_hist(fscache_retrieval_histogram, op->start_time);\n\tif (op->context)\n\t\tfscache_put_context(op->op.object->cookie, op->context);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "__fscache_attr_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "197-248",
    "snippet": "int __fscache_attr_changed(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\n\t_enter(\"%p\", cookie);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\n\tfscache_stat(&fscache_n_attr_changed);\n\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_attr_changed_nomem);\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfscache_operation_init(op, fscache_attr_changed_op, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto nobufs_dec;\n\tspin_unlock(&cookie->lock);\n\tfscache_stat(&fscache_n_attr_changed_ok);\n\tfscache_put_operation(op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nnobufs_dec:\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_attr_changed_nobufs);\n\t_leave(\" = %d\", -ENOBUFS);\n\treturn -ENOBUFS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "-ENOBUFS"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_attr_changed_nobufs"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_wake_unused_cookie",
          "args": [
            "cookie"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_unuse_cookie",
          "args": [
            "cookie"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "op"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_submit_exclusive_op",
          "args": [
            "object",
            "op"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_submit_exclusive_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "83-139",
          "snippet": "int fscache_submit_exclusive_op(struct fscache_object *object,\n\t\t\t\tstruct fscache_operation *op)\n{\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},\", object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\n\t\tif (object->n_in_progress > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_in_progress, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\n\t\t/* need to issue a new write op after this */\n\t\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else {\n\t\t/* If we're in any other state, there must have been an I/O\n\t\t * error of some nature.\n\t\t */\n\t\tASSERT(test_bit(FSCACHE_IOERROR, &object->cache->flags));\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_exclusive_op(struct fscache_object *object,\n\t\t\t\tstruct fscache_operation *op)\n{\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},\", object->debug_id, op->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\n\t\tif (object->n_in_progress > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_in_progress, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\n\t\t/* need to issue a new write op after this */\n\t\tclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tobject->n_exclusive++;\t/* reads and writes must wait */\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else {\n\t\t/* If we're in any other state, there must have been an I/O\n\t\t * error of some nature.\n\t\t */\n\t\tASSERT(test_bit(FSCACHE_IOERROR, &object->cache->flags));\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_use_cookie",
          "args": [
            "cookie"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_operation_init",
          "args": [
            "op",
            "fscache_attr_changed_op",
            "NULL"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*op)",
            "GFP_KERNEL"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "cookie->def->type",
            "!=, FSCACHE_COOKIE_TYPE_INDEX"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p\"",
            "cookie"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_attr_changed(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\n\t_enter(\"%p\", cookie);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\n\tfscache_stat(&fscache_n_attr_changed);\n\n\top = kzalloc(sizeof(*op), GFP_KERNEL);\n\tif (!op) {\n\t\tfscache_stat(&fscache_n_attr_changed_nomem);\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfscache_operation_init(op, fscache_attr_changed_op, NULL);\n\top->flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_EXCLUSIVE) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_exclusive_op(object, op) < 0)\n\t\tgoto nobufs_dec;\n\tspin_unlock(&cookie->lock);\n\tfscache_stat(&fscache_n_attr_changed_ok);\n\tfscache_put_operation(op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nnobufs_dec:\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_attr_changed_nobufs);\n\t_leave(\" = %d\", -ENOBUFS);\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "fscache_attr_changed_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "173-192",
    "snippet": "static void fscache_attr_changed_op(struct fscache_operation *op)\n{\n\tstruct fscache_object *object = op->object;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x}\", object->debug_id, op->debug_id);\n\n\tfscache_stat(&fscache_n_attr_changed_calls);\n\n\tif (fscache_object_is_active(object)) {\n\t\tfscache_stat(&fscache_n_cop_attr_changed);\n\t\tret = object->cache->ops->attr_changed(object);\n\t\tfscache_stat_d(&fscache_n_cop_attr_changed);\n\t\tif (ret < 0)\n\t\t\tfscache_abort_object(object);\n\t}\n\n\tfscache_op_complete(op, true);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_op_complete",
          "args": [
            "op",
            "true"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_op_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "365-391",
          "snippet": "void fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_abort_object",
          "args": [
            "object"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_abort_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "254-259",
          "snippet": "void fscache_abort_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_abort_object(struct fscache_object *object)\n{\n\t_enter(\"{OBJ%x}\", object->debug_id);\n\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_attr_changed"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->attr_changed",
          "args": [
            "object"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_active",
          "args": [
            "object"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x OP%x}\"",
            "object->debug_id",
            "op->debug_id"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic void fscache_attr_changed_op(struct fscache_operation *op)\n{\n\tstruct fscache_object *object = op->object;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x}\", object->debug_id, op->debug_id);\n\n\tfscache_stat(&fscache_n_attr_changed_calls);\n\n\tif (fscache_object_is_active(object)) {\n\t\tfscache_stat(&fscache_n_cop_attr_changed);\n\t\tret = object->cache->ops->attr_changed(object);\n\t\tfscache_stat_d(&fscache_n_cop_attr_changed);\n\t\tif (ret < 0)\n\t\t\tfscache_abort_object(object);\n\t}\n\n\tfscache_op_complete(op, true);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_end_page_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "143-168",
    "snippet": "static void fscache_end_page_write(struct fscache_object *object,\n\t\t\t\t   struct page *page)\n{\n\tstruct fscache_cookie *cookie;\n\tstruct page *xpage = NULL;\n\n\tspin_lock(&object->lock);\n\tcookie = object->cookie;\n\tif (cookie) {\n\t\t/* delete the page from the tree if it is now no longer\n\t\t * pending */\n\t\tspin_lock(&cookie->stores_lock);\n\t\tradix_tree_tag_clear(&cookie->stores, page->index,\n\t\t\t\t     FSCACHE_COOKIE_STORING_TAG);\n\t\tif (!radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t\t\tFSCACHE_COOKIE_PENDING_TAG)) {\n\t\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\t\txpage = radix_tree_delete(&cookie->stores, page->index);\n\t\t}\n\t\tspin_unlock(&cookie->stores_lock);\n\t\twake_up_bit(&cookie->flags, 0);\n\t}\n\tspin_unlock(&object->lock);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "xpage"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&object->lock"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&cookie->stores",
            "page->index"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_store_radix_deletes"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_get",
          "args": [
            "&cookie->stores",
            "page->index",
            "FSCACHE_COOKIE_PENDING_TAG"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&cookie->stores",
            "page->index",
            "FSCACHE_COOKIE_STORING_TAG"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->stores_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic void fscache_end_page_write(struct fscache_object *object,\n\t\t\t\t   struct page *page)\n{\n\tstruct fscache_cookie *cookie;\n\tstruct page *xpage = NULL;\n\n\tspin_lock(&object->lock);\n\tcookie = object->cookie;\n\tif (cookie) {\n\t\t/* delete the page from the tree if it is now no longer\n\t\t * pending */\n\t\tspin_lock(&cookie->stores_lock);\n\t\tradix_tree_tag_clear(&cookie->stores, page->index,\n\t\t\t\t     FSCACHE_COOKIE_STORING_TAG);\n\t\tif (!radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t\t\tFSCACHE_COOKIE_PENDING_TAG)) {\n\t\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\t\txpage = radix_tree_delete(&cookie->stores, page->index);\n\t\t}\n\t\tspin_unlock(&cookie->stores_lock);\n\t\twake_up_bit(&cookie->flags, 0);\n\t}\n\tspin_unlock(&object->lock);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n}"
  },
  {
    "function_name": "__fscache_maybe_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "63-137",
    "snippet": "bool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"fscache writeout timeout page: %p{%lx}\"",
            "page",
            "page->index"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_page_wait_timeout",
          "args": [
            "cookie",
            "page"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "release_page_wait_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "50-57",
          "snippet": "static\nbool release_page_wait_timeout(struct fscache_cookie *cookie, struct page *page)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&cookie->flags, 0);\n\n\treturn wait_event_timeout(*wq, !__fscache_check_page_write(cookie, page),\n\t\t\t\t  HZ);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic\nbool release_page_wait_timeout(struct fscache_cookie *cookie, struct page *page)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&cookie->flags, 0);\n\n\treturn wait_event_timeout(*wq, !__fscache_check_page_write(cookie, page),\n\t\t\t\t  HZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_store_vmscan_wait"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_uncache_page",
          "args": [
            "cookie",
            "page"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "xpage"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "xpage",
            "==,page"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->stores_lock"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&cookie->stores",
            "page->index"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_get",
          "args": [
            "&cookie->stores",
            "page->index",
            "FSCACHE_COOKIE_STORING_TAG"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->stores_lock"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_get",
          "args": [
            "&cookie->stores",
            "page->index",
            "FSCACHE_COOKIE_STORING_TAG"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&cookie->stores",
            "page->index"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p,%x\"",
            "cookie",
            "page",
            "gfp"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nbool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}"
  },
  {
    "function_name": "release_page_wait_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "50-57",
    "snippet": "static\nbool release_page_wait_timeout(struct fscache_cookie *cookie, struct page *page)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&cookie->flags, 0);\n\n\treturn wait_event_timeout(*wq, !__fscache_check_page_write(cookie, page),\n\t\t\t\t  HZ);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "*wq",
            "!__fscache_check_page_write(cookie, page)",
            "HZ"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_check_page_write",
          "args": [
            "cookie",
            "page"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_check_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "23-32",
          "snippet": "bool __fscache_check_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\tvoid *val;\n\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\trcu_read_unlock();\n\n\treturn val != NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nbool __fscache_check_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\tvoid *val;\n\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\trcu_read_unlock();\n\n\treturn val != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&cookie->flags",
            "0"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nstatic\nbool release_page_wait_timeout(struct fscache_cookie *cookie, struct page *page)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&cookie->flags, 0);\n\n\treturn wait_event_timeout(*wq, !__fscache_check_page_write(cookie, page),\n\t\t\t\t  HZ);\n}"
  },
  {
    "function_name": "__fscache_wait_on_page_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "38-43",
    "snippet": "void __fscache_wait_on_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&cookie->flags, 0);\n\n\twait_event(*wq, !__fscache_check_page_write(cookie, page));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "*wq",
            "!__fscache_check_page_write(cookie, page)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_check_page_write",
          "args": [
            "cookie",
            "page"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_check_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "23-32",
          "snippet": "bool __fscache_check_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\tvoid *val;\n\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\trcu_read_unlock();\n\n\treturn val != NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nbool __fscache_check_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\tvoid *val;\n\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\trcu_read_unlock();\n\n\treturn val != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&cookie->flags",
            "0"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_wait_on_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&cookie->flags, 0);\n\n\twait_event(*wq, !__fscache_check_page_write(cookie, page));\n}"
  },
  {
    "function_name": "__fscache_check_page_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
    "lines": "23-32",
    "snippet": "bool __fscache_check_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\tvoid *val;\n\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\trcu_read_unlock();\n\n\treturn val != NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fscache-cache.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&cookie->stores",
            "page->index"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nbool __fscache_check_page_write(struct fscache_cookie *cookie, struct page *page)\n{\n\tvoid *val;\n\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\trcu_read_unlock();\n\n\treturn val != NULL;\n}"
  }
]