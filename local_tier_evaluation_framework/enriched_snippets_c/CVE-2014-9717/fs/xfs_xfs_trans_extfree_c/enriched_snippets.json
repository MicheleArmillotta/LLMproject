[
  {
    "function_name": "xfs_trans_log_efd_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
    "lines": "115-133",
    "snippet": "void\nxfs_trans_log_efd_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efd_log_item_t\t*efdp,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefdp->efd_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\tnext_extent = efdp->efd_next_extent;\n\tASSERT(next_extent < efdp->efd_format.efd_nextents);\n\textp = &(efdp->efd_format.efd_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n\tefdp->efd_next_extent++;\n}",
    "includes": [
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_extent < efdp->efd_format.efd_nextents"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_efd_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efd_log_item_t\t*efdp,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefdp->efd_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\tnext_extent = efdp->efd_next_extent;\n\tASSERT(next_extent < efdp->efd_format.efd_nextents);\n\textp = &(efdp->efd_format.efd_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n\tefdp->efd_next_extent++;\n}"
  },
  {
    "function_name": "xfs_trans_get_efd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
    "lines": "90-108",
    "snippet": "xfs_efd_log_item_t *\nxfs_trans_get_efd(xfs_trans_t\t\t*tp,\n\t\t  xfs_efi_log_item_t\t*efip,\n\t\t  uint\t\t\tnextents)\n{\n\txfs_efd_log_item_t\t*efdp;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefdp = xfs_efd_init(tp->t_mountp, efip, nextents);\n\tASSERT(efdp != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efdp->efd_item);\n\treturn efdp;\n}",
    "includes": [
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_add_item",
          "args": [
            "tp",
            "&efdp->efd_item"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_add_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "651-668",
          "snippet": "void\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nvoid\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "efdp != NULL"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_efd_init",
          "args": [
            "tp->t_mountp",
            "efip",
            "nextents"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efd_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "482-507",
          "snippet": "struct xfs_efd_log_item *\nxfs_efd_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_efi_log_item\t*efip,\n\tuint\t\t\tnextents)\n\n{\n\tstruct xfs_efd_log_item\t*efdp;\n\tuint\t\t\tsize;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_EFD_MAX_FAST_EXTENTS) {\n\t\tsize = (uint)(sizeof(xfs_efd_log_item_t) +\n\t\t\t((nextents - 1) * sizeof(xfs_extent_t)));\n\t\tefdp = kmem_zalloc(size, KM_SLEEP);\n\t} else {\n\t\tefdp = kmem_zone_zalloc(xfs_efd_zone, KM_SLEEP);\n\t}\n\n\txfs_log_item_init(mp, &efdp->efd_item, XFS_LI_EFD, &xfs_efd_item_ops);\n\tefdp->efd_efip = efip;\n\tefdp->efd_format.efd_nextents = nextents;\n\tefdp->efd_format.efd_efi_id = efip->efi_format.efi_id;\n\n\treturn efdp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_efd_zone;",
            "static const struct xfs_item_ops xfs_efd_item_ops = {\n\t.iop_size\t= xfs_efd_item_size,\n\t.iop_format\t= xfs_efd_item_format,\n\t.iop_pin\t= xfs_efd_item_pin,\n\t.iop_unpin\t= xfs_efd_item_unpin,\n\t.iop_unlock\t= xfs_efd_item_unlock,\n\t.iop_committed\t= xfs_efd_item_committed,\n\t.iop_push\t= xfs_efd_item_push,\n\t.iop_committing = xfs_efd_item_committing\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_efd_zone;\nstatic const struct xfs_item_ops xfs_efd_item_ops = {\n\t.iop_size\t= xfs_efd_item_size,\n\t.iop_format\t= xfs_efd_item_format,\n\t.iop_pin\t= xfs_efd_item_pin,\n\t.iop_unpin\t= xfs_efd_item_unpin,\n\t.iop_unlock\t= xfs_efd_item_unlock,\n\t.iop_committed\t= xfs_efd_item_committed,\n\t.iop_push\t= xfs_efd_item_push,\n\t.iop_committing = xfs_efd_item_committing\n};\n\nstruct xfs_efd_log_item *\nxfs_efd_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_efi_log_item\t*efip,\n\tuint\t\t\tnextents)\n\n{\n\tstruct xfs_efd_log_item\t*efdp;\n\tuint\t\t\tsize;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_EFD_MAX_FAST_EXTENTS) {\n\t\tsize = (uint)(sizeof(xfs_efd_log_item_t) +\n\t\t\t((nextents - 1) * sizeof(xfs_extent_t)));\n\t\tefdp = kmem_zalloc(size, KM_SLEEP);\n\t} else {\n\t\tefdp = kmem_zone_zalloc(xfs_efd_zone, KM_SLEEP);\n\t}\n\n\txfs_log_item_init(mp, &efdp->efd_item, XFS_LI_EFD, &xfs_efd_item_ops);\n\tefdp->efd_efip = efip;\n\tefdp->efd_format.efd_nextents = nextents;\n\tefdp->efd_format.efd_efi_id = efip->efi_format.efi_id;\n\n\treturn efdp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nextents > 0"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp != NULL"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_efd_log_item_t *\nxfs_trans_get_efd(xfs_trans_t\t\t*tp,\n\t\t  xfs_efi_log_item_t\t*efip,\n\t\t  uint\t\t\tnextents)\n{\n\txfs_efd_log_item_t\t*efdp;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefdp = xfs_efd_init(tp->t_mountp, efip, nextents);\n\tASSERT(efdp != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efdp->efd_item);\n\treturn efdp;\n}"
  },
  {
    "function_name": "xfs_trans_log_efi_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
    "lines": "59-81",
    "snippet": "void\nxfs_trans_log_efi_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efi_log_item_t\t*efip,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefip->efi_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * atomic_inc_return gives us the value after the increment;\n\t * we want to use it as an array index so we need to subtract 1 from\n\t * it.\n\t */\n\tnext_extent = atomic_inc_return(&efip->efi_next_extent) - 1;\n\tASSERT(next_extent < efip->efi_format.efi_nextents);\n\textp = &(efip->efi_format.efi_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n}",
    "includes": [
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "next_extent < efip->efi_format.efi_nextents"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&efip->efi_next_extent"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_efi_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efi_log_item_t\t*efip,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefip->efi_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * atomic_inc_return gives us the value after the increment;\n\t * we want to use it as an array index so we need to subtract 1 from\n\t * it.\n\t */\n\tnext_extent = atomic_inc_return(&efip->efi_next_extent) - 1;\n\tASSERT(next_extent < efip->efi_format.efi_nextents);\n\textp = &(efip->efi_format.efi_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n}"
  },
  {
    "function_name": "xfs_trans_get_efi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
    "lines": "35-52",
    "snippet": "xfs_efi_log_item_t *\nxfs_trans_get_efi(xfs_trans_t\t*tp,\n\t\t  uint\t\tnextents)\n{\n\txfs_efi_log_item_t\t*efip;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefip = xfs_efi_init(tp->t_mountp, nextents);\n\tASSERT(efip != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efip->efi_item);\n\treturn efip;\n}",
    "includes": [
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_add_item",
          "args": [
            "tp",
            "&efip->efi_item"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_add_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "651-668",
          "snippet": "void\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nvoid\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "efip != NULL"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_efi_init",
          "args": [
            "tp->t_mountp",
            "nextents"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "222-247",
          "snippet": "struct xfs_efi_log_item *\nxfs_efi_init(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tnextents)\n\n{\n\tstruct xfs_efi_log_item\t*efip;\n\tuint\t\t\tsize;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_EFI_MAX_FAST_EXTENTS) {\n\t\tsize = (uint)(sizeof(xfs_efi_log_item_t) +\n\t\t\t((nextents - 1) * sizeof(xfs_extent_t)));\n\t\tefip = kmem_zalloc(size, KM_SLEEP);\n\t} else {\n\t\tefip = kmem_zone_zalloc(xfs_efi_zone, KM_SLEEP);\n\t}\n\n\txfs_log_item_init(mp, &efip->efi_item, XFS_LI_EFI, &xfs_efi_item_ops);\n\tefip->efi_format.efi_nextents = nextents;\n\tefip->efi_format.efi_id = (__psint_t)(void*)efip;\n\tatomic_set(&efip->efi_next_extent, 0);\n\tatomic_set(&efip->efi_refcount, 2);\n\n\treturn efip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_efi_zone;",
            "static const struct xfs_item_ops xfs_efi_item_ops = {\n\t.iop_size\t= xfs_efi_item_size,\n\t.iop_format\t= xfs_efi_item_format,\n\t.iop_pin\t= xfs_efi_item_pin,\n\t.iop_unpin\t= xfs_efi_item_unpin,\n\t.iop_unlock\t= xfs_efi_item_unlock,\n\t.iop_committed\t= xfs_efi_item_committed,\n\t.iop_push\t= xfs_efi_item_push,\n\t.iop_committing = xfs_efi_item_committing\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_efi_zone;\nstatic const struct xfs_item_ops xfs_efi_item_ops = {\n\t.iop_size\t= xfs_efi_item_size,\n\t.iop_format\t= xfs_efi_item_format,\n\t.iop_pin\t= xfs_efi_item_pin,\n\t.iop_unpin\t= xfs_efi_item_unpin,\n\t.iop_unlock\t= xfs_efi_item_unlock,\n\t.iop_committed\t= xfs_efi_item_committed,\n\t.iop_push\t= xfs_efi_item_push,\n\t.iop_committing = xfs_efi_item_committing\n};\n\nstruct xfs_efi_log_item *\nxfs_efi_init(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tnextents)\n\n{\n\tstruct xfs_efi_log_item\t*efip;\n\tuint\t\t\tsize;\n\n\tASSERT(nextents > 0);\n\tif (nextents > XFS_EFI_MAX_FAST_EXTENTS) {\n\t\tsize = (uint)(sizeof(xfs_efi_log_item_t) +\n\t\t\t((nextents - 1) * sizeof(xfs_extent_t)));\n\t\tefip = kmem_zalloc(size, KM_SLEEP);\n\t} else {\n\t\tefip = kmem_zone_zalloc(xfs_efi_zone, KM_SLEEP);\n\t}\n\n\txfs_log_item_init(mp, &efip->efi_item, XFS_LI_EFI, &xfs_efi_item_ops);\n\tefip->efi_format.efi_nextents = nextents;\n\tefip->efi_format.efi_id = (__psint_t)(void*)efip;\n\tatomic_set(&efip->efi_next_extent, 0);\n\tatomic_set(&efip->efi_refcount, 2);\n\n\treturn efip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nextents > 0"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp != NULL"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_efi_log_item_t *\nxfs_trans_get_efi(xfs_trans_t\t*tp,\n\t\t  uint\t\tnextents)\n{\n\txfs_efi_log_item_t\t*efip;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefip = xfs_efi_init(tp->t_mountp, nextents);\n\tASSERT(efip != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efip->efi_item);\n\treturn efip;\n}"
  }
]